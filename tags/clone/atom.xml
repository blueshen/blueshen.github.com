<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Clone | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/clone/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-03-22T16:52:53+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：原型（prototype） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/07/prototype-in-java/"/>
    <updated>2012-11-07T20:41:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/07/prototype-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br/>
基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。</p>

<p>Java中的原型模式：</p>

<pre><code>public class ProtoTypeClass implements Cloneable {

    @Override
    public ProtoTypeClass clone(){
        ProtoTypeClass cloneObject = null;
        try{
            cloneObject = (ProtoTypeClass) super.clone();
        }catch (Exception e) {
            // TODO: handle exception
        }
        return cloneObject;
    }
}
</code></pre>

<p>上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。</p>

<ul>
<li>clone时，构造函数不会执行</li>
<li>浅拷贝与深拷贝</li>
</ul>


<p>这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。</p>
]]></content>
  </entry>
  
</feed>