<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 读书笔记 | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/读书笔记/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-06-28T19:56:50+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《重构与模式》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes/"/>
    <updated>2013-06-28T13:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes</id>
    <content type="html"><![CDATA[<p>GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。</p>

<h3>写作缘由</h3>

<ul>
<li>过度设计：代码存在设计过度的情况</li>
<li>模式万灵丹：认为设计模式的万能的</li>
<li>设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”</li>
<li>测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”</li>
<li>重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构</li>
<li>演进式设计：将模式放到重构的背景中进行领会

<h3>什么是重构</h3>

<p>定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。 <br/>
重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。</p></li>
</ul>


<p>重构的动机：</p>

<ul>
<li>使新代码的增加更容易</li>
<li>改善既有代码的设计</li>
<li>对代码理解更透彻</li>
<li>提高编程的趣味性</li>
</ul>


<!--more-->


<h3>什么是模式</h3>

<p>GoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。 <br/>
应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。</p>

<h3>代码坏味</h3>

<ul>
<li><p>1.重复代码（Duplicated Code）</p>

<blockquote><p>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；</p></blockquote></li>
<li><p>2.过长函数（Long Method）：</p>

<blockquote><p>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；</p></blockquote></li>
<li><p>3.条件逻辑太复杂（Conditional Complexity）：</p>

<blockquote><p>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;</p></blockquote></li>
<li><p>4.基本类型偏执（Primitive Obsession）:</p>

<blockquote><p>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。</p></blockquote></li>
<li><p>5.不恰当的暴露（Indecent Exposure）：</p>

<blockquote><p>用Factory封装类；</p></blockquote></li>
<li><p>6.解决方案蔓延（Solution Sprawl）：</p>

<blockquote><p>将创建知识搬移到Factory；</p></blockquote></li>
<li><p>7.异曲同工的类（Alternative Classes With Different Interfaces）：</p>

<blockquote><p>通过Adapter统一接口；</p></blockquote></li>
<li><p>8.冗赘类（Lazy Class）：</p>

<blockquote><p>内联Singeton；</p></blockquote></li>
<li>9.过大的类（Large Class）：

<blockquote><p>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；</p></blockquote></li>
<li>10.分支语句（Switch Statement）：

<blockquote><p>用Command替换条件调度程序；将聚集操作搬移到Visitor；</p></blockquote></li>
<li>11.组合爆炸（Combinatorial Explosion）：

<blockquote><p>用Interpreter替换隐式语言；</p></blockquote></li>
<li>12.怪异解决方案（Oddball Solution）：

<blockquote><p>通过Adapter统一接口；</p>

<h3>创建</h3>

<h4>用Creation Method替换构造函数</h4>

<p>如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。 <br/>
优缺点：<br/>
+比构造函数能够更好的表达所创建的实例的种类。 <br/>
+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。 <br/>
+更容易发现无用的创建代码。 <br/>
-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。</p>

<h4>将创建知识搬移到Factory</h4>

<p>当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。  <br/>
优缺点： <br/>
+合并创建逻辑和实例化/配置选项。 <br/>
+将客户代码与创建逻辑解耦。  <br/>
-如果可以直接实例化，会使设计复杂化。</p>

<h4>用Factory封装类</h4>

<p>如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。 <br/>
优缺点： <br/>
+通过意图导向的CreationMethod简化了不同种类实例的创建。  <br/>
+通过隐藏不需要公开的类减少了包结构的“概念重量”  <br/>
+帮助严格执行“面向接口编程，而不是面向实现”这一格言。  <br/>
-当需要创建新种类的实例时，必须新建/更新Creation Method。<br/>
-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。</p>

<h4>用Factory Method引入多态创建</h4>

<p>一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。 <br/>
优缺点： <br/>
+减少因创建自定义对象而产生的重复代码  <br/>
+有效的表达了对象创建发生的位置，以及如何重写对象的创建。 <br/>
+强制Factory Method使用的类必须实现统一的类型。 <br/>
-可能会向Factory Method的一些实现者传递不必要的参数。</p>

<h4>用Builder封装Composite</h4>

<p>构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。 <br/>
优缺点： <br/>
+简化了构造Composite的客户代码。 <br/>
+减少了创建Composite的重复和易出错的本性。<br/>
+在客户代码和Composite之间实现了松耦合。 <br/>
-接口可能不会很清楚的表达其意图。</p>

<h4>内联Singleton</h4>

<p>绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。 <br/>
优缺点： <br/>
+使对象的协作变得更明显和明确。 <br/>
+保护了单一的实例，且不要要特殊的代码。 <br/>
-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。</p>

<h3>简化</h3>

<h4>组合方法</h4>

<p>一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。 <br/>
优缺点：  <br/>
+清晰的描述了一个方法所实现的功能以及如何实现。 <br/>
+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。 <br/>
-可能会产生过多的小方法。 <br/>
-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。</p>

<h4>用Strategy替换条件逻辑</h4>

<p>当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。  <br/>
优缺点： <br/>
+通过减少或去除条件逻辑使算法变得清晰易懂。 <br/>
+通过把算法的变体搬移到类层次中简化了类。 <br/>
+允许在运行时用一种算法替换另一种算法。 <br/>
-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。 <br/>
-增加了算法如何获取或接受上下文类的数据的复杂度。</p>

<h4>将装饰功能搬移到Decorator</h4>

<p>如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。 <br/>
优缺点： <br/>
+把装饰功能从类中搬移去除，从而简化了类。 <br/>
+有效地把类的核心职责和装饰功能区分开来。 <br/>
+可以去除几个相关类中重复的装饰逻辑。 <br/>
-改变了被装饰对象的对象类型。 <br/>
-会使代码变得更难理解和调适。 <br/>
-当Decorator组合产生负面影响的时候，会增加设计的复杂度。</p>

<h4>用State替换状态改变条件语句</h4>

<p>如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。 <br/>
优缺点： <br/>
+减少或去除状态改变条件逻辑。<br/>
+简化了复杂的状态改变逻辑。 <br/>
+提供了观察状态改变逻辑的很好的鸟瞰图。<br/>
-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。</p>

<h4>用Composite替换隐含树</h4>

<p>有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。 <br/>
优缺点： <br/>
+封装重复的指令，如格式化、添加或删除结点。 <br/>
+提供了处理相似逻辑增长的一般性方法。 <br/>
+简化了客户代码的构造职责。  <br/>
-当构造隐式树更简单的时候，会增加设计的复杂度。</p>

<h4>用Command替换条件调度程序</h4>

<p>许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。  <br/>
优缺点： <br/>
+提供了用统一方法执行不同行为的简单机制。 <br/>
+允许在运行时改变所处理的请求，以及如何处理请求。 <br/>
+仅仅需要很少的代码实现。 <br/>
-当条件调度程序已经足够的时候，会增加设计的复杂度。</p></blockquote></li>
</ul>


<h3>泛化</h3>

<h4>形成Template Method</h4>

<p>借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。  <br/>
优点与缺点： <br/>
+通过把不变行为搬移到超类，去除子类中的重复代码  <br/>
+简化并有效地表达了一个通用算法的步骤。 <br/>
+允许子类很容易的定制一个算法  <br/>
-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。</p>

<h4>提取Composite</h4>

<p>在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。  <br/>
优缺点： <br/>
+去除重复的类存储逻辑和类处理逻辑。  <br/>
+能够有效的表达类处理逻辑的可继承性。</p>

<h4>用Composite替换一/多之分</h4>

<p>这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题： <br/>
如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。  <br/>
使用Composite扩展出And，Or等条件，简化客户端的处理。  <br/>
优缺点： <br/>
+去除与处理一个或多个对象相关联的重复代码。 <br/>
+提供了处理一个或多个对象的同一方法。 <br/>
+支持处理多个对象的更丰富的方法。（如OR表达式） <br/>
-可能会在Composite的构造过程中要求类型安全的运行时检查。</p>

<h4>用Observer替换硬编码的通知</h4>

<p>拒绝使用硬编码的通知，考虑使用Observer模式。 <br/>
优缺点： <br/>
+使主题及其观察者访问松散耦合 <br/>
+支持一个或多个观察者  <br/>
-当硬编码的通知已经足够的时候，会增加设计复杂度  <br/>
-当出现串联通知的时候，会增加代码的复杂度      <br/>
-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。</p>

<h4>通过Adapter统一接口</h4>

<p>全部满足以下条件，考虑使用Adapter:</p>

<ul>
<li>2个类所做的事情相同或者相似，但是具有不同的接口。</li>
<li>如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。</li>
<li>无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。</li>
</ul>


<p>比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。 <br/>
优缺点： <br/>
+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。 <br/>
+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。  <br/>
+统一了客户代码与不同的类的交互方式。  <br/>
-当类的接口可以改变的时候，会增加设计的复杂度。</p>

<h4>提取Adapter</h4>

<p>当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。  <br/>
优缺点：<br/>
+隔离了不同版本的组件，类库或API之间的不同之处。 <br/>
+使类只负责适配代码的一个版本。  <br/>
+避免频繁地修改代码   <br/>
-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。</p>

<h4>用Interpreter替换隐式语言</h4>

<p>在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。  <br/>
优缺点： <br/>
+比隐式语言更好的支持语言元素的组合。 <br/>
+不需要新的代码来支持语言元素的新组合。<br/>
+允许行为的运行时配置。
-会产生定义语法和修改客户代码的开销。 <br/>
-如果语言很复杂，则需要很多的编程工作。 <br/>
-如果语言本身就很简单，则会增加设计的复杂度。</p>

<h3>保护</h3>

<h4>用类替换类型代码</h4>

<p>字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。  <br/>
优缺点：  <br/>
+更好的避免非法赋值和比较。  <br/>
-比使用不安全类型要求更多的代码。</p>

<h4>用Singleton限制实例化</h4>

<p>有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。 <br/>
优缺点：  <br/>
+改进性能。  <br/>
-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。 <br/>
-当对象含有不能共享的状态的时候，本重构就无效了。</p>

<h4>引入Null Object</h4>

<p>代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。  <br/>
优缺点：   <br/>
+不需要重复的null逻辑就可以避免null错误。 <br/>
+通过最小化null测试简化了代码。  <br/>
-当系统不太需要null测试的时候，会增加设计的复杂度。 <br/>
-如果程序员不知道Null Object的存在，就会产生多余的null测试。 <br/>
-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。</p>

<h3>聚集操作</h3>

<h4>将聚集操作搬移到Collecting Parameter</h4>

<p>有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。  <br/>
优缺点：   <br/>
+帮助我们把很大的方法转换成更小的，更简单的多个方法。  <br/>
-使结果代码运行得更快。</p>

<h4>将聚集操作搬移到Visitor</h4>

<p>如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。   <br/>
优缺点：  <br/>
+调节多个算法，使其适用于不同的对象结构。 <br/>
+访问相同或不同继承结构中的类。 <br/>
+调用不同类上的类型特定方法，无需类型转换。  <br/>
-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。  <br/>
-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。  <br/>
-可能会破坏被访问类的封装性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《HTTP权威指南》读书笔记1]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes/"/>
    <updated>2013-05-15T16:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes</id>
    <content type="html"><![CDATA[<h3>URL语法</h3>

<p>完整的URL是建立在由以下9个部分构成的通用格式上的。</p>

<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;   
</code></pre>

<p>其中各个部分代表：</p>

<ul>
<li>scheme(方案)：使用的哪种协议;默认无</li>
<li>user（用户）：用户名；默认匿名</li>
<li>password(密码)：密码</li>
<li>host(主机)：服务器主机名或点分IP地址</li>
<li>port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80</li>
<li>path(路径)：/分割的资源路径</li>
<li>params(参数)：名/值对，使用；分割。</li>
<li>query（查询）：名=值对，用&amp;分割多个</li>
<li>frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。</li>
</ul>


<!--more-->


<h3>HTTP报文格式</h3>

<h4>1.请求报文（request message）</h4>

<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>GET /images/blog/qunit-pic.png HTTP/1.0
Host: www.shenyanchao.cn
</code></pre>

<h4>2.响应报文（request message）</h4>

<pre><code>&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: image/png
Content-Length: 18107
</code></pre>

<p>以上报文格式中，各个部分的描述如下：</p>

<ul>
<li>method（方法）：希望服务器对资源执行的动作。如GET，POST等。</li>
<li>request-URL（请求的URL）：要请求的资源。</li>
<li>version（版本）：报文使用的HTTP协议版本。</li>
<li>status-code(状态码)：描述了请求过程中的状态。</li>
<li>reason-phrase（原因短语）：状态码的可读版本。</li>
<li>header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。</li>
<li>entity-body（实体的主题部分）：任意数据组成的数据块。</li>
</ul>


<h3>HTTP方法</h3>

<h4>1.GET</h4>

<p>请求服务器发送某个资源。请求无主体部分。</p>

<h4>2.HEAD</h4>

<p>与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：</p>

<ul>
<li>在不获取资源的情况下了解资源的情况（比如其类型）;</li>
<li>通过查看响应中的状态码，判断某个对象是否存在。</li>
<li>通过查看header，测试资源是否被修改了。</li>
</ul>


<h4>3.PUT</h4>

<p>PUT方法用于向服务器写入文档。请求有主体部分。</p>

<h4>4.POST</h4>

<p>POST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。</p>

<h4>5.TRACE</h4>

<p>客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。</p>

<h4>6.OPTIONS</h4>

<p>OPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。</p>

<h4>7.DELETE</h4>

<p>DELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。</p>

<h3>HTTP连接</h3>

<p>HTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。 <br/>
HTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：</p>

<ul>
<li>客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。</li>
<li>客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。</li>
<li>连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。</li>
<li>服务器回送响应也花费时间。</li>
</ul>


<h4>1.TCP连接握手时延</h4>

<p>由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。</p>

<h4>2.延迟确认</h4>

<p>网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。 <br/>
由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。</p>

<h4>3.TCP慢启动</h4>

<p>TCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。</p>

<h4>4.Nagle算法与TCP_NODELAY</h4>

<p>一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。</p>

<h4>5.TIME_WAIT累积与端口耗尽</h4>

<p>在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。</p>

<h3>HTTP状态码</h3>

<p>+------------+---------------+---------+<br/>
|  整体范围   |   已定义范围     |   分类   |  <br/>
+------------+----------------+---------+ <br/>
| 100～199   | 100～101        | 信息提示 | <br/>
+------------+----------------+---------+ <br/>
| 200～299   | 200～206        | 成功    |  <br/>
+------------+----------------+---------+ <br/>
| 300~399    | 300~305        | 重定向   |  <br/>
+------------+----------------+---------+ <br/>
| 400～499   | 400～415       |客户端错误| <br/>
+------------+----------------+---------+ <br/>
| 500~599    | 500~505        | 服务器错误|   <br/>
+------------+----------------+---------+</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Node.js开发指南》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/11/node-dot-js-develop-guide-reading-note/"/>
    <updated>2013-03-11T16:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/11/node-dot-js-develop-guide-reading-note</id>
    <content type="html"><![CDATA[<h3>书籍信息</h3>

<p>Amazon: <a href="http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I">NodeJS开发指南</a></p>

<p>PDF: <a href="http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf">免费下载</a></p>

<h3>NodeJS简介</h3>

<p>是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。<br/>
由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。
CommonJS规范包括：</p>

<ul>
<li>模块（modules）</li>
<li>包（packages）</li>
<li>系统（system）</li>
<li>二进制（binary）</li>
<li>控制台（console）</li>
<li>编码（encodings）</li>
<li>文件系统（filesystems）</li>
<li>套接字（sockets）</li>
<li>单元测试（unit testing）</li>
</ul>


<!--more-->


<h3>NodeJS的模块与包</h3>

<p>模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。</p>

<h4>1.什么是模块？</h4>

<pre><code>var http = require("http");
</code></pre>

<p>其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。</p>

<h4>2.创建与发布模块</h4>

<p>NodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。
如创建一个module.js:</p>

<pre><code>var name;
exports.setName=function(thyName){
     name=thyName;
     }
     exports.sayHello = function(){
    console.log('Hello '+name);
}
</code></pre>

<p>在同一个目录下，再创建一个getmodule.js:</p>

<pre><code>var mymodule = require('./module');
myModule.setName('shenyanchao');
myModule.sayHello();
</code></pre>

<p>运行后的结果：</p>

<pre><code>Hello shenyanchao
</code></pre>

<p>这就是一个简单的模块发布与调用关系。</p>

<h4>3.包（package）</h4>

<p>包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。<br/>
直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征：</p>

<ul>
<li>package.json在包的顶层目录下；</li>
<li>二进制可执行文件在bin目录下；</li>
<li>JS代码在lib目录下；</li>
<li>文档在doc目录下；</li>
<li>单元测试在test下；
这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。</li>
</ul>


<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:</p>

<pre><code>exports.hello = function() {
   console.log('Hello.');
};
</code></pre>

<p>然后在 somepackage 之外建立 getpackage.js,内容如下:</p>

<pre><code>var somePackage = require('./somepackage');
somePackage.hello();
</code></pre>

<p>运行 node getpackage.js,控制台将输出结果 Hello。 <br/>
我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。 <br/>
<strong>package.json</strong>
在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:</p>

<pre><code>{
    "main" : "./lib/interface.js"
}
</code></pre>

<p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。 <br/>
NodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。<br/>
package.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。 <br/>
name:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。 <br/>
description:包的简要说明。 <br/>
version:符合语义化版本识别 规范的版本字符串。<br/>
keywords:关键字数组,通常用于搜索。 <br/>
maintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。<br/>
contributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。 <br/>
bugs:提交bug的地址,可以是网址或者电子邮件地址。 <br/>
licenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。 <br/>
repositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。 <br/>
下面是mocha的package.json:</p>

<pre><code>{
 "name": "mocha",
 "version": "1.8.1",
"description": "simple, flexible, fun test framework",
 "keywords": [
 "mocha",
    "test",
 "bdd",
 "tdd",
 "tap"
],
 "author": {
 "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
 },
"repository": {
    "type": "git",
    "url": "git://github.com/visionmedia/mocha.git"
 },
"main": "./index",
"bin": {
    "mocha": "./bin/mocha",
    "_mocha": "./bin/_mocha"
},
"engines": {
    "node": "&gt;= 0.4.x"
},
"scripts": {
    "test": "make test-all"
 },
"dependencies": {
    "commander": "0.6.1",
    "growl": "1.7.x",
    "jade": "0.26.3",
    "diff": "1.0.2",
    "debug": "*",
    "mkdirp": "0.3.3",
    "ms": "0.3.0"
},
"devDependencies": {
 "should": "*",
    "coffee-script": "1.2"
 },
"readme": "..."
}
</code></pre>

<p>也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。 <br/>
如执行：</p>

<pre><code>npm install -g mocha
</code></pre>

<p>那么，npm将会依据json提供的信息来进行管理。</p>

<h4>4.npm的本地模式与全局模式</h4>

<p>npm默认会从http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用<code>-g</code>参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。</p>

<h3>模块（modules）的加载机制</h3>

<p>前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。<br/>
那么，文件模块是如何加载的呢？</p>

<h4>按路径加载模块</h4>

<p>1.如果require按“/”开头，那就是绝对路径进行加载。如require('/home/shenyanchao/module'),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。 <br/>
2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。<br/>
3.对于核心模块,比如require('http')，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？ <br/>
如果，使用require('mymodule'),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。 <br/>
例如： 我们在/home/shenyanchao/develop/app.js中使用require('mymodule')，NodeJS的查找路径如下：</p>

<ul>
<li>/home/shenyanchao/develop/node_modules/mymodule.js</li>
<li>/home/shenyanchao/node_modules/mymodule.js</li>
<li>/home/node_modules/mymodule.js</li>
<li>/node_modules/mymodule.js</li>
</ul>


<p>这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式<code>npm install mocha</code>的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require('mocha')时，能够直接使用。而<code>npm install -g mocha</code>相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。</p>

<h3>express: JS的MVC框架</h3>

<p>这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。 <br/>
express将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！  <br/>
express主页：<a href="http://expressjs.com/">http://expressjs.com/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《探索式软件测试》读书笔记(1)]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1/"/>
    <updated>2013-01-21T19:14:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1</id>
    <content type="html"><![CDATA[<p>书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。 <br/>
一般情况下，旅游地都会有这样一些区域：</p>

<ul>
<li><strong>商业区</strong>: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。</li>
<li><strong>历史区</strong>: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。</li>
<li><strong>旅游区</strong>: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。</li>
<li><strong>娱乐区</strong>: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。</li>
<li><strong>旅馆区</strong>: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。</li>
<li><strong>破旧区</strong>：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。</li>
</ul>


<!--more-->


<h3>商业区测试类型</h3>

<p>商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。</p>

<blockquote><p><strong>指南测试法</strong>： 测试人员按照用户手册进行操作。 <br/>
各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。</p>

<p><strong>卖点测试法</strong>： 按照销售人员对客户演示的顺序（卖点）进行测试。 <br/>
令旅游者向往的任何一个地方一定有吸引他们的理由。</p>

<p><strong>地标测试法</strong>： 选择一个功能点，然后向另外的功能点测试。<br/>
在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。</p>

<p><strong>极限测试法</strong>： 向软件提出很多难以回答的问题。 <br/>
旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。</p>

<p><strong>快递测试法</strong>： 专注与数据，保证数据在任何出现的地方都是同一个。<br/>
信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A->B->C->A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A->A->A->A，不能开封的说。</p>

<p><strong>深夜／清晨测试法</strong>： 在软件的空闲时段，去测试一些功能。 <br/>
下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。</p>

<p><strong>遍历测试法</strong>： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。  <br/>
城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。</p></blockquote>

<h3>历史区测试类型</h3>

<p>主要是针对老功能以及修复代码的测试。</p>

<blockquote><p><strong>恶邻测试法</strong>： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。<br/>
每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。</p>

<p><strong>博物馆测试法</strong>： 历史遗留代码值得测试人员多加关注。<br/>
展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。</p>

<p><strong>上一版测试法</strong>： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。</p></blockquote>

<h3>娱乐区测试类型</h3>

<p>旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。</p>

<blockquote><p><strong>配角测试法</strong>：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。 <br/>
导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。</p>

<p><strong>深巷测试法</strong>： 测试那些最不可能被用到或者那些最不吸引用户的特性。 <br/>
高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。</p>

<p><strong>通宵测试法</strong>： 让程序一直运行，而不去关闭他。<br/>
通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。</p></blockquote>

<h3>旅游区测试类型</h3>

<p>每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。</p>

<blockquote><p><strong>收藏家测试法</strong>：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。<br/>
旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。</p>

<p><strong>长路径测试法</strong>： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。<br/>
在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。</p>

<p><strong>超模测试法</strong>： 关注表面的东西，测试界面。<br/>
旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。</p>

<p><strong>测一送一法</strong>: 测试同一个应用多个拷贝的情况。<br/>
旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。</p>

<p><strong>苏格兰酒吧测试法</strong>： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。<br/>
作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。</p></blockquote>

<h3>旅馆区测试类型</h3>

<p>休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。</p>

<blockquote><p><strong>取消测试法</strong>： 启动操作然后停止它。学会使用取消按钮。 <br/>
任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。</p>

<p><strong>懒汉测试法</strong>： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。 <br/>
一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。</p></blockquote>

<h3>破旧区测试类型</h3>

<blockquote><p><strong>破坏测试法</strong>： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。</p>

<p><strong>反叛测试法</strong>： 输入最不可能的数据，或者已知的恶意输入。<br/>
旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。</p>

<p><strong>强迫症测试法</strong>： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。 <br/>
如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。</p></blockquote>
]]></content>
  </entry>
  
</feed>