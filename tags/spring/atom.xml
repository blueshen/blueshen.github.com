<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: spring | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/spring/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-11-14T17:46:50+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring中配置quartz集群]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/06/24/quartz-cluster-with-spring/"/>
    <updated>2014-06-24T15:10:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/06/24/quartz-cluster-with-spring</id>
    <content type="html"><![CDATA[<h3>为什么使用quartz集群？</h3>

<p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。
quartz集群在spring中的配置</p>

<h4>1.导入数据库表</h4>

<p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>

<p>注意事项：</p>

<p>修改SQL： TYPE=InnoDB –> ENGINE=InnoDB</p>

<!--more-->


<h4>2.项目中加入配置文件quartz.properties</h4>

<pre><code>#============================================================================
# Configure Main Scheduler Properties
#============================================================================
org.quartz.scheduler.instanceName = ClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.scheduler.skipUpdateCheck = true

#============================================================================
# Configure ThreadPool
#============================================================================
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.useProperties = false
org.quartz.jobStore.tablePrefix = QRTZ_

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 15000
</code></pre>

<h4>3.增加applicationContext-quartz.xml</h4>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd"
       default-lazy-init="false"&gt;

    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;

    &lt;bean id="quartzDataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource"&gt;
        &lt;property name="driverClass" value="${db.driver}" /&gt;
        &lt;property name="url" value="${db.url}" /&gt;
        &lt;property name="username" value="${db.user}" /&gt;
        &lt;property name="password" value="${db.pass}" /&gt;
    &lt;/bean&gt;

    &lt;!-- Quartz集群Schduler --&gt;
    &lt;bean id="clusterQuartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
        &lt;!-- Triggers集成 --&gt;
        &lt;property name="triggers"&gt;
            &lt;list&gt;
                &lt;ref bean="testTrigger" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--  quartz配置文件路径--&gt;
        &lt;property name="configLocation" value="classpath:quartz/quartz.properties" /&gt;
        &lt;!-- 启动时延期3秒开始任务 --&gt;
        &lt;property name="startupDelay" value="3" /&gt;
        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;
        &lt;property name="dataSource" ref="quartzDataSource" /&gt;
        &lt;!-- Job接受applicationContext的成员变量名 --&gt;
        &lt;property name="applicationContextSchedulerContextKey" value="applicationContext" /&gt;
        &lt;property name="overwriteExistingJobs" value="true" /&gt;
        &lt;property name="jobFactory"&gt;
            &lt;bean class="com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory"/&gt;
        &lt;/property&gt;
     &lt;/bean&gt;


    &lt;bean id="testTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
        &lt;property name="jobDetail" ref="testJobDetail" /&gt;
        &lt;property name="cronExpression" value="* 0/10 * * * ?" /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;
    &lt;bean id="testJobDetail" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;
        &lt;property name="jobClass" value="cn.shenyanchao.quartz.TestTask" /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;
    &lt;util:map id="timerJobConfig"&gt;
        &lt;entry key="nodeName" value="default" /&gt;
    &lt;/util:map&gt;
&lt;/beans&gt;
</code></pre>

<p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>

<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>

<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {

        private transient AutowireCapableBeanFactory beanFactory;

        public void setApplicationContext(final ApplicationContext context) {
            beanFactory = context.getAutowireCapableBeanFactory();
        }

        @Override
        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {
            final Object job = super.createJobInstance(bundle);
            beanFactory.autowireBean(job);
            return job;
        }
    }
</code></pre>

<h4>4. 如何写JOB？</h4>

<pre><code>@Component
public class TestTask extends QuartzJobBean {


    @Autowired
    private UserService userService;

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(userService.findByName("shenyanchao").getEmail());
    }
}
</code></pre>

<p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>

<h4>5.quartz在mysql5.6下报错</h4>

<pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OPTION SQL_SELECT_LIMIT=5' at line 1
</code></pre>

<p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<a href="http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Velocity学习小结]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/03/31/velocity-study-summary/"/>
    <updated>2014-03-31T16:24:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/03/31/velocity-study-summary</id>
    <content type="html"><![CDATA[<h3>velocity在spring项目中的使用</h3>

<p>本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。
首先，可以交给Spring来初始化velocityEngine:</p>

<pre><code>&lt;bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"&gt;
    &lt;property name="configLocation"&gt;
        &lt;value&gt;classpath:velocity.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="resourceLoaderPath"&gt;
        &lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>其中的<code>configLocation</code>指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：</p>

<pre><code>resource.loader  =  file

file.resource.loader.description =  Velocity  File Resource Loader
file.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader
file.resource.loader.cache =  true
file.resource.loader.modificationCheckInterval =  100

input.encoding = utf-8
output.encoding = utf-8
</code></pre>

<p>需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：</p>

<ul>
<li>spring增强了file加载的能力，推荐使用<code>resourceLoaderPath</code>来指明路径，而不是交给<code>file.resource.loader.path</code>进行处理。如果使用这个可能会跑NullPointerException；</li>
<li>class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。</li>
</ul>


<h3>关于Velocity使用的坑</h3>

<ul>
<li><p>关于减号（-）的问题</p>

<blockquote><p>请注意下面的2中写法  <br/>
<code>#set($maxIndex=$DOC_COUNT-1)</code>报错  <br/>
<code>#set($maxIndex=$DOC_COUNT - 1)</code>正确，区别仅在于-两侧的空格</p></blockquote></li>
<li><p>关于Range类型的问题</p>

<blockquote><p><code>#set($array = [0..$maxIndex])</code> 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样<code>#set($array = [0..$maxIndex+1])</code>也是错误的。</p></blockquote></li>
</ul>

]]></content>
  </entry>
  
</feed>