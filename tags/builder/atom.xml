<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: builder | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/builder/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-07-01T10:31:21+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：构建者（builder） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/05/builder-in-java/"/>
    <updated>2012-11-05T20:08:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/05/builder-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>建造者模式,又叫生成器模式，将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示. <br/>
<strong>适用性</strong>:</p>

<blockquote><p>a.当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式.  <br/>
b.当构建过程必须允许构造的对象有不同的表示.</p></blockquote>

<p>构建者模式的<strong>核心思想</strong>:</p>

<blockquote><p>将一个“<strong>复杂对象的构建算法</strong>”与它的“<strong>部件及组装方式</strong>”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式。</p></blockquote>

<p>建造者者模式有4个角色：</p>

<ul>
<li>Product产品类:<br/>
要构建的对象</li>
<li>Builder抽象构建者: <br/>
定义操作接口</li>
<li>ConcreteBuilder具体建造者:<br/>
实现Builder所有方法</li>
<li>Director导演类：   <br/>
每个观察者在接收到消息后的更新操作是不同的。</li>
</ul>


<!--more-->


<p>下面以参考文献里提到的造人来说明: <br/>
首先定义以下产品类person,本例的产品就是"人"了.</p>

<pre><code>public class Person {


    private List&lt;String&gt; arms = new ArrayList&lt;String&gt;();

    private List&lt;String&gt; heads = new ArrayList&lt;String&gt;();

    private List&lt;String&gt; legs = new ArrayList&lt;String&gt;();

    private List&lt;String&gt; bodys = new ArrayList&lt;String&gt;();

    public Person(){
        System.out.println("person开始构建......");
    }

    @Override
    public String toString() {
        return "我有"+heads.size()+"个头,"+bodys.size()+"个身体,"+arms.size()+"个手臂,"+legs.size()+"个腿.";
    }

    //setter and getter ...
}
</code></pre>

<p>人嘛,一般都有头,身体,手臂,腿了.</p>

<p>下面是一个抽象的Builder:</p>

<pre><code>public  abstract class Builder {

    protected Person person = new Person();

    public abstract void buildHead();
    public abstract void buildArm();
    public abstract void buildLeg();
    public abstract void buildBody();


    public abstract Person getPerson();
}
</code></pre>

<p>这里面定义了如何装配头,身体,手臂,腿的方法.  <br/>
到这里,我可能想构建一个普通人:</p>

<pre><code>public class HumanBuilder extends Builder {

    @Override
    public void buildHead() {
        person.getHeads().add("human head");
    }

    @Override
    public void buildArm() {
        person.getArms().add("human arm");
    }

    @Override
    public void buildLeg() {
        person.getLegs().add("human leg");
    }

    @Override
    public void buildBody() {
        person.getBodys().add("human body");
    }

    @Override
    public Person getPerson() {
        return person;  
    }
}
</code></pre>

<p>在这个类里,定义了实际的构建过程,需要注意的是各个部分可都是"human"的.  <br/>
另外,我如果想构建另外一种人呢,比方奥特曼,那自然需要另外的一个Builder了.</p>

<pre><code>public class UltramanBuilder extends Builder {

    @Override
    public void buildHead() {
        person.getHeads().add("ultraman head");
    }

    @Override
    public void buildArm() {
        person.getArms().add("ultraman arm");
    }

    @Override
    public void buildLeg() {
        person.getLegs().add("ultraman leg");
    }

    @Override
    public void buildBody() {
        person.getBodys().add("ultraman body");
    }

    @Override
    public Person getPerson() {
        return person;
    }
}
</code></pre>

<p>接下了,就是导演要出场了,到底是要一个普通人还是奥特曼呢,一切都是导演说了算.</p>

<pre><code>public class PersonDirector {

    private Builder builder;

    public PersonDirector(Builder builder){
        this.builder = builder;
    }

    public Person createPerson(){
        builder.buildBody();
        builder.buildLeg();
        builder.buildLeg();
        if (builder instanceof HumanBuilder){
            builder.buildHead();
            builder.buildArm();
        }else if(builder instanceof UltramanBuilder){
            for(int i=0;i&lt;3;i++){//3 head
                builder.buildHead();
            }
            for(int i=0;i&lt;6;i++){//6 arms
                builder.buildArm();
            }

        }
        return builder.getPerson();
    }
}    
</code></pre>

<p>奥特曼可不像普通人一样,那可是有3头6臂的.</p>

<p>到这里构建者模式已经好了,到具体场景里用一下吧.</p>

<pre><code>public class Client {
    public static void main(String[] args) {
        PersonDirector personDirector = null;
        Person person = null;
        Builder builder = null;
        builder = new HumanBuilder();
        personDirector = new PersonDirector(builder);
        person = personDirector.createPerson();
        System.out.println(person);

        builder = new UltramanBuilder();
        personDirector = new PersonDirector(builder);
        person = personDirector.createPerson();
        System.out.println(person);
    }
}
</code></pre>

<p>运行结果如下:</p>

<pre><code>person开始构建......
我有1个头,1个身体,1个手臂,2个腿.
person开始构建......
我有3个头,1个身体,6个手臂,2个腿.
</code></pre>

<p>可见,不同的builder构建出的是不同的人.完全满足需要.</p>

<p><strong>需要注意</strong>
* 构建算法由Director来确定,Builder只负责提供装配接口.
* 组成不见不能替换,比如普通人的头给奥特曼的头明显是不一样的.</p>

<p><strong>Builder in Java</strong>: <br/>
在Java中有一个StringBuilder,看名字应该就知道了.</p>

<pre><code>   //Client同时充当了Director的角色
   StringBuilder builder = new StringBuilder();
   builder.Append("www");
   builder.Append(".shenyanchao");
   builder.Append(".cn");
   //返回string对象：www.shenyanchao.cn
   builder.toString(); 
</code></pre>

<p>这中间没有了director,用client进行了代替.StringBuilder既是抽象接口又是具体构建者. 返回的字符串自然就是产品了. 这是一种简单的Builder模式.</p>

<p>参考文档: <br/>
<a href="http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html">http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html</a></p>
]]></content>
  </entry>
  
</feed>