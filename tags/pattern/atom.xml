<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: pattern | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/pattern/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-03-18T21:07:21+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：访问者（visitor） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/visitor-in-java/"/>
    <updated>2012-11-02T20:12:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/visitor-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>

<p>访问者模式有以下几个角色：</p>

<ul>
<li>Visitor抽象访问者  <br/>
抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。</li>
<li>ConcreteVisitor具体访问者  <br/>
它影响访问者访问到一个类后该怎么办，要做什么事情。</li>
<li>Element抽象元素  <br/>
接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。</li>
<li>ConcreteElement具体元素  <br/>
实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。</li>
<li>ObjectStruture结构对象  <br/>
元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。</li>
</ul>


<!--more-->


<p>下面看看各个部分是如何实现的。  <br/>
抽象元素：</p>

<pre><code>public abstract class Element {
    //业务逻辑
    public abstract void doSomething();
    //允许谁来访问
    public abstract void accept(IVisitor visitor);
}
</code></pre>

<p>具体元素：</p>

<pre><code>public class ConcreteElement1 extends Element {

    @Override
    public void doSomething() {
        //todo
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}

public class ConcreteElement2 extends Element {

    @Override
    public void doSomething() {
        //todo
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}  
</code></pre>

<p>抽象访问者：</p>

<pre><code>public interface IVisitor {

    public void visit(ConcreteElement1 el1);

    public void visit(ConcreteElement2 el2);
}
</code></pre>

<p>具体访问者：</p>

<pre><code>public class Visitor implements IVisitor {

    @Override
    public void visit(ConcreteElement1 el1) {
        el1.doSomething();
    }

    @Override
    public void visit(ConcreteElement2 el2) {
        el2.doSomething();
    }
}
</code></pre>

<p>结构对象：</p>

<pre><code>public class ObjectStruture {

    public static Element createElment(){
        Random random = new Random();
        if (random.nextInt(100) &gt; 50){
            return new ConcreteElement1();
        }else{
            return new ConcreteElement2();
        }
    }

}
</code></pre>

<p>下面看下具体场景类是怎么使用的：</p>

<pre><code>public class Client {

    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            Element el = ObjectStruture.createElment();
            el.accept(new Visitor());
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：策略（strategy） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java/"/>
    <updated>2012-11-02T20:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>

<p>策略模式有3个角色：</p>

<ul>
<li>Context封装角色  <br/>
它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>
<li>Strategy抽象策略角色  <br/>
策略、算法的家族的抽象，通常为接口。</li>
<li>ConcreteStrategy具体策略角色  <br/>
实现抽象策略中的操作，该类含有具体的算法。</li>
</ul>


<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。</p>

<!--more-->


<p>这3个妙计，分别是：</p>

<ul>
<li>找乔国老帮忙（走后门）</li>
<li>求吴国太放行（诉苦）</li>
<li>孙尚香断后</li>
</ul>


<p>首先，设计一个妙计的策略接口：</p>

<pre><code>public interface IStrategy{
    public void operate();
}    
</code></pre>

<p>下面来分别实现这几个妙计。</p>

<pre><code>//妙计1
public class BackDoor implements IStrategy{    
    public void operate(){
        System.out.println("找乔国老帮忙，让吴国太给孙权施加压力");
    }
}
//妙计2
public class GivenGreenLight implements IStrategy{    
    public void operate(){
        System.out.println("找吴国太开绿灯，放行！");
    }
}
//妙计3
public class BlockEnemy implements IStrategy{    
    public void operate(){
        System.out.println("孙尚香断口，挡住追兵！");
    }
}
</code></pre>

<p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。</p>

<pre><code>public class Context{
    private IStrategy strategy;
    public Context(IStrategy strategy){
        this.strategy = strategy;
    }

    public void operate(){
        this.strategy.operate();
    }
}
</code></pre>

<p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。</p>

<p>下面看下赵云如何使用的。</p>

<pre><code>public class ZhaoYun{   
    Context context;
    System.out.println("---刚到吴国的时候拆第一个---");
    context = new Context(new BackDoor());
    context.operate();
    System.out.println("---刘备乐不思蜀了，拆第二个---");
    context = new Context(new GivenGreenLight());
    context.operate();
    System.out.println("---孙权的小兵过来追，拆第三个---");
    context = new Context(new BlockEnemy());
    context.operate();
}
</code></pre>

<p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：状态（state） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/state-in-java/"/>
    <updated>2012-11-02T20:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/state-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>当一个对象内在状态改变时允许其改变行为，这个对象看起来想改变了其类。  <br/>
状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。</p>

<p>状态模式有3个角色：</p>

<ul>
<li>State抽象状态角色    <br/>
接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态转换。</li>
<li>ConcreteState具体状态角色  <br/>
每一个具体状态必须完成2个职责：本状态的行为管理以及趋向状态处理。简单说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。</li>
<li>Context环境角色   <br/>
定义客户端需要的接口，并且负责具体状态的切换。</li>
</ul>


<!--more-->


<p>具体看看各个角色的实现.</p>

<p>抽象状态角色</p>

<pre><code>public abstract class State{
    //定义一个环境角色，提供子类访问
    protected Context context;
    //设置环境角色
    public void setContext(Context _context){
        this.context = _context;
    }
    //行为1
    public abstract void handle1();
    //行为2
    public abstract void handle2();

}
</code></pre>

<p>具体状态角色</p>

<pre><code>public class ConcreteState1 extends State{
    @override
    public void handle1(){
        //本状态下必须处理的逻辑
    }
    @override
    public void handle2(){
        //设置当前状态为STATE2
        super.context.setCurrentState(Context.STATE2);
        //过渡到STATE2状态，由Context实现
        super.context.handle2();
    }
}

public class ConcreteState2 extends State{

    @override
    public void handle1(){
        //设置当前状态为STATE1
        super.context.setCurrentState(Context.STATE1);
        //过渡到STATE1状态，由Context实现
        super.context.handle1();
    }
    @override
    public void handle2(){
        //本状态下必须处理的逻辑
    }
}
</code></pre>

<p>具体环境角色</p>

<pre><code>public class Context{
    //定义状态
    public final static State STATE1 = new ConcreteState1();
    public final static State STATE2 = new ConcreteState2();
    //当前状态
    private State CurrentState;
    //获得当前状态
    public State getCurrentState(){
        return CurrentState;
    }
    //设置当前状态
    public void setCurrentState(State currentState){
        this.CurrentState = currentState;
        //切换状态
        this.CurrentState.setContext(this);
    }
    //行为委托
    public void handle1(){
        this.CurrentState.handle1();
    }
    public void handle2(){
        this.CurrentState.handle2();
    }
}
</code></pre>

<p>环境角色有2个不成文的约束：</p>

<ul>
<li>把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。</li>
<li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。</li>
</ul>


<p>在具体使用状态模式的时候，直接调用Context就行了。</p>

<pre><code>public class Client{
    public static void main(String[] args){
        Context context = new Context();
        context.setCurrentState(new ConcreteState1());
        context.handle1();
        context.handle2();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:备忘录（memento） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/memento-in-java/"/>
    <updated>2012-11-02T20:10:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/memento-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>

<p>备忘录模式有以下三个角色：</p>

<ul>
<li>Originator发起人角色  <br/>
记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li>
<li>Memento备忘录角色   <br/>
负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li>
<li>Caretaker备忘录管理员角色  <br/>
对备忘录进行管理、保存和提供备忘录。</li>
</ul>


<!--more-->


<p>发起人角色：</p>

<pre><code>public class Originator{
    //内部状态
    private String state = "";

    public String getState(){
        return state;
    }

    public void setState(String state){
        this.state = state;
    }

    //创建一个备忘录
    public Memento createMemento(){
        return new Memento(this.state);
    }
    //恢复一个备忘录
    public void restoreMemento(Memento _memento){
        this.setState(_memento.getState());
    }
}
</code></pre>

<p>备忘录角色：</p>

<pre><code>public class Memento{
    //发起人的内部状态
    private String state = "";
    //构造函数传递参数
    public Memento(String _state){
        this.state = _state;
    }  
    public String getState(){
        return state;
    }

    public void setState(String state){
        this.state = state;
    }
}
</code></pre>

<p>备忘录管理员角色：</p>

<pre><code>public class Caretaker{
    //备忘录对象
    private Memento memento;
    public Memento getMemento(){
        return memento;
    }
    public void setMemento(Memento memento){
        this.memento = memento;
    }
}
</code></pre>

<p>现在看看是如何使用的：</p>

<pre><code>public class Client{
    public static void main(String[] args){
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();
        caretaker.setMemento(originator.createMemento()); 
        originator.restoreMemento(caretaker.getMemento);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：解释器（interpreter） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/interpreter-in-java/"/>
    <updated>2012-11-02T20:09:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/interpreter-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>解释器模式是一种按照规定语法进行解析的方案，在现在项目中使用较少。正式定义：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子。</p>

<p>解释器模式有以下几个角色：</p>

<ul>
<li>AbstractExpression抽象解释器   <br/>
具体的解释任务由各个实现类完成。</li>
<li>TerminalExpression终结符表达式  <br/>
实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。</li>
<li>NonterminalExpression非终结符表达式   <br/>
文法中的每条规则对应于一个非终结表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</li>
<li>Context环境角色</li>
</ul>

]]></content>
  </entry>
  
</feed>