<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: pattern | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/pattern/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-07-05T14:09:09+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：访问者（visitor） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/visitor-in-java/"/>
    <updated>2012-11-02T20:12:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/visitor-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>

<p>访问者模式有以下几个角色：</p>

<ul>
<li>Visitor抽象访问者  <br/>
抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。</li>
<li>ConcreteVisitor具体访问者  <br/>
它影响访问者访问到一个类后该怎么办，要做什么事情。</li>
<li>Element抽象元素  <br/>
接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。</li>
<li>ConcreteElement具体元素  <br/>
实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。</li>
<li>ObjectStruture结构对象  <br/>
元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。</li>
</ul>


<!--more-->


<p>下面看看各个部分是如何实现的。  <br/>
抽象元素：</p>

<pre><code>public abstract class Element {
    //业务逻辑
    public abstract void doSomething();
    //允许谁来访问
    public abstract void accept(IVisitor visitor);
}
</code></pre>

<p>具体元素：</p>

<pre><code>public class ConcreteElement1 extends Element {

    @Override
    public void doSomething() {
        //todo
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}

public class ConcreteElement2 extends Element {

    @Override
    public void doSomething() {
        //todo
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}  
</code></pre>

<p>抽象访问者：</p>

<pre><code>public interface IVisitor {

    public void visit(ConcreteElement1 el1);

    public void visit(ConcreteElement2 el2);
}
</code></pre>

<p>具体访问者：</p>

<pre><code>public class Visitor implements IVisitor {

    @Override
    public void visit(ConcreteElement1 el1) {
        el1.doSomething();
    }

    @Override
    public void visit(ConcreteElement2 el2) {
        el2.doSomething();
    }
}
</code></pre>

<p>结构对象：</p>

<pre><code>public class ObjectStruture {

    public static Element createElment(){
        Random random = new Random();
        if (random.nextInt(100) &gt; 50){
            return new ConcreteElement1();
        }else{
            return new ConcreteElement2();
        }
    }

}
</code></pre>

<p>下面看下具体场景类是怎么使用的：</p>

<pre><code>public class Client {

    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            Element el = ObjectStruture.createElment();
            el.accept(new Visitor());
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：策略（strategy） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java/"/>
    <updated>2012-11-02T20:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>

<p>策略模式有3个角色：</p>

<ul>
<li>Context封装角色  <br/>
它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>
<li>Strategy抽象策略角色  <br/>
策略、算法的家族的抽象，通常为接口。</li>
<li>ConcreteStrategy具体策略角色  <br/>
实现抽象策略中的操作，该类含有具体的算法。</li>
</ul>


<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。</p>

<!--more-->


<p>这3个妙计，分别是：</p>

<ul>
<li>找乔国老帮忙（走后门）</li>
<li>求吴国太放行（诉苦）</li>
<li>孙尚香断后</li>
</ul>


<p>首先，设计一个妙计的策略接口：</p>

<pre><code>public interface IStrategy{
    public void operate();
}    
</code></pre>

<p>下面来分别实现这几个妙计。</p>

<pre><code>//妙计1
public class BackDoor implements IStrategy{    
    public void operate(){
        System.out.println("找乔国老帮忙，让吴国太给孙权施加压力");
    }
}
//妙计2
public class GivenGreenLight implements IStrategy{    
    public void operate(){
        System.out.println("找吴国太开绿灯，放行！");
    }
}
//妙计3
public class BlockEnemy implements IStrategy{    
    public void operate(){
        System.out.println("孙尚香断口，挡住追兵！");
    }
}
</code></pre>

<p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。</p>

<pre><code>public class Context{
    private IStrategy strategy;
    public Context(IStrategy strategy){
        this.strategy = strategy;
    }

    public void operate(){
        this.strategy.operate();
    }
}
</code></pre>

<p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。</p>

<p>下面看下赵云如何使用的。</p>

<pre><code>public class ZhaoYun{   
    Context context;
    System.out.println("---刚到吴国的时候拆第一个---");
    context = new Context(new BackDoor());
    context.operate();
    System.out.println("---刘备乐不思蜀了，拆第二个---");
    context = new Context(new GivenGreenLight());
    context.operate();
    System.out.println("---孙权的小兵过来追，拆第三个---");
    context = new Context(new BlockEnemy());
    context.operate();
}
</code></pre>

<p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:备忘录（memento） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/memento-in-java/"/>
    <updated>2012-11-02T20:10:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/memento-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>

<p>备忘录模式有以下三个角色：</p>

<ul>
<li>Originator发起人角色  <br/>
记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li>
<li>Memento备忘录角色   <br/>
负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li>
<li>Caretaker备忘录管理员角色  <br/>
对备忘录进行管理、保存和提供备忘录。</li>
</ul>


<!--more-->


<p>发起人角色：</p>

<pre><code>public class Originator{
    //内部状态
    private String state = "";

    public String getState(){
        return state;
    }

    public void setState(String state){
        this.state = state;
    }

    //创建一个备忘录
    public Memento createMemento(){
        return new Memento(this.state);
    }
    //恢复一个备忘录
    public void restoreMemento(Memento _memento){
        this.setState(_memento.getState());
    }
}
</code></pre>

<p>备忘录角色：</p>

<pre><code>public class Memento{
    //发起人的内部状态
    private String state = "";
    //构造函数传递参数
    public Memento(String _state){
        this.state = _state;
    }  
    public String getState(){
        return state;
    }

    public void setState(String state){
        this.state = state;
    }
}
</code></pre>

<p>备忘录管理员角色：</p>

<pre><code>public class Caretaker{
    //备忘录对象
    private Memento memento;
    public Memento getMemento(){
        return memento;
    }
    public void setMemento(Memento memento){
        this.memento = memento;
    }
}
</code></pre>

<p>现在看看是如何使用的：</p>

<pre><code>public class Client{
    public static void main(String[] args){
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();
        caretaker.setMemento(originator.createMemento()); 
        originator.restoreMemento(caretaker.getMemento);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：责任链（chain of responsibility） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/chain-of-responsibility-in-java/"/>
    <updated>2012-11-02T20:09:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/chain-of-responsibility-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>

<p>责任链由2个角色组成：</p>

<ul>
<li>Handler抽象处理者角色  <br/>
它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。</li>
<li>Concrete Handler具体处理者角色  <br/>
实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。</li>
</ul>


<p>比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：享元（flyweight） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/flyweight-in-java/"/>
    <updated>2012-11-02T20:07:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/flyweight-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。</p>

<p>享元模式提出了2个要求：细粒度的对象和共享对象。  <br/>
要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：</p>

<ul>
<li>内部状态（intrinsic）  <br/>
内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。</li>
<li>外部状态（extrinsic） <br/>
外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。</li>
</ul>


<!--more-->


<p>享元模式有以下几个角色：</p>

<ul>
<li>Flyweight抽象享元角色
它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>
<li>ConcreteFlyweight具体享元角色   <br/>
具体的一个产品类，实现抽象角色定义的业务。</li>
<li>unsharedConcreteFlyweight不可共享的享元角色  <br/>
不存在外部状态或者安全要求不能够使用共享技术</li>
<li>FlyweightFactory享元工厂  <br/>
职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。</li>
</ul>


<p>抽象享元角色：</p>

<pre><code>public abstract class Flyweight{
    //内部状态
    private String intrinstic;
    //外部状态
    protected final String Extrinsic;
    //要求享元角色必须接受外部状态
    public Flyweight(String _Extrinsic){
        this.Extrinsic = _Extrinsic;
    }
    //定义业务操作
    public abstract void operate();

    //内部状态的getter/setter
    public String getIntrinsic(){
        return intrinsic;
    }
    public void setIntrinsic(String intrinsic){
        this.intrinsic = intrinsic
    }
}
</code></pre>

<p>具体享元角色：</p>

<pre><code>public class ConcreteFlyweight1 extends Flyweight{
    //接受外部状态
    public ConcreteFlyweight1(String _Extrinsic){
        super(_Extrinsic);
    }
    //根据外部状态进行逻辑处理
    public void operate(){
        //todo
    }    
}

public class ConcreteFlyweight2 extends Flyweight{
    //接受外部状态
    public ConcreteFlyweight1(String _Extrinsic){
        super(_Extrinsic);
    }
    //根据外部状态进行逻辑处理
    public void operate(){
        //todo
    }    
}
</code></pre>

<p>享元工厂：</p>

<pre><code>public class FlyweightFactory{
    //定义一个池容器
    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;&gt;(String,Flyweight);
    //享元工厂
    public static Flyweight getFlyweight(String Extrinsic){
        //需要返回的对象
        Flyweight flyweight = null;
        //在池中没有该对象
        if(pool.containsKey(Extrinsic)){
            flyweight = pool.get(Extrinsic);
        }else{
            //根据外部状态创建享元对象
            flyweight = new ConcreteFlyweight1(Extrinsic);
            //放置到池中
            pool.put(Extrinsic,flyweight);
        }
        return flyweight;
    }

}
</code></pre>

<p>享元模式的使用场景： <br/>
（1）系统中存在大量的相似对象   <br/>
（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。     <br/>
（3）需要缓冲池的场景。</p>
]]></content>
  </entry>
  
</feed>