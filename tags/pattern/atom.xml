<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: pattern | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/pattern/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-07-04T18:58:10+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：策略（strategy） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java/"/>
    <updated>2012-11-02T20:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>

<p>策略模式有3个角色：</p>

<ul>
<li>Context封装角色  <br/>
它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>
<li>Strategy抽象策略角色  <br/>
策略、算法的家族的抽象，通常为接口。</li>
<li>ConcreteStrategy具体策略角色  <br/>
实现抽象策略中的操作，该类含有具体的算法。</li>
</ul>


<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。</p>

<!--more-->


<p>这3个妙计，分别是：</p>

<ul>
<li>找乔国老帮忙（走后门）</li>
<li>求吴国太放行（诉苦）</li>
<li>孙尚香断后</li>
</ul>


<p>首先，设计一个妙计的策略接口：</p>

<pre><code>public interface IStrategy{
    public void operate();
}    
</code></pre>

<p>下面来分别实现这几个妙计。</p>

<pre><code>//妙计1
public class BackDoor implements IStrategy{    
    public void operate(){
        System.out.println("找乔国老帮忙，让吴国太给孙权施加压力");
    }
}
//妙计2
public class GivenGreenLight implements IStrategy{    
    public void operate(){
        System.out.println("找吴国太开绿灯，放行！");
    }
}
//妙计3
public class BlockEnemy implements IStrategy{    
    public void operate(){
        System.out.println("孙尚香断口，挡住追兵！");
    }
}
</code></pre>

<p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。</p>

<pre><code>public class Context{
    private IStrategy strategy;
    public Context(IStrategy strategy){
        this.strategy = strategy;
    }

    public void operate(){
        this.strategy.operate();
    }
}
</code></pre>

<p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。</p>

<p>下面看下赵云如何使用的。</p>

<pre><code>public class ZhaoYun{   
    Context context;
    System.out.println("---刚到吴国的时候拆第一个---");
    context = new Context(new BackDoor());
    context.operate();
    System.out.println("---刘备乐不思蜀了，拆第二个---");
    context = new Context(new GivenGreenLight());
    context.operate();
    System.out.println("---孙权的小兵过来追，拆第三个---");
    context = new Context(new BlockEnemy());
    context.operate();
}
</code></pre>

<p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：责任链（chain of responsibility） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/chain-of-responsibility-in-java/"/>
    <updated>2012-11-02T20:09:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/chain-of-responsibility-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>

<p>责任链由2个角色组成：</p>

<ul>
<li>Handler抽象处理者角色  <br/>
它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。</li>
<li>Concrete Handler具体处理者角色  <br/>
实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。</li>
</ul>


<p>比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：组合（composite） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/composite-in-java/"/>
    <updated>2012-11-02T20:07:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/composite-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>组合模式（Composite Pattern）也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系。确切的定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>

<p>组合模式类图如下：</p>

<p><img src="/images/blog/composite-pattern.jpg" alt="组合模式" /></p>

<p>组合模式有以下几个角色：</p>

<ul>
<li>Component抽象构件角色 <br/>
定义参加组合对象的共有方法和树形，可以定义一些默认的行为或属性。</li>
<li>Leaf叶子构件  <br/>
叶子对象，下面没有其他分支，也就是最小的遍历单位。</li>
<li>Composite树枝构件  <br/>
树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</li>
</ul>


<p>这个说白了就是一个树形结构，不再具体使用例子了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：桥接(bridge) in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/bridge-in-java/"/>
    <updated>2012-11-02T20:06:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/bridge-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。</p>

<h3>为什么要使用桥接模式？</h3>

<p>场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。  <br/>
我们可能很快就会想到这样的方案：</p>

<p><img src="/images/blog/bridge-pattern-1.png" alt="方案1" />      <br/>
按照上面的说法，我们可能要新建4*3=12个类来完成。 <br/>
但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。</p>

<!--more-->


<p>那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。</p>

<p><img src="/images/blog/bridge-pattern-2.png" alt="方案2" /></p>

<h3>桥接模式的角色和职责</h3>

<ul>
<li>Client <br/>
  Bridge模式的使用者</li>
<li>Abstraction <br/>
 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</li>
<li>Refined Abstraction  <br/>
  修正抽象化角色。它引用实现化角色对抽象化角色进行修正。</li>
<li>Implementor  <br/>
  实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。</li>
<li>ConcreteImplementor  <br/>
  它实现接口或者抽象类定义的方法和属性。</li>
</ul>


<h3>使用Bridge模式来实现绘图场景</h3>

<p>Abstraction：</p>

<pre><code>public abstract class Shape {

    protected   Color color;
    public Shape(){
        this.color = new BlackColor();
    }
    public Shape(Color color){
        this.color = color;
    }

    public void setColor(Color color) {
        this.color = color;
    }
    public abstract void draw();

}
</code></pre>

<p>Refined Abstraction：</p>

<pre><code>//圆形
public class CircleShape extends Shape{

    public CircleShape(){
        super();
    }
    public CircleShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个圆形");
        color.draw();
    }
}
//椭圆形
public class EllipseShape extends Shape {

    public EllipseShape(){
        super();
    }
    public EllipseShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个椭圆形");
        color.draw();
    }
}
//矩形
public class RectangleShape extends Shape {

    public  RectangleShape(){
        super();
    }
    public  RectangleShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个矩形");
        color.draw();
    }
}
</code></pre>

<p>Implementor：</p>

<pre><code>public interface Color {

    public void draw();

}
</code></pre>

<p>ConcreteImplementor：</p>

<pre><code>public class WhiteColor implements Color {
    @Override
    public void draw() {
        System.out.println("颜色是白色的");
    }
}  

public class GrayColor implements Color {

    @Override
    public void draw() {
        System.out.println("颜色是灰色的");
    }
}

public class BlackColor implements Color {

    @Override
    public void draw() {
        System.out.println("颜色是黑色的");
    }
} 
</code></pre>

<p>上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。</p>

<pre><code>public class Client {

    public static void main(String[] args) {
        Color whiteColor = new WhiteColor();
        Color grayColor = new GrayColor();
        Color blackColor = new BlackColor();

        Shape circleShape = new CircleShape();
        Shape ellipseShape = new EllipseShape();
        Shape rectangleShape = new RectangleShape();

        //画一个黑色的圆形
        circleShape.setColor(blackColor);
        circleShape.draw();

        //画一个白色的椭圆
        ellipseShape.setColor(whiteColor);
        ellipseShape.draw();

        //画一个灰色的矩形
        rectangleShape.setColor(grayColor);
        rectangleShape.draw();
    }
}
</code></pre>

<p>这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。</p>
]]></content>
  </entry>
  
</feed>