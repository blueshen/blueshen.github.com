<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 享元 | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/享元/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-09-24T19:08:39+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：享元（flyweight） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/flyweight-in-java/"/>
    <updated>2012-11-02T20:07:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/flyweight-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。</p>

<p>享元模式提出了2个要求：细粒度的对象和共享对象。  <br/>
要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：</p>

<ul>
<li>内部状态（intrinsic）  <br/>
内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。</li>
<li>外部状态（extrinsic） <br/>
外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。</li>
</ul>


<!--more-->


<p>享元模式有以下几个角色：</p>

<ul>
<li>Flyweight抽象享元角色
它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>
<li>ConcreteFlyweight具体享元角色   <br/>
具体的一个产品类，实现抽象角色定义的业务。</li>
<li>unsharedConcreteFlyweight不可共享的享元角色  <br/>
不存在外部状态或者安全要求不能够使用共享技术</li>
<li>FlyweightFactory享元工厂  <br/>
职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。</li>
</ul>


<p>抽象享元角色：</p>

<pre><code>public abstract class Flyweight{
    //内部状态
    private String intrinstic;
    //外部状态
    protected final String Extrinsic;
    //要求享元角色必须接受外部状态
    public Flyweight(String _Extrinsic){
        this.Extrinsic = _Extrinsic;
    }
    //定义业务操作
    public abstract void operate();

    //内部状态的getter/setter
    public String getIntrinsic(){
        return intrinsic;
    }
    public void setIntrinsic(String intrinsic){
        this.intrinsic = intrinsic
    }
}
</code></pre>

<p>具体享元角色：</p>

<pre><code>public class ConcreteFlyweight1 extends Flyweight{
    //接受外部状态
    public ConcreteFlyweight1(String _Extrinsic){
        super(_Extrinsic);
    }
    //根据外部状态进行逻辑处理
    public void operate(){
        //todo
    }    
}

public class ConcreteFlyweight2 extends Flyweight{
    //接受外部状态
    public ConcreteFlyweight1(String _Extrinsic){
        super(_Extrinsic);
    }
    //根据外部状态进行逻辑处理
    public void operate(){
        //todo
    }    
}
</code></pre>

<p>享元工厂：</p>

<pre><code>public class FlyweightFactory{
    //定义一个池容器
    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;&gt;(String,Flyweight);
    //享元工厂
    public static Flyweight getFlyweight(String Extrinsic){
        //需要返回的对象
        Flyweight flyweight = null;
        //在池中没有该对象
        if(pool.containsKey(Extrinsic)){
            flyweight = pool.get(Extrinsic);
        }else{
            //根据外部状态创建享元对象
            flyweight = new ConcreteFlyweight1(Extrinsic);
            //放置到池中
            pool.put(Extrinsic,flyweight);
        }
        return flyweight;
    }

}
</code></pre>

<p>享元模式的使用场景： <br/>
（1）系统中存在大量的相似对象   <br/>
（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。     <br/>
（3）需要缓冲池的场景。</p>
]]></content>
  </entry>
  
</feed>