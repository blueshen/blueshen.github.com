<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: jenkins | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/jenkins/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-07-04T20:08:05+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Karma与Jenkins-CI集成]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci/"/>
    <updated>2013-04-01T19:38:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci</id>
    <content type="html"><![CDATA[<p>Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？</p>

<h3>前提条件</h3>

<p>Jenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：</p>

<ul>
<li>Node</li>
<li>Karma</li>
</ul>


<h3>配置Karma.conf.js文件</h3>

<p>必须保证：</p>

<pre><code>singleRun = true;
</code></pre>

<p>只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。  <br/>
在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。</p>

<pre><code>reporters = ['junit'];
junitReporter = {
    outputFile: 'test-results.xml'
};
</code></pre>

<p>那么，Junit格式的测试结果就存到了test-results.xml中。</p>

<p>另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：</p>

<pre><code>reporters = ['coverage'];

preprocessors = {
    'src/*.js': 'coverage'
};

coverageReporter = {
    type : 'cobertura',
    dir : 'coverage/'
};
</code></pre>

<p>这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。</p>

<!--more-->


<h3>一个Jenkins Job</h3>

<p>1.新建一个自由风格（freestyle）的Job即可。 <br/>
2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。 <br/>
3.源码管理部分，填写repository url。  <br/>
4.在构建里，直接填写<code>karma start</code>即可。 <br/>
5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：</p>

<p><img src="/images/blog/karma-jenkins-cobertura.png" alt="karma-jenkins-cobertura" /></p>

<p>6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：</p>

<p><img src="/images/blog/karma-jenkins-junit.png" alt="karma-jenkins-junit" /></p>

<h3>Jenkins运行结果</h3>

<p>Code Coverage结果： <br/>
<img src="/images/blog/karma-jenkins-codecoverage.png" alt="" /></p>

<p>点击进入后，可以看到具体的覆盖率情况： <br/>
<img src="/images/blog/karma-jenkins-codecoverage-detail.png" alt="" /></p>

<p>JUnit结果： <br/>
<img src="/images/blog/karma-jenkins-junit-report.png" alt="" /></p>

<p>点进去后可以查看详细信息：<br/>
<img src="/images/blog/karma-jenkins-junit-report-detail.png" alt="" /></p>

<h3>关于Coverage</h3>

<p>coverageReporter的类型有以下几种：</p>

<ul>
<li>html (default)</li>
<li>lcov (lcov and html)</li>
<li>lcovonly</li>
<li>text (standard output)</li>
<li>text-summary (standard output)</li>
<li>cobertura (xml format supported by Jenkins)</li>
</ul>


<p>Karma是使用<a href="http://gotwarlost.github.com/istanbul/">istanbul</a>来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。 <br/>
以下是lcov类型的Coverage结果：</p>

<p><img src="/images/blog/karma-lcov-1.png" alt="" /></p>

<p>而下面的结果，则指明了哪行源码被覆盖了。 <br/>
<img src="/images/blog/karma-lcov-2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始第一个Jenkins Plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/jenkins-plugin-start/"/>
    <updated>2013-03-22T16:48:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/jenkins-plugin-start</id>
    <content type="html"><![CDATA[<h2>一，Jenkins插件的结构</h2>

<p>Jenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：</p>

<pre><code>xxx.hpi
+- META-INF
|   +-MANIFEST.MF
+- WEB-INF
|   +- classes
|       +- index.jelly
|       +- XXXX.class
|   +- lib
+-  (static resources)
</code></pre>

<p>说明：</p>

<ul>
<li>1.插件的后缀为".hpi",文件名（xxx部分）是插件的简写名字，用来区分插件。</li>
<li>2.如上图结构所示，它与war包类似，只是缺少web.xml。</li>
<li>3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。</li>
<li>4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面</li>
<li>5.WEB-INF/lib 包含插件中需要的.jar文件</li>
<li>6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。</li>
</ul>


<!--more-->


<h2>二，Jenkins-Plugins的开发</h2>

<p>Jenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。</p>

<h3>2.1 Jenkins插件开发时的环境配置</h3>

<p>Jenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。</p>

<h4>2.1.1 JDK配置</h4>

<p>JDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：</p>

<pre><code>JAVA_HOME = C:\Program Files (x86)\Java\jdk1.6.0_38   
CLASSPATH = ...;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;   
PATH = ...;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;   
</code></pre>

<h4>2.1.2 Maven的配置</h4>

<pre><code>M2_HOME =  D:\maven
M2 = %M2_HOME%\bin
MAVEN_OPTS  = -Xms256m -Xmx512m

CLASSPATH = ...;%M2%   
PATH = ...;%M2%   
</code></pre>

<p>可以通过<code>mvn --version</code>,查看maven是否配置成功。</p>

<h4>2.1.3 Maven开发环境的配置</h4>

<p>在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：</p>

<pre><code>&lt;settings&gt;
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;
  &lt;/pluginGroups&gt;

  &lt;profiles&gt;
    &lt;!-- Give access to Jenkins plugins --&gt;
    &lt;profile&gt;
      &lt;id&gt;jenkins&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don't like to have it on per default --&gt;
      &lt;/activation&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
  &lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
      &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
      &lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
  &lt;/mirrors&gt;
&lt;/settings&gt;
</code></pre>

<h3>2.2 生成插件的框架程序</h3>

<p>配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：</p>

<pre><code>mvn hpi:create

Enter the groupId of your plugin: com.baidu.ite.hudson
Enter the artifactId of your plugin: samplePlugin
</code></pre>

<p>这样会建立一个工程，名字为<code>samplePlugin</code>,包路径<code>com.baidu.ite.hudson</code>。 <br/>
或者使用如下的命令：</p>

<pre><code>mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}
</code></pre>

<p>说明： <br/>
1，-u代表jenkins需要更新自己所有的插件内容。 <br/>
2，jenkins中提供的archetype-resources，文件的名字为<code>HelloWorldBuilder.java</code>。我们需要手工修改成自己需要的内容。</p>

<h4>2.2.1 代码结构</h4>

<p>使用 hpi:create生成的文件结构如下：</p>

<pre><code>+- src 
|   +- main 
|   |   +- java
|   |   |   +- groupId.HelloWorldBuilder.java 
|   |   +- resources 
|   |   |   +-  groupId.HelloWorldBuilder
|   |   |   |   +- config.jelly
|   |   |   |   +- help-name.html 
|   |   |   +- index.jelly 
</code></pre>

<p>Jenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。</p>

<h4>2.2.2 代码的解释</h4>

<pre><code>数据的绑定：   

&lt;!--config.jelly--&gt;
&lt;f:entry title="Name" field="name"&gt;
    &lt;f:textbox /&gt;
&lt;/f:entry&gt;

//--HelloWorldBuilder.java--
@DataBoundConstructor
public HelloWorldBuilder(String name) {
    this.name = name;
}
</code></pre>

<p>首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。</p>

<pre><code>Jenkins插件任务的执行

@Override
public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {
    // This is where you 'build' the project.

    // This also shows how you can consult the global configuration of the builder
        listener.getLogger().println("Hello, "+name+"!");
    return true;
}
</code></pre>

<p>根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。</p>

<pre><code>传入数据的检查

 public FormValidation doCheckName(@QueryParameter String value)
                throws IOException, ServletException {
            if (value.length() == 0)
                return FormValidation.error("Please set a name");
            if (value.length() &lt; 4)
                return FormValidation.warning("Isn't the name too short?");
            return FormValidation.ok();
        }
</code></pre>

<p>在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。</p>

<h3>2.3 转换为eclipse工程</h3>

<p>为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：</p>

<pre><code>mvn eclipse:eclipse
或者
mvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse
</code></pre>

<p>第二条较长的命令中，参数是可选的。</p>

<h3>2.4 生成hpi文件</h3>

<p>使用如下命令可以生成<code>./target/pluginname.hpi</code>:</p>

<pre><code>mvn install
或者
mvn package 
</code></pre>

<p>其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。</p>

<h3>2.5 使用.hpl进行调试</h3>

<p>maven中使用<code>.hpl（hudson plugin link）</code>格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似<code>META-INF/MANIFEST.MF</code>的说明文件<code>../path/to/your/plugin/workspace/manifest-debug.mf</code>。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。 <br/>
在maven中可以使用命令：</p>

<pre><code>mvn hpi:hpl -DhudsonHome=/...
</code></pre>

<h3>2.6 使用.hpi进行测试</h3>

<p>在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：</p>

<pre><code>mvn hpi:run -DhudsonHome=/...
</code></pre>

<p>说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。</p>

<hr />

<p>致谢:lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Karma  or Testacular 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief/"/>
    <updated>2013-03-12T15:12:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief</id>
    <content type="html"><![CDATA[<h2>Karma/Testacular是什么？</h2>

<p>在2012年11月，Google开源了<a href="http://testacular.github.com/">Testacular</a>，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。</p>

<p>Testacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与<a href="http://jenkins-ci.org/">Jenkins</a>或<a href="https://travis-ci.org/">Travis</a>整合，用于执行持续集成测试。</p>

<!--more-->


<p>这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到<a href="http://www.jetbrains.com/webstorm/">WebStorm</a>中，而WebStorm持错误栈追踪和单元测试调试。</p>

<p>为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）</p>

<p>说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。</p>

<p>Jína也说到Testacular是受<a href="http://code.google.com/p/js-test-driver/">JS Test Driver(JSTD)</a>的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。</p>

<h2>Vojta Jína原版视频</h2>

<p>youtube(凸墙): <br/>
<a href="http://www.youtube.com/watch?v=5mHjJ4xf_K0">http://www.youtube.com/watch?v=5mHjJ4xf_K0</a>  <br/>
<a href="http://www.youtube.com/watch?v=MVw8N3hTfCI">http://www.youtube.com/watch?v=MVw8N3hTfCI</a>  <br/>
youku[个人转录]:</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Nzky" frameborder=0 allowfullscreen></iframe>




<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Mzc2" frameborder=0 allowfullscreen></iframe>


<h2>Karma/Testacular 安装</h2>

<p>首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：</p>

<pre><code>npm install -g karma/testacular
</code></pre>

<p>安装成功后，可以查看其支持的命令。</p>

<pre><code>testacular --help
Testacular - Spectacular Test Runner for JavaScript.

Usage:
testacular &lt;command&gt;

Commands:
start [&lt;configFile&gt;] [&lt;options&gt;] Start the server / do single run.
init [&lt;configFile&gt;] Initialize a config file.
run [&lt;options&gt;] Trigger a test run.

Run --help with particular command to see its description and   available options.

Options:
--help     Print usage and options.
--version  Print current version.   
</code></pre>

<p>简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。<br/>
下面就来看以下，最主要的部分，那就是配置文件了。</p>

<h2>Karma/Testacular配置文件</h2>

<p>这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。 <br/>
在GitHub上可以看到一个官方提供的默认样例<a href="https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js">https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js</a>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。<br/>
同样的，使用<code>karma/testacular init</code>命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的<code>karma/testacular start</code>也会默认搜索当前目录下的karma/testacular.conf.js来启动。  <br/>
下面，我们来生成一个看看：</p>

<pre><code>karma/testacular init my.conf.js

Which testing framework do you want to use ?
Press tab to list possible options. Enter to move to the next   question.
&gt; mocha

Do you want to use Require.js ?
This will add Require.js adapter into files.
Press tab to list possible options. Enter to move to the next question.
&gt; no

Do you want to capture a browser automatically ?
Press tab to list possible options. Enter empty string to move to the next question.
&gt; Firefox
......

Config file generated at "/home/shenyanchao/tmp/my.conf.js".
</code></pre>

<p>这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是<strong>Tab</strong>。<br/>
此时，执行<code>testacular start my.conf.js</code>,可以发现，浏览器已经启动了。</p>

<p><img src="/images/blog/testacular-run-in-firefox.png" alt="Testacular启动" /></p>

<p><strong>配置文件参数：</strong></p>

<pre><code>autoWatch

类型: Boolean
默认: false
命令行: --auto-watch, --no-auto-watch
详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test

basePath

类型: String
默认: ''
详细介绍: 基本路径，用来解决相对路径问题。

browsers

类型: Array
默认: []
命令行: --browsers Chrome,Firefox
取值:
Chrome
ChromeCanary
Firefox
Opera
Safari
PhantomJS
IE
详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。

captureTimeout

类型: Number
默认: 60000
详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  

colors

类型: Boolean
默认: true
命令行: --colors, --no-colors
详细介绍: 在reporters和logs里面是否启用色彩。
exclude

类型: Array
默认: []
详细介绍: 排除在外的文件列表或者正则表达式

files

类型: Array
默认: []
详细介绍: 要加载的文件列表或者正则表达式

hostname

类型: String
默认: 'localhost'
详细介绍: 启动的浏览器主机名

logLevel

类型: Constant
默认: LOG_INFO
命令行: --log-level debug
取值:
LOG_DISABLE
LOG_ERROR
LOG_WARN
LOG_INFO
LOG_DEBUG
详细介绍: 日志级别.

loggers

类型: Array
默认: [{type: 'console'}]
详细介绍: 定义日志目标。比如log4js

port

类型: Number
默认: 9876
命令行: --port 9876
详细介绍: web服务的监听端口

preprocessors

类型: Object
默认: {'**/*.coffee': 'coffee'}
详细介绍: 前置处理器的MAP

proxies

类型: Object
默认: {}
详细介绍: 路径代理的映射MAP
例如:
proxies =  {
    '/static': 'http://gstatic.com',
    '/web': 'http://localhost:9000'
};

reportSlowerThan

类型: Number
默认: 0
详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 

reporters

类型: Array
默认: ['progress']
命令行: --reporters progress,growl
取值:
dots
progress
junit
growl
coverage
详细介绍: 使用的报表列表

runnerPort

类型: Number
默认: 9100
命令行: --runner-port 9100
详细介绍: 使用testacular run时，服务器的监听端口

singleRun

类型: Boolean
默认: false
命令行: --single-run, no-single-run
详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.

urlRoot

类型: String
默认: '/'
详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。
</code></pre>

<h2>browser无法启动？</h2>

<p>当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。
如果无法找到，可以通过覆盖<code>&lt;BROWSER&gt;_BIN</code>来解决。 <br/>
比如：</p>

<pre><code>export CHROME_BIN=/usr/local/bin/my-chrome-build
export CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build
export PHANTOMJS_BIN=$HOME/local/bin/phantomjs
</code></pre>

<p>就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。</p>

<h2>写在Testacular学习之后</h2>

<p>Testacular应该是Google<a href="http://angularjs.org/">AngularJS</a>的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。<br/>
以上，存在一定的个人猜测，但是其产生的过程值得好好学习。</p>

<h2>改名为Karma</h2>

<p>2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为<code>chore: rename this shit to Karma</code>。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。</p>
]]></content>
  </entry>
  
</feed>