<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: bridge | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/bridge/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-10-20T19:42:56+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：桥接(bridge) in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/bridge-in-java/"/>
    <updated>2012-11-02T20:06:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/bridge-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。</p>

<h3>为什么要使用桥接模式？</h3>

<p>场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。  <br/>
我们可能很快就会想到这样的方案：</p>

<p><img src="/images/blog/bridge-pattern-1.png" alt="方案1" />      <br/>
按照上面的说法，我们可能要新建4*3=12个类来完成。 <br/>
但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。</p>

<!--more-->


<p>那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。</p>

<p><img src="/images/blog/bridge-pattern-2.png" alt="方案2" /></p>

<h3>桥接模式的角色和职责</h3>

<ul>
<li>Client <br/>
  Bridge模式的使用者</li>
<li>Abstraction <br/>
 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</li>
<li>Refined Abstraction  <br/>
  修正抽象化角色。它引用实现化角色对抽象化角色进行修正。</li>
<li>Implementor  <br/>
  实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。</li>
<li>ConcreteImplementor  <br/>
  它实现接口或者抽象类定义的方法和属性。</li>
</ul>


<h3>使用Bridge模式来实现绘图场景</h3>

<p>Abstraction：</p>

<pre><code>public abstract class Shape {

    protected   Color color;
    public Shape(){
        this.color = new BlackColor();
    }
    public Shape(Color color){
        this.color = color;
    }

    public void setColor(Color color) {
        this.color = color;
    }
    public abstract void draw();

}
</code></pre>

<p>Refined Abstraction：</p>

<pre><code>//圆形
public class CircleShape extends Shape{

    public CircleShape(){
        super();
    }
    public CircleShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个圆形");
        color.draw();
    }
}
//椭圆形
public class EllipseShape extends Shape {

    public EllipseShape(){
        super();
    }
    public EllipseShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个椭圆形");
        color.draw();
    }
}
//矩形
public class RectangleShape extends Shape {

    public  RectangleShape(){
        super();
    }
    public  RectangleShape(Color color){
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("画一个矩形");
        color.draw();
    }
}
</code></pre>

<p>Implementor：</p>

<pre><code>public interface Color {

    public void draw();

}
</code></pre>

<p>ConcreteImplementor：</p>

<pre><code>public class WhiteColor implements Color {
    @Override
    public void draw() {
        System.out.println("颜色是白色的");
    }
}  

public class GrayColor implements Color {

    @Override
    public void draw() {
        System.out.println("颜色是灰色的");
    }
}

public class BlackColor implements Color {

    @Override
    public void draw() {
        System.out.println("颜色是黑色的");
    }
} 
</code></pre>

<p>上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。</p>

<pre><code>public class Client {

    public static void main(String[] args) {
        Color whiteColor = new WhiteColor();
        Color grayColor = new GrayColor();
        Color blackColor = new BlackColor();

        Shape circleShape = new CircleShape();
        Shape ellipseShape = new EllipseShape();
        Shape rectangleShape = new RectangleShape();

        //画一个黑色的圆形
        circleShape.setColor(blackColor);
        circleShape.draw();

        //画一个白色的椭圆
        ellipseShape.setColor(whiteColor);
        ellipseShape.draw();

        //画一个灰色的矩形
        rectangleShape.setColor(grayColor);
        rectangleShape.draw();
    }
}
</code></pre>

<p>这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。</p>
]]></content>
  </entry>
  
</feed>