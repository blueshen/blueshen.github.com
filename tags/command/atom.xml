<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: command | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/command/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-05-30T20:21:10+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：命令（Command） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/08/command-in-java/"/>
    <updated>2012-11-08T15:09:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/08/command-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>命令模式是一种高内聚的模式。它将一个请求封装成一个对象，从而让使用不同请求来把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销与恢复功能。 <br/>
听起来，好复杂！</p>

<p>在程序员之间，流传着这样一句话：程序写到最后，就是if-else,for,while。<br/>
真是枯燥啊！其实能体会到这种感觉，说明作为一个程序员，你已经有了一定的造诣了。那如何提高呢？</p>

<p>试想，在代码中，你有很多if-else或者case语句。为什么有这样的语句呢？因为判断条件多啊，需要根据不同的条件来做不同的事情。2、3个条件还可以写，如果有20个条件呢，或者N多呢。那么我们的if-else那就判断N重条件，这简直是无法忍受的，写出的代码可维护性更不用说了。</p>

<!--more-->


<p> <br/>
<strong>命令模式</strong>就是可以解决这种问题的方法之一。下面就来提高一下程序员的自我修养了。</p>

<p>命令模式中，主要有3个角色：</p>

<ul>
<li>Receiver命令接收者</li>
<li>Command命令</li>
<li>Invoker命令调用者</li>
</ul>


<p>下面开始分别定义： <br/>
<strong>Receiver:</strong>定义命令的N种接收者</p>

<pre><code>public abstract class AbstractReceiver {
    public abstract void doSomething();
}

public class Receiver1 extends AbstractReceiver {
    @Override
    public void doSomething() {
        System.out.println("receiver1 do something");
    }
}
public class Receiver2 extends AbstractReceiver {
    @Override
    public void doSomething() {
        System.out.println("receiver2 do something");
    }
}
...
public class ReceiverN
...
</code></pre>

<p><strong>Command:</strong>定义N种命令</p>

<pre><code>public abstract class AbstractCommand {
    public abstract void execute();
}

public class Command1 extends AbstractCommand {
    private AbstractReceiver receiver;
    public Command1(AbstractReceiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        System.out.println("command1 命令发出");
        receiver.doSomething();
    }
}
public class Command2 extends AbstractCommand {
    private AbstractReceiver receiver;
    public Command2(AbstractReceiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        System.out.println("command2 命令发出");
        receiver.doSomething();
    }
}
...
public class CommandN
....
</code></pre>

<p><strong>Invoker:</strong>定义调用者</p>

<pre><code>public class Invoker {

    private List&lt;AbstractCommand&gt; commandList = new LinkedList&lt;AbstractCommand&gt;();

    public void addCommand(AbstractCommand command) {
        commandList.add(command);
    }

    public void addCommands(LinkedList&lt;AbstractCommand&gt; commands) {
        commandList.addAll(commands);
    }

    public void action() {
        for (AbstractCommand command : commandList) {
            command.execute();
        }
    }

}
</code></pre>

<p>使用场景：</p>

<pre><code>Invoker invoker = new Invoker();
AbstractReceiver receiver1 = new Receiver1();
AbstractReceiver receiver2 = new Receiver2();
AbstractCommand command1 = new Command1(receiver2);
AbstractCommand command2 = new Command2(receiver1);
invoker.addCommand(command1);
invoker.addCommand(command2);
invoker.action();
</code></pre>

<p>运行结果：</p>

<pre><code>command1 命令发出
receiver2 do something
command2 命令发出
receiver1 do something
</code></pre>

<p>现在再回过来看命令模式的定义，就比较明白了吧。也就是说有N种请求条件，那么就定义N个类来封装请求，我们称之为命令（Command）。每个命令做什么操作呢，谁来执行这个命令呢，有命令自己来进行定义。这样就避免了if-else，而由N种命令来决定跳转关系。</p>

<p>调用者（Invoker）呢，它维护了一个命令列表，并按照一定的顺序来发起命令调用。当然这个列表也有可能就只有一个命令了，就简化了一下。与if-else对比更直观的了。</p>

<p>定义中还提到了命令撤销或恢复的功能，这种撤销与恢复也是命令的一种了，一般可以通过扩展一个命令出来，通过诸如日志等来恢复之前的操作。其实这个也是可以通过备忘录模式来实现的。</p>

<h2>命令模式 in JDK</h2>

<pre><code>java.lang.Runnable#run()
javax.swing.Action#actionPeformed(ActionEvent e)
</code></pre>

<p>从Runnable来说，不同的实现者，通过调用run()来实现在不同线程执行不同的操作。
从Action来说，由于桌面UI有很多的操作事件，这些事件就是命令。通过actionPerformed函数，接受不同的命令参数来做出不同的表现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 命令]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/10/20/git-command/"/>
    <updated>2012-10-20T10:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/10/20/git-command</id>
    <content type="html"><![CDATA[<h2>Git 命令结构图：</h2>

<!--more-->


<p><img src="/images/blog/git-command.png" alt="git command" /></p>
]]></content>
  </entry>
  
</feed>