<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: jXLS | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/jxls/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-10-22T17:27:37+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 jXLS导出报表]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/06/24/export-excel-by-jxls/"/>
    <updated>2014-06-24T15:17:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/06/24/export-excel-by-jxls</id>
    <content type="html"><![CDATA[<h3>常用的excel操作工具</h3>

<ul>
<li>Apache POI</li>
<li>jexcelApi</li>
</ul>


<p>它们都提供了完善的API来支持EXCEL的读写。</p>

<h3>jXLS是什么？</h3>

<p>jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>

<p>jXLS的基本功能：</p>

<ul>
<li>支持Excel 95-2000的所有版本</li>
<li>生成Excel 2000标准格式</li>
<li>支持字体、数字、日期操作</li>
<li>能够修饰单元格属性</li>
<li><p>支持图像和图表</p>

<pre><code>  &lt;dependency&gt;
         &lt;groupId&gt;net.sf.jxls&lt;/groupId&gt;
         &lt;artifactId&gt;jxls-core&lt;/artifactId&gt;
         &lt;version&gt;1.0.5&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre></li>
</ul>


<!--more-->


<p>jXLS的API也很简单：</p>

<pre><code>            Map beans = new HashMap();
            beans.put("department", department);
            XLSTransformer transformer = new XLSTransformer();
            transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);
</code></pre>

<h3>jXLS是如何解析模板生成数据的？</h3>

<p>查看<code>net.sf.jxls.transformer.CellTransformer</code>可以看到：</p>

<pre><code>Object value = ((Expression) cell.getExpressions().get(0)).evaluate();
</code></pre>

<p>而evaluate()方法如下：</p>

<pre><code>public Object evaluate() throws Exception {
    if (beans != null &amp;&amp; !beans.isEmpty()) {
        JexlContext context = new MapContext(beans);
        Object ret = jexlExpresssion.evaluate(context);
        if (aggregateFunction != null) {
            return calculateAggregate(aggregateFunction, aggregateField, ret);
        }
        return ret;
    }
    return expression;
}
</code></pre>

<p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>

<h3>让jXLS支持hyperlink</h3>

<p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>

<pre><code>    if (cell.getStringCellValue().toLowerCase().startsWith("${href}") &amp;&amp; cell.getExpressions().size() == 3){
           //是链接类型的cell
           HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();
           Expression valueExpr = (Expression)cell.getExpressions().get(1);
           Expression linkExpr = (Expression)cell.getExpressions().get(2);
           hssfCell.setCellValue((String)valueExpr.evaluate());
           Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);
           link.setAddress((String)linkExpr.evaluate());
           hssfCell.setHyperlink(link);
           cell.setPoiCell(hssfCell);
        }
</code></pre>

<p>当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>
]]></content>
  </entry>
  
</feed>