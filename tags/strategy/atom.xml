<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: strategy | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/strategy/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-09-04T18:02:52+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：策略（strategy） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java/"/>
    <updated>2012-11-02T20:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/02/strategy-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>

<p>策略模式有3个角色：</p>

<ul>
<li>Context封装角色  <br/>
它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>
<li>Strategy抽象策略角色  <br/>
策略、算法的家族的抽象，通常为接口。</li>
<li>ConcreteStrategy具体策略角色  <br/>
实现抽象策略中的操作，该类含有具体的算法。</li>
</ul>


<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。</p>

<!--more-->


<p>这3个妙计，分别是：</p>

<ul>
<li>找乔国老帮忙（走后门）</li>
<li>求吴国太放行（诉苦）</li>
<li>孙尚香断后</li>
</ul>


<p>首先，设计一个妙计的策略接口：</p>

<pre><code>public interface IStrategy{
    public void operate();
}    
</code></pre>

<p>下面来分别实现这几个妙计。</p>

<pre><code>//妙计1
public class BackDoor implements IStrategy{    
    public void operate(){
        System.out.println("找乔国老帮忙，让吴国太给孙权施加压力");
    }
}
//妙计2
public class GivenGreenLight implements IStrategy{    
    public void operate(){
        System.out.println("找吴国太开绿灯，放行！");
    }
}
//妙计3
public class BlockEnemy implements IStrategy{    
    public void operate(){
        System.out.println("孙尚香断口，挡住追兵！");
    }
}
</code></pre>

<p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。</p>

<pre><code>public class Context{
    private IStrategy strategy;
    public Context(IStrategy strategy){
        this.strategy = strategy;
    }

    public void operate(){
        this.strategy.operate();
    }
}
</code></pre>

<p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。</p>

<p>下面看下赵云如何使用的。</p>

<pre><code>public class ZhaoYun{   
    Context context;
    System.out.println("---刚到吴国的时候拆第一个---");
    context = new Context(new BackDoor());
    context.operate();
    System.out.println("---刘备乐不思蜀了，拆第二个---");
    context = new Context(new GivenGreenLight());
    context.operate();
    System.out.println("---孙权的小兵过来追，拆第三个---");
    context = new Context(new BlockEnemy());
    context.operate();
}
</code></pre>

<p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。</p>
]]></content>
  </entry>
  
</feed>