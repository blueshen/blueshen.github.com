<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 编码 | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/tags/编码/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-11-14T14:06:30+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux中文件编码转换]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/11/13/encode-convert-in-linux/"/>
    <updated>2014-11-13T16:20:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/11/13/encode-convert-in-linux</id>
    <content type="html"><![CDATA[<p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK->UTF-8文件编码批量转换。</p>

<p>Linux命令-enca 查看文件的编码</p>

<p>Enca语法</p>

<pre><code>Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...
        enconv [-L LANGUAGE] [OPTION]... [FILE]...
        Detect encoding of text files and convert them if required.
</code></pre>

<p>Enca用法</p>

<pre><code>$ enca -L zh_CN file 检查文件的编码
$ enca -L zh_CN -x UTF-8 file 将文件编码转换为"UTF-8"编码
$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样
</code></pre>

<p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。</p>

<!--more-->


<p>转换单个文件的编码</p>

<pre><code>$ enca -L none -x utf-8  index.html
</code></pre>

<p>转换多个文件的编码</p>

<pre><code>$ enca -x utf-8 *
</code></pre>

<p>Linux文件名编码批量转换--convmv</p>

<p>Convmv语法</p>

<pre><code>$ convmv -f 源编码 -t 新编码 [选项] 文件名
</code></pre>

<p>Convmv 常用参数</p>

<pre><code>-r 递归处理子文件夹
–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。
–list 显示所有支持的编码
–unescap 可以做一下转义，比如把%20变成空格
</code></pre>

<p>示例</p>

<p>转换一个文件由GBK转换成UTF-8</p>

<pre><code>convmv -f GBK -t UTF-8 --notest utf8 filename
</code></pre>

<p>GBK->UTF-8文件编码批量转换脚本</p>

<pre><code>$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \;
</code></pre>

<p>使用iconv 转换</p>

<p>Iconv语法</p>

<pre><code>iconv -f encoding -t encoding inputfile
</code></pre>

<p>示例</p>

<p>单个文件转换</p>

<pre><code>$ iconv -f GBK -t UTF-8 file1 -o file2
</code></pre>

<p>批量转换</p>

<pre><code>$ find default -type d -exec mkdir -p utf/{} \;
$ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \;
</code></pre>

<p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>

<hr />

<p>原文:<a href="http://blog.csdn.net/a280606790/article/details/8504133">http://blog.csdn.net/a280606790/article/details/8504133</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[又见Java乱码]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/03/27/java-encode-error-again/"/>
    <updated>2014-03-27T21:43:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/03/27/java-encode-error-again</id>
    <content type="html"><![CDATA[<h3>dom4j解析xml</h3>

<p>dom4j提供了一个<code>DocumentHelper</code>来解析xml内容，此处的内容是String类型的。下面是其源码：</p>

<pre><code>    public static Document parseText(String text) throws DocumentException {
        Document result = null;

        SAXReader reader = new SAXReader();
        String encoding = getEncoding(text);

        InputSource source = new InputSource(new StringReader(text));
        source.setEncoding(encoding);

        result = reader.read(source);

        // if the XML parser doesn't provide a way to retrieve the encoding,
        // specify it manually
        if (result.getXMLEncoding() == null) {
            result.setXMLEncoding(encoding);
        }

        return result;
    }

    private static String getEncoding(String text) {
        String result = null;

        String xml = text.trim();

        if (xml.startsWith("&lt;?xml")) {
            int end = xml.indexOf("?&gt;");
            String sub = xml.substring(0, end);
            StringTokenizer tokens = new StringTokenizer(sub, " =\"\'");

            while (tokens.hasMoreTokens()) {
                String token = tokens.nextToken();

                if ("encoding".equals(token)) {
                    if (tokens.hasMoreTokens()) {
                        result = tokens.nextToken();
                    }

                    break;
                }
            }
        }

        return result;
    }
</code></pre>

<p>从以上的代码中可以看出，解析过程中是使用XML的头<code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>来获取编码信息的。</p>

<!--more-->


<h3>如何读取文件到String</h3>

<pre><code>    public String loadXmlRule() {
        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("file.xml");
        String xmlContent = null;
        try {
            xmlContent = IOUtils.toString(inputStream);
        } catch (IOException e) {
            LOG.error("read xml:{} io error", e);
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        return xmlContent;
    }
</code></pre>

<p><a href="http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as">getResourceAsStream将文件读为字节流</a>，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。</p>

<pre><code>xmlContent = IOUtils.toString(inputStream);

转换为：

xmlContent = IOUtils.toString(inputStream，"UTF-8);//假设文件是UTF-8
</code></pre>

<p>由此，一定要慎重使用编码。<strong>永远不要相信默认编码</strong>。</p>

<h3>Jenkins/Hudson中shell command的编码</h3>

<p>遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。</p>
]]></content>
  </entry>
  
</feed>