<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-05-30T20:17:01+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[selenium wiki:selenium常见问题]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions/"/>
    <updated>2013-05-30T19:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions</id>
    <content type="html"><![CDATA[<h3>selenium常见问题</h3>

<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions">https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions</a></p>

<h4>Q:什么是WebDriver?</h4>

<p>A:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。</p>

<h4>Q:Selenium与<a href="http://sahi.co.in/">Sahi</a>有什么异同？</h4>

<p>A:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。</p>

<h4>Q：什么是Selenium 2.0?</h4>

<p>A:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。</p>

<!--more-->


<h4>Q：如何从原来的selenium api迁移到新的webdriver api?</h4>

<p>A:参见<a href="http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html">http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html</a></p>

<h4>Q:WebDriver支持哪些浏览器？</h4>

<p>A:目前支持<a href="https://code.google.com/p/selenium/wiki/ChromeDriver">ChromeDriver</a>,<a href="https://code.google.com/p/selenium/wiki/InternetExplorerDriver">InternetExplorerDriver</a>,<a href="https://code.google.com/p/selenium/wiki/FirefoxDriver">FirefoxDriver</a>,<a href="https://code.google.com/p/selenium/wiki/OperaDriver">OperaDriver</a>,<a href="https://code.google.com/p/selenium/wiki/HtmlUnitDriver">HtmlUnitDriver</a>。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括<a href="https://code.google.com/p/selenium/wiki/AndroidDriver">AndroidDriver</a>,OperaMobileDriver,IPhoneDriver。</p>

<h4>Q：“developer focused”是什么意思？</h4>

<p>A:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。</p>

<h4>Q:如何直接执行Javascript?</h4>

<p>A:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。  <br/>
我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。</p>

<pre><code>WebDriver driver; // Assigned elsewhere
JavascriptExecutor js =     (JavascriptExecutor) driver;
js.executeScript("return document.title");
</code></pre>

<p>至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。</p>

<h4>Q：为什么我执行Javascript,总是返回NULL？</h4>

<p>A:你需要让你的JS脚本有返回值。所以<code>js.executeScript("document.title");</code>会返回null;而<code>js.executeScript("return document.title");</code>则会返回页面的title。</p>

<h4>Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？</h4>

<p>A:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见<a href="https://code.google.com/p/selenium/wiki/XpathInWebDriver">XpathInWebDriver</a>章节。</p>

<h4>Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？</h4>

<p>A:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：</p>

<pre><code>DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();
capabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);
WebDriver driver = new InternetExplorerDriver(capabilities);    
</code></pre>

<p>正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。</p>

<h4>Q：除了Java，还支持哪些语言？</h4>

<p>A:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。</p>

<h4>Q：如何处理新弹出的浏览器窗口？</h4>

<p>A:WebDriver提供了处理多浏览器窗口的能力。通过使用<code>WebDriver.switchTo().window()</code>可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用<code>"WebDriver.getWindowHandles()</code>获取窗口的名字列表。然后就可以使用<code>switchTo().window()</code>来转向了。</p>

<h4>Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？</h4>

<p>A: 使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html">Alert API</a>可以搞定:</p>

<pre><code>// Get a handle to the open alert, prompt or confirmation
Alert alert = driver.switchTo().alert();
// Get the text of the alert or prompt
alert.getText();  
// And acknowledge the alert (equivalent to clicking "OK")
alert.accept();
</code></pre>

<h4>Q：WebDriver支持文件上传？</h4>

<p>A:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用<code>WebElement#sendKeys("/path/to/file")</code> 就可以正确上传。同时你要保证不要在文件上传元素上进行<code>WebElement#click()</code>操作，否则可能导致浏览器挂起。 <br/>
小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。</p>

<pre><code>((JavascriptExecutor)driver).executeScript("arguments[0].style.visibility = 'visible';      arguments[0].style.height = '1px'; arguments[0].style.width = '1px'; arguments[0].style.opacity = 1", fileUploadElement); 
</code></pre>

<h4>Q：为什么在执行<code>sendKeys</code>后，没有触发onchange事件？</h4>

<p>A:WebDriver是将焦点一直放在调用<code>sendKeys</code>的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的<code>click</code>下其他元素即可。</p>

<h4>Q：能同时运行多个WebDriver的实例？</h4>

<p>A:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。</p>

<h4>Q：我需要使用代理。我该如何配置呢？</h4>

<p>A：代理配置是通过<code>org.openqa.selenium.Proxy</code>类来实现的，类似下面代码所示：</p>

<pre><code>Proxy proxy = new Proxy();
proxy.setProxyAutoconfigUrl("http://youdomain/config");

// We use firefox as an example here.
DesiredCapabilities capabilities = DesiredCapabilities.firefox();
capabilities.setCapability(CapabilityType.PROXY, proxy);

// You could use any webdriver implementation here
WebDriver driver = new FirefoxDriver(capabilities);
</code></pre>

<h4>Q：使用HtmlUnitDriver该如何实现权限验证？</h4>

<p>A:当创建HtmlUnitDriver时，重写<code>modifyWebClient</code>方法即可。例如：</p>

<pre><code>WebDriver driver = new HtmlUnitDriver() {
  protected WebClient modifyWebClient(WebClient client) {
    // This class ships with HtmlUnit itself
    DefaultCredentialsProvider creds = new DefaultCredentialsProvider();

    // Set some example credentials
    creds.addCredentials("username", "password");

    // And now add the provider to the webClient instance
    client.setCredentialsProvider(creds);

    return client;
  }
};
</code></pre>

<h4>Q：WebDriver是线程安全的吗？</h4>

<p>A:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。</p>

<h4>Q：如何向一个可编辑的iframe里输入？</h4>

<p>A:假设那个iframe的name是“foo”:</p>

<pre><code>driver.switchTo().frame("foo");
WebElement editable = driver.switchTo().activeElement();
editable.sendKeys("Your text here");
</code></pre>

<p>有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在<code>sendKeys</code>之前做以下的操作：</p>

<pre><code>((JavascriptExecutor) driver).executeScript("document.body.innerHTML = '&lt;br&gt;'");
</code></pre>

<p>因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。 <br/>
记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。</p>

<pre><code>driver.switchTo().defaultContent();
</code></pre>

<h4>Q：在Linux系统上WebDriver无法启动Firefox，并抛出<code>java.net.SocketException</code>。</h4>

<p>A:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：</p>

<pre><code>Caused by: java.net.SocketException: Invalid argument
        at java.net.PlainSocketImpl.socketBind(Native Method)
        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)
        at java.net.Socket.bind(Socket.java:571)
        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)
        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)
</code></pre>

<p>这可能是因为机器上的IPv6设置导致的。执行下面的脚本：</p>

<pre><code>sudo sysctl net.ipv6.bindv6only=0
</code></pre>

<p>为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑<code>/etc/sysctl.d/bindv6only.conf</code>禁用这个行为。</p>

<h4>Q:WebDriver找不到元素/页面没有完全加载就返回了。</h4>

<p>A:这个问题可以从各种方式显现出来：</p>

<ul>
<li>使用WebDriver.findElement(&#8230;)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。</li>
<li>调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。</li>
<li>click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？</li>
<li>我怎么才能知道一个页面是否已经完全加载了？</li>
</ul>


<p><strong>解析</strong>：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。  <br/>
<strong>解决方案</strong>：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html">WebDriver.manage().timeouts()</a>来实现.</p>

<h4>Q:如何能触发页面上的任意事件？</h4>

<p>A:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。 <br/>
触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。</p>

<h4>Q:为什么不能与隐藏的元素进行交互？</h4>

<p>A:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。
然而，执行JavaScript来直接调用隐藏元素的getText是允许的。</p>

<pre><code>WebElement element = ...;
((JavascriptExecutor) driver).executeScript("return arguments[0].getText();", element);
</code></pre>

<h4>Q:如何启动一个带插件的Firefox？</h4>

<p>A:</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile()
profile.addExtension(....);

WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h4>Q: 要是WebDriver有&#8230;功能，我会更喜欢它。</h4>

<p>A: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。</p>

<h4>Q: 有时Selenium server启动一个新session的时候要花费很长的时间？</h4>

<p>A:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。<br/>
在Windows(XP)系统上，你可以看下<a href="http://bugs.sun.com/view_bug.do?bug_id=6705872">http://bugs.sun.com/view_bug.do?bug_id=6705872</a>,这通常需要从你的临时文件夹清理大量的数据文件。</p>

<h4>Q: 在Selenium WebDriver的API中哪个与TextPresent对等?</h4>

<p>A:</p>

<pre><code>driver.findElement(By.tagName("body")).getText()
</code></pre>

<p>会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。</p>

<h4>Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。</h4>

<p>A:守护Firefox启动的socket lock在设计时，有以下的限制：</p>

<ul>
<li>socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。</li>
<li>启动firefox的某些关键部分必须在机器上独占锁定。</li>
<li>socket lock本身不是瓶颈。启动firefox才是。</li>
</ul>


<p><code>SocketLock</code>是<code>Lock</code>接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。</p>

<h4>Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？</h4>

<p>A: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=&#8221;en_US.UTF-8&#8221;就可以了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:webdriverJs]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js</id>
    <content type="html"><![CDATA[<h1>WebDriverJS</h1>

<p>WebDriver 的 JavaScript 语言绑定。本文包含以下内容：</p>

<ul>
<li>介绍</li>
<li>快速上手

<ul>
<li>在 Node 中运行</li>
<li>在浏览器中运行</li>
</ul>
</li>
<li>设计细节

<ul>
<li>管理异步 API</li>
<li>同服务端通讯</li>
<li>/xdrpc</li>
</ul>
</li>
<li>未来计划</li>
</ul>


<h2>介绍</h2>

<p>WebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。</p>

<p><strong>警告：</strong> WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。</p>

<!--more-->


<h2>快速上手</h2>

<h3>在 Node 中运行</h3>

<p>虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：</p>

<pre><code>$ ./go selenium-server-standalone //javascript/node:webdriver
</code></pre>

<p>当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：</p>

<pre><code>$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
$ node

var webdriver = require('./build/javascript/node/webdriver');

var driver = new webdriver.Builder().
    usingServer('http://localhost:4444/wd/hub').
    withCapabilities({
      'browserName': 'chrome',
      'version': '',
      'platform': 'ANY',
      'javascriptEnabled': true
    }).
    build();

driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click();
driver.getTitle().then(function(title) {
  require('assert').equal('webdriver - Google Search', title);

});

driver.quit();
</code></pre>

<h3>在浏览器中运行</h3>

<p>除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：</p>

<pre><code>$ ./go //javascript/webdriver:webdriver
</code></pre>

<p>为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 <a href="https://code.google.com/p/selenium/wiki/JsonWireProtocol">JsonWireProtocol</a> 和 <a href="https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing">cross-origin resource sharing</a>：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;script&gt;
  var client = new webdriver.http.CorsClient('http://localhost:4444/wd/hub');
  var executor = new webdriver.http.Executor(client);

  // 启动一个新浏览器，这个浏览器可以被这段脚本控制
  var driver = webdriver.WebDriver.createSession(executor, {
    'browserName': 'chrome',
    'version': '',
    'platform': 'ANY',
    'javascriptEnabled': true
  });

  driver.get('http://www.google.com');
  driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
  driver.findElement(webdriver.By.name('btnG')).click();
  driver.getTitle().then(function(title) {
    if (title !== 'webdriver - Google Search') {
      throw new Error(
          'Expected "webdriver - Google Search", but was "' + title + '"');
    }
  });

  driver.quit();
&lt;/script&gt;
</code></pre>

<h4>控制宿主浏览器</h4>

<p>启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。</p>

<pre><code>&lt;!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&amp;wdsid=foo1234 --&gt;
&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;input id="input" type="text"/&gt;
&lt;script&gt;
  // Attaches to the server and session controlling this browser.
  var driver = new webdriver.Builder().build();

  var input = driver.findElement(webdriver.By.tagName('input'));
  input.sendKeys('foo bar baz').then(function() {
    assertEquals('foo bar baz',
        document.getElementById('input').value);
  });
&lt;/script&gt;
</code></pre>

<h5>警告</h5>

<p>在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。</p>

<ul>
<li>webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。</li>
<li><p>webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):</p>

<p>  &lt;!DOCTYPE html>
  <script src="webdriver.js"></script>
  <script></p>

<pre><code>var testWindow = window.open('', 'slave');

var driver = new webdriver.Builder().build();
driver.switchTo().window('slave');
driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click(); 
</code></pre>

<p>  </script></p></li>
</ul>


<h4>调试 Tests</h4>

<p>你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。</p>

<pre><code>$ ./go selenium-server-standalone
$ java -jar \
    -Dwebdriver.server.session.timeout=0 \
    build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
</code></pre>

<p>启动服务后，访问 WebDriver 的控制面板： http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除 sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。</p>

<h5>支持的浏览器</h5>

<ul>
<li>IE 8+</li>
<li>Firefox 4+</li>
<li>Chrome 12+</li>
<li>Opera 12.0a+</li>
<li>Android 4.0+</li>
</ul>


<h2>设计细节</h2>

<h3>管理异步 API</h3>

<p>不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 <a href="http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw">Promise/A</a> 提议，它定义了 promise 是任意对象上的 then 函数属性。</p>

<pre><code>/**
 * Registers listeners for when this instance is resolved.
 *
 * @param {?function(*)} callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {?function(*)=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the failure
 *     reason. While this argument is typically an {@code Error}, any type is
 *     permissible.
 * @return {!Promise} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
Promise.prototype.then = function(callback, opt_errback) {
};
</code></pre>

<p>通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com').then(function() {
  return driver.findElement(webdriver.By.name('q')).then(function(searchBox){
    return searchBox.sendKeys('webdriver').then(function() {
      return driver.findElement(webdriver.By.name('btnG')).then(function(submitButton) {
        return submitButton.click().then(function() {
          return driver.getTitle().then(function(title) {
            assertEquals('webdriver - Google Search', title);
          });
        });
      });
    });
  });
});
</code></pre>

<p>不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。</p>

<p>简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com');

var searchBox = driver.findElement(webdriver.By.name('q'));
searchBox.sendKeys('webdriver');

var submitButton = driver.findElement(webdriver.By.name('btnG'));
submitButton.click();

driver.getTitle().then(function(title) {
  assertEquals('webdriver - Google Search', title);
});
</code></pre>

<h4>On Frames and Callbacks</h4>

<p>就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：</p>

<pre><code>driver.get(MY_APP_URL);
driver.getTitle().then(function(title) {
  if (title === 'Login page') {
    driver.findElement(webdriver.By.id('user')).sendKeys('bugs');
    driver.findElement(webdriver.By.id('pw')).sendKeys('bunny');
    driver.findElement(webdriver.By.id('login')).click();
  }
});
driver.findElement(webdriver.By.id('userPreferences')).click();
</code></pre>

<p>这个测试用例可以使用 WebDriver 的 Java API 重写如下：</p>

<pre><code>driver.get(MY_APP_URL);
if ("Login Page".equals(driver.getTitle())) {
  driver.findElement(By.id("user")).sendKeys("bugs");
  driver.findElement(By.id("pw")).sendKeys("bunny");
  driver.findElement(By.id("login")).click();
}
driver.findElement(By.id("userPreferences")).click();
</code></pre>

<h4>错误处理</h4>

<p>既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。</p>

<p>如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。</p>

<pre><code>// 注册一个事件监听未处理的错误
webdriver.promise.Application.
    getInstance().
    on('uncaughtException', function(e) {
      console.error('There was an uncaught exception: ' + e.message);
    });

driver.switchTo().window('foo').then(null, function(e) {
  // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡
  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {
    throw e;
  }
});
// 如果上面的错误不被抑制的话，这句将永远不会执行
driver.getTitle();
</code></pre>

<h3>同服务端通讯</h3>

<p>当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。</p>

<h4>Cross-Origin Resource Sharing</h4>

<p>如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。</p>

<pre><code>Access-Control-Origin: *
Access-Control-Allow-Methods: DELETE,GET,HEAD,POST
Access-Control-Allow-Headers: Accept,Content-Type
</code></pre>

<p>在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。</p>

<ul>
<li>IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。</li>
<li>WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。</li>
<li>如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。</li>
</ul>


<p>为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。</p>

<h4>/xdrpc</h4>

<p><strong>POST /xdrpc</strong></p>

<p>作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。</p>

<p><strong>参数：</strong></p>

<ul>
<li>method - {string} http 方法</li>
<li>path - {string} 命令路径</li>
<li>data - {Object} JSON 格式的命令参数</li>
</ul>


<p><strong>返回：</strong></p>

<p>{*} 命令执行的结果。</p>

<p>举个例子，考虑以下 /xdrpc 命令：</p>

<pre><code>POST /xdrpc HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 94

{"method":"POST","path":"/session/123/element/0a/element","data":{"using":"id","value":"foo"}}
</code></pre>

<p>服务端将编码这个命令并重新分发：</p>

<pre><code>POST /session/123/element/0a/element HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28

{"using":"id","value":"foo"}
</code></pre>

<p>不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 60

{"status":7,"value":{"message":"Unable to locate element."}}
</code></pre>

<h2>未来计划</h2>

<p>以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）</p>

<ul>
<li>使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。</li>
<li>基于扩展实现一个 SafariDriver。</li>
<li>为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:高级用户交互]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions</id>
    <content type="html"><![CDATA[<h3>AdvancedUserInteractions(高级用户交互)</h3>

<h3>入门</h3>

<p>高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。</p>

<h4>开始（short how to）</h4>

<p>为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：</p>

<pre><code>Actions builder = new Actions(driver);

builder.keyDown(Keys.CONTROL)
.click(someElement)
.click(someOtherElement)
.keyUp(Keys.CONTROL);
</code></pre>

<p>然后，获得操作（Action）:</p>

<pre><code>Action selectMultiple = builder.build();
</code></pre>

<p>最后，执行这个动作：</p>

<pre><code>selectMultiple.perform();   
</code></pre>

<p>这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。</p>

<!--more-->


<p></p>

<h4>键盘交互（Keyboard interactions）</h4>

<p>键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。 <br/>
既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（<code>Keys.TAB</code>）键。<br/>
The new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.</p>

<h4>鼠标交互（Mouse interactions）</h4>

<p>鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。</p>

<h3>支持情况</h3>

<p>这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。</p>

<h3>大纲</h3>

<h4>单个动作</h4>

<p>所有的动作都实现了<code>Action</code>接口，这个接口只有一个方法：<code>perform（）</code>。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。 <br/>
下面是一些动作：</p>

<ul>
<li>ButtonReleaseAction - 释放鼠标左键</li>
<li>ClickAction - 相当于 WebElement.click()</li>
<li>ClickAndHoldAction - 按下鼠标左键并保持</li>
<li>ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。</li>
<li>DoubleClickAction - 双击某个元素</li>
<li>KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）</li>
<li>KeyUpAction - 释放修饰键</li>
<li>MoveMouseAction - 移动鼠标从当前位置到另外的元素.</li>
<li>MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。</li>
<li>SendKeysAction - 相当于 WebElement.sendKey(&#8230;)</li>
</ul>


<p><code>CompositeAction</code>包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用<code>ActionChainsGenerator</code>。</p>

<h4>生成动作链</h4>

<p><code>Actions</code>链生成器实现了创建者模式来新建一个包含一组动作的<code>CompositeAction</code>。使用Actions生成器可以很容易的生成动作并调用<code>build（）</code>方法来获得复杂的操作。</p>

<pre><code>Actions builder = new Actions(driver);

Action dragAndDrop = builder.clickAndHold(someElement)
   .moveToElement(otherElement)
   .release(otherElement)
   .build();

dragAndDrop.perform();
</code></pre>

<p>有一个对<code>Actions</code>进行扩展的计划，给<code>Actions</code>类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展<code>Actions</code>,请往下看。</p>

<h4>扩展Action接口的指导</h4>

<p>Action接口只有一个方法-<code>perform()</code>。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。</p>

<h3>实现细节</h3>

<p>为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：<code>Mouse</code>和<code>Keyboard</code>。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。</p>

<h4>一字警告</h4>

<p><code>Keyboard</code>和<code>Mouse</code>接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。</p>

<h4>Keyboard接口</h4>

<p>Keyboard接口包含3个方法：</p>

<ul>
<li>void sendKeys(CharSequence&#8230; keysToSend) - 与 sendKeys(&#8230;)相似.</li>
<li>void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).</li>
<li>void releaseKey(Keys keyToRelease) - 释放修饰键.</li>
</ul>


<p>至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。</p>

<h4>Mouse接口</h4>

<p><code>Mouse</code>接口包含以下方法（有可能不久之后会有变化）：</p>

<ul>
<li>void click(WebElement onElement) - 同click()方法一样.</li>
<li>void doubleClick(WebElement onElement) - 双击一个元素.</li>
<li>void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持
Action selectMultiple = builder.build();</li>
<li>void mouseUp(WebElement onElement) - 在一个元素上释放左键.</li>
<li>void mouseMove(WebElement toElement) - 从当前位置移动到一个元素</li>
<li>void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标</li>
<li>void contextClick(WebElement onElement) - 在一个元素上做一个右键操作</li>
</ul>


<h4>Native events（原生事件） VS synthetic events（合成事件）</h4>

<p>WebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加<a href="https://code.google.com/p/selenium/wiki/NativeEventsOnLinux">native events on Linux</a>。原生事件无论什么时候总是应该尽可能的使用。</p>

<p>下面的表格展示了浏览器对事件的支持情况。</p>

<table border="1px">
<tr>
<td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td>
</tr>
<tr>
<td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td>
</tr>
<tr>
<td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td>
</tr>
<tr>
<td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td>
</tr>
<tr>
<td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
</table>


<p>*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。</p>

<p>FirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.setEnableNativeEvents(true);
FirefoxDriver driver = new FirefoxDriver(profile);
</code></pre>

<h5>例子</h5>

<p>以下是原生事件与合成事件表现不同的一些例子：</p>

<ul>
<li>使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。</li>
<li>当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。</li>
</ul>


<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/AdvancedUserInteractions">https://code.google.com/p/selenium/wiki/AdvancedUserInteractions</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium WebDriver]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-web-driver/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-web-driver</id>
    <content type="html"><![CDATA[<h1>Selenium WebDriver</h1>

<p>注意：本章内容官方团队正在完善中。</p>

<h2>介绍 WebDriver</h2>

<p>Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。</p>

<h2>同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？</h2>

<p>Selenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。</p>

<p>相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。</p>

<!--more-->


<h2>WebDriver 和 Selenium-Server</h2>

<p>你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。</p>

<p>在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：</p>

<ul>
<li>你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。</li>
<li>你希望连接一台远程的机器来测试一个特定的浏览器。</li>
<li>你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。</li>
</ul>


<h2>设置一个 Selenium-WebDriver 项目</h2>

<p>安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。</p>

<h3>Java</h3>

<p>创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。</p>

<p>首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;MySel20Proj&lt;/groupId&gt;
    &lt;artifactId&gt;MySel20Proj&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
            &lt;version&gt;2.28.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.opera&lt;/groupId&gt;
            &lt;artifactId&gt;operadriver&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.opera&lt;/groupId&gt;
                &lt;artifactId&gt;operadriver&lt;/artifactId&gt;
                &lt;version&gt;1.1&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
                        &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>

<p>确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 <a href="http://seleniumhq.org/download/maven.html">Maven 下载页面</a> 中的最新版本，并修改上述文件中依赖的版本。</p>

<p>命令行进入本目录，运行如下命令：</p>

<pre><code>mvn clean install
</code></pre>

<p>该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。</p>

<p>最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。</p>

<p><a href="http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference">Importing a maven project into IntelliJ IDEA</a></p>

<p><a href="http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference">Importing a maven project into Eclipse</a></p>

<h2>从 Selenium 1.0 迁移</h2>

<p>对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。</p>

<p><a href="http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference">Migrating From Selenium RC to Selenium WebDriver</a></p>

<h2>实例介绍 Selenium-WebDriver API</h2>

<p>WebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。</p>

<p>建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。</p>

<p><strong>注意：</strong> 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。</p>

<p>我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。</p>

<pre><code>package org.openqa.selenium.example;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.WebDriverWait;

public class Selenium2Example  {
    public static void main(String[] args) {
        // 创建了一个 Firefox driver 的实例
        // 注意，其余的代码依赖于接口而非实例
        WebDriver driver = new FirefoxDriver();

        // 使用它访问 Google
        driver.get("http://www.google.com");
        // 同样的事情也可以通过以下代码完成
        // driver.navigate().to("http://www.google.com");

        // 找到搜索输入框
        WebElement element = driver.findElement(By.name("q"));

        // 输入要查找的词
        element.sendKeys("Cheese!");

        // 提交表单
        element.submit();

        // 检查页面标题
        System.out.println("Page title is: " + driver.getTitle());

        // Google 搜索结果由 JavaScript 动态渲染
        // 等待页面加载完毕，超时时间设为10秒
        (new WebDriverWait(driver, 10)).until(new ExpectedCondition&lt;Boolean&gt;() {
            public Boolean apply(WebDriver d) {
                return d.getTitle().toLowerCase().startsWith("cheese!");
            }
        });

        //应该能看到: "cheese! - Google Search"
        System.out.println("Page title is: " + driver.getTitle());

        //关闭浏览器
        driver.quit();
    }
}
</code></pre>

<p>在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。</p>

<h2>Selenium-WebDriver API 和操作</h2>

<h3>获取一个页面</h3>

<p>访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：</p>

<pre><code>driver.get("http://www.google.com");
</code></pre>

<p>包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 <a href="http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference">Explicit and Implicit Waits</a> 等到页面元素可用。</p>

<h3>查找 UI 元素（web 元素）</h3>

<p>WebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。</p>

<p>“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：</p>

<h4>By id</h4>

<p>这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。</p>

<p>HTML:</p>

<pre><code>&lt;div id="coolestWidgetEvah"&gt;...&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement element = driver.findElement(By.id("coolestWidgetEvah"));
</code></pre>

<h4>By Class Name</h4>

<p>&#8220;class&#8221; 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。</p>

<p>HTML:</p>

<pre><code>&lt;div class="cheese"&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class="cheese"&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>List&lt;WebElement&gt; cheeses = driver.findElements(By.className("cheese"));
</code></pre>

<h4>By Tag Name</h4>

<p>根据元素标签名查找。</p>

<p>HTML:</p>

<pre><code>&lt;iframe src="..."&gt;&lt;/iframe&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement frame = driver.findElement(By.tagName("iframe"));
</code></pre>

<h4>By Name</h4>

<p>查找 name 属性匹配的表单元素。</p>

<p>HTML:</p>

<pre><code>&lt;input name="cheese" type="text"/&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.name("cheese"));
</code></pre>

<h4>By Link Text</h4>

<p>查找链接文字匹配的链接元素。</p>

<p>HTML：</p>

<pre><code>&lt;a href="http://www.google.com/search?q=cheese"&gt;cheese&lt;/a&gt;&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.linkText("cheese"));
</code></pre>

<h4>By Partial Link Text</h4>

<p>查找链接文字部分匹配的链接元素。</p>

<p>HTML:</p>

<pre><code>&lt;a href="http://www.google.com/search?q=cheese"&gt;search for cheese&lt;/a&gt;&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.partialLinkText("cheese"));
</code></pre>

<h4>By CSS</h4>

<p>正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 <a href="http://www.w3.org/TR/CSS/#selectors">css 选择器</a>。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。</p>

<p>注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。</p>

<p>HTML:</p>

<pre><code>&lt;div id="food"&gt;&lt;span class="dairy"&gt;milk&lt;/span&gt;&lt;span class="dairy aged"&gt;cheese&lt;/span&gt;&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.cssSelector("#food span.dairy.aged"));
</code></pre>

<h4>By XPATH</h4>

<p>此处略过不译</p>

<h3>用户输入 - 填充表单</h3>

<p>我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：</p>

<pre><code>WebElement select = driver.findElement(By.tagName("select"));
List&lt;WebElement&gt; allOptions = select.findElements(By.tagName("option"));
for (WebElement option : allOptions) {
    System.out.println(String.format("Value is: %s", option.getAttribute("value")));
    option.click();
}
</code></pre>

<p>上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver
有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。</p>

<pre><code>Select select = new Select(driver.findElement(By.tagName("select")));
select.deselectAll();
select.selectByVisibleText("Edam");
</code></pre>

<p>上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。</p>

<p>如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。</p>

<pre><code>driver.findElement(By.id("submit")).click();
</code></pre>

<p>或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。</p>

<pre><code>element.submit();
</code></pre>

<h3>在窗口和帧(frames)之间切换</h3>

<p>有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。</p>

<pre><code>driver.switchTo().window("windowName");
</code></pre>

<p>所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：</p>

<pre><code>&lt;a href="somewhere.html" target="windowName"&gt;Click here to open a new window&lt;/a&gt;
</code></pre>

<p>你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：</p>

<p>   for (String handle : driver.getWindowHandles()) {</p>

<pre><code>    driver.switchTo().window(handle);
}
</code></pre>

<p>你也可以切换到指定帧：</p>

<pre><code>driver.switchTo().frame("frameName");
</code></pre>

<p>你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：</p>

<pre><code>driver.switchTo().frame("frameName.0.child");
</code></pre>

<p>该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 <strong>top</strong> 开始。</p>

<h3>弹出框</h3>

<p>由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：</p>

<pre><code>Alert alert = driver.switchTo().alert();
</code></pre>

<p>该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。</p>

<h3>导航：历史记录和位置</h3>

<p>更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(&#8220;http://www.example.com&#8221;))。正如你所见，WebDriver 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：</p>

<pre><code>driver.navigate().to("http://www.example.com");
</code></pre>

<p>重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。</p>

<p>“navigate” 接口暴露了访问浏览器历史记录的接口：</p>

<pre><code>driver.navigate().forward();
driver.navigate().back();
</code></pre>

<p>需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。</p>

<h3>Cookies</h3>

<p>在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (http://example.com/some404page)。</p>

<pre><code>// 进到正确的域
driver.get("http://www.example.com");

// 设置 cookie，这个cookie 对整个域都有效
Cookie cookie = new Cookie("key", "value");
driver.manage().addCookie(cookie);

// 输出当前 url 所有可用的 cookie
Set&lt;Cookie&gt; allCookies = driver.manage().getCookies();
for (Cookie loadedCookie : allCookies) {
    System.out.println(String.format("%s -&gt; %s", loadedCookie.getName(), loadedCookie.getValue()));
}

// 你可以通过3中方式删除 cookie
// By name
driver.manage().deleteCookieNamed("CookieName");
// By Cookie
driver.manage().deleteCookie(loadedCookie);
// Or all of them
driver.manage().deleteAllCookies();
</code></pre>

<h3>改变 UA</h3>

<p>当使用 Firefox Driver 的时候这很容易：</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.addAdditionalPreference("general.useragent.override", "some UA string");
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h3>拖拽</h3>

<p>以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：</p>

<pre><code>WebElement element = driver.findElement(By.name("source"));
WebElement target = driver.findElement(By.name("target"));

(new Actions(driver)).dragAndDrop(element, target).perform();
</code></pre>

<h2>Driver 特性和权衡</h2>

<h2>Selenium-WebDriver’s Drivers</h2>

<p>WebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：</p>

<h3>HtmlUnit Driver</h3>

<p>这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new HtmlUnitDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>WebDriver 最快速的实现</li>
<li>纯 Java 实现，跨平台</li>
<li>支持 JavaScript</li>
</ul>


<h4>劣势</h4>

<ul>
<li>需要模拟浏览器中 JavaScript 的行为（如下）。</li>
</ul>


<h4>JavaScript in the HtmlUnit Driver</h4>

<p>没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。</p>

<p>当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。</p>

<p>使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。</p>

<h5>启用 JavaScript</h5>

<p>启用 JavaScript 也非常简单：</p>

<pre><code>HtmlUnitDriver driver = new HtmlUnitDriver(true);
</code></pre>

<p>上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。</p>

<h3>Firefox Driver</h3>

<p>我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（<a href="http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55">see the source to see which ones</a>）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new FirefoxDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>在真实的浏览器里运行，且支持 JavaScript</li>
<li>比 IE Driver 快</li>
</ul>


<h4>劣势</h4>

<ul>
<li>比 HtmlUnit Driver 慢</li>
<li>需要修改 Firefox 配置</li>
</ul>


<p>例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：</p>

<pre><code>ProfilesIni allProfiles = new ProfilesIni();
FirefoxProfile profile = allProfiles.getProfile("WebDriver");
profile.setPreferences("foo.bar", 23);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<p>如果配置文件没有注册至 Firefox：</p>

<pre><code>File profileDir = new File("path/to/top/level/of/profile");
FirefoxProfile profile = new FirefoxProfile(profileDir);
profile.addAdditionalPreferences(extraPrefs);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<p>当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.setEnableNativeEvents(true);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h4>信息</h4>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/FirefoxDriver">Firefox section in the wiki page</a> 以获得更多新鲜信息。</p>

<h3>Internet Explorer Driver</h3>

<p>这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new InternetExplorerDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>显然它只在 Windows 系统上有效。</li>
<li>相对较慢。</li>
<li>Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。</li>
<li>IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。</li>
<li>IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.</li>
</ul>


<h4>信息</h4>

<p>访问 <a href="http://code.google.com/p/selenium/wiki/InternetExplorerDriver">Internet Explorer section of the wiki page</a> 以获得更多新鲜信息。特别注意配置部分的内容。</p>

<h3>Chrome Driver</h3>

<p>Chrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 以获得更多信息。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new ChromeDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>运行在真实的浏览器中，并且支持 JavaScript。</li>
<li>由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>比 HtmlUnit 慢</li>
</ul>


<h4>信息</h4>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 以获得更多最新信息。更多信息可以在 <a href="http://seleniumhq.org/download/">下载页面</a> 找到。</p>

<h4>运行 Chrome Driver</h4>

<p>下载 <a href="http://code.google.com/p/chromium/downloads/list">Chrome Driver</a> 并参考 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 上的其他建议。</p>

<h3>Opera Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/OperaDriver">wiki</a></p>

<h3>iPhone Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/IPhoneDriver">wiki</a></p>

<h3>Android Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/AndroidDriver">wiki</a></p>

<h2>可选择的后端：混合 WebDriver 和 RC 技术</h2>

<h3>WebDriver-Backed Selenium-RC</h3>

<p>Java 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。</p>

<p>Selenium-WebDriver 的用法如下：</p>

<pre><code>// 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。
WebDriver driver = new FirefoxDriver();

// 基准 url，selenium 用于解析相对路径。
 String baseUrl = "http://www.google.com";

// 创建一个 Selenium 实现。
Selenium selenium = new WebDriverBackedSelenium(driver, baseUrl);

// 使用 selenium 进行一些操作。
selenium.open("http://www.google.com");
selenium.type("name=q", "cheese");
selenium.click("name=btnG");

// Get the underlying WebDriver implementation back. This will refer to the
// same WebDriver instance as the "driver" variable above.
WebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();

// 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。
// 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。
selenium.stop();
</code></pre>

<h4>优势</h4>

<ul>
<li>允许 WebDriver 和 Selenium API 并存。</li>
<li>提供了简单的机制从 Selenium RC API 迁移至 WebDriver。</li>
<li>不需要运行 Selenium RC server。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>没有实现所有的方法。</li>
<li>一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。</li>
<li>由于底层的实现，有些方法会比较慢。</li>
</ul>


<h3>Backing WebDriver with Selenium</h3>

<p>WebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。</p>

<p>通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：</p>

<pre><code>DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setBrowserName("safari");
CommandExecutor executor = new SeleneseCommandExecutor(new URL("http://localhost:4444/"), new URL("http://www.google.com/"), capabilities);
WebDriver driver = new RemoteWebDriver(executor, capabilities);
</code></pre>

<p>这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。</p>

<h2>运行 Selenium Server 以使用 RemoteDrivers¶</h2>

<p>从 <a href="https://code.google.com/p/selenium/downloads/list">Selenium 下载页面</a> 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 <a href="http://chromedriver.googlecode.com/">google code</a> 下载它。</p>

<p>把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。</p>

<p>从命令行启动服务：</p>

<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar
</code></pre>

<p>如果你希望使用本地事件功能，在命令行添加以下参数：</p>

<pre><code>-Dwebdriver.enable.native.events=1
</code></pre>

<p>查看帮助：</p>

<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar -help
</code></pre>

<p>为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。</p>

<h2>更多资源</h2>

<p>你可以在 <a href="http://code.google.com/p/selenium/wiki/FurtherResources">WebDriver wiki</a> 找到更多有用的资源。</p>

<p>当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：http://groups.google.com/group/selenium-users。</p>

<h2>接下来</h2>

<p>本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium RC]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-rc/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-rc</id>
    <content type="html"><![CDATA[<h1>Selenium 1 (Selenium RC)¶</h1>

<h2>介绍</h2>

<p>正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。</p>

<p>Selenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。</p>

<h2>Selenium RC 如何工作</h2>

<p>首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。</p>

<h3>RC 组件</h3>

<p>Selenium RC 组件是：</p>

<p>Selenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。</p>

<!--more-->


<p>客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。</p>

<p>以下是一个简单的架构图：</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png" alt="架构图" /></p>

<p>上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。</p>

<h3>Selenium 服务端</h3>

<p>Selenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。</p>

<p>RC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。</p>

<p>Server 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。</p>

<h3>客户端库</h3>

<p>客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。</p>

<p>客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。</p>

<p>因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。</p>

<h2>安装</h2>

<p>用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。</p>

<p>一旦你选定了一种编程语言，你仅需要：</p>

<ul>
<li>安装 Selenium RC 服务端。</li>
<li>使用特定于该语言的客户端驱动创建你的项目</li>
</ul>


<h3>安装 Selenium 服务端</h3>

<p>Selenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。</p>

<h3>运行 Selenium 服务</h3>

<p>在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar
</code></pre>

<p>你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。</p>

<p>要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：</p>

<pre><code>java -version
</code></pre>

<p>如果你得到一个版本号（必须>=1.5），那么你已经成功启动 Selenium RC。</p>

<h3>使用 Java 客户端驱动</h3>

<ul>
<li>从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。</li>
<li>提取 selenium-java-<version-number>.jar</li>
<li>打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)</li>
<li>创建一个 java 项目。</li>
<li>将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。</li>
<li>将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。</li>
<li>从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。</li>
<li>从命令行运行 Selenium 服务。</li>
<li>从 Java IDE 或者命令行中执行你的测试。</li>
</ul>


<p>关于更多 Java 测试项目的配置细节，可查看本章附件：<strong>在 Eclipse 中配置 Selenium RC</strong> 和 <strong>在 Intellij 中配置 Selenium RC</strong>。</p>

<h2>将 Selenese 转换成程序</h2>

<p>使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。</p>

<h3>测试脚本范例</h3>

<p>让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：</p>

<table>
    <tbody>
        <tr>
            <td>open</td>
            <td>/</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium rc</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium rc</td>
            <td>&nbsp;</td>
        </tr>
    </tbody>
</table>


<p>注意: 这个例子仅仅在 Google 搜索页面 http://www.google.com 工作。</p>

<h2>Selenese 作为编程代码</h2>

<p>以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。</p>

<pre><code>/** Add JUnit framework to your classpath if not already there
 *  for this example to work
 */
package com.example.tests;

import com.thoughtworks.selenium.*;
import java.util.regex.Pattern;

public class NewTest extends SeleneseTestCase {
    public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
    }
      public void testNew() throws Exception {
          selenium.open("/");
          selenium.type("q", "selenium rc");
          selenium.click("btnG");
          selenium.waitForPageToLoad("30000");
          assertTrue(selenium.isTextPresent("Results * for selenium rc"));
    }
}
</code></pre>

<p>在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。</p>

<h2>编写你的测试代码</h2>

<p>现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：</p>

<ul>
<li>从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。</li>
<li>编写一个 main() 方法来执行创建的代码。</li>
</ul>


<p>你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。</p>

<p>这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。</p>

<h3>Java</h3>

<p>在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。</p>

<p>你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。</p>

<pre><code>selenium = new DefaultSelenium("localhost", 4444, "*iehta", "http://www.google.com/");
</code></pre>

<p>使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。</p>

<pre><code>package com.example.tests;
// 我们指定了这个文件的包

import com.thoughtworks.selenium.*;
// 导入驱动。
// 你将使用它来初始化浏览器并执行一些任务。

import java.util.regex.Pattern;
// 加入正则表达式模块，因为有些我们需要使用它进行校验。
// 如果你的代码不需要它，完全可以移除掉。 

public class NewTest extends SeleneseTestCase {
// 创建 Selenium 测试用例

      public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
             // 初始化并启动浏览器
      }

      public void testNew() throws Exception {
           selenium.open("/");
           selenium.type("q", "selenium rc");
           selenium.click("btnG");
           selenium.waitForPageToLoad("30000");
           assertTrue(selenium.isTextPresent("Results * for selenium rc"));
           // 以上为真实的测试步骤
     }
}
</code></pre>

<h2>学习使用 API</h2>

<p>Selenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。</p>

<h3>启动浏览器</h3>

<pre><code>setUp("http://www.google.com/", "*firefox");
</code></pre>

<p>每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。</p>

<p>创建浏览器对象所需要的参数如下：</p>

<h4>host</h4>

<p>指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。</p>

<h4>port</h4>

<p>指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。</p>

<h4>browser</h4>

<p>指定你希望运行测试的浏览器。该参数必选。</p>

<h4>url</h4>

<p>AUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。</p>

<p>注意，有些客户端要求调用 start() 方法来启动浏览器。</p>

<h3>运行 命令</h3>

<p>一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 &#8220;Selenium&#8221;），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：</p>

<pre><code>selenium.type(“field-id”,”string to type”)
</code></pre>

<p>此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。</p>

<h2>报告结果</h2>

<p>Selenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。</p>

<h3>测试框架报告工具</h3>

<p>很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。</p>

<p>我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。</p>

<h3>测试报告库</h3>

<p>同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。</p>

<h3>最佳实践是？</h3>

<p>大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。</p>

<h3>测试报告范例</h3>

<p>为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。</p>

<h4>Java 中的测试报告</h4>

<ul>
<li>如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 <a href="http://ant.apache.org/manual/Tasks/junitreport.html">JUnit 报告</a> 。</li>
<li>如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 <a href="http://testng.org/doc/documentation-main.html#test-results">TestNG 报告</a> 。</li>
<li>ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 <a href="http://reportng.uncommons.org/">TestNG</a></li>
<li><p>同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：</p>

<p>  <img src="http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png" alt="TestNG-xslt" /></p>

<p>  了解更多 <a href="">TestNG-xslt</a></p></li>
</ul>


<h5>记录 Selenese 命令</h5>

<p>Logging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 <a href="http://loggingselenium.sourceforge.net/index.html">Logging Selenium</a></p>

<h2>为你的测试加点料</h2>

<p>现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。</p>

<p>当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。</p>

<p>本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。</p>

<h3>迭代</h3>

<p>迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。</p>

<p>使用同之前一样的 <a href="http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example">Google 搜索例子</a>，让我们来检查搜索结果。这个测试将使用 Selenese：</p>

<table>
    <tbody>
        <tr>
            <td>open</td>
            <td>/</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium rc</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium rc</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium ide</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium ide</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium grid</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium grid</td>
            <td>&nbsp;</td>
        </tr>
    </tbody>
</table>


<p>同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。</p>

<h3>In Csharp</h3>

<pre><code>// Collection of String values.
String[] arr = {"ide", "rc", "grid"};

// Execute loop for each String in array 'arr'.
foreach (String s in arr) {
    sel.open("/");
    sel.type("q", "selenium " +s);
    sel.click("btnG");
    sel.waitForPageToLoad("30000");
    assertTrue("Expected text: " +s+ " is missing on page."
    , sel.isTextPresent("Results * for selenium " + s));
}
</code></pre>

<h3>条件语句</h3>

<p>我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：</p>

<pre><code>// Java
selenium.type("q", "selenium " +s);
</code></pre>

<p>如果元素“q”不在页面上将会抛出一个异常：</p>

<pre><code>com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found
</code></pre>

<p>这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。</p>

<p>一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：</p>

<pre><code>// 如果元素可用，则则行类型判定操作
if(selenium.isElementPresent("q")) {
    selenium.type("q", "Selenium rc");
} else {
    System.out.printf("Element: " +q+ " is not available on page.")
}
</code></pre>

<p>这样做的好处是，即使页面上没有这个元素测试也能够继续执行。</p>

<h3>在你的测试中执行 JavaScript</h3>

<p>在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。</p>

<p>考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。</p>

<pre><code>// Java
public static String[] getAllCheckboxIds () {
     String script = "var inputId  = new Array();";// Create array in java script.
            script += "var cnt = 0;"; // Counter for check box ids.
            script += "var inputFields  = new Array();"; // Create array in java script.
            script += "inputFields = window.document.getElementsByTagName('input');"; // Collect input elements.
            script += "for(var i=0; i&lt;inputFields.length; i++) {"; // Loop through the collected elements.
            script += "if(inputFields[i].id !=null " +
                      "&amp;&amp; inputFields[i].id !='undefined' " +
                      "&amp;&amp; inputFields[i].getAttribute('type') == 'checkbox') {"; // If input field is of type check box and input id is not null.
            script += "inputId[cnt]=inputFields[i].id ;" + // Save check box id to inputId array.
                      "cnt++;" + // increment the counter.
                      "}" + // end of if.
                      "}"; // end of for.
            script += "inputId.toString();" ;// Convert array in to string.
     String[] checkboxIds = selenium.getEval(script).split(","); // Split the string.
     return checkboxIds;
 }
</code></pre>

<p>如果要计算页面中的图片数，你可以：</p>

<pre><code>// Java
selenium.getEval("window.document.images.length;");
</code></pre>

<p>记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。</p>

<h2>服务端选项</h2>

<p>当服务启动时，可以使用命令行配置项来改变其默认行为。</p>

<p>回想一下，我们是这样启动服务的：</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar
</code></pre>

<p>你可以使用 -h 来查看所有的配置项：</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -h
</code></pre>

<p>你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。</p>

<h3>代理配置</h3>

<p>如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password
</code></pre>

<h3>多窗口模式</h3>

<p>如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png" alt="multi-window" /></p>

<p>有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png" alt="multi-window2" /></p>

<p>对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：</p>

<pre><code>-multiwindow
</code></pre>

<p>在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：</p>

<pre><code>-singlewindow
</code></pre>

<h3>指定 Firefox 配置</h3>

<p>Firefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。</p>

<p>首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：</p>

<pre><code>firefox.exe -profilemanager

firefox.exe -P
</code></pre>

<p>使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。</p>

<pre><code>-firefoxProfileTemplate "path to the profile"
</code></pre>

<p><strong>警告</strong></p>

<p>确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。</p>

<p>更多请参考 <a href="http://support.mozilla.com/zh-CN/kb/Managing+profiles">Mozilla’s Knowledge Base</a></p>

<h3>通过 -htmlSuite 配置项在服务端直接运行 Selenese</h3>

<p>通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -htmlSuite "*firefox"
"http://www.google.com" "c:\absolute\path\to\my\HTMLSuite.html"
"c:\absolute\path\to\my\results.html"
</code></pre>

<p>这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。</p>

<p><strong>注意</strong></p>

<p>在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。</p>

<p>这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。</p>

<h3>Selenium 服务日志</h3>

<h4>服务端日志</h4>

<p>当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -log selenium.log
</code></pre>

<p>这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：</p>

<pre><code>20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -
Browser 465828/:top frame1 posted START NEW
</code></pre>

<p>该信息格式为：</p>

<pre><code>TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE
</code></pre>

<h4>浏览器端日志</h4>

<p>在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -browserSideLog
</code></pre>

<p>为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。</p>

<h3>指定特定浏览器路径</h3>

<p>你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：</p>

<pre><code>*custom &lt;path to browser&gt;
</code></pre>

<h2>Selenium RC 架构</h2>

<p><strong>注意</strong></p>

<p>该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。</p>

<p>为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 <a href="http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy">同源策略</a>。</p>

<h3>同源策略</h3>

<p>Selenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。</p>

<p>为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。</p>

<p>之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。</p>

<p><strong>注意</strong></p>

<p>你可以在维基百科上找到更多关于 <a href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略</a> 和 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> 的内容</p>

<h3>代理注入</h3>

<p>Selenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。</p>

<ol>
<li>代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。</li>
<li>浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：</li>
</ol>


<p><img src="http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png" alt="proxy" /></p>

<p>当测试开始时，将发生以下事情：</p>

<ol>
<li>客户端驱动将和 Selenium RC 服务端建立一个连接。</li>
<li>Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。</li>
<li>客户端驱动向服务端传递一个 Selenese 命令。</li>
<li>服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。</li>
<li>Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。</li>
<li>浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）</li>
<li>Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）</li>
<li>浏览器接收到这个页面并且渲染到相应的帧或者窗口。</li>
</ol>


<h3>高特权浏览器（Heightened Privileges Browsers）</h3>

<p>这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。</p>

<p>结构图如下：</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png" alt="Heightened Privileges Browsers" /></p>

<p>此时，将发生以下事情：</p>

<ol>
<li>客户端驱动和 Selenium RC 服务端建立一个连接。</li>
<li>Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。</li>
<li>Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。</li>
<li>Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。</li>
<li>浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。</li>
</ol>


<h2>处理 HTTPS 和安全警告弹出框</h2>

<p>当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。</p>

<p>为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。</p>

<p>当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。</p>

<p>在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 <em>firefox 和 </em>iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 <em>chrome 和 </em>iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。</p>

<p>在版本1中，推荐运行 <em>firefox 和 </em>iexplore 运行模式。然而，我们还提供 <em>iexploreproxy 和 </em>firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。</p>

<p>在 Selenium RC 的早期版本中，<em>chrome 或 </em>iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。</p>

<h3>关于安全证书</h3>

<p>通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。</p>

<p>为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。</p>

<p>另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。</p>

<h2>更多浏览器支持和相关配置</h2>

<p>Selenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”<em>custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 </em>firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。</p>

<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\Program Files\Mozilla Firefox\MyBrowser.exe&amp;2=http://www.google.com
</code></pre>

<h3>使用不同的浏览器配置来运行测试</h3>

<p>通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。</p>

<p>例如，你使用如下自定义配置启动 Firefox：</p>

<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\Program Files\Mozilla Firefox\firefox.exe&amp;2=http://www.google.com
</code></pre>

<p>注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。</p>

<p>注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。</p>

<h2>常见问题</h2>

<p><strong>译者注：</strong>这部分内容不翻译了，请参考原英文文档。</p>

<ul>
<li>Unable to Connect to Server</li>
<li>Unable to Load the Browser</li>
<li>Selenium Cannot Find the AUT</li>
<li>Firefox Refused Shutdown While Preparing a Profile</li>
<li>Versioning Problems</li>
<li>Error message: “(Unsupported major.minor version 49.0)” while starting server</li>
<li>404 error when running the getNewBrowserSession command</li>
<li>Permission Denied Error</li>
<li>Handling Browser Popup Windows</li>
<li>On Linux, why isn’t my Firefox browser session closing?</li>
<li>Firefox *chrome doesn’t work with custom profile</li>
<li>Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?</li>
<li>Problems With Verify Commands</li>
<li>Safari and MultiWindow Mode</li>
<li>Firefox on Linux</li>
<li>IE and Style Attributes</li>
<li>Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser</li>
<li>Where can I Ask Questions that Aren’t Answered Here?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium Grid]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-grid/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-grid</id>
    <content type="html"><![CDATA[<h1>Selenium Grid</h1>

<h2>快速上手</h2>

<p>如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 <a href="http://code.google.com/p/selenium/wiki/Grid2">Selenium Wiki</a> 的相关文章。</p>

<h2>什么是 Selenium-Grid ?</h2>

<p>Selenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。</p>

<h2>何时需要使用</h2>

<p>通常，以下两种情况你都会需要使用 Selenium-Grid。</p>

<ul>
<li>在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。</li>
<li>减少测试运行时间。</li>
</ul>


<p>Selenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。</p>

<p>Selenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。</p>

<p>另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。</p>

<p>Selenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。</p>

<h2>Selenium-Grid 2.0</h2>

<p>Selenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。</p>

<h2>Selenium-Grid 1.0</h2>

<p>版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 <a href="http://selenium-grid.seleniumhq.org/">Selenium-Grid website</a></p>

<h2>Selenium-Grid 的 Hub 和 Nodes 是如何工作的？</h2>

<p>Grid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。</p>

<p>中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。</p>

<p>我们提供了一些<a href="http://selenium-grid.seleniumhq.org/how_it_works.html">图标</a>来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。</p>

<h2>下载</h2>

<p>下载过程很简单。从 SeleniumHq 站点的<a href="http://docs.seleniumhq.org/download/">下载页面</a>下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。</p>

<p>将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。</p>

<h2>启动 Selenium-Grid</h2>

<p>由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。</p>

<!--more-->


<h3>启动中心</h3>

<p>通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub
</code></pre>

<p>我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。</p>

<h3>启动节点</h3>

<p>通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register
</code></pre>

<p>该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。</p>

<p><strong>警告：</strong> 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。</p>

<h2>配置 Selenium-Grid</h2>

<h3>默认配置</h3>

<h3>JSON 配置文件</h3>

<h3>通过命令行选项配置</h3>

<h2>中心配置</h2>

<p>通过指定 <code>-role hub</code> 即以默认设置启动中心：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub
</code></pre>

<p>你将看到以下日志输出：</p>

<pre><code>Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main
INFO: Launching a selenium grid server
2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT
2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}
2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444
</code></pre>

<h3>指定端口</h3>

<p>中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：</p>

<pre><code>10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444
Exception in thread "main" java.net.BindException: Selenium is already running on port 4444. Or some other service is.
</code></pre>

<p>如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。<code>-port</code> 选项用于修改中心的端口：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441
</code></pre>

<p>即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。</p>

<p>你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：</p>

<pre><code>netstat -a
</code></pre>

<p>Unix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。</p>

<h2>节点配置</h2>

<h2>时间参数</h2>

<h2>获取命令行帮助</h2>

<p>Selenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。</p>

<p>Selenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。</p>

<p>如果你仅传递一个 <code>-h</code> 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -h
</code></pre>

<p>上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 <code>-hub</code> 或 <code>-node</code> 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 <code>-h</code> 选项。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node -h
</code></pre>

<p>对于这个问题，你还可以给 <code>-role node</code> 传递一个垃圾参数：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node xx
</code></pre>

<p>你将先看到 “INFO&#8230;” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：</p>

<pre><code>Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main
INFO: Launching a selenium grid node
org.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444
        at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)
        at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)
        at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)
Error building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444
Usage :
  -hubConfig:
        (hub) a JSON file following grid2 format.

 -nodeTimeout:
        (node) &lt;XXXX&gt;  the timeout in seconds before the hub
          automatically ends a test that hasn't had aby activity than XX
          sec.The browser will be released for another test to use.This
          typically takes care of the client crashes.
</code></pre>

<h2>常见错误</h2>

<h3>Unable to acess the jarfile</h3>

<p>Unable to access jarfile selenium-server-standalone-2.21.0.jar</p>

<p>无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium 文档:入门介绍]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-introduction/"/>
    <updated>2013-05-30T19:54:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-introduction</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<h2>用于网站应用的测试自动化</h2>

<p>如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。</p>

<p>测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。</p>

<p>本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。</p>

<p>对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：</p>

<ul>
<li>频繁的回归测试</li>
<li>快速反馈</li>
<li>几乎无限制的测试用例迭代执行</li>
<li>支持敏捷和极限编程</li>
<li>遵循测试用例的文档</li>
<li>自定义缺陷报告</li>
<li>能找出手工测试中没发现的缺陷</li>
</ul>


<!--more-->


<h2>自动化？或不自动化？</h2>

<p>自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？</p>

<p>自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。</p>

<h2>介绍 Selenium</h2>

<p>Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。</p>

<h2>Selenium 项目简史</h2>

<p>Selenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。</p>

<p>Selenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。</p>

<p>在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。</p>

<p>跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：</p>

<blockquote><p>为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。</p></blockquote>

<h2>Selenium 工具集</h2>

<p>Selenium 由多个软件工具组成，每个具备特定的功能。</p>

<h3>Selenium 2 (又叫 Selenium Webdriver)</h3>

<p>Selenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。</p>

<p>正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。</p>

<p>Selenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。</p>

<h3>Selenium 1 (又叫 Selenium RC 或 Remote Control)</h3>

<p>正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.</p>

<p>Seleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。</p>

<h3>Selenium IDE</h3>

<p>Selenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。</p>

<p><strong>注意</strong></p>

<p>虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.</p>

<h3>Selenium-Grid</h3>

<p>Selenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。</p>

<h2>选择合适你的 Selenium 工具</h2>

<p>很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。</p>

<p>但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。</p>

<p>在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。</p>

<p>我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。</p>

<h2>支持的浏览器和平台</h2>

<p>在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。</p>

<h3>Selenium-WebDriver</h3>

<p>Selenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。</p>

<ul>
<li>Google Chrome 12.0.712.0+</li>
<li>Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable</li>
<li>Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7</li>
<li>Opera 11.5+</li>
<li>HtmlUnit 2.9</li>
<li>Android – 2.3+ for phones and tablets (devices &amp; emulators)</li>
<li>iOS 3+ for phones (devices &amp; emulators) and 3.2+ for tablets (devices &amp; emulators)</li>
</ul>


<p><strong>注意：</strong></p>

<p>在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。</p>

<h3>Selenium 1.0 and Selenium-RC</h3>

<p>这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。</p>

<table border="1">
    <tbody>
    <tr>
        <td><strong>Browser</strong></td>
        <td><strong>Selenium IDE</strong></td>
        <td><strong>Selenium 1 (RC)</strong></td>
        <td><strong>Operating Systems</strong></td>
    </tr>
    <tr>
        <td>Firefox 3.x</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Firefox 3</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Firefox 2</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>IE 8</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>IE 7</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>IE 6</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>Safari 4</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Safari 3</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Safari 2</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Opera 10</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Opera 9</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Opera 8</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Google Chrome</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Others</td>
        <td>Test execution only via Selenium RC</td>
        <td>Partial support possible**</td>
        <td>As applicable</td>
    </tr>
    </tbody>
</table>


<p>* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。</p>

<p>** Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。</p>

<h2>灵活性和可扩展性</h2>

<p>你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。</p>

<h2>本文档包含哪些内容？</h2>

<p>本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。</p>

<p>剩下的章节将讲述以下内容:</p>

<h3>Selenium IDE</h3>

<p>介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。</p>

<h3>Selenium 2</h3>

<p>解释如何通过 Selenium 2 创建自动化测试项目。</p>

<h3>Selenium 1</h3>

<p>解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。</p>

<h3>测试设计</h3>

<p>这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。</p>

<h3>Selenium-Grid</h3>

<p>这部分内容未完成。</p>

<h3>User extensions</h3>

<p>讲述如何修改、扩展和定制 Selenium。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Maven Archetype来生成项目框架]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/21/use-maven-archetype-to-generate-project-architecture/"/>
    <updated>2013-05-21T16:36:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/21/use-maven-archetype-to-generate-project-architecture</id>
    <content type="html"><![CDATA[<h3>Maven in 5 Minutes</h3>

<p><a href="http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">maven官方文档</a>的入门章节就介绍了如何创建一个maven项目。大致如下：</p>

<pre><code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     
</code></pre>

<p>我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？  <br/>
其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。</p>

<!--more-->


<h3>Maven Archetype Plugin</h3>

<p>我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。  <br/>
Maven Archetype Plugin有4个Goal:</p>

<ul>
<li>archetype:create 已过时，用于从archetype创建maven project</li>
<li>archetype:generate  替代create,并且可以用交互的模式</li>
<li>archetype:create-from-project 依据存在的project 创建archetype</li>
<li>archetype:crawl 查找repo里存在的archetypes并更新目录。</li>
</ul>


<h3>实战演练一把</h3>

<p>假设我们已经有了一个项目名叫seleniumframework-start: <br/>
进入到这个工程的根目录，首先执行：</p>

<pre><code>mvn clean archetype:create-from-project
</code></pre>

<p>这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.baidu.selenium.archetypes&lt;/groupId&gt;
  &lt;artifactId&gt;seleniumframework-start-archetype&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;maven-archetype&lt;/packaging&gt;

  &lt;name&gt;seleniumframework-start-archetype&lt;/name&gt;

  &lt;build&gt;
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.apache.maven.archetype&lt;/groupId&gt;
        &lt;artifactId&gt;archetype-packaging&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;

    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<p>这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：</p>

<ul>
<li>${groupId}</li>
<li>${artifactId}</li>
<li>${version}</li>
<li>${package}</li>
</ul>


<p>找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的<code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>转为了<code>&lt;?xml version="${version}" encoding="UTF-8"?&gt;^</code>。这并不是我们想要的，<code>${version}</code>是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：</p>

<pre><code>mvn clean install
</code></pre>

<p>这样，这个archetype就安装到了local repository。
如何使用呢？咱们试试。</p>

<pre><code>mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes -DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0
</code></pre>

<p>其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。<br/>
此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《HTTP权威指南》读书笔记1]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes/"/>
    <updated>2013-05-15T16:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes</id>
    <content type="html"><![CDATA[<h3>URL语法</h3>

<p>完整的URL是建立在由以下9个部分构成的通用格式上的。</p>

<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;   
</code></pre>

<p>其中各个部分代表：</p>

<ul>
<li>scheme(方案)：使用的哪种协议;默认无</li>
<li>user（用户）：用户名；默认匿名</li>
<li>password(密码)：密码</li>
<li>host(主机)：服务器主机名或点分IP地址</li>
<li>port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80</li>
<li>path(路径)：/分割的资源路径</li>
<li>params(参数)：名/值对，使用；分割。</li>
<li>query（查询）：名=值对，用&amp;分割多个</li>
<li>frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。</li>
</ul>


<!--more-->


<h3>HTTP报文格式</h3>

<h4>1.请求报文（request message）</h4>

<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>GET /images/blog/qunit-pic.png HTTP/1.0
Host: www.shenyanchao.cn
</code></pre>

<h4>2.响应报文（request message）</h4>

<pre><code>&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: image/png
Content-Length: 18107
</code></pre>

<p>以上报文格式中，各个部分的描述如下：</p>

<ul>
<li>method（方法）：希望服务器对资源执行的动作。如GET，POST等。</li>
<li>request-URL（请求的URL）：要请求的资源。</li>
<li>version（版本）：报文使用的HTTP协议版本。</li>
<li>status-code(状态码)：描述了请求过程中的状态。</li>
<li>reason-phrase（原因短语）：状态码的可读版本。</li>
<li>header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。</li>
<li>entity-body（实体的主题部分）：任意数据组成的数据块。</li>
</ul>


<h3>HTTP方法</h3>

<h4>1.GET</h4>

<p>请求服务器发送某个资源。请求无主体部分。</p>

<h4>2.HEAD</h4>

<p>与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：</p>

<ul>
<li>在不获取资源的情况下了解资源的情况（比如其类型）;</li>
<li>通过查看响应中的状态码，判断某个对象是否存在。</li>
<li>通过查看header，测试资源是否被修改了。

<h4>3.PUT</h4>

PUT方法用于向服务器写入文档。请求有主体部分。

<h4>4.POST</h4>

POST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。

<h4>5.TRACE</h4>

客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。

<h4>6.OPTIONS</h4>

OPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。

<h4>7.DELETE</h4>

<p>DELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。</p></li>
</ul>


<h3>HTTP连接</h3>

<p>HTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。 <br/>
HTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：</p>

<ul>
<li>客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。</li>
<li>客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。</li>
<li>连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。</li>
<li>服务器回送响应也花费时间。</li>
</ul>


<h4>1.TCP连接握手时延</h4>

<p>由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。</p>

<h4>2.延迟确认</h4>

<p>网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。 <br/>
由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。</p>

<h4>3.TCP慢启动</h4>

<p>TCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。</p>

<h4>4.Nagle算法与TCP_NODELAY</h4>

<p>一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。</p>

<h4>5.TIME_WAIT累积与端口耗尽</h4>

<p>在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。</p>

<h3>HTTP状态码</h3>

<p>+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;+<br/>
|  整体范围   |   已定义范围     |   分类   |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 100～199   | 100～101        | 信息提示 | <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 200～299   | 200～206        | 成功    |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 300~399    | 300~305        | 重定向   |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 400～499   | 400～415       |客户端错误| <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 500~599    | 500~505        | 服务器错误|   <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从windows到linux]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/02/my-linux-dream/"/>
    <updated>2013-05-02T16:37:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/02/my-linux-dream</id>
    <content type="html"><![CDATA[<p>从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.</p>

<p>高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.</p>

<p>大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.</p>

<p>研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.</p>

<p>工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.</p>

<p>大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.</p>

<p>个人常用软件推荐:</p>

<ul>
<li>office: wps for linux  or libreoffice</li>
<li>输入法:  sogou for linux</li>
<li>开发IDE: Intellij IDEA or Eclipse</li>
<li>编辑器: sublime,retext</li>
<li>浏览器: chrome,firefox</li>
<li>邮件客户端: thunderbird</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Karma与Jenkins-CI集成]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci/"/>
    <updated>2013-04-01T19:38:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci</id>
    <content type="html"><![CDATA[<p>Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？</p>

<h3>前提条件</h3>

<p>Jenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：</p>

<ul>
<li>Node</li>
<li>Karma</li>
</ul>


<h3>配置Karma.conf.js文件</h3>

<p>必须保证：</p>

<pre><code>singleRun = true;
</code></pre>

<p>只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。  <br/>
在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。</p>

<pre><code>reporters = ['junit'];
junitReporter = {
    outputFile: 'test-results.xml'
};
</code></pre>

<p>那么，Junit格式的测试结果就存到了test-results.xml中。</p>

<p>另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：</p>

<pre><code>reporters = ['coverage'];

preprocessors = {
    'src/*.js': 'coverage'
};

coverageReporter = {
    type : 'cobertura',
    dir : 'coverage/'
};
</code></pre>

<p>这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。</p>

<!--more-->


<h3>一个Jenkins Job</h3>

<p>1.新建一个自由风格（freestyle）的Job即可。 <br/>
2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。 <br/>
3.源码管理部分，填写repository url。  <br/>
4.在构建里，直接填写<code>karma start</code>即可。 <br/>
5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-cobertura.png" alt="karma-jenkins-cobertura" /></p>

<p>6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit.png" alt="karma-jenkins-junit" /></p>

<h3>Jenkins运行结果</h3>

<p>Code Coverage结果： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-codecoverage.png" alt="" /></p>

<p>点击进入后，可以看到具体的覆盖率情况： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-codecoverage-detail.png" alt="" /></p>

<p>JUnit结果： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit-report.png" alt="" /></p>

<p>点进去后可以查看详细信息：<br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit-report-detail.png" alt="" /></p>

<h3>关于Coverage</h3>

<p>coverageReporter的类型有以下几种：</p>

<ul>
<li>html (default)</li>
<li>lcov (lcov and html)</li>
<li>lcovonly</li>
<li>text (standard output)</li>
<li>text-summary (standard output)</li>
<li>cobertura (xml format supported by Jenkins)</li>
</ul>


<p>Karma是使用<a href="http://gotwarlost.github.com/istanbul/">istanbul</a>来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。 <br/>
以下是lcov类型的Coverage结果：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-lcov-1.png" alt="" /></p>

<p>而下面的结果，则指明了哪行源码被覆盖了。 <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-lcov-2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Karma来驱动mocha测试]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/27/use-karma-to-run-mocha-test/"/>
    <updated>2013-03-27T19:00:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/27/use-karma-to-run-mocha-test</id>
    <content type="html"><![CDATA[<h2>从Testacular到Karma的变化</h2>

<p>2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。<br/>
安装：</p>

<pre><code>npm install -g karma
</code></pre>

<h2>什么时候使用Karma？</h2>

<ul>
<li>在真实浏览器里测试。</li>
<li>在多种浏览器里进行测试（包括桌面、移动）。</li>
<li>在本地开发环境执行测试。</li>
<li>想在持续集成CI内运行测试。</li>
<li>想在每次保存代码时，自动执行测试。</li>
<li>热衷于terminal小黑屏。</li>
<li>不想陷入令人厌烦的测试生活。</li>
<li>想使用Istanbul自动生成coverage报告。</li>
<li>想在源码中使用RequireJS。</li>
</ul>


<h2>Karma不是Testing Framework</h2>

<p>Karma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。</p>

<ul>
<li>Mocha</li>
<li>Jasmine</li>
<li>QUnit</li>
</ul>


<!--more-->


<h2>Karma与Test Framework集成</h2>

<p>Karma对各种Test Framework的支持是以插件的模式进行支持的。<br/>
只需要在karma.conf.js进行以下配置（mocha为例）：</p>

<pre><code>frameworks = ['mocha'];

plugins = [
'karma-mocha'
];
</code></pre>

<p>在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：</p>

<pre><code>npm install karma-mocha
</code></pre>

<p>其他框架依此类推。</p>

<h2>Karma报告</h2>

<p>Karma的报告（reporter）也是以插件模式进行的。</p>

<h4>JUnit Reporter</h4>

<p>首先，要定义reporter类型，在karma.conf.js添加：</p>

<pre><code>reporters = ['junit'];
</code></pre>

<p>如果想更近一步的话，可以配置一下报告的位置。</p>

<pre><code>junitReporter = {
    outputFile: 'junit-report/test-results.xml'
};
</code></pre>

<p>报告配置完了，自然要有依赖啊。执行<code>npm install karma-junit-reporter</code>来安装。然后在加上这个plugin:</p>

<pre><code>plugins = [
    'karma-junit-reporter'
];
</code></pre>

<h4>Coverage Reporter</h4>

<p>同JUnit Reporter一样，首先添加：</p>

<pre><code>reporters = ['coverage'];
</code></pre>

<p>进一步的配置coverage report:</p>

<pre><code>coverageReporter = {
    type : 'cobertura',
    dir : 'coverage/'
};
</code></pre>

<p>其中，type用于指出报告类型；dir用于指出生成报告的存放目录。<br/>
type包括：</p>

<ul>
<li>html (default)</li>
<li>lcov (lcov and html)</li>
<li>lcovonly</li>
<li>text (standard output)</li>
<li>text-summary (standard output)</li>
<li>cobertura (xml format supported by Jenkins)</li>
</ul>


<p>下面，需要安装依赖<code>npm install karma-coverage</code>。并在配置文件内添加：</p>

<pre><code>plugins = [
    'karma-coverage'
];
</code></pre>

<h2>创建一个样例</h2>

<p>1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。</p>

<p>2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。</p>

<p>3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：</p>

<pre><code>// Karma configuration
// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)

// base path, that will be used to resolve files and exclude
basePath = './';

frameworks = ['mocha'];

// list of files / patterns to load in the browser
files = [
    {pattern: 'node_modules/chai/chai.js',include: true},
    'src/*.js',
    'test/*.js'
];


// list of files to exclude
exclude = [
    'karma.conf.js'
];


// use dots reporter, as travis terminal does not support escaping sequences
// possible values: 'dots', 'progress', 'junit', 'teamcity'
// CLI --reporters progress
reporters = ['progress','junit','coverage'];

junitReporter = {
    // will be resolved to basePath (in the same way as files/exclude patterns)
    outputFile: 'junit-report/test-results.xml'
};

preprocessors = {
    'src/*.js': 'coverage'
};

//Code Coverage options. report type available:
//- html (default)
//- lcov (lcov and html)
//- lcovonly
//- text (standard output)
//- text-summary (standard output)
//- cobertura (xml format supported by Jenkins)
coverageReporter = {
    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/
    type : 'cobertura',
    dir : 'coverage/'
};


// web server port
port = 9876;


// cli runner port
runnerPort = 9100;


// enable / disable colors in the output (reporters and logs)
colors = true;


// level of logging
// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG
logLevel = LOG_DEBUG;


// enable / disable watching file and executing tests whenever any file changes
autoWatch = true;


// Start these browsers, currently available:
// - Chrome
// - ChromeCanary
// - Firefox
// - Opera
// - Safari (only Mac)
// - PhantomJS
// - IE (only Windows)
// CLI --browsers Chrome,Firefox,Safari
browsers = ['Chrome'];


// If browser does not capture in given timeout [ms], kill it
captureTimeout = 6000;


// Continuous Integration mode
// if true, it capture browsers, run tests and exit
singleRun = true;


plugins = [
    'karma-mocha',
    'karma-chrome-launcher',
    'karma-firefox-launcher',
    'karma-junit-reporter',
    'karma-coverage'
];
</code></pre>

<p>4.放入相应的代码到src以及test目录里。执行&#8217;karma start&#8217;命令, 浏览器将会被打开，然后执行相应的Test。效果如下图： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-chrome.png" alt="Karma in Chrome" /></p>

<p>完整样例代码： <br/>
<a href="https://github.com/blueshen/Karma-mocha-example">https://github.com/blueshen/Karma-mocha-example</a></p>

<h2>IntelliJ IDEA集成</h2>

<p>为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。 <br/>
1.安装NodeJS插件： Settings &#8211;> IDE Settings &#8211;> Plugins &#8211;> Browse repositories &#8211;> NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。 <br/>
2.配置Karma Server: 从菜单Run &#8211;> Edit Configurations&#8230; &#8211;>点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：  <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-node-server.png" alt="karma-node-server" /></p>

<p>其中：  <br/>
Name： 任意，本处为Karma node Server <br/>
Path to Node: node可执行全路径。$NODE_PATH/bin/node   <br/>
Working Directory: 当前项目的跟路径 <br/>
Path to Node App JS File: 此处为karma的可执行全路径。 <br/>
Application Parameters: 要执行的命令，此处为start   <br/>
Environment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。</p>

<p>3.配置Karma run   <br/>
同Karma Server，只是修改Application Parameters为run
<img src="http://www.shenyanchao.cn/images/blog/karma-node-run.png" alt="karma-node-run" /></p>

<p>配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将<code>singleRun=false</code>,也就是说执行完测试之后不退出。只有在CI环境下才用true。</p>

<p>在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将<code>autoWatch=true</code>,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开始第一个Jenkins Plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/jenkins-plugin-start/"/>
    <updated>2013-03-22T16:48:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/jenkins-plugin-start</id>
    <content type="html"><![CDATA[<h2>一，Jenkins插件的结构</h2>

<p>Jenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：</p>

<pre><code>xxx.hpi
+- META-INF
|   +-MANIFEST.MF
+- WEB-INF
|   +- classes
|       +- index.jelly
|       +- XXXX.class
|   +- lib
+-  (static resources)
</code></pre>

<p>说明：</p>

<ul>
<li>1.插件的后缀为&#8221;.hpi&#8221;,文件名（xxx部分）是插件的简写名字，用来区分插件。</li>
<li>2.如上图结构所示，它与war包类似，只是缺少web.xml。</li>
<li>3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。</li>
<li>4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面</li>
<li>5.WEB-INF/lib 包含插件中需要的.jar文件</li>
<li>6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。</li>
</ul>


<!--more-->


<h2>二，Jenkins-Plugins的开发</h2>

<p>Jenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。</p>

<h3>2.1 Jenkins插件开发时的环境配置</h3>

<p>Jenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。</p>

<h4>2.1.1 JDK配置</h4>

<p>JDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：</p>

<pre><code>JAVA_HOME = C:\Program Files (x86)\Java\jdk1.6.0_38   
CLASSPATH = ...;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;   
PATH = ...;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;   
</code></pre>

<h4>2.1.2 Maven的配置</h4>

<pre><code>M2_HOME =  D:\maven
M2 = %M2_HOME%\bin
MAVEN_OPTS  = -Xms256m -Xmx512m

CLASSPATH = ...;%M2%   
PATH = ...;%M2%   
</code></pre>

<p>可以通过<code>mvn --version</code>,查看maven是否配置成功。</p>

<h4>2.1.3 Maven开发环境的配置</h4>

<p>在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：</p>

<pre><code>&lt;settings&gt;
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;
  &lt;/pluginGroups&gt;

  &lt;profiles&gt;
    &lt;!-- Give access to Jenkins plugins --&gt;
    &lt;profile&gt;
      &lt;id&gt;jenkins&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don't like to have it on per default --&gt;
      &lt;/activation&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
  &lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;
      &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;
      &lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
  &lt;/mirrors&gt;
&lt;/settings&gt;
</code></pre>

<h3>2.2 生成插件的框架程序</h3>

<p>配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：</p>

<pre><code>mvn hpi:create

Enter the groupId of your plugin: com.baidu.ite.hudson
Enter the artifactId of your plugin: samplePlugin
</code></pre>

<p>这样会建立一个工程，名字为<code>samplePlugin</code>,包路径<code>com.baidu.ite.hudson</code>。 <br/>
或者使用如下的命令：</p>

<pre><code>mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}
</code></pre>

<p>说明： <br/>
1，-u代表jenkins需要更新自己所有的插件内容。 <br/>
2，jenkins中提供的archetype-resources，文件的名字为<code>HelloWorldBuilder.java</code>。我们需要手工修改成自己需要的内容。</p>

<h4>2.2.1 代码结构</h4>

<p>使用 hpi:create生成的文件结构如下：</p>

<pre><code>+- src 
|   +- main 
|   |   +- java
|   |   |   +- groupId.HelloWorldBuilder.java 
|   |   +- resources 
|   |   |   +-  groupId.HelloWorldBuilder
|   |   |   |   +- config.jelly
|   |   |   |   +- help-name.html 
|   |   |   +- index.jelly 
</code></pre>

<p>Jenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。</p>

<h4>2.2.2 代码的解释</h4>

<pre><code>数据的绑定：   

&lt;!--config.jelly--&gt;
&lt;f:entry title="Name" field="name"&gt;
    &lt;f:textbox /&gt;
&lt;/f:entry&gt;

//--HelloWorldBuilder.java--
@DataBoundConstructor
public HelloWorldBuilder(String name) {
    this.name = name;
}
</code></pre>

<p>首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。</p>

<pre><code>Jenkins插件任务的执行

@Override
public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {
    // This is where you 'build' the project.

    // This also shows how you can consult the global configuration of the builder
        listener.getLogger().println("Hello, "+name+"!");
    return true;
}
</code></pre>

<p>根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。</p>

<pre><code>传入数据的检查

 public FormValidation doCheckName(@QueryParameter String value)
                throws IOException, ServletException {
            if (value.length() == 0)
                return FormValidation.error("Please set a name");
            if (value.length() &lt; 4)
                return FormValidation.warning("Isn't the name too short?");
            return FormValidation.ok();
        }
</code></pre>

<p>在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。</p>

<h3>2.3 转换为eclipse工程</h3>

<p>为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：</p>

<pre><code>mvn eclipse:eclipse
或者
mvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse
</code></pre>

<p>第二条较长的命令中，参数是可选的。</p>

<h3>2.4 生成hpi文件</h3>

<p>使用如下命令可以生成<code>./target/pluginname.hpi</code>:</p>

<pre><code>mvn install
或者
mvn package 
</code></pre>

<p>其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。</p>

<h3>2.5 使用.hpl进行调试</h3>

<p>maven中使用<code>.hpl（hudson plugin link）</code>格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似<code>META-INF/MANIFEST.MF</code>的说明文件<code>../path/to/your/plugin/workspace/manifest-debug.mf</code>。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。 <br/>
在maven中可以使用命令：</p>

<pre><code>mvn hpi:hpl -DhudsonHome=/...
</code></pre>

<h3>2.6 使用.hpi进行测试</h3>

<p>在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：</p>

<pre><code>mvn hpi:run -DhudsonHome=/...
</code></pre>

<p>说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。</p>

<hr />

<p>致谢:lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JsTestDriver 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/jstestdriver-in-brief/"/>
    <updated>2013-03-22T16:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/jstestdriver-in-brief</id>
    <content type="html"><![CDATA[<h1>jsTestDriver</h1>

<p>jsTestDriver是一个JavaScript单元测试工具，易于与持续构建系统相集成并能够在多个浏览器上执行运行测试，轻松实现TDD（测试驱动开发）风格的开发。当在项目中配置好js-test-driver以后，如同junit测试java文件一般，js-test-driver可以直接通过直接运行js文件，来对js文件单元测试。 <br/>
<img src="http://www.shenyanchao.cn/images/blog/jsTestDriver-framework.jpg" alt="alt jsTestDriver框架" /></p>

<!--more-->


<h5>在Intellij IDEA中安装JsTestDriver</h5>

<ul>
<li>打开IDEA编辑器，点击<strong>File</strong>，点击下拉列表中的<strong>setting</strong>，进入IDEA设置对话框</li>
<li>在搜索框中键入<strong>plugins</strong>，在搜索结果中选择<strong>plugins</strong>这一项</li>
<li>点击<strong>Browse Repositories</strong>，在弹出的列表中搜索jsTestDriver。</li>
<li>右击jsTestDriver插件，选择<strong>Download and Install</strong>.</li>
</ul>


<p><img src="http://www.shenyanchao.cn/images/blog/idea-install-jstestdriver-plugin-dialog.png" alt="alt jsTestDriver插件安装" /></p>

<h5>在IDEA中使用jsTestDriver运行js测试代码</h5>

<ul>
<li>在IDEA中新建一个空的工程，在工程目录下新建代码包test</li>
<li><p>在src代码包中新建Greeter.js代码如下：</p>

<p>  myapp = {};<br/>
  myapp.Greeter = function() { };<br/>
  myapp.Greeter.prototype.greet = function(name) {
  return &#8220;Hello &#8221; + name + &#8220;!&#8221;;<br/>
  };</p></li>
<li><p>在test代码包中新建GreeterTest.js,代码如下</p>

<p>  GGdTestCase(&#8220;GreeterTest&#8221;, {
  &#8220;test greet&#8221;: function() {</p>

<pre><code>  var greeter = new myapp.Greeter();
  assertEquals("Hello World!", greeter.greet("World"));
</code></pre>

  },
  &#8220;test greet null&#8221;: function() {

<pre><code>  var greeter = new myapp.Greeter();
  //assertNull(greeter.greet(null));
  assertTrue(true);
</code></pre>

<p>  }
  });</p></li>
<li><p>在项目主文件夹中新建配置文件greeter.jstd,文件内容如下：</p>

<p>  load:<br/>
&#8211; src/Greeter.js<br/>
&#8211;test/GreeterTest.js</p></li>
<li>启动jsTestDriver Server<br/>
<img src="http://www.shenyanchao.cn/images/blog/jsTestDriver-server.jpg" alt="alt jsTestDriver server" /></li>
<li>打开本地浏览器，访问url http://localhost:9876/capture</li>
<li>运行greeter.jstd</li>
</ul>


<h5>在Eclipse中安装jsTestDriver</h5>

<ul>
<li>在<strong>Help</strong>中的<strong>Install new software</strong>中，添加一个update site ：http://js-test-driver.googlecode.com/svn/update/</li>
<li>安装完毕后，重启Eclipse，新建一个空的java项目</li>
<li>在java项目中添加test代码包，在src中新建src.js,其代码如IDEA中的Greeter.js一样。</li>
<li>在test中添加test.js，其代码和IDEA中GreeterTest.js一样。</li>
<li><p>在项目目录中添加配置文件jsTestDriver.conf，其内容为</p>

<p>  load:<br/>
  &#8211; src/<em>.js<br/>
  &#8211; test/</em>.js<br/>
目录结构如图：<br/>
<img src="http://www.shenyanchao.cn/images/blog/eclipse-jstestDriver.jpg" alt="alt 目录结构" /></p></li>
<li>配置Run Configuration，新建一个Js Test Driver Test, 选择好项目和相应的配置文件。</li>
<li>启动jsTestDriver服务器，然后用浏览器去访问http://127.0.0.1:4244/capture，这样就可以在
浏览器中执行我们的js测试脚本了。<br/>
<img src="http://www.shenyanchao.cn/images/blog//eclipse-test.jpg" alt="alt eclipse执行结果" /><br/>
我们可以再eclipse中配置jsTestDriver的相关项，如图：<br/>
<img src="http://www.shenyanchao.cn/images/blog//eclipse-js-setting.jpg" alt="alt eclipse配置jsTestDriver" /></li>
</ul>


<hr />

<p>参考文献：<a href="http://code.google.com/p/js-test-driver/">http://code.google.com/p/js-test-driver/</a> <br/>
感谢：youthflies</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jasmine 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/jasmine-in-brief/"/>
    <updated>2013-03-22T15:47:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/jasmine-in-brief</id>
    <content type="html"><![CDATA[<h2>jasmine测试框架简介</h2>

<p><strong>jasmine</strong>是一种javascript测试框架，它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。</p>

<h3>jasmine的简单语法</h3>

<p>一个基本的jasmine测试用例如下：</p>

<pre><code>describe("A suite", function() {  
    it("contains spec with an expectation", function() {  
    expect(true).toBe(true);  
    });  
});   
</code></pre>

<h4>describe方法</h4>

<p>describe方法标志着一个测试集(test suite)的开始，这个方法有两个参数，一个字符串String，一个方法function；字符串用来描述我们这个test suite，function里的东西就是测试代码，它们就是suite。</p>

<!--more-->


<h4>it方法</h4>

<p>jasmine中用方法it来开始specs（我理解成测试点，一个测试suite里可以有很多spec）。it方法和describe方法类似，同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。一个测试点(spec)可以包含多个expections（其实是断言的意思）。</p>

<h4>expectations</h4>

<p>断言可以返回为true或者false。全部的断言返回true这个测试点就通过，一个或者多个断言返回false这个测试点就不通过。<br/>
describe和it都是方法，我们可以自定义一些变量，在describe中定义的变量，在it方法中可以直接使用。</p>

<pre><code>describe("A suite is just a function", function() {
var a;

it("and so is a spec", function() {
    a = true;

    expect(a).toBe(true);
});
});  
</code></pre>

<h4>Matchers</h4>

<p>一个一个的测试点们由expect开头，后面跟着一个我们需要测试的变量，如上面的a，然后跟着一个Matcher方法（我理解成校验规则），Matcher方法带着一个期望值，如上面的true。Matchers方法返回true或者false，它决定着测试点（spec）是否通过。所有的Matchers方法都能在mathcer前面加上not来进行否定断言，如`expect(a).not.toBe(true);</p>

<p>jasmine中有很多Matchers方法供我们使用，当然我们也可以定义自己的Matchers方法。</p>

<pre><code>describe("Included matchers:", function() {

    it("The 'toBe' matcher compares with ===", function() {
        var a = 12;
        var b = a;

        expect(a).toBe(b);
        expect(a).not.toBe(null);
    });  
    //上面的例子，比较a、b是否相等；验证a是否不是空。 

    it("should work for objects", function() {
        var foo = {
            a: 12,
            b: 34
        };
        var bar = {
            a: 12,
            b: 34
        };
        expect(foo).toEqual(bar);
    });
    //上面的例子比较了两个对象是否相等
});

it("The 'toMatch' matcher is for regular expressions", function() {
    var message = 'foo bar baz';

    expect(message).toMatch(/bar/);
    expect(message).toMatch('bar');
    expect(message).not.toMatch(/quux/);
});
//也可以使用正则表达式

it("The 'toBeDefined' matcher compares against `undefined`", function() {
    var a = {
        foo: 'foo'
    };

    expect(a.foo).toBeDefined();
    expect(a.bar).not.toBeDefined();
});
//验证变量是否被定义

it("The 'toBeNull' matcher compares against null", function() {
    var a = null;
    var foo = 'foo';

    expect(null).toBeNull();
    expect(a).toBeNull();
    expect(foo).not.toBeNull();
});
//验证是否为空

it("The 'toBeTruthy' matcher is for boolean casting testing", function() {
    var a, foo = 'foo';

    expect(foo).toBeTruthy();
    expect(a).not.toBeTruthy();
});

it("The 'toBeFalsy' matcher is for boolean casting testing", function() {
    var a, foo = 'foo';

    expect(a).toBeFalsy();
    expect(foo).not.toBeFalsy();
});
//变量是否能够转化成boolean变量？ 不太确定

it("The 'toContain' matcher is for finding an item in an Array", function() {
    var a = ['foo', 'bar', 'baz'];

    expect(a).toContain('bar');
    expect(a).not.toContain('quux');
});
//是否包含
it("The 'toBeLessThan' matcher is for mathematical comparisons", function() {
    var pi = 3.1415926, e = 2.78;

    expect(e).toBeLessThan(pi);
    expect(pi).not.toBeLessThan(e);
});

it("The 'toBeGreaterThan' is for mathematical comparisons", function() {
    var pi = 3.1415926, e = 2.78;

    expect(pi).toBeGreaterThan(e);
    expect(e).not.toBeGreaterThan(pi);
});
//数学大小的比较

it("The 'toBeCloseTo' matcher is for precision math comparison", function() {
var pi = 3.1415926, e = 2.78;

expect(pi).not.toBeCloseTo(e, 2);
expect(pi).toBeCloseTo(e, 0);
});
//两个数值是否接近，这里接近的意思是将pi和e保留一定小数位数后，是否相等。（一定小数位数：默认为2，也可以手动指定）

it("The 'toThrow' matcher is for testing if a function throws an exception", function() {
    var foo = function() {
    return 1 + 2;
    };
    var bar = function() {
        return a + 1;
    };

    expect(foo).not.toThrow();
    expect(bar).toThrow();
    });
}); 
//测试一个方法是否抛出异常  
</code></pre>

<h4>Setup和Teardown方法</h4>

<p>为了代码简洁，减少重复性的工作，jasmine提供<code>beforeEach</code>和<code>afterEach</code>方法。<code>beforeEach</code>会在每个spec之前执行，<code>after</code>会在每个spec之后执行，类似于selenium中的<code>beforeMethod</code>和<code>afterMethod</code>方法。</p>

<pre><code>describe("A spec (with setup and tear-down)", function() {
    var foo;

    beforeEach(function() {
        foo = 1;
    });

    afterEach(function() {
        foo = 0;
    });

    it("is just a function, so it can contain any code", function() {
        expect(foo).toEqual(1);
    });

    it("can have more than one expectation", function() {
        expect(foo).toEqual(1);
        expect(true).toEqual(true);
    });
});  
</code></pre>

<p>另外describe和it作为方法是可以嵌套的，也就是describe中可以出现子describe和it。</p>

<h4>禁用某些spec和suites</h4>

<p>在测试中，我们可能需要禁用一些suites和spec，方法是使用xdescribe和xit方法，这些测试的方法会被忽略，不计入统计结果。</p>

<h4>The Runner and Reporter</h4>

<p>Jasmine是用javascript实现的，所以它也必须在javascript的环境中运行，最简单的环境也就是一个web页面。所有的spec都可以在这个页面中运行，这个页面就叫做Runner。</p>

<p>Jasmine通过下面的js代码来展现spec运行结果：</p>

<pre><code>var htmlReporter = new jasmine.HtmlReporter(); //创建一个HTMLReporter
jasmineEnv.addReporter(htmlReporter);  

jasmineEnv.specFilter = function(spec) {  //一个过滤器，允许我们点击单个的suites，单独运行
return htmlReporter.specFilter(spec);
};  


var currentWindowOnload = window.onload;   //页面加载完毕后，执行所有的test。
window.onload = function() {
    if (currentWindowOnload) {
        currentWindowOnload();
    }

    document.querySelector('.version').innerHTML = jasmineEnv.versionString();
    execJasmine();
};

function execJasmine() {
        jasmineEnv.execute();
}
})();
</code></pre>

<hr />

<p>参考文献：<a href="http://pivotal.github.com/jasmine/">http://pivotal.github.com/jasmine/</a> <br/>
感谢：youthflies</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qunit 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/qunit-in-brief/"/>
    <updated>2013-03-22T15:21:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/qunit-in-brief</id>
    <content type="html"><![CDATA[<h1>QUnit</h1>

<p>QUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。 <br/>
<a href="http://qunitjs.com/">项目官网</a> <br/>
<a href="https://github.com/jquery/qunit">文件下载地址</a></p>

<h1>建立测试程序</h1>

<p>建立html测试页面，引入 <code>qunit.js</code> 和 <code>qunit.css</code> 这两个必需的文件。其中<code>qunit.js</code>是测试套件程序，<code>qunit.css</code>用于控制测试套件的结果显示的样式。</p>

<pre><code>&lt;!--sample.html:--&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
  &lt;title&gt;QUnit basic example&lt;/title&gt;
  &lt;link rel="stylesheet" href="./resources/qunit.css"&gt;
&lt;script type="text/javascript" src="./resources/jquery.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="qunit"&gt;&lt;/div&gt;
  &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;script src="./resources/qunit.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    test( "a basic test example", function() {
      var value = "hello";
      equal( value, "hello", "We expect value to be hello" );
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<!--more-->


<p>其中放置的文件及文件结构如下：</p>

<pre><code>|-qunit-test   
|  |-sample.html   
|  |-resources   
|  |    |-qunit.js   
|  |    |-qunit.css
|  |    |-jquery.js   
</code></pre>

<p>测试的结果会由<code>qunit.js</code>控制输出到页面代码中的<code>&lt;div id="qunit"&gt;&lt;/div&gt;</code>中。另外一个必不可少的元素是<code>&lt;div id=""qunit-fixture""&gt;&lt;/div&gt;</code>。在每个test执行完毕后，如果改动了该元素，会自动重置。<code>jquery.js</code>的引入是为了测试使用jQuery语法写的程序。 <br/>
在浏览器中打开sample1.html可以看到结果显示如下图所示： <br/>
<img src="http://www.shenyanchao.cn/images/blog/qunit-pic.png" alt="qunit的用例运行显示结果" /></p>

<h1>测试框架使用说明</h1>

<p>标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。 <br/>
下面是3个checkbox。&#8221;Hide passed tests&#8221;点击后可以过滤掉通过的用例，只显示失败的用例。&#8221;Check for Globals&#8221;，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。&#8221;No try-catch&#8221;用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。</p>

<h1>断言</h1>

<ul>
<li><strong>ok( truthy [, message ] )</strong>   判断是否为true</li>
<li><strong>equal( actual, expected [, message ] )</strong>    判断actual==expected</li>
<li><strong>deepEqual( actual, expected [, message ] )</strong>    判断actual===expected</li>
</ul>


<p>用例如下：</p>

<pre><code>test("assertion",function(){   

    ok( true, "true succeeds" );
    ok( NaN, "NaN fails" );

    equal( 0, 0, "0, 0 : equal succeeds" );
    equal( "", 0, "Empty, 0: equal succeeds" );
    equal( null, "", "null, empty: equal fails" );

    var obj = { foo: "bar" };
    deepEqual( obj, { foo: "bar" }, "Two objects can be the same in value" );
    equal( "", 0, "Empty, 0: equal succeeds" );
});    
</code></pre>

<h1>测试同步代码</h1>

<p>在同步代码的测试中，有两种方式： <br/>
-   test( name, expected, fucntion(){&#8230;})：expceted指assertion的数量。 <br/>
-   test( name, function(){expected(amount);&#8230;})：在function中增加expected(amount)，amount表示assertiong的数量。</p>

<p>test()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。</p>

<pre><code>test( "a test", 2, function() {
    ok( true, "sucess" );
    ok( false, "fail" );
});   

test( "a test", function() {
  expect( 2 );

  function calc( x, operation ) {
    return operation( x );
  }

  var result = calc( 2, function( x ) {
    ok( true, "calc() calls operation function" );
    return x * x;
  });

  equal( result, 4, "2 square equals 4" );
});
</code></pre>

<h1>测试异步代码</h1>

<p>对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。</p>

<pre><code>asyncTest( "asynchronous test: one second later!", function() {
  expect( 1 );

  setTimeout(function() {
     ok( true, "Passed and ready to resume!" );
     start();
  }, 1000);
});      
</code></pre>

<h1>用户行为的测试</h1>

<p>测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用<code>trigger()</code>或者<code>triggerHandler()</code>来实现。</p>

<pre><code>test( "div click test", 1, function() {
  var $body = $( "#qunit-fixture" );

  $body.bind( "click", function() {
    ok( true, "body was clicked!" );
  });

  $body.trigger( "click" );
});
</code></pre>

<p>下面是Qunit中的一个demo例子，其中模拟了一个key的记录器<code>KeyLogger()</code>，在test中初始化了一个事件event，并且使触发了两次，：</p>

<pre><code>function KeyLogger( target ) {
  if ( !(this instanceof KeyLogger) ) {
    return new KeyLogger( target );
  }
  this.target = target;
  this.log = [];

  var self = this;

  this.target.bind( "keydown", function( event ) {
    self.log.push( event.keyCode );
  });
}
test( "keylogger api behavior", function() {

  var event,
      $doc = $( document ),
      keys = KeyLogger( $doc );

  // trigger event
  event = $.Event( "keydown" );

  event.keyCode = 'A';
  $doc.trigger( event );
  $doc.trigger( event );

  // verify expected behavior
  equal( keys.log.length, 2, "2 key was logged" );
  equal( keys.log[ 0 ], 'A', "correct key was logged" );

});   
</code></pre>

<h1>模块化</h1>

<p>为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。</p>

<pre><code>module( "group a" );
test( "a basic test example", function() {
  ok( true, "this test is fine" );
});
test( "a basic test example 2", function() {
  ok( true, "this test is fine" );
});

module( "group b" );
test( "a basic test example 3", function() {
  ok( true, "this test is fine" );
});
test( "a basic test example 4", function() {
  ok( true, "this test is fine" );
});
</code></pre>

<p>除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。</p>

<pre><code>module( "module", {
  setup: function() {
    ok( true, "one extra assert per test" );
  }, teardown: function() {
    ok( true, "and one extra assert after each test" );
  }
});
test( "test with setup and teardown", function() {
  expect( 3 );
  ok( true, "test" );
});
</code></pre>

<h1>推荐使用的框架程序</h1>

<p>最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码<code>myProject.js</code>和测试代码<code>myTests.js</code>。</p>

<pre><code>&lt;!--sample-framework.html:--&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
  &lt;title&gt;QUnit basic example&lt;/title&gt;
  &lt;link rel="stylesheet" href="./resources/qunit.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="qunit"&gt;&lt;/div&gt;
  &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;script src="./resources/qunit.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="./resources/jquery.js"&gt;&lt;/script&gt;
    &lt;!-- 项目代码 --&gt;
  &lt;script type="text/javascript" src="myProject.js"&gt;&lt;/script&gt;
    &lt;!-- 测试代码 --&gt;
  &lt;script type="text/javascript" src="myTests.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<hr />

<p>参考文献：<a href="http://qunitjs.com/cookbook/">http://qunitjs.com/cookbook/</a> <br/>
感谢：lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocha简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/18/mocha-in-brief/"/>
    <updated>2013-03-18T20:44:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/18/mocha-in-brief</id>
    <content type="html"><![CDATA[<h2>Mocha</h2>

<p>Mocha作为一种咖啡名，应该是广为人知的，中文翻译为<strong>摩卡</strong>。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。<br/>
Mocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。 <br/>
项目主页：<a href="http://visionmedia.github.com/mocha/">http://visionmedia.github.com/mocha/</a></p>

<h2>安装</h2>

<pre><code>npm install -g mocha
</code></pre>

<h2>一个简单的样例</h2>

<pre><code>$ mkdir test
$ cd ..
$ mocha test/test.js

var assert = require("assert")
describe('Array', function(){
describe('#indexOf()', function(){
    it('should return -1 when the value is not present', function(){
    assert.equal(-1, [1,2,3].indexOf(5));
    assert.equal(-1, [1,2,3].indexOf(0));
    })
})
})

$  mocha

 .

 ✔ 1 test complete (1ms)
</code></pre>

<!--more-->


<h2>Assertions</h2>

<p>在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。</p>

<ul>
<li><a href="http://github.com/visionmedia/should.js">should.js</a></li>
<li><a href="https://github.com/LearnBoost/expect.js">expect.js</a></li>
<li><a href="http://chaijs.com/">chai</a></li>
<li><a href="https://github.com/visionmedia/better-assert">better-assert</a></li>
</ul>


<h2>测试同步代码</h2>

<pre><code>describe('Array', function(){
describe('#indexOf()', function(){
    it('should return -1 when the value is not present', function(){
    [1,2,3].indexOf(5).should.equal(-1);
    [1,2,3].indexOf(0).should.equal(-1);
    })
})
})
</code></pre>

<h2>测试异步代码</h2>

<p>添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。</p>

<pre><code>describe('User', function(){
describe('#save()', function(){
    it('should save without error', function(done){
    var user = new User('Luna');
    user.save(done);
    })
})
})
</code></pre>

<h2>类似与JUNIT的函数</h2>

<ul>
<li>before : 在所有测试执行之前</li>
<li>after ： 在所有测试执行之后</li>
<li>beforeEach ： 每个测试之前</li>
<li>afterEach ：每个测试之后</li>
</ul>


<h2>mocha指令</h2>

<pre><code>Usage: mocha [debug] [options] [files]

Commands:

init &lt;path&gt;
initialize a client-side mocha setup at &lt;path&gt;

Options:

-h, --help                      帮助信息
-V, --version                   版本信息
-r, --require &lt;name&gt;            依赖的module
-R, --reporter &lt;name&gt;           使用的报告模式
-u, --ui &lt;name&gt;                 用什么接口(bdd|tdd|exports)
-g, --grep &lt;pattern&gt;            执行匹配 &lt;pattern&gt;的测试
-i, --invert                    --grep 相反的测试
-t, --timeout &lt;ms&gt;              超时毫秒数 [2000]
-s, --slow &lt;ms&gt;                 "slow" 测试的门槛 [75]
-w, --watch                     查看文件的变化，如true,则变化后自动运行。
-c, --colors                    启用colors
-C, --no-colors                 禁用colors
-G, --growl                     启用growl notification
-d, --debug                     启用debug
-b, --bail                      只对第一个报错的TEST感兴趣
--recursive                     递归执行
--debug-brk                     enable node's debugger breaking on the first line
--globals &lt;names&gt;               allow the given comma-delimited global [names]
--ignore-leaks                  ignore global variable leaks
--interfaces                    显示可用的接口
--reporters                     显示可用的报表列表
--compilers &lt;ext&gt;:&lt;module&gt;,...  使用指定的module来编译文件
</code></pre>

<h2>报表</h2>

<pre><code>dot - dot matrix
    doc - html documentation
    spec - hierarchical spec list
    json - single json object
    progress - progress bar
    list - spec-style listing
    tap - test-anything-protocol
    landing - unicode landing strip
    xunit - xunit reportert
    teamcity - teamcity ci support
    html-cov - HTML test coverage
    json-cov - JSON test coverage
    min - minimal reporter (great with --watch)
    json-stream - newline delimited json events
    markdown - markdown documentation (github flavour)
    nyan - nyan cat!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Karma  or Testacular 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief/"/>
    <updated>2013-03-12T15:12:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief</id>
    <content type="html"><![CDATA[<h2>Karma/Testacular是什么？</h2>

<p>在2012年11月，Google开源了<a href="http://testacular.github.com/">Testacular</a>，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。</p>

<p>Testacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与<a href="http://jenkins-ci.org/">Jenkins</a>或<a href="https://travis-ci.org/">Travis</a>整合，用于执行持续集成测试。</p>

<!--more-->


<p>这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到<a href="http://www.jetbrains.com/webstorm/">WebStorm</a>中，而WebStorm持错误栈追踪和单元测试调试。</p>

<p>为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）</p>

<p>说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。</p>

<p>Jína也说到Testacular是受<a href="http://code.google.com/p/js-test-driver/">JS Test Driver(JSTD)</a>的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。</p>

<h2>Vojta Jína原版视频</h2>

<p>youtube(凸墙): <br/>
<a href="http://www.youtube.com/watch?v=5mHjJ4xf_K0">http://www.youtube.com/watch?v=5mHjJ4xf_K0</a>  <br/>
<a href="http://www.youtube.com/watch?v=MVw8N3hTfCI">http://www.youtube.com/watch?v=MVw8N3hTfCI</a>  <br/>
youku[个人转录]:</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Nzky" frameborder=0 allowfullscreen></iframe>




<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Mzc2" frameborder=0 allowfullscreen></iframe>


<h2>Karma/Testacular 安装</h2>

<p>首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：</p>

<pre><code>npm install -g karma/testacular
</code></pre>

<p>安装成功后，可以查看其支持的命令。</p>

<pre><code>testacular --help
Testacular - Spectacular Test Runner for JavaScript.

Usage:
testacular &lt;command&gt;

Commands:
start [&lt;configFile&gt;] [&lt;options&gt;] Start the server / do single run.
init [&lt;configFile&gt;] Initialize a config file.
run [&lt;options&gt;] Trigger a test run.

Run --help with particular command to see its description and   available options.

Options:
--help     Print usage and options.
--version  Print current version.   
</code></pre>

<p>简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。<br/>
下面就来看以下，最主要的部分，那就是配置文件了。</p>

<h2>Karma/Testacular配置文件</h2>

<p>这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。 <br/>
在GitHub上可以看到一个官方提供的默认样例<a href="https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js">https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js</a>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。<br/>
同样的，使用<code>karma/testacular init</code>命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的<code>karma/testacular start</code>也会默认搜索当前目录下的karma/testacular.conf.js来启动。  <br/>
下面，我们来生成一个看看：</p>

<pre><code>karma/testacular init my.conf.js

Which testing framework do you want to use ?
Press tab to list possible options. Enter to move to the next   question.
&gt; mocha

Do you want to use Require.js ?
This will add Require.js adapter into files.
Press tab to list possible options. Enter to move to the next question.
&gt; no

Do you want to capture a browser automatically ?
Press tab to list possible options. Enter empty string to move to the next question.
&gt; Firefox
......

Config file generated at "/home/shenyanchao/tmp/my.conf.js".
</code></pre>

<p>这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是<strong>Tab</strong>。<br/>
此时，执行<code>testacular start my.conf.js</code>,可以发现，浏览器已经启动了。</p>

<p><img src="http://www.shenyanchao.cn/images/blog/testacular-run-in-firefox.png" alt="Testacular启动" /></p>

<p><strong>配置文件参数：</strong></p>

<pre><code>autoWatch

类型: Boolean
默认: false
命令行: --auto-watch, --no-auto-watch
详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test

basePath

类型: String
默认: ''
详细介绍: 基本路径，用来解决相对路径问题。

browsers

类型: Array
默认: []
命令行: --browsers Chrome,Firefox
取值:
Chrome
ChromeCanary
Firefox
Opera
Safari
PhantomJS
IE
详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。

captureTimeout

类型: Number
默认: 60000
详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  

colors

类型: Boolean
默认: true
命令行: --colors, --no-colors
详细介绍: 在reporters和logs里面是否启用色彩。
exclude

类型: Array
默认: []
详细介绍: 排除在外的文件列表或者正则表达式

files

类型: Array
默认: []
详细介绍: 要加载的文件列表或者正则表达式

hostname

类型: String
默认: 'localhost'
详细介绍: 启动的浏览器主机名

logLevel

类型: Constant
默认: LOG_INFO
命令行: --log-level debug
取值:
LOG_DISABLE
LOG_ERROR
LOG_WARN
LOG_INFO
LOG_DEBUG
详细介绍: 日志级别.

loggers

类型: Array
默认: [{type: 'console'}]
详细介绍: 定义日志目标。比如log4js

port

类型: Number
默认: 9876
命令行: --port 9876
详细介绍: web服务的监听端口

preprocessors

类型: Object
默认: {'**/*.coffee': 'coffee'}
详细介绍: 前置处理器的MAP

proxies

类型: Object
默认: {}
详细介绍: 路径代理的映射MAP
例如:
proxies =  {
    '/static': 'http://gstatic.com',
    '/web': 'http://localhost:9000'
};

reportSlowerThan

类型: Number
默认: 0
详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 

reporters

类型: Array
默认: ['progress']
命令行: --reporters progress,growl
取值:
dots
progress
junit
growl
coverage
详细介绍: 使用的报表列表

runnerPort

类型: Number
默认: 9100
命令行: --runner-port 9100
详细介绍: 使用testacular run时，服务器的监听端口

singleRun

类型: Boolean
默认: false
命令行: --single-run, no-single-run
详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.

urlRoot

类型: String
默认: '/'
详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。
</code></pre>

<h2>browser无法启动？</h2>

<p>当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。
如果无法找到，可以通过覆盖<code>&lt;BROWSER&gt;_BIN</code>来解决。 <br/>
比如：</p>

<pre><code>export CHROME_BIN=/usr/local/bin/my-chrome-build
export CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build
export PHANTOMJS_BIN=$HOME/local/bin/phantomjs
</code></pre>

<p>就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。</p>

<h2>写在Testacular学习之后</h2>

<p>Testacular应该是Google<a href="http://angularjs.org/">AngularJS</a>的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。<br/>
以上，存在一定的个人猜测，但是其产生的过程值得好好学习。</p>

<h2>改名为Karma</h2>

<p>2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为<code>chore: rename this shit to Karma</code>。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Node.js开发指南》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/11/node-dot-js-develop-guide-reading-note/"/>
    <updated>2013-03-11T16:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/11/node-dot-js-develop-guide-reading-note</id>
    <content type="html"><![CDATA[<h3>书籍信息</h3>

<p>Amazon: <a href="http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I">NodeJS开发指南</a></p>

<p>PDF: <a href="http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf">免费下载</a></p>

<h3>NodeJS简介</h3>

<p>是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。<br/>
由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。
CommonJS规范包括：</p>

<ul>
<li>模块（modules）</li>
<li>包（packages）</li>
<li>系统（system）</li>
<li>二进制（binary）</li>
<li>控制台（console）</li>
<li>编码（encodings）</li>
<li>文件系统（filesystems）</li>
<li>套接字（sockets）</li>
<li>单元测试（unit testing）</li>
</ul>


<!--more-->


<h3>NodeJS的模块与包</h3>

<p>模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。</p>

<h4>1.什么是模块？</h4>

<pre><code>var http = require("http");
</code></pre>

<p>其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。</p>

<h4>2.创建与发布模块</h4>

<p>NodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。
如创建一个module.js:</p>

<pre><code>var name;
exports.setName=function(thyName){
     name=thyName;
     }
     exports.sayHello = function(){
    console.log('Hello '+name);
}
</code></pre>

<p>在同一个目录下，再创建一个getmodule.js:</p>

<pre><code>var mymodule = require('./module');
myModule.setName('shenyanchao');
myModule.sayHello();
</code></pre>

<p>运行后的结果：</p>

<pre><code>Hello shenyanchao
</code></pre>

<p>这就是一个简单的模块发布与调用关系。</p>

<h4>3.包（package）</h4>

<p>包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。<br/>
直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征：</p>

<ul>
<li>package.json在包的顶层目录下；</li>
<li>二进制可执行文件在bin目录下；</li>
<li>JS代码在lib目录下；</li>
<li>文档在doc目录下；</li>
<li>单元测试在test下；
这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。</li>
</ul>


<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:</p>

<pre><code>exports.hello = function() {
   console.log('Hello.');
};
</code></pre>

<p>然后在 somepackage 之外建立 getpackage.js,内容如下:</p>

<pre><code>var somePackage = require('./somepackage');
somePackage.hello();
</code></pre>

<p>运行 node getpackage.js,控制台将输出结果 Hello。 <br/>
我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。 <br/>
<strong>package.json</strong>
在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:</p>

<pre><code>{
    "main" : "./lib/interface.js"
}
</code></pre>

<p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。 <br/>
NodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。<br/>
package.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。 <br/>
name:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。 <br/>
description:包的简要说明。 <br/>
version:符合语义化版本识别 规范的版本字符串。<br/>
keywords:关键字数组,通常用于搜索。 <br/>
maintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。<br/>
contributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。 <br/>
bugs:提交bug的地址,可以是网址或者电子邮件地址。 <br/>
licenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。 <br/>
repositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。 <br/>
下面是mocha的package.json:</p>

<pre><code>{
 "name": "mocha",
 "version": "1.8.1",
"description": "simple, flexible, fun test framework",
 "keywords": [
 "mocha",
    "test",
 "bdd",
 "tdd",
 "tap"
],
 "author": {
 "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
 },
"repository": {
    "type": "git",
    "url": "git://github.com/visionmedia/mocha.git"
 },
"main": "./index",
"bin": {
    "mocha": "./bin/mocha",
    "_mocha": "./bin/_mocha"
},
"engines": {
    "node": "&gt;= 0.4.x"
},
"scripts": {
    "test": "make test-all"
 },
"dependencies": {
    "commander": "0.6.1",
    "growl": "1.7.x",
    "jade": "0.26.3",
    "diff": "1.0.2",
    "debug": "*",
    "mkdirp": "0.3.3",
    "ms": "0.3.0"
},
"devDependencies": {
 "should": "*",
    "coffee-script": "1.2"
 },
"readme": "..."
}
</code></pre>

<p>也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。 <br/>
如执行：</p>

<pre><code>npm install -g mocha
</code></pre>

<p>那么，npm将会依据json提供的信息来进行管理。</p>

<h4>4.npm的本地模式与全局模式</h4>

<p>npm默认会从http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用<code>-g</code>参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。</p>

<h3>模块（modules）的加载机制</h3>

<p>前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。<br/>
那么，文件模块是如何加载的呢？</p>

<h4>按路径加载模块</h4>

<p>1.如果require按“/”开头，那就是绝对路径进行加载。如require(&#8216;/home/shenyanchao/module&#8217;),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。 <br/>
2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。<br/>
3.对于核心模块,比如require(&#8216;http&#8217;)，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？ <br/>
如果，使用require(&#8216;mymodule&#8217;),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。 <br/>
例如： 我们在/home/shenyanchao/develop/app.js中使用require(&#8216;mymodule&#8217;)，NodeJS的查找路径如下：</p>

<ul>
<li>/home/shenyanchao/develop/node_modules/mymodule.js</li>
<li>/home/shenyanchao/node_modules/mymodule.js</li>
<li>/home/node_modules/mymodule.js</li>
<li>/node_modules/mymodule.js</li>
</ul>


<p>这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式<code>npm install mocha</code>的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require(&#8216;mocha&#8217;)时，能够直接使用。而<code>npm install -g mocha</code>相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。</p>

<h3>express: JS的MVC框架</h3>

<p>这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。 <br/>
express将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！  <br/>
express主页：<a href="http://expressjs.com/">http://expressjs.com/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《探索式软件测试》读书笔记(1)]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1/"/>
    <updated>2013-01-21T19:14:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1</id>
    <content type="html"><![CDATA[<p>书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。 <br/>
一般情况下，旅游地都会有这样一些区域：</p>

<ul>
<li><strong>商业区</strong>: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。</li>
<li><strong>历史区</strong>: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。</li>
<li><strong>旅游区</strong>: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。</li>
<li><strong>娱乐区</strong>: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。</li>
<li><strong>旅馆区</strong>: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。</li>
<li><strong>破旧区</strong>：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。</li>
</ul>


<!--more-->


<h3>商业区测试类型</h3>

<p>商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。</p>

<blockquote><p><strong>指南测试法</strong>： 测试人员按照用户手册进行操作。 <br/>
各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。</p>

<p><strong>卖点测试法</strong>： 按照销售人员对客户演示的顺序（卖点）进行测试。 <br/>
令旅游者向往的任何一个地方一定有吸引他们的理由。</p>

<p><strong>地标测试法</strong>： 选择一个功能点，然后向另外的功能点测试。<br/>
在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。</p>

<p><strong>极限测试法</strong>： 向软件提出很多难以回答的问题。 <br/>
旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。</p>

<p><strong>快递测试法</strong>： 专注与数据，保证数据在任何出现的地方都是同一个。<br/>
信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A->B->C->A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A->A->A->A，不能开封的说。</p>

<p><strong>深夜／清晨测试法</strong>： 在软件的空闲时段，去测试一些功能。 <br/>
下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。</p>

<p><strong>遍历测试法</strong>： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。  <br/>
城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。</p></blockquote>

<h3>历史区测试类型</h3>

<p>主要是针对老功能以及修复代码的测试。</p>

<blockquote><p><strong>恶邻测试法</strong>： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。<br/>
每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。</p>

<p><strong>博物馆测试法</strong>： 历史遗留代码值得测试人员多加关注。<br/>
展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。</p>

<p><strong>上一版测试法</strong>： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。</p></blockquote>

<h3>娱乐区测试类型</h3>

<p>旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。</p>

<blockquote><p><strong>配角测试法</strong>：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。 <br/>
导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。</p>

<p><strong>深巷测试法</strong>： 测试那些最不可能被用到或者那些最不吸引用户的特性。 <br/>
高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。</p>

<p><strong>通宵测试法</strong>： 让程序一直运行，而不去关闭他。<br/>
通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。</p></blockquote>

<h3>旅游区测试类型</h3>

<p>每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。</p>

<blockquote><p><strong>收藏家测试法</strong>：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。<br/>
旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。</p>

<p><strong>长路径测试法</strong>： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。<br/>
在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。</p>

<p><strong>超模测试法</strong>： 关注表面的东西，测试界面。<br/>
旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。</p>

<p><strong>测一送一法</strong>: 测试同一个应用多个拷贝的情况。<br/>
旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。</p>

<p><strong>苏格兰酒吧测试法</strong>： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。<br/>
作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。</p></blockquote>

<h3>旅馆区测试类型</h3>

<p>休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。</p>

<blockquote><p><strong>取消测试法</strong>： 启动操作然后停止它。学会使用取消按钮。 <br/>
任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。</p>

<p><strong>懒汉测试法</strong>： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。 <br/>
一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。</p></blockquote>

<h3>破旧区测试类型</h3>

<blockquote><p><strong>破坏测试法</strong>： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。</p>

<p><strong>反叛测试法</strong>： 输入最不可能的数据，或者已知的恶意输入。<br/>
旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。</p>

<p><strong>强迫症测试法</strong>： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。 <br/>
如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。</p></blockquote>
]]></content>
  </entry>
  
</feed>
