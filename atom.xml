<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-06-23T13:13:46+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用jXLS来导出报表]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/06/20/export-excel-by-jxls/"/>
    <updated>2014-06-20T16:47:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/06/20/export-excel-by-jxls</id>
    <content type="html"><![CDATA[<h3>常用的excel操作工具</h3>

<ul>
<li><a href="http://poi.apache.org/">Apache POI</a></li>
<li><a href="http://jexcelapi.sourceforge.net/">jexcelApi</a></li>
</ul>


<p>它们都提供了完善的API来支持EXCEL的读写。</p>

<h3>jXLS是什么？</h3>

<p><a href="http://jxls.sourceforge.net/">jXLS</a>是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>

<p>jXLS的基本功能：</p>

<ul>
<li>支持Excel 95-2000的所有版本</li>
<li>生成Excel 2000标准格式</li>
<li>支持字体、数字、日期操作</li>
<li>能够修饰单元格属性</li>
<li>支持图像和图表</li>
</ul>


<!--more-->


<pre><code>    &lt;dependency&gt;
           &lt;groupId&gt;net.sf.jxls&lt;/groupId&gt;
           &lt;artifactId&gt;jxls-core&lt;/artifactId&gt;
           &lt;version&gt;1.0.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>

<p>jXLS的API也很简单：</p>

<pre><code>                Map beans = new HashMap();
                beans.put("department", department);
                XLSTransformer transformer = new XLSTransformer();
                transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);
</code></pre>

<h3>jXLS是如何解析模板生成数据的？</h3>

<p>查看net.sf.jxls.transformer.CellTransformer可以看到：</p>

<pre><code>Object value = ((Expression) cell.getExpressions().get(0)).evaluate();
</code></pre>

<p>而evaluate()方法如下：</p>

<pre><code>public Object evaluate() throws Exception {
    if (beans != null &amp;&amp; !beans.isEmpty()) {
        JexlContext context = new MapContext(beans);
        Object ret = jexlExpresssion.evaluate(context);
        if (aggregateFunction != null) {
            return calculateAggregate(aggregateFunction, aggregateField, ret);
        }
        return ret;
    }
    return expression;
}
</code></pre>

<p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>

<h4>让jXLS支持hyperlink</h4>

<p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>

<pre><code>    if (cell.getStringCellValue().toLowerCase().startsWith("${href}") &amp;&amp; cell.getExpressions().size() == 3){
           //是链接类型的cell
           HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();
           Expression valueExpr = (Expression)cell.getExpressions().get(1);
           Expression linkExpr = (Expression)cell.getExpressions().get(2);
           hssfCell.setCellValue((String)valueExpr.evaluate());
           Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);
           link.setAddress((String)linkExpr.evaluate());
           hssfCell.setHyperlink(link);
           cell.setPoiCell(hssfCell);
        }
</code></pre>

<p>当遇见<code>${href}</code>开头的表达式，则认为是链接CELL。此处<code>${href}</code>只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring中配置quartz集群]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/06/20/quartz-cluster-with-spring/"/>
    <updated>2014-06-20T16:01:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/06/20/quartz-cluster-with-spring</id>
    <content type="html"><![CDATA[<h3>为什么使用quartz集群？</h3>

<p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。</p>

<h3>quartz集群在spring中的配置</h3>

<h4>1.导入数据库表</h4>

<p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。
使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>

<p>注意事项：</p>

<p>修改SQL： TYPE=InnoDB  &#8211;> ENGINE=InnoDB</p>

<!--more-->


<h4>2.项目中加入配置文件quartz.properties</h4>

<pre><code>#============================================================================
# Configure Main Scheduler Properties
#============================================================================
org.quartz.scheduler.instanceName = ClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.scheduler.skipUpdateCheck = true

#============================================================================
# Configure ThreadPool
#============================================================================
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.useProperties = false
org.quartz.jobStore.tablePrefix = QRTZ_

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 15000
</code></pre>

<h4>3.增加applicationContext-quartz.xml</h4>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd"
       default-lazy-init="false"&gt;

    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;

    &lt;bean id="quartzDataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource"&gt;
        &lt;property name="driverClass" value="${db.driver}" /&gt;
        &lt;property name="url" value="${db.url}" /&gt;
        &lt;property name="username" value="${db.user}" /&gt;
        &lt;property name="password" value="${db.pass}" /&gt;
    &lt;/bean&gt;

    &lt;!-- Quartz集群Schduler --&gt;
    &lt;bean id="clusterQuartzScheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
        &lt;!-- Triggers集成 --&gt;
        &lt;property name="triggers"&gt;
            &lt;list&gt;
                &lt;ref bean="testTrigger" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--  quartz配置文件路径--&gt;
        &lt;property name="configLocation" value="classpath:quartz/quartz.properties" /&gt;
        &lt;!-- 启动时延期3秒开始任务 --&gt;
        &lt;property name="startupDelay" value="3" /&gt;
        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;
        &lt;property name="dataSource" ref="quartzDataSource" /&gt;
        &lt;!-- Job接受applicationContext的成员变量名 --&gt;
        &lt;property name="applicationContextSchedulerContextKey" value="applicationContext" /&gt;
        &lt;property name="overwriteExistingJobs" value="true" /&gt;
        &lt;property name="jobFactory"&gt;
            &lt;bean class="com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory"/&gt;
        &lt;/property&gt;
     &lt;/bean&gt;


    &lt;bean id="testTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
        &lt;property name="jobDetail" ref="testJobDetail" /&gt;
        &lt;property name="cronExpression" value="* 0/10 * * * ?" /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;
    &lt;bean id="testJobDetail" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;
        &lt;property name="jobClass" value="cn.shenyanchao.quartz.TestTask" /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;
    &lt;util:map id="timerJobConfig"&gt;
        &lt;entry key="nodeName" value="default" /&gt;
    &lt;/util:map&gt;
&lt;/beans&gt;
</code></pre>

<p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>

<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>

<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {

        private transient AutowireCapableBeanFactory beanFactory;

        public void setApplicationContext(final ApplicationContext context) {
            beanFactory = context.getAutowireCapableBeanFactory();
        }

        @Override
        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {
            final Object job = super.createJobInstance(bundle);
            beanFactory.autowireBean(job);
            return job;
        }
    }
</code></pre>

<h4>4. 如何写JOB？</h4>

<pre><code>@Component
public class TestTask extends QuartzJobBean {


    @Autowired
    private UserService userService;

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(userService.findByName("shenyanchao").getEmail());
    }
}
</code></pre>

<p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>

<p> ####5.quartz在mysql5.6下报错</p>

<pre><code>    You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OPTION SQL_SELECT_LIMIT=5' at line 1
</code></pre>

<p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。
参见<a href="http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Velocity学习小结]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/03/31/velocity-study-summary/"/>
    <updated>2014-03-31T16:24:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/03/31/velocity-study-summary</id>
    <content type="html"><![CDATA[<h3>velocity在spring项目中的使用</h3>

<p>本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。
首先，可以交给Spring来初始化velocityEngine:</p>

<pre><code>&lt;bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"&gt;
    &lt;property name="configLocation"&gt;
        &lt;value&gt;classpath:velocity.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="resourceLoaderPath"&gt;
        &lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>其中的<code>configLocation</code>指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：</p>

<pre><code>resource.loader  =  file

file.resource.loader.description =  Velocity  File Resource Loader
file.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader
file.resource.loader.cache =  true
file.resource.loader.modificationCheckInterval =  100

input.encoding = utf-8
output.encoding = utf-8
</code></pre>

<p>需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：</p>

<ul>
<li>spring增强了file加载的能力，推荐使用<code>resourceLoaderPath</code>来指明路径，而不是交给<code>file.resource.loader.path</code>进行处理。如果使用这个可能会跑NullPointerException；</li>
<li>class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。</li>
</ul>


<h3>关于Velocity使用的坑</h3>

<ul>
<li><p>关于减号（-）的问题</p>

<blockquote><p>请注意下面的2中写法  <br/>
<code>#set($maxIndex=$DOC_COUNT-1)</code>报错  <br/>
<code>#set($maxIndex=$DOC_COUNT - 1)</code>正确，区别仅在于-两侧的空格</p></blockquote></li>
<li><p>关于Range类型的问题</p>

<blockquote><p><code>#set($array = [0..$maxIndex])</code> 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样<code>#set($array = [0..$maxIndex+1])</code>也是错误的。</p></blockquote></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[又见Java乱码]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/03/27/java-encode-error-again/"/>
    <updated>2014-03-27T21:43:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/03/27/java-encode-error-again</id>
    <content type="html"><![CDATA[<h3>dom4j解析xml</h3>

<p>dom4j提供了一个<code>DocumentHelper</code>来解析xml内容，此处的内容是String类型的。下面是其源码：</p>

<pre><code>    public static Document parseText(String text) throws DocumentException {
        Document result = null;

        SAXReader reader = new SAXReader();
        String encoding = getEncoding(text);

        InputSource source = new InputSource(new StringReader(text));
        source.setEncoding(encoding);

        result = reader.read(source);

        // if the XML parser doesn't provide a way to retrieve the encoding,
        // specify it manually
        if (result.getXMLEncoding() == null) {
            result.setXMLEncoding(encoding);
        }

        return result;
    }

    private static String getEncoding(String text) {
        String result = null;

        String xml = text.trim();

        if (xml.startsWith("&lt;?xml")) {
            int end = xml.indexOf("?&gt;");
            String sub = xml.substring(0, end);
            StringTokenizer tokens = new StringTokenizer(sub, " =\"\'");

            while (tokens.hasMoreTokens()) {
                String token = tokens.nextToken();

                if ("encoding".equals(token)) {
                    if (tokens.hasMoreTokens()) {
                        result = tokens.nextToken();
                    }

                    break;
                }
            }
        }

        return result;
    }
</code></pre>

<p>从以上的代码中可以看出，解析过程中是使用XML的头<code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>来获取编码信息的。</p>

<!--more-->


<h3>如何读取文件到String</h3>

<pre><code>    public String loadXmlRule() {
        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("file.xml");
        String xmlContent = null;
        try {
            xmlContent = IOUtils.toString(inputStream);
        } catch (IOException e) {
            LOG.error("read xml:{} io error", e);
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        return xmlContent;
    }
</code></pre>

<p><a href="http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as">getResourceAsStream将文件读为字节流</a>，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。</p>

<pre><code>xmlContent = IOUtils.toString(inputStream);

转换为：

xmlContent = IOUtils.toString(inputStream，"UTF-8);//假设文件是UTF-8
</code></pre>

<p>由此，一定要慎重使用编码。<strong>永远不要相信默认编码</strong>。</p>

<h3>Jenkins/Hudson中shell command的编码</h3>

<p>遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSTL介绍]]></title>
    <link href="http://www.shenyanchao.cn/blog/2014/03/18/use-jstl/"/>
    <updated>2014-03-18T18:49:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2014/03/18/use-jstl</id>
    <content type="html"><![CDATA[<h3>EL 表达式</h3>

<p>在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。</p>

<p>Sun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。</p>

<p>Standard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。</p>

<p>Standard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。</p>

<p>本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：</p>

<ul>
<li>核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。</li>
<li>国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。</li>
<li>数据库标签库：可以做访问数据库的工作。</li>
<li>XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。</li>
<li>函数标签库：用来读取已经定义的某个函数。</li>
</ul>


<p>此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。</p>

<p>JSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。</p>

<p>说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。</p>

<!--more-->


<h4>9.2.1JSTL EL 表达式语言简介</h4>

<p>EL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。</p>

<p>下面的示例就是一个EL表达式，见例9.1。</p>

<p>例9.1：简单EL表达式</p>

<pre><code>  &lt;%@ page contentType="text/html; charset=UTF-8"%&gt;
  &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
  &lt;html&gt;
   &lt;body&gt; ${sampleValue + 1} &lt;br&gt; &lt;/body&gt;
  &lt;/html&gt;
</code></pre>

<p>这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。</p>

<h4>9.2.2 EL 表达式的默认变量</h4>

<p>一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：</p>

<p>1．默认变量pageScope、requestScope、sessionScope、applicationScope</p>

<pre><code>  这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：
</code></pre>

<p>例9.2：使用sessionScope变量的EL表达式</p>

<pre><code>&lt;%request.getSession().setAttribute("sampleValue", new Integer(10));%&gt;
${sessionScope.sampleValue}
</code></pre>

<p>取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。</p>

<p>2．默认变量param、paramValues</p>

<pre><code>  这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：
</code></pre>

<p>例9.3：提交请求的页面和接受的页面</p>

<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8"%&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
 &lt;body&gt;
     &lt;form action="SampleJsp.jsp"&gt;
    &lt;input type="text" name="sampleValue" value="10"&gt;
    &lt;input type="text" name="sampleValue" value="11"&gt;
    &lt;input type="text" name="sampleValue" value="12"&gt;
    &lt;input type="text" name="sampleSingleValue" value="SingleValue"&gt;
    &lt;input type="submit" value="Submit"&gt;
    &lt;/form&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。</p>

<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8"%&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
 &lt;body&gt;
    ${paramValues.sampleValue[2]} &lt;br&gt;
    ${param.sampleSingleValue} &lt;br&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。</p>

<p>3．默认变量header、headerValues</p>

<p>这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。</p>

<p>4．默认变量cookie</p>

<p>包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。</p>

<p>5．默认变量initParam</p>

<p>包含所有应用程序初始化参数的集合。</p>

<p>6．默认变量pageContext</p>

<p>等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。
11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。</p>

<h3>表达式的操作符</h3>

<p>EL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。</p>

<p>表9.1 EL表达式的操作符</p>

<table cellspacing="0" cellpadding="0" width="562" border="1">
                        <tbody>
                            <tr>
                                <td width="64">
                                <p align="left">操作符</p>
                                </td>
                                <td width="498">
                                <p align="left">功能和作用</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">.</p>
                                </td>
                                <td width="498">
                                <p align="left">访问一个bean属性或者Map entry</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">[]</p>
                                </td>
                                <td width="498">
                                <p align="left">访问一个数组或者链表元素</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">()</p>
                                </td>
                                <td width="498">
                                <p align="left">对子表达式分组，用来改变赋值顺序</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">? :</p>
                                </td>
                                <td width="498">
                                <p align="left">条件语句，比如：条件?ifTrue:ifFalse</p>
                                <p align="left">如果条件为真，表达式值为前者，反之为后者</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">+</p>
                                </td>
                                <td width="498">
                                <p align="left">数学运算符，加操作</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">-</p>
                                </td>
                                <td width="498">
                                <p align="left">数学运算符，减操作或者对一个值取反</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">*</p>
                                </td>
                                <td width="498">
                                <p align="left">数学运算符，乘操作</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">/ 或div</p>
                                </td>
                                <td width="498">
                                <p align="left">数学运算符，除操作</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">% 或mod</p>
                                </td>
                                <td width="498">
                                <p align="left">数学运算符，模操作(取余)</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">== 或eq</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">!= 或ne</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">&lt; 或lt</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">&gt; 或gt</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">&lt;= 或le</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">&gt;= 或ge</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">&amp;&amp; 或and</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">|| 或or</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">! 或not</p>
                                </td>
                                <td width="498">
                                <p align="left">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">empty</p>
                                </td>
                                <td width="498">
                                <p align="left">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p>
                                </td>
                            </tr>
                            <tr>
                                <td valign="top" width="64">
                                <p align="left">func(args)</p>
                                </td>
                                <td width="498">
                                <p align="left">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：</p>

<p>例9.4：几组操作符的示例</p>

<pre><code>${pageScope.sampleValue + 12} &lt;br&gt;           //显示12
${(pageScope.sampleValue + 12)/3} &lt;br&gt;     //显示4.0
${(pageScope.sampleValue + 12) /3==4} &lt;br&gt;         //显示true
${(pageScope.sampleValue + 12) /3&gt;=5} &lt;br&gt;         //显示false
&lt;input type="text" name="sample1" value="${pageScope.sampleValue + 10}"&gt; //显示值为10的Text控件
</code></pre>

<p>可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。</p>

<h3>标签库介绍</h3>

<p>在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。
对应的标识符见表9.2所示：</p>

<p>表9.2 标签库的标识符</p>

<table cellspacing="0" cellpadding="0" width="360" border="1">
                        <tbody>
                            <tr>
                                <td width="107">
                                <p align="left">标签库</p>
                                </td>
                                <td width="202">
                                <p align="left">URI</p>
                                </td>
                                <td width="50">
                                <p align="center">前缀</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="107">
                                <p align="left">Core</p>
                                </td>
                                <td width="202">
                                <p align="left">http://java.sun.com/jsp/jstl/core</p>
                                </td>
                                <td width="50">
                                <p align="left">c</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="107">
                                <p align="left">XML processing</p>
                                </td>
                                <td width="202">
                                <p align="left">http://java.sun.com/jsp/jstl/xml</p>
                                </td>
                                <td width="50">
                                <p align="left">x</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="107">
                                <p align="left">I18N formatting</p>
                                </td>
                                <td width="202">
                                <p align="left">http://java.sun.com/jsp/jstl/fmt</p>
                                </td>
                                <td width="50">
                                <p align="left">fmt</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="107">
                                <p align="left">Database access</p>
                                </td>
                                <td width="202">
                                <p align="left">http://java.sun.com/jsp/jstl/sql</p>
                                </td>
                                <td width="50">
                                <p align="left">sql</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="107">
                                <p align="left">Functions</p>
                                </td>
                                <td width="202">
                                <p align="left">http://java.sun.com/jsp/jstl/functions</p>
                                </td>
                                <td width="50">
                                <p align="left">fn</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看例9.5，简单使用标签库的示例。</p>

<p>例9.5：简单JSTL标签库示例</p>

<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8"%&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
 &lt;body&gt;
    &lt;c:forEach var="i" begin="1" end="10" step="1"&gt; ${i} &lt;br /&gt;&lt;/c:forEach&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在该示例的JSP页面中声明了将使用Core标签库，它的URI为“http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中&lt;c:forEach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。</p>

<h3>标签库</h3>

<p>Core标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：</p>

<ul>
<li>多用途核心标签：&lt;c:out>、&lt;c:set>、&lt;c:remove>、&lt;c:catch>。</li>
<li>条件控制标签：&lt;c:if>、&lt;c:choose>、&lt;c:when>、&lt;c:otherwise>。</li>
<li>循环控制标签：&lt;c:forEach>、&lt;c:forTokens>。</li>
<li>URL相关标签：&lt;c:import>、&lt;c:url>、&lt;c:redirect>、&lt;c:param>。</li>
</ul>


<p>以下是各个标签的用途和属性以及简单示例。</p>

<h3>用于显示的<code>&lt;c:out&gt;</code> 标签</h3>

<p><code>&lt;c:out&gt;</code>标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：</p>

<p>表9.3　<code>&lt;c:out&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="535" border="1">
                        <tbody>
                            <tr>
                                <td width="79">
                                <p align="left">属性</p>
                                </td>
                                <td width="456">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="79">
                                <p align="left">value</p>
                                </td>
                                <td width="456">
                                <p align="left">输出到页面的数据，可以是EL表达式或常量（必须）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="79">
                                <p align="left">default</p>
                                </td>
                                <td width="456">
                                <p align="left">当value为null时显示的数据（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="79">
                                <p align="left">escapeXml</p>
                                </td>
                                <td width="456">
                                <p align="left">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>在JSTL1.0的时候，在页面显示数据必须使用&lt;c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。</p>

<pre><code>&lt;c:out value="${sessionScope.anyValue}" default="no value" escapeXml="false"/&gt;
</code></pre>

<p>该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。</p>

<h3><code>&lt;c: &gt;</code> 标签</h3>

<h4>用于赋值的&lt;c:set>标签</h4>

<p><code>&lt;c:set&gt;</code>标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：</p>

<p>表9.4　<code>&lt;c:set&gt;</code>标签属性和说明</p>

<table cellpadding="0" width="393" border="1">
                        <tbody>
                            <tr>
                                <td width="72">
                                <p align="left">属性</p>
                                </td>
                                <td width="311">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">value</p>
                                </td>
                                <td>
                                <p align="left">值的信息，可以是EL表达式或常量</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">target</p>
                                </td>
                                <td>
                                <p align="left">被赋值的JavaBean实例的名称，若存在该属性则必须<br />
                                存在property属性（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">property</p>
                                </td>
                                <td>
                                <p align="left">JavaBean实例的变量属性名称（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">var</p>
                                </td>
                                <td>
                                <p align="left">被赋值的变量名（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">scope</p>
                                </td>
                                <td>
                                <p align="left">变量的作用范围，若没有指定，默认为page（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p> 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：</p>

<pre><code>&lt;c:set value="this is andy" var="oneString"/&gt;
${oneString} &lt;br&gt;
</code></pre>

<p>该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。</p>

<h4>9.3.3 用于删除的 <code>&lt;c:remove&gt;</code>标签</h4>

<p><code>&lt;c:remove&gt;</code>标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：</p>

<p>表9.5　<code>&lt;c:remove&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="365" border="1">
                        <tbody>
                            <tr>
                                <td width="53">
                                <p align="left">属性</p>
                                </td>
                                <td width="312">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="53">
                                <p align="left">var</p>
                                </td>
                                <td width="312">
                                <p align="left">需要被删除的变量名</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="53">
                                <p align="left">scope</p>
                                </td>
                                <td width="312">
                                <p align="left">变量的作用范围，若没有指定，默认为全部查找（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例：</p>

<pre><code>&lt;c:remove var="sampleValue" scope="session"/&gt;
${sessionScope.sampleValue} &lt;br&gt;
</code></pre>

<p>该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。</p>

<h4>9.3.4 用于异常捕获的 <code>&lt;c:catch&gt;</code> 标签</h4>

<p><code>&lt;c:catch&gt;</code>标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。</p>

<pre><code>&lt;c:catch var="err"&gt; ${param.sampleSingleValue[9] == 3}&lt;/c:catch&gt;
${err}
</code></pre>

<p>当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。</p>

<h4>9.3.5 用于判断的 <code>&lt;c:if&gt;</code> 标签</h4>

<p><code>&lt;c:if&gt;</code>标签用于简单的条件语句。它的属性和描述如表9.6所示：</p>

<p>表9.6　<code>&lt;c:if&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="454" border="1">
                        <tbody>
                            <tr>
                                <td width="60">
                                <p align="left">属性</p>
                                </td>
                                <td width="394">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="60">
                                <p align="left">test</p>
                                </td>
                                <td width="394">
                                <p align="left">需要判断的条件</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="60">
                                <p align="left">var</p>
                                </td>
                                <td width="394">
                                <p align="left">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="60">
                                <p align="left">scope</p>
                                </td>
                                <td width="394">
                                <p align="left">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例：</p>

<pre><code>&lt;c:if test="${paramValues.sampleValue[2] == 12}" var="visits"&gt;It is 12&lt;/c:if&gt;&lt;br&gt;
${visits} &lt;br&gt;
</code></pre>

<p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。</p>

<h4>9.3.6 用于复杂判断的 <code>&lt;c:choose&gt; 、 &lt;c:when&gt; 、 &lt;c:otherwise&gt;</code> 标签</h4>

<p>这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。</p>

<p><code>&lt;c:choose&gt;</code>标签没有属性，可以被认为是父标签，<code>&lt;c:when&gt;、&lt;c:otherwise&gt;</code>将作为其子标签来使用。
<code>&lt;c:when&gt;</code>标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。
<code>&lt;c:otherwise&gt;</code>标签没有属性，它等价于“else”语句。</p>

<p>下面看一个复杂条件语句的示例。</p>

<pre><code>&lt;c:choose&gt;
         &lt;c:when test="${paramValues.sampleValue[2] == 11}"&gt;
                   not 12 not 13,it is 11
         &lt;/c:when&gt;
         &lt;c:when test="${paramValues.sampleValue[2] == 12}"&gt;
                   not 11 not 13,it is 12
         &lt;/c:when&gt;
         &lt;c:when test="${paramValues.sampleValue[2] == 13}"&gt;
                   not 11 not 12,it is 13
         &lt;/c:when&gt;
         &lt;c:otherwise&gt;
                   not 11 、12、13
         &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre>

<p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。</p>

<h4>9.3.7 用于循环的 <code>&lt;c:forEach&gt;</code> 标签</h4>

<p><code>&lt;c:forEach&gt;</code>为循环控制标签。它的属性和描述如表9.7所示：</p>

<p>表9.7　<code>&lt;c:forEach&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="511" border="1">
                        <tbody>
                            <tr>
                                <td width="59">
                                <p align="left">属性</p>
                                </td>
                                <td width="452">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">items</p>
                                </td>
                                <td width="452">
                                <p align="left">进行循环的集合（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">begin</p>
                                </td>
                                <td width="452">
                                <p align="left">开始条件（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">end</p>
                                </td>
                                <td width="452">
                                <p align="left">结束条件（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">step</p>
                                </td>
                                <td width="452">
                                <p align="left">循环的步长，默认为1（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">var</p>
                                </td>
                                <td width="452">
                                <p align="left">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="59">
                                <p align="left">varStatus</p>
                                </td>
                                <td width="452">
                                <p align="left">显示循环状态的变量（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个集合循环的示例。</p>

<p>&lt;%ArrayList arrayList = new ArrayList();</p>

<pre><code>               arrayList.add("aa");
               arrayList.add("bb");
               arrayList.add("cc");
</code></pre>

<p>%>
&lt;%request.getSession().setAttribute(&#8220;arrayList&#8221;, arrayList);%>
&lt;c:forEach items=&#8221;${sessionScope.arrayList}&#8221; var=&#8221;arrayListI&#8221;></p>

<pre><code>     ${arrayListI}
</code></pre>

<p>&lt;/c:forEach></p>

<p>该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。</p>

<pre><code>&lt;c:forEach var="i" begin="1" end="10" step="1"&gt;
      ${i}&lt;br /&gt;
&lt;/c:forEach&gt;
</code></pre>

<p>该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。</p>

<h4>9.3.8 用于分隔字符的 <code>&lt;c:forTokens&gt;</code> 标签</h4>

<p><code>&lt;c:forTokens&gt;</code>标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：</p>

<p>表9.8　<code>&lt;c:forTokens&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="268" border="1">
                        <tbody>
                            <tr>
                                <td width="76">
                                <p align="left">属性</p>
                                </td>
                                <td width="192">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">items</p>
                                </td>
                                <td width="192">
                                <p align="left">进行分隔的EL表达式或常量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">delims</p>
                                </td>
                                <td width="192">
                                <p align="left">分隔符</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">begin</p>
                                </td>
                                <td width="192">
                                <p align="left">开始条件（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">end</p>
                                </td>
                                <td width="192">
                                <p align="left">结束条件（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">step</p>
                                </td>
                                <td width="192">
                                <p align="left">循环的步长，默认为1（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">var</p>
                                </td>
                                <td width="192">
                                <p align="left">做循环的对象变量名（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="76">
                                <p align="left">varStatus</p>
                                </td>
                                <td width="192">
                                <p align="left">显示循环状态的变量（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<pre><code>&lt;c:forTokens items="aa,bb,cc,dd" begin="0" end="2" step="2" delims="," var="aValue"&gt;
         ${aValue}
&lt;/c:forTokens&gt;
</code></pre>

<p>需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa</p>

<h3><code>&lt;x: &gt;</code> 标签</h3>

<h4>9.3.9 用于包含页面的<code>&lt;c:import&gt;</code></h4>

<p><code>&lt;c:import&gt;</code>标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：</p>

<p>表9.9　<code>&lt;c:import&gt;</code>标签属性和说明</p>

<table cellpadding="0" width="360" border="1">
                        <tbody>
                            <tr>
                                <td width="73">
                                <p align="left">属性</p>
                                </td>
                                <td width="271">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">rl</p>
                                </td>
                                <td>
                                <p align="left">需要导入页面的URL</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">context</p>
                                </td>
                                <td>
                                <p align="left">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">charEncoding</p>
                                </td>
                                <td>
                                <p align="left">导入页面的字符集（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">var</p>
                                </td>
                                <td>
                                <p align="left">可以定义导入文本的变量名（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">scope</p>
                                </td>
                                <td>
                                <p align="left">导入文本的变量名作用范围（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                <p align="left">varReader</p>
                                </td>
                                <td>
                                <p align="left">接受文本的java.io.Reader类变量名（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p> 下面看一个示例。</p>

<pre><code>&lt;c:import url="/MyHtml.html" var="thisPage" /&gt;
&lt;c:import url="/MyHtml.html" context=”/sample2” var="thisPage"/&gt;
&lt;c:import url="www.sample.com/MyHtml.html" var="thisPage"/&gt;
</code></pre>

<p>该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。</p>

<h4>9.3.10 用于得到URL地址的<code>&lt;c:url&gt;</code>标签</h4>

<p><code>&lt;c:url&gt;</code> 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：</p>

<p>表9.10 <code>&lt;c:url&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="459" border="1">
                        <tbody>
                            <tr>
                                <td width="81">
                                <p align="left">属性</p>
                                </td>
                                <td width="378">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="81">
                                <p align="left">value</p>
                                </td>
                                <td width="378">
                                <p align="left">页面的URL地址</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="81">
                                <p align="left">context</p>
                                </td>
                                <td width="378">
                                <p align="left">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="81">
                                <p align="left">charEncoding</p>
                                </td>
                                <td width="378">
                                <p align="left">URL的字符集（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="81">
                                <p align="left">var</p>
                                </td>
                                <td width="378">
                                <p align="left">存储URL的变量名（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="81">
                                <p align="left">scope</p>
                                </td>
                                <td width="378">
                                <p align="left">变量名作用范围（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例：</p>

<pre><code>&lt;c:url value="/MyHtml.html" var="urlPage" /&gt;
&lt;a href="${urlPage}"&gt;link&lt;/a&gt;
</code></pre>

<p>得到了一个 URL 后，以 EL 表达式放入<code>&lt;a&gt;</code> 标签的 href 属性，达到链接的目的。</p>

<h4>9.3.11 用于页面重定向的<code>&lt;c:redirect&gt;</code>标签</h4>

<p><code>&lt;c:redirect&gt;</code> 用于页面的重定向，该标签的作用相当于 <code>response.setRedirect</code> 方法的工作。它包含 url 和 context 两个属性，属性含义和 <code>&lt;c:url&gt;</code> 标签相同。下面看一个示例。</p>

<pre><code>&lt;c:redirect url="/MyHtml.html"/&gt;
</code></pre>

<p>该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 <code>&lt;c:if&gt;</code> 等标签一起使用。</p>

<h4>9.3.12 用于包含传递参数的<code>&lt;c:param&gt;</code>标签</h4>

<p> <code>&lt;c:param&gt;</code> 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：</p>

<p>表9.11　<code>&lt;c:param&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="190" border="1">
                        <tbody>
                            <tr>
                                <td width="58">
                                <p align="left">属性</p>
                                </td>
                                <td width="132">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="58">
                                <p align="left">name</p>
                                </td>
                                <td width="132">
                                <p align="left">传递的参数名</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="58">
                                <p align="left">value</p>
                                </td>
                                <td width="132">
                                <p align="left">传递的参数值（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面是一个示例：</p>

<pre><code>&lt;c:redirect url="/MyHtml.jsp"&gt;
&lt;c:param name="userName" value=”RW” /&gt;
&lt;/c:redirect&gt;
</code></pre>

<p>该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。</p>

<h3>9.4 JSTL XML processing标签库</h3>

<p>在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：</p>

<ul>
<li>XML核心标签：<code>&lt;x:parse&gt;、&lt;x:out&gt;、&lt;x:set&gt;</code>。</li>
<li>XML流控制标签：<code>&lt;x:if&gt;、&lt;x:choose&gt;、&lt;x:when&gt;、&lt;x:otherwise&gt;、&lt;x:forEach&gt;</code>。</li>
<li>XML转换标签：<code>&lt;x:transform&gt;、&lt;x:param&gt;</code>。</li>
</ul>


<p>由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。</p>

<h4>9.4.1 用于解析XML文件的<code>&lt;x:parse&gt;</code>标签</h4>

<p><code>&lt;x:parse&gt;</code> 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：</p>

<p>表9.12　<code>&lt;x:parse&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" width="537" border="1">
                        <tbody>
                            <tr>
                                <td width="67">
                                <p align="left">属性</p>
                                </td>
                                <td width="470">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">doc</p>
                                </td>
                                <td width="470">
                                <p align="left">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">var</p>
                                </td>
                                <td width="470">
                                <p align="left">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">scope</p>
                                </td>
                                <td width="470">
                                <p align="left">变量的作用范围（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">varDom</p>
                                </td>
                                <td width="470">
                                <p align="left">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">scopeDom</p>
                                </td>
                                <td width="470">
                                <p align="left">org.w3c.dom.Document的接口类型变量作用范围（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">systemId</p>
                                </td>
                                <td width="470">
                                <p align="left">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="67">
                                <p align="left">filter</p>
                                </td>
                                <td width="470">
                                <p align="left">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。</p>

<p><code>&lt;x:parse&gt;</code>标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。</p>

<p>首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xml-body&gt;
         &lt;name&gt;RW&lt;/name&gt;
         &lt;passWord&gt;123456&lt;/passWord&gt;
         &lt;age&gt;28&lt;/age&gt;
         &lt;books&gt;
                   &lt;book&gt;book1&lt;/book&gt;
                   &lt;book&gt;book2&lt;/book&gt;
                   &lt;book&gt;book3&lt;/book&gt;
         &lt;/books&gt;
&lt;/xml-body&gt;
</code></pre>

<p>标签库的工作：</p>

<pre><code>&lt;c:import var="xmlFile" url="http://localhost:8080/booksamplejstl/SampleXml.xml"/&gt;
&lt;x:parse var="xmlFileValue" doc="${xmlFile}"/&gt;
</code></pre>

<h3><code>&lt;fmt: &gt;</code> 标签</h3>

<p>看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：</p>

<ul>
<li>国际化核心标签：<code>&lt;fmt:setLocale&gt;、&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;、&lt;fmt:message&gt;、&lt;fmt:param&gt;、&lt;fmt:requestEncoding&gt;</code>。</li>
<li>格式化标签：<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;、&lt;fmt:formatNumber&gt;、&lt;fmt:parseNumber&gt;、&lt;fmt:formatDate&gt;、&lt;fmt:parseDate&gt;</code>。</li>
</ul>


<p>下面只选择其中常见的一些标签和属性进行介绍。</p>

<h4>9.5.1 用于设置本地化环境的<code>&lt;fmt:setLocale&gt;</code>标签</h4>

<pre><code>`&lt;fmt:setLocale&gt;`标签用于设置Locale环境。它的属性和描述如表9.17所示：
</code></pre>

<p>表9.17　<code>&lt;fmt:setLocale&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="49">
                                <p align="left">属性</p>
                                </td>
                                <td width="336">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="49">
                                <p align="left">value</p>
                                </td>
                                <td width="336">
                                <p align="left">Locale环境的指定，可以是java.util.Locale或String类型的实例</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="49">
                                <p align="left">scope</p>
                                </td>
                                <td width="336">
                                <p align="left">Locale环境变量的作用范围（可选）</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例：</p>

<pre><code>&lt;fmt:setLocale value="zh_TW"/&gt;
</code></pre>

<p>表示设置本地环境为繁体中文。</p>

<h4>9.5.2 用于资源文件绑定的<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签</h4>

<p>这两组标签用于资源配置文件的绑定，唯一不同的是<code>&lt;fmt:bundle&gt;</code>标签将资源配置文件绑定于它标签体中的显示，<code>&lt;fmt:setBundle&gt;</code>标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。</p>

<p>根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：</p>

<p>表9.18　<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="69">
                                <p align="left">属性</p>
                                </td>
                                <td width="421">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="69">
                                <p align="left">basename</p>
                                </td>
                                <td width="421">
                                <p align="left">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="69">
                                <p align="left">var</p>
                                </td>
                                <td width="421">
                                <p align="left">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="69">
                                <p align="left">scope</p>
                                </td>
                                <td width="421">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例</p>

<pre><code>&lt;fmt:setLocale value="zh_CN"/&gt;
&lt;fmt:setBundle basename="applicationMessage" var="applicationBundle"/&gt;
</code></pre>

<p>该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。</p>

<h4>9.5.3  用于显示资源配置文件信息的<code>&lt;fmt:message&gt;</code>标签</h4>

<p>用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：</p>

<p>表9.19　<code>&lt;fmt:message&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="55">
                                <p align="left">属性</p>
                                </td>
                                <td width="513">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="55">
                                <p align="left">key</p>
                                </td>
                                <td width="513">
                                <p align="left">资源配置文件的&ldquo;键&rdquo;指定</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="55">
                                <p align="left">bundle</p>
                                </td>
                                <td width="513">
                                <p align="left">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="55">
                                <p align="left">var</p>
                                </td>
                                <td width="513">
                                <p align="left">将显示信息保存为一个变量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="55">
                                <p align="left">scope</p>
                                </td>
                                <td width="513">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例：</p>

<pre><code>&lt;fmt:setBundle basename="applicationMessage" var="applicationBundle"/&gt;
&lt;fmt:bundle basename="applicationAllMessage"&gt;
         &lt;fmt:message key="userName" /&gt;
         &lt;p&gt;
         &lt;fmt:message key="passWord" bundle="${applicationBundle}" /&gt;
&lt;/fmt:bundle&gt;
</code></pre>

<p>该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用<code>&lt;fmt:setBundle&gt;</code>标签被赋于了变量“ applicationBundle ”，而作为<code>&lt;fmt:bundle&gt;</code>标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。</p>

<p>第一个<code>&lt;fmt:message&gt;</code>标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。
第二个<code>&lt;fmt:message&gt;</code>标签虽然被定义在<code>&lt;fmt:bundle&gt;</code>标签体内，但是它使用了bundle属性，因此将指定之前由<code>&lt;fmt:setBundle&gt;</code>标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。</p>

<h4>9.5.4  用于参数传递的<code>&lt;fmt:param&gt;</code>标签</h4>

<p><code>&lt;fmt:param&gt;</code>标签应该位于<code>&lt;fmt:message&gt;</code>标签内，将为该消息标签提供参数值。它只有一个属性value。
<code>&lt;fmt:param&gt;</code>标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。</p>

<h4>9.5.6  用于为请求设置字符编码的<code>&lt;fmt:requestEncoding&gt;</code>标签</h4>

<p><code>&lt;fmt:requestEncoding&gt;</code>标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。</p>

<h4>9.5.7  用于设定时区的<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签</h4>

<p>这两组标签都用于设定一个时区。唯一不同的是<code>&lt;fmt:timeZone&gt;</code>标签将使得在其标签体内的工作可以使用该时区设置，<code>&lt;fmt:setBundle&gt;</code>标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：</p>

<p>表9.20　<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="53">
                                <p align="left">属性</p>
                                </td>
                                <td width="312">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="53">
                                <p align="left">value</p>
                                </td>
                                <td width="312">
                                <p align="left">时区的设置</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="53">
                                <p align="left">var</p>
                                </td>
                                <td width="312">
                                <p align="left">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="53">
                                <p align="left">scope</p>
                                </td>
                                <td width="312">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<h4>9.5.8  用于格式化数字的<code>&lt;fmt:formatNumber&gt;</code>标签</h4>

<p><code>&lt;fmt: formatNumber &gt;</code> 标签用于格式化数字。它的属性和描述如表9.21所示：</p>

<p>表9.21　<code>&lt;fmt:formatNumber&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="104">
                                <p align="left">属性</p>
                                </td>
                                <td width="384">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">value</p>
                                </td>
                                <td width="384">
                                <p align="left">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">type</p>
                                </td>
                                <td width="384">
                                <p align="left">格式化的类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">pattern</p>
                                </td>
                                <td width="384">
                                <p align="left">格式化模式</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">var</p>
                                </td>
                                <td width="384">
                                <p align="left">结果保存变量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">scope</p>
                                </td>
                                <td width="384">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">maxIntegerDigits</p>
                                </td>
                                <td width="384">
                                <p align="left">指定格式化结果的最大值</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">minIntegerDigits</p>
                                </td>
                                <td width="384">
                                <p align="left">指定格式化结果的最小值</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">maxFractionDigits</p>
                                </td>
                                <td width="384">
                                <p align="left">指定格式化结果的最大值，带小数</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="104">
                                <p align="left">minFractionDigits</p>
                                </td>
                                <td width="384">
                                <p align="left">指定格式化结果的最小值，带小数</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p><code>&lt;fmt:formatNumber&gt;</code>标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。</p>

<p>下面看一个示例。</p>

<pre><code>&lt;fmt:formatNumber value="1000.888" type="currency" var="money"/&gt;
</code></pre>

<p>该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。</p>

<h4>9.5.9  用于解析数字的<code>&lt;fmt:parseNumber&gt;</code>标签</h4>

<p><code>&lt;fmt:parseNumber&gt;</code>标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。<code>&lt;fmt:parseNumber&gt;</code>标签看起来和<code>&lt;fmt:formatNumber&gt;</code>标签的作用正好相反。它的属性和描述如表9.22所示：</p>

<p>表9.22　<code>&lt;fmt:parseNumber&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="72">
                                <p align="left">属性</p>
                                </td>
                                <td width="463">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">value</p>
                                </td>
                                <td width="463">
                                <p align="left">将被解析的字符串</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">type</p>
                                </td>
                                <td width="463">
                                <p align="left">解析格式化的类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">pattern</p>
                                </td>
                                <td width="463">
                                <p align="left">解析格式化模式</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">var</p>
                                </td>
                                <td width="463">
                                <p align="left">结果保存变量，类型为java.lang.Number</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">scope</p>
                                </td>
                                <td width="463">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">parseLocale</p>
                                </td>
                                <td width="463">
                                <p align="left">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<pre><code>&lt;fmt:parseNumber value="15%" type="percent" var="num"/&gt;
</code></pre>

<p>解析之后的结果为“ 0.15 ”。</p>

<h4>9.5.10  用于格式化日期的<code>&lt;fmt:formatDate&gt;</code>标签</h4>

<p><code>&lt;fmt:formatDate&gt;</code>标签用于格式化日期。它的属性和描述如表9.23所示：</p>

<p>表9.23　<code>&lt;fmt:formatDate&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="105">
                                <p align="left">属性</p>
                                </td>
                                <td width="343">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">value</p>
                                </td>
                                <td width="343">
                                <p align="left">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">type</p>
                                </td>
                                <td width="343">
                                <p align="left">格式化的类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">pattern</p>
                                </td>
                                <td width="343">
                                <p align="left">格式化模式</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">var</p>
                                </td>
                                <td width="343">
                                <p align="left">结果保存变量</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">scope</p>
                                </td>
                                <td width="343">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p align="left">timeZone</p>
                                </td>
                                <td width="343">
                                <p align="left">指定格式化日期的时区</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p><code>&lt;fmt:formatDate&gt;</code>标签与<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签的关系密切。若没有指定 timeZone属性，也可以通过<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签设定的时区来格式化最后的结果。</p>

<h4>9.5.11  用于解析日期的<code>&lt;fmt:parseDate&gt;</code>标签</h4>

<p><code>&lt;fmt:parseDate&gt;</code>标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。<code>&lt;fmt:parseDate&gt;</code>标签看起来和<code>&lt;fmt:formatDate&gt;</code>标签的作用正好相反。它的属性和描述如表9.24所示：</p>

<p>表9.24　<code>&lt;fmt:parseDate&gt;</code>标签属性和说明</p>

<table cellspacing="0" cellpadding="0" border="1">
                        <tbody>
                            <tr>
                                <td width="72">
                                <p align="left">属性</p>
                                </td>
                                <td width="451">
                                <p align="left">描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">value</p>
                                </td>
                                <td width="451">
                                <p align="left">将被解析的字符串</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">type</p>
                                </td>
                                <td width="451">
                                <p align="left">解析格式化的类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">pattern</p>
                                </td>
                                <td width="451">
                                <p align="left">解析格式化模式</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">var</p>
                                </td>
                                <td width="451">
                                <p align="left">结果保存变量，类型为java.lang.Date</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">scope</p>
                                </td>
                                <td width="451">
                                <p align="left">变量的作用范围</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">parseLocale</p>
                                </td>
                                <td width="451">
                                <p align="left">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="72">
                                <p align="left">timeZone</p>
                                </td>
                                <td width="451">
                                <p align="left">指定解析格式化日期的时区</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p><code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此<code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。</p>

<p> <code>&lt;sql:&gt;</code>标签</p>

<h3>9.6  Database access 标签库</h3>

<p>Database access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。</p>

<p>对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。</p>

<p>Database access标签库有以下6组标签来进行工作：<code>&lt;sql:setDataSource&gt;、&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:transaction&gt;、&lt;sql:setDataSource&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;</code>。</p>

<h4>9.6.1 用于设置数据源的 <code>&lt;sql:setDataSource&gt;</code> 标签</h4>

<p><code>&lt;sql:setDataSource&gt;</code>标签用于设置数据源，下面看一个示例：</p>

<pre><code>&lt;sql:setDataSource
         var="dataSrc"
         url="jdbc:postgresql://localhost:5432/myDB"
         driver="org.postgresql.Driver"
         user="admin"
         password="1111"/&gt;
</code></pre>

<p>该示例定义一个数据源并保存在“ dataSrc ”变量内。</p>

<h4>9.6.2 用于查询的 <code>&lt;sql:query&gt;</code>标签</h4>

<p><code>&lt;sql:query&gt;</code>标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：</p>

<pre><code>&lt;sql:query var="queryResults" dataSource="${dataSrc}"&gt;
      select * from table1
&lt;/sql:query&gt;
</code></pre>

<p>该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用<code>&lt;c:forEach&gt;</code>循环来进行。下面看一个示例。</p>

<pre><code>&lt;c:forEach var="row" items="${queryResults.rows}"&gt;
      &lt;tr&gt;
               &lt;td&gt;${row.userName}&lt;/td&gt;
                &lt;td&gt;${row.passWord}&lt;/td&gt;
      &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre>

<p>“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。</p>

<h4>9.6.3 用于更新的 <code>&lt;sql:update&gt;</code> 标签</h4>

<p><code>&lt;sql:update&gt;</code>标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和<code>&lt;sql:query&gt;</code>标签没有什么不同。</p>

<h4>9.6.4 用于事务处理的<code>&lt;sql:transaction&gt;</code>标签</h4>

<p><code>&lt;sql:transaction&gt;</code>标签用于数据库的事务处理，在该标签体内可以使用<code>&lt;sql:update&gt;</code>标签和<code>&lt;sql:query&gt;</code>标签，而<code>&lt;sql:transaction&gt;</code>标签的事务管理将作用于它们之上。
<code>&lt;sql:transaction&gt;</code>标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。</p>

<h4>9.6.5 用于事务处理的<code>&lt;sql:param&gt; 、 &lt;sql:dateParam&gt;</code> 标签</h4>

<p>这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。<code>&lt;sql:param&gt;</code>标签传递除java.util.Date类型以外的所有相融参数，<code>&lt;sql:dateParam&gt;</code>标签则指定必须传递java.util.Date类型的参数。</p>

<h3><code>&lt;fn:&gt;</code> 标签</h3>

<h3>9.7 Functions 标签库</h3>

<pre><code>   称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。

   长度函数：fn:length
   字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim
</code></pre>

<p>以下是各个函数的用途和属性以及简单示例。</p>

<h4>9.7.1 长度函数 fn:length 函数</h4>

<pre><code>   长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。
</code></pre>

<p>fn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。</p>

<pre><code>&lt;%ArrayList arrayList1 = new ArrayList();
                            arrayList1.add("aa");
                            arrayList1.add("bb");
                            arrayList1.add("cc");

%&gt;
&lt;%request.getSession().setAttribute("arrayList1", arrayList1);%&gt;
${fn:length(sessionScope.arrayList1)}
</code></pre>

<p>假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。</p>

<h4>9.7.2 判断函数 fn:contains 函数</h4>

<pre><code>   fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。

${fn:contains("ABC", "a")}&lt;br&gt;
${fn:contains("ABC", "A")}&lt;br&gt;
</code></pre>

<p>前者返回“ false ”，后者返回“ true ”。</p>

<h4>9.7.3 fn:containsIgnoreCase函数</h4>

<pre><code>  fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。

${fn:containsIgnoreCase("ABC", "a")}&lt;br&gt;
${fn:containsIgnoreCase("ABC", "A")}&lt;br&gt;
</code></pre>

<p>前者和后者都会返回“ true ”。</p>

<h4>9.7.4 词头判断函数 fn:startsWith 函数</h4>

<pre><code>   fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。

${fn:startsWith ("ABC", "ab")}&lt;br&gt;
${fn:startsWith ("ABC", "AB")}&lt;br&gt;
</code></pre>

<p>前者返回“ false ”，后者返回“ true ”。</p>

<h4>9.7.5 词尾判断函数 fn:endsWith 函数</h4>

<pre><code>   fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。

${fn:endsWith("ABC", "bc")}&lt;br&gt;
${fn:endsWith("ABC", "BC")}&lt;br&gt;
</code></pre>

<p>前者返回“ false ”，后者返回“ true ”。</p>

<h4>9.7.6 字符实体转换函数 fn:escapeXml 函数</h4>

<p>fn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。</p>

<h4>9.7.8 字符匹配函数 fn:indexOf 函数</h4>

<pre><code>   fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。

${fn:indexOf("ABCD","aBC")}&lt;br&gt;
${fn:indexOf("ABCD","BC")}&lt;br&gt;
</code></pre>

<p>前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。</p>

<h4>9.7.9 分隔符函数 fn:join 函数</h4>

<pre><code>   fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：
</code></pre>

<p>表9.25　fn:join函数</p>

<table cellspacing="0" cellpadding="0" width="350" border="1">
                        <tbody>
                            <tr>
                                <td width="65">
                                <p>参数</p>
                                </td>
                                <td width="216">
                                <p>描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>array</p>
                                </td>
                                <td width="216">
                                <p>字符串数组。其类型必须为String[]类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>separator</p>
                                </td>
                                <td width="216">
                                <p>分隔符。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>返回结果</p>
                                </td>
                                <td width="216">
                                <p>返回一个String类型的值</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<pre><code>&lt;% String[] stringArray = {"a","b","c"}; %&gt;
&lt;%request.getSession().setAttribute("stringArray", stringArray);%&gt;
${fn:join(sessionScope.stringArray,";")}&lt;br&gt;
</code></pre>

<p>定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。</p>

<h4>9.7.10 替换函数 fn:replace 函数</h4>

<pre><code>   fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：
</code></pre>

<p>表9.26　fn:replace函数</p>

<table cellspacing="0" cellpadding="0" width="353" border="1">
                        <tbody>
                            <tr>
                                <td width="105">
                                <p>参数</p>
                                </td>
                                <td width="249">
                                <p>描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p>inputString</p>
                                </td>
                                <td width="249">
                                <p>源字符串。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p>beforeSubstring</p>
                                </td>
                                <td width="249">
                                <p>指定被替换字符串。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p>afterSubstring</p>
                                </td>
                                <td width="249">
                                <p>指定替换字符串。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="105">
                                <p>返回结果</p>
                                </td>
                                <td width="249">
                                <p>返回一个String类型的值</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<p>${fn:replace(&#8220;ABC&#8221;,&#8221;A&#8221;,&#8221;B&#8221;)}<br></p>

<p>将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。</p>

<h4>9.7.11 分隔符转换数组函数 fn:split 函数</h4>

<p>fn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：</p>

<p>表9.27　fn:split函数</p>

<table cellspacing="0" cellpadding="0" width="281" border="1">
                        <tbody>
                            <tr>
                                <td width="65">
                                <p>参数</p>
                                </td>
                                <td width="216">
                                <p>描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>string</p>
                                </td>
                                <td width="216">
                                <p>源字符串。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>delimiters</p>
                                </td>
                                <td width="216">
                                <p>指定分隔符。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="65">
                                <p>返回结果</p>
                                </td>
                                <td width="216">
                                <p>返回一个String[]类型的值</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<p>${fn:split(&#8220;A,B,C&#8221;,&#8221;,&#8221;)}<br></p>

<p>将“ A,B,C ”字符串转换为数组{A,B,C}。</p>

<h4>9.7.12 字符串截取函数 fn:substring 函数</h4>

<p>fn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：</p>

<p>表9.28　fn:substring函数</p>

<table cellspacing="0" cellpadding="0" width="353" border="1">
                        <tbody>
                            <tr>
                                <td width="68">
                                <p>参数</p>
                                </td>
                                <td width="285">
                                <p>描述</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="68">
                                <p>string</p>
                                </td>
                                <td width="285">
                                <p>源字符串。其类型必须为String类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="68">
                                <p>beginIndex</p>
                                </td>
                                <td width="285">
                                <p>指定起始下标（值从0开始）。其类型必须为int类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="68">
                                <p>endIndex</p>
                                </td>
                                <td width="285">
                                <p>指定结束下标（值从0开始）。其类型必须为int类型</p>
                                </td>
                            </tr>
                            <tr>
                                <td width="68">
                                <p>返回结果</p>
                                </td>
                                <td width="285">
                                <p>返回一个String类型的值</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>


<p>下面看一个示例。</p>

<p>${fn:substring(&#8220;ABC&#8221;,&#8221;1&#8221;,&#8221;2&#8221;)}<br></p>

<p>截取结果为“ B ”。</p>

<h4>9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数</h4>

<p>fn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。</p>

<pre><code>${fn:substringBefore("ABCD","BC")}&lt;br&gt;
</code></pre>

<p>截取的结果为“ A ”。</p>

<h4>9.7.15 小写转换函数 fn:toLowerCase 函数</h4>

<p>fn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。</p>

<pre><code>${fn:toLowerCase("ABCD")}&lt;br&gt;
</code></pre>

<p>转换的结果为“ abcd ”。</p>

<h4>9.7.16大写转换函数 fn:toUpperCase 函数</h4>

<p>fn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>

<pre><code>${fn:toUpperCase("abcd")}&lt;br&gt;
</code></pre>

<p>转换的结果为“ ABCD ”。</p>

<h4>9.7.17空格删除函数 fn:trim 函数</h4>

<p>fn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>

<pre><code>${fn:trim("AB C ")}D&lt;br&gt;
</code></pre>

<p>转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。</p>

<p>参考文档<a href="http://www.javawind.net/help/html/jstl_el.htm">http://www.javawind.net/help/html/jstl_el.htm</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ut-maven-plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/12/14/ut-maven-plugin/"/>
    <updated>2013-12-14T21:31:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/12/14/ut-maven-plugin</id>
    <content type="html"><![CDATA[<h3>ut-maven-plugin简介</h3>

<p>这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。<br/>
《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。</p>

<p>也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。</p>

<!--more-->


<h3>实现原理</h3>

<p>如何解析源码，这是首先需要解决的问题。在计算机科学中，有<strong>抽象语法树(Abstract Syntax Tree)</strong>这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。</p>

<p>Eclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。</p>

<p><img src="http://www.shenyanchao.cn/images/blog/2013/eclipse-outline.png" alt="" /></p>

<p>同时,Eclipse也提供的有抽象语法树视图，即ASTView。</p>

<p><img src="http://www.shenyanchao.cn/images/blog/2013/eclipse-ast-view.png" alt="" /></p>

<p>本插件选用<a href="https://code.google.com/p/javaparser/">JavaParser</a>来分析源码，提取并生成测试代码。</p>

<h3>如何使用这个工具？</h3>

<p>这个插件一个被我放到了<a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22">Maven Central</a>上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。 <br/>
比如：</p>

<pre><code>&lt;plugin&gt;
&lt;groupId&gt;cn.shenyanchao.ut&lt;/groupId&gt;
&lt;artifactId&gt;ut-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;0.2.9&lt;/version&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;source2test&lt;/id&gt;
        &lt;phase&gt;process-test-sources&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;source2test&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<h3>解决了什么问题？</h3>

<p>以<a href="https://github.com/spring-projects/spring-petclinic">spring-petclinic</a>中的代码为例。</p>

<p>下面的Service代码：</p>

<pre><code>package org.springframework.samples.petclinic.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.model.PetType;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;

@Service
public class ClinicServiceImpl implements ClinicService {

    @Autowired
    private PetRepository petRepository;
    //省略
    ......

    @Override
    @Transactional(readOnly = true)
    public Pet findPetById(int id) throws DataAccessException {
        return petRepository.findById(id);
    }
    //省略
    ......

}
</code></pre>

<p>那么，我们自己手工写的单元测试代码有可能是这样的：</p>

<pre><code>package org.springframework.samples.petclinic.service.test;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.samples.petclinic.service.ClinicServiceImpl;

import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

public class ClinicServiceImplTest {

    @InjectMocks
    private ClinicServiceImpl clinicService = new ClinicServiceImpl();

    @Mock
    private PetRepository petRepository;

    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void findPetByIdTest() {
        when(petRepository.findById(anyInt())).thenReturn(new Pet());
        Pet pet = clinicService.findPetById(1);
        Assert.assertNotNull(pet);
    }
</code></pre>

<p>如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：</p>

<pre><code>        when(petRepository.findById(anyInt())).thenReturn(new Pet());
        Pet pet = clinicService.findPetById(1);
</code></pre>

<p>因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。</p>

<p>当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员修炼之道》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/12/04/the-pragmatic-programmer-reading-notes/"/>
    <updated>2013-12-04T15:45:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/12/04/the-pragmatic-programmer-reading-notes</id>
    <content type="html"><![CDATA[<p>《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。</p>

<h3>关于心态</h3>

<h4>石头汤与煮青蛙</h4>

<blockquote><p>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。</p>

<p>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。</p>

<p>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好&#8230;&#8230;.” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。
几分钟后，村民们又问：“就这些了吗？”</p>

<p>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。</p>

<p>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。</p>

<p>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。</p></blockquote>

<!--more-->


<p>在石头汤的故事里有两层寓意。</p>

<p>士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。</p>

<p>另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。</p>

<p>我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。</p>

<p>再来看两个案例。</p>

<blockquote><p>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。</p>

<p>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！</p></blockquote>

<p>锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。</p>

<p>当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。</p>

<p>作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。</p>

<h3>关于工具</h3>

<h3>文本编辑器</h3>

<p>文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：</p>

<ul>
<li>可配置</li>
<li>可扩展</li>
<li>可编程</li>
</ul>


<p>一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。 <br/>
知道了这些应该怎么做？</p>

<table border="1px">
<tr>
<th>如果你现在这样&#8230;</th><th>那么考虑&#8230;</th>
</tr>
<tr>
<td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td>
</tr>
<tr>
<td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td>
</tr>
<tr>
<td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td>
</tr>
<tr>
<td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td>
</tr>
</table>


<p><strong>推荐工具：</strong>Emacs,vi,CRiSP,Brief以及其他的跨平台软件。  <br/>
珍惜生命，远离office哦。</p>

<h4>源码控制</h4>

<p>源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。</p>

<p>把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。</p>

<h3>关于编码</h3>

<p>注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。</p>

<p>适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。</p>

<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。</li>
</ul>


<p>重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH原理]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/11/26/the-principle-of-ssh/"/>
    <updated>2013-11-26T16:04:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/11/26/the-principle-of-ssh</id>
    <content type="html"><![CDATA[<h3>一、什么是SSH？</h3>

<p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p>

<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>

<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p>

<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p>

<!--more-->


<h3>二、最基本的用法</h3>

<p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>

<pre><code>$ ssh user@host
</code></pre>

<p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>

<pre><code>$ ssh host
</code></pre>

<p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p>

<p>　　$ ssh -p 2222 user@host</p>

<p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p>

<h3>三、中间人攻击</h3>

<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>

<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。  <br/>
这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>

<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的&#8221;中间人攻击&#8221;（Man-in-the-middle attack）。 <br/>
SSH协议是如何应对的呢？</p>

<h3>四、口令登录</h3>

<p>如果你是第一次登录对方主机，系统会出现下面的提示：</p>

<pre><code>$ ssh user@host
The authenticity of host 'host (12.18.429.21)' can't be established.
RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.
Are you sure you want to continue connecting (yes/no)?
</code></pre>

<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？  <br/>
所谓&#8221;公钥指纹&#8221;，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。   <br/>
很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。   <br/>
假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>

<pre><code>Are you sure you want to continue connecting (yes/no)? yes
</code></pre>

<p>系统会出现一句提示，表示host主机已经得到认可。</p>

<pre><code>Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.
</code></pre>

<p>然后，会要求输入密码。</p>

<pre><code>Password: (enter password)
</code></pre>

<p>如果密码正确，就可以登录了。   <br/>
当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。   <br/>
每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>

<h3>五、公钥登录</h3>

<p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。   <br/>
所谓&#8221;公钥登录&#8221;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。   <br/>
这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p>

<pre><code>$ ssh-keygen
</code></pre>

<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p>

<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。   <br/>
这时再输入下面的命令，将公钥传送到远程主机host上面：</p>

<pre><code>$ ssh-copy-id user@host
</code></pre>

<p>好了，从此你再登录，就不需要输入密码了。    <br/>
如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面&#8221;#&#8221;注释是否取掉。</p>

<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
</code></pre>

<p>然后，重启远程主机的ssh服务。</p>

<pre><code>// ubuntu系统
service ssh restart
// debian系统
/etc/init.d/ssh restart
</code></pre>

<h3>六、authorized_keys文件</h3>

<p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>

<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>

<pre><code>$ ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub     
</code></pre>

<p>这条命令由多个语句组成，依次分解开来看： <br/>
（1）<code>$ ssh user@host</code>，表示登录远程主机； <br/>
（2）单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程shell上执行的命令： <br/>
（3）<code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;   <br/>
（4）<code>cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件authorized_keys的末尾。    <br/>
写入authorized_keys文件后，公钥登录的设置就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven项目集成CheckStyle,PMD,FindBugs进行静态代码扫描]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/11/20/maven-project-integrate-checkstyle-pmd-findbugs/"/>
    <updated>2013-11-20T19:22:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/11/20/maven-project-integrate-checkstyle-pmd-findbugs</id>
    <content type="html"><![CDATA[<p>在pom.xml里添加以下maven插件配置：</p>

<pre><code>    &lt;!-- 静态代码检查 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.11&lt;/version&gt;
    &lt;configuration&gt;
        &lt;configLocation&gt;checkstyle.xml&lt;/configLocation&gt;
        &lt;includeResources&gt;false&lt;/includeResources&gt;
        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;
        &lt;violationSeverity&gt;info&lt;/violationSeverity&gt;
        &lt;maxAllowedViolations&gt;0&lt;/maxAllowedViolations&gt;
        &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;
        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
        &lt;includes&gt;
            **\/package\/**.java,**\/otherpackage\/**.java
        &lt;/includes&gt;
    &lt;/configuration&gt;
&lt;!--     &lt;executions&gt;
         &lt;execution&gt;
             &lt;goals&gt;
                 &lt;goal&gt;check&lt;/goal&gt;
             &lt;/goals&gt;
             &lt;phase&gt;validate&lt;/phase&gt;
         &lt;/execution&gt;
     &lt;/executions&gt;--&gt;
&lt;/plugin&gt;

&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.7.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;failurePriority&gt;5&lt;/failurePriority&gt;
        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;
        &lt;targetJdk&gt;${jdk.version}&lt;/targetJdk&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;
        &lt;rulesets&gt;
            &lt;ruleset&gt;pmd.xml&lt;/ruleset&gt;
        &lt;/rulesets&gt;
        &lt;includes&gt;
            &lt;include&gt;**\/package\/**.java&lt;/include&gt;
            &lt;include&gt;**\/otherpackage\/**.java&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/configuration&gt;
  &lt;!--   &lt;executions&gt;
         &lt;execution&gt;
             &lt;phase&gt;package&lt;/phase&gt;
             &lt;goals&gt;
                 &lt;goal&gt;check&lt;/goal&gt;
             &lt;/goals&gt;
         &lt;/execution&gt;
     &lt;/executions&gt;--&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.5.2&lt;/version&gt;
    &lt;configuration&gt;
        &lt;onlyAnalyze&gt;
            cn.shenyanchao.package.*,
            cn.shenyanchao.otherpackage.*,
        &lt;/onlyAnalyze&gt;
        &lt;includeFilterFile&gt;findbugs.xml&lt;/includeFilterFile&gt;
        &lt;failOnError&gt;true&lt;/failOnError&gt;
        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;
    &lt;/configuration&gt;
 &lt;!--   &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;check&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;--&gt;
&lt;/plugin&gt;
</code></pre>

<p>这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。</p>

<!--more-->


<p></p>

<h5>那么能否指定只扫描特定的包或者文件呢？</h5>

<p>上面checkstyle用的是：</p>

<pre><code>&lt;includes&gt;
    **\/package\/**.java,**\/otherpackage\/**.java
&lt;/includes&gt;
</code></pre>

<p>pmd是：</p>

<pre><code>&lt;includes&gt;
    &lt;include&gt;**\/package\/**.java&lt;/include&gt;
    &lt;include&gt;**\/otherpackage\/**.java&lt;/include&gt;
&lt;/includes&gt;
</code></pre>

<p>findbugs则使用的是：</p>

<pre><code>&lt;onlyAnalyze&gt;
    cn.shenyanchao.package.*,
    cn.shenyanchao.otherpackage.*,
&lt;/onlyAnalyze&gt;
</code></pre>

<h5>如何在编译期间或打包期间执行检查？</h5>

<p>如上所示的注释掉部分，添加就可以了：</p>

<pre><code>&lt;executions&gt;
     &lt;execution&gt;
         &lt;phase&gt;package&lt;/phase&gt;
         &lt;goals&gt;
             &lt;goal&gt;check&lt;/goal&gt;
         &lt;/goals&gt;
     &lt;/execution&gt;
 &lt;/executions&gt;
</code></pre>

<p>这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven如何打包本地依赖包]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/11/20/how-package-system-dependency-lib-in-maven/"/>
    <updated>2013-11-20T19:04:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/11/20/how-package-system-dependency-lib-in-maven</id>
    <content type="html"><![CDATA[<h4>Maven如何依赖本地包？</h4>

<p>有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？</p>

<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.wltea.ik-analyzer&lt;/groupId&gt;
        &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt;
        &lt;version&gt;3.2.8&lt;/version&gt;
        &lt;scope&gt;system&lt;/scope&gt;
        &lt;systemPath&gt;${project.basedir}/lib/ik-analyzer-3.2.8.jar&lt;/systemPath&gt;
    &lt;/dependency&gt;
</code></pre>

<p>这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。</p>

<h4>如何将本地包打到war包内？</h4>

<p>打war包，一般直接执行<code>mvn clean package</code>即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。</p>

<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
            &lt;configuration&gt;
                &lt;warName&gt;${project.artifactId}&lt;/warName&gt;
                &lt;webResources&gt;
                    &lt;resource&gt;
                        &lt;directory&gt;lib/&lt;/directory&gt;
                        &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;
                        &lt;includes&gt;
                            &lt;include&gt;**/*.jar&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/resource&gt;
                &lt;/webResources&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义CheckStyle规则]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/09/25/custome-checkstyle-rule/"/>
    <updated>2013-09-25T13:11:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/09/25/custome-checkstyle-rule</id>
    <content type="html"><![CDATA[<h3>CheckStyle基于antlr对源码进行处理</h3>

<ul>
<li>antlr对AST解析</li>
<li>使用Visitor模式</li>
</ul>


<p>主要是通过：</p>

<pre><code>public int[] getDefaultTokens()
</code></pre>

<p>指定要访问的节点类型。</p>

<pre><code>public void visitToken(DetailAST assignAST)
</code></pre>

<p>指定如何处理节点，并进行规则校验。</p>

<!--more-->


<h4>参数不可在方法内重新赋值</h4>

<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;

import java.util.ArrayList;
import java.util.List;

/**
 * Date:  13-8-26
 * Time:  下午4:34
 * checks the Method Parameter should not assign.
 *
 * @author shenyanchao
 */
public class ParameterNoAssignCheck extends Check {

    private int[] assignTokenTypes = {
            TokenTypes.ASSIGN,
            TokenTypes.PLUS_ASSIGN,
            TokenTypes.MINUS_ASSIGN,
            TokenTypes.STAR_ASSIGN,
            TokenTypes.DIV_ASSIGN,
            TokenTypes.MOD_ASSIGN,
            TokenTypes.SR_ASSIGN,
            TokenTypes.BSR_ASSIGN,
            TokenTypes.SL_ASSIGN,
            TokenTypes.BAND_ASSIGN,
            TokenTypes.BXOR_ASSIGN,
            TokenTypes.BOR_ASSIGN
    };

    @Override
    public int[] getDefaultTokens() {
        return assignTokenTypes;
    }


    @Override
    public void visitToken(DetailAST assignAST) {
        if (null == assignAST) {
            return;
        }
        DetailAST leftVarAST = assignAST.findFirstToken(TokenTypes.IDENT);
        if (null == leftVarAST) {
            return;
        }
        String leftVar = leftVarAST.getText();
        DetailAST methodDefAST = findParentMethodDefBy(assignAST);
        if (null != methodDefAST) {
            List&lt;String&gt; parameters = findMethodParameterNames(methodDefAST);
            if (parameters.contains(leftVar)) {
                log(leftVarAST.getLineNo(), "Method parameter [" + leftVar + "] should not assign!");
            }
        }
    }


    private List&lt;String&gt; findMethodParameterNames(DetailAST methodDefAST) {
        List&lt;String&gt; parameters = new ArrayList&lt;String&gt;();
        if (null != methodDefAST) {
            DetailAST parametersAST = methodDefAST.findFirstToken(TokenTypes.PARAMETERS);
            if (null != parametersAST) {
                DetailAST parameterDefAST = parametersAST.getFirstChild();
                while (null != parameterDefAST) {
                    if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF) {
                        String parameterName = parameterDefAST.findFirstToken(TokenTypes.IDENT).getText();
                        parameters.add(parameterName);
                    }
                    parameterDefAST = parameterDefAST.getNextSibling();
                }
            }
        }
        return parameters;
    }


    /**
     * @param aAST aAST
     * @return ancestor METHOD_DEF or null
     */
    private DetailAST findParentMethodDefBy(DetailAST aAST) {
        if (null == aAST || aAST.getType() == TokenTypes.METHOD_DEF) {
            return aAST;
        } else {
            return findParentMethodDefBy(aAST.getParent());
        }
    }

}
</code></pre>

<h4>控制使用String连+的数量</h4>

<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;

/**
 * Date:  13-8-26
 * Time:  下午1:29
 *
 * @author shenyanchao
 */
public class ConcatStringCheck extends Check {

    private static final int DEFAULT_MAX = 10;
    private int max = DEFAULT_MAX;

    @Override
    public int[] getDefaultTokens() {
        return new int[]{TokenTypes.EXPR};
    }

    @Override
    public void visitToken(DetailAST ast) {
        int plusCount = findAllSubNodeIn(ast, TokenTypes.PLUS);
        if (plusCount &gt; max - 1) {
            log(ast.getLineNo(), "more than " + (max) + " string concat,please use StringBuffer or StringBuilder " +
                    "instead");
        }
    }


    public void setMax(int limit) {
        max = limit;
    }

    private int findAllSubNodeIn(DetailAST ast, int tokenTypes) {
        if (ast.getChildCount() == 0) {
            return 0;
        } else {
            int count = 0;
            count += ast.getChildCount(tokenTypes);
            DetailAST childAST = ast.getFirstChild();
            while (null != childAST) {
                count += findAllSubNodeIn(childAST, tokenTypes);
                childAST = childAST.getNextSibling();
            }
            return count;
        }
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web系统性能调优常用技巧]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/09/24/performance-tuning-in-web-test/"/>
    <updated>2013-09-24T18:02:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/09/24/performance-tuning-in-web-test</id>
    <content type="html"><![CDATA[<h4>目标Web系统</h4>

<p>apache + tomcat + mysql + linux, 介绍如何定位瓶颈与调优</p>

<h4>Tomcat</h4>

<p>按照官方默认配置。 <br/>
并发150正常;达到210时，报connection refuse</p>

<p>$TOMCAT_HOME/conf/server.xml中</p>

<pre><code>&lt;Connector port="8080" protocol="HTTP/1.1"      connectionTimeout="20000" 
               redirectPort="8443" URIEncoding="UTF-8"/&gt;
</code></pre>

<p>maxThreads 默认值是200
acceptCount 默认值是100</p>

<p>解决方法：显式指明以上2项，并提高数值。并可配合min/maxSpareThreads</p>

<p>参数文档： <a href="http://tomcat.apache.org/tomcat-6.0-doc/config/http.html">http://tomcat.apache.org/tomcat-6.0-doc/config/http.html</a></p>

<!--more-->


<p>继续增加并发数，出现以下现象：</p>

<ul>
<li>420并发，观察到Jmeter的聚合报告有明显卡顿现象。</li>
<li><p>Noah监控，显示CPU使用率下降。大锯齿出现。</p>

<p>问题分析：</p>

<pre><code>  在加压过程中，对tomcat的JVM情况进行监控。出现FullGC,每次大概4s .
</code></pre></li>
</ul>


<p>如何监控GC吗？</p>

<pre><code>jstat -gcutil 3950 3000 5

  S0     S1         E          O      P       YGC     YGCT    FGC       FGCT     GCT   
  0.00  47.86  66.10   6.55  99.92      7       0.087     0         0.000    0.087
  0.00  47.86  66.90   6.55  99.94      7       0.087     0         0.000    0.087
  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087
  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087
  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087
</code></pre>

<p>解决方法：</p>

<pre><code>     $TOMCAT_HOME/bin/catalina.sh   第一行添加
    export CATALINA_OPTS="-Xmx3500m -Xms2048m -XX:PermSize=256m XX:MaxPermSize=512m -Xss128k"
</code></pre>

<p>JAVA_OPTS   VS   CATALINA_OPTS（推荐使用）   <br/>
<strong>差别</strong>：JAVA_OPTS start run stop   适用所有JVM</p>

<pre><code>           CATALINA_OPTS   start run    专门配置tomcat    
</code></pre>

<p>tomcat默认-client ，production环境加-server</p>

<p>JVM参数文档：<a href="http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>

<h5>Tomcat executor</h5>

<p>据信使用executor后，能在实际中有更好的性能以及稳定性！更为重要的是能在多个connector之间共用。</p>

<pre><code>&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="1000" minSpareThreads="25"/&gt;

&lt;Connector executor="tomcatThreadPool"  port="8080" protocol="HTTP/1.1"   connectionTimeout="20000"  redirectPort="8443" /&gt;  
</code></pre>

<p>此时，connector再使用maxThreads等属性将被忽略。</p>

<h5>Tomcat Connector protocol</h5>

<ul>
<li><p>bio   默认模式，性能低下，无任何优化，阻塞IO模式</p>

<p>  protocol = &#8220;org.apache.coyote.http11.Http11Protocol&#8221; or HTTP/1.1(for http connector)
  protocol = &#8220;org.apache.jk.server.JkCoyoteHandler&#8221; or AJP/1.3(for ajp connector)</p></li>
<li><p>nio   Java的异步io技术，非阻塞 IO</p>

<p>  protocol = &#8220;org.apache.coyote.http11.Http11NioProtocol&#8221;(for http connector)
  protocol = &#8220;org.apache.coyote.ajp.AjpProtocol&#8221;(for ajp connector)</p></li>
<li><p>apr  需要安装apr(Apache Portable Runtime)和Native。</p>

<p>  protocol = &#8220;org.apache.coyote.http11.Http11AprProtocol&#8221;(for http connector)
  protocol = &#8220;org.apache.coyote.ajp.AjpAprProtocol&#8221;  (for ajp connector)</p></li>
</ul>


<p>参考文档：  <br/>
&lt;http://tomcat.apache.org/tomcat-6.0-doc/config/http.html#Connector Comparison></p>

<p><a href="http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html">http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html</a></p>

<h5>MySQL</h5>

<p>大并发下，响应时间如何提高，绝大部分瓶颈都处于数据库端。</p>

<p>与数据库的连接，使用JDBC连接池</p>

<p>slow query监控：   <br/>
1. 开启慢查询 my.cnf</p>

<pre><code>long_query_time = 2
log-slow-queries =  slow.log
</code></pre>

<p>2.使用mysqldumpslow分析log</p>

<pre><code>mysqldumpslow -t 10 -s t  slow.log
</code></pre>

<p>解决：</p>

<ul>
<li>1.SQL调优   （http://coolshell.cn/articles/1846.html）</li>
<li>2.走类似lucene索引，空间换时间（idea实际测试中，吞吐提升7倍）</li>
<li>3.使用NoSQL?</li>
</ul>


<p>$MYSQL_HOME/etc/my.cnf  或者 my.ini（windows）</p>

<p>主要影响性能参数：</p>

<pre><code>max-connections = 3000     会话数上限
max_connect_errors = 10000    允许的最大连接错误量
query_cache_size =128M    查询缓存
query_cache_limit = 2M   小于这么大的才缓存，保护查询缓存
sort_buffer_size =256M    排序order by 或 group by 使用
</code></pre>

<p>参考：<a href="http://www.ha97.com/4110.html">http://www.ha97.com/4110.html</a></p>

<h4>Apache</h4>

<p>处理静态资源，无法处理动态（需要应用服务器支持）</p>

<p>静态资源直接交给apache处理</p>

<p>ab 命令进行测试，达到1000并发很easy</p>

<pre><code>ab -k -c 1000  -n 1000000  http://hostname:port/path
</code></pre>

<p>参考：<a href="http://httpd.apache.org/docs/2.2/programs/ab.html">http://httpd.apache.org/docs/2.2/programs/ab.html</a></p>

<h5>开启MPM支持大并发</h5>

<table border="1px">
<thead>
<th>Mpm模式</th><th>并发方式</th><th>内存占用</th><th>并发性能</th>
</thead>
<tbody>
<tr>
<td>prefork</td><td>进程</td><td>高</td><td>低并发下，吞吐率高</td>
</tr>
<tr>
<td>worker</td><td>进程+线程</td><td>低</td><td>支持海量并发</td>
</tr>
</tbody>
</table>


<p>确定apache模式命令：</p>

<pre><code>./httpd –l
</code></pre>

<p>输出：</p>

<pre><code>Compiled in modules:
core.c
worker.c
http_core.c
mod_so.c
</code></pre>

<p>修改httpd-mpm.conf</p>

<pre><code>&lt;IfModule mpm_worker_module&gt;
    StartServers          2
    MaxClients          150
    MinSpareThreads      25
    MaxSpareThreads      75
    ThreadsPerChild      25
    MaxRequestsPerChild   0
&lt;/IfModule&gt;
</code></pre>

<p>上面的配置需要满足以下公式：</p>

<pre><code>     ThreadLimit &gt;= ThreadsPerChild    
     MaxClients &lt;= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数     
     MaxSpareThreads &gt;= MinSpareThreads+ThreadsPerChild    
</code></pre>

<h4>Linux</h4>

<h5>too many open files error</h5>

<p><code>ulimit -a</code>进行查看
修改<code>vi /etc/security/limits.conf</code></p>

<p>添加：</p>

<pre><code>*    -     nofile    65535
</code></pre>

<p>参考文档： <br/>
 <a href="http://blog.csdn.net/lifeibo/article/details/5972356">http://blog.csdn.net/lifeibo/article/details/5972356</a></p>

<p>Http连接是基于TCP的，这个时候需要对linux服务器进行优化。 <br/>
<strong>三次握手</strong></p>

<p><img src="http://www.shenyanchao.cn/images/blog/2013/three-times-handshake.png" alt="三次握手" /></p>

<p><strong>四次挥手</strong></p>

<p><img src="http://www.shenyanchao.cn/images/blog/2013/four-wave.png" alt="四次挥手" /></p>

<p>如何查看服务器TCP状态？  <br/>
命令：</p>

<pre><code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre>

<p>输出：</p>

<pre><code>ESTABLISHED 1423
FIN_WAIT1 1
FIN_WAIT2 262
SYN_SENT 1
TIME_WAIT 962
</code></pre>

<p>优化TCP连接相关参数：</p>

<p><code>vi /etc/sysctl.conf</code></p>

<pre><code>net.ipv4.tcp_fin_timeout = 30  保持在FIN-WAIT-2的时间。默认60秒。2.2内核是180秒
net.ipv4.tcp_keepalive_time = 1200     长连接keepalive打开，发送的频率。默认7200（2H）
net.ipv4.tcp_tw_reuse = 1     默认0，处于TIME-WAIT状态的socket可以用于新的TCP连接
net.ipv4.tcp_tw_recycle = 1   默认0，TIME-WAIT状态的sockets快速回收
net.ipv4.ip_local_port_range = 1024    65000 向外连接的端口范围，默认32768~61000
net.ipv4.tcp_max_syn_backlog = 8192  默认1024/128,未获得客户端连接请求并保存在队列中的最大数目。
net.ipv4.tcp_max_tw_buckets = 5000   默认180000，系统处理的最大TIME_WAIT数目。
net.ipv4.route.gc_timeout = 100  路由缓存刷新频率，失败多长时间跳到另一个。默认300.
net.ipv4.tcp_syncookies = 1 默认0，SYN队列溢出，启用cookies处理。
net.ipv4.tcp_syn_retries = 1       新建连接发送SYN次数，默认5，180秒
net.ipv4.tcp_synack_retries = 1    3次握手的第二步，重试几次。默认5.
</code></pre>

<p><code>/sbin/sysctl -p</code>   生效</p>

<p>参考文档：<a href="http://www.itlearner.com/article/4792">http://www.itlearner.com/article/4792</a></p>

<p>备注：此文由本人在公司内做的PPT分享制作而成，内容有些省略以及跳跃。欢迎留言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[提交代码到GitHub SSH错误解决方案]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/09/16/git-ssh-connection/"/>
    <updated>2013-09-16T18:08:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/09/16/git-ssh-connection</id>
    <content type="html"><![CDATA[<p>最近，由于公司内部的网络改造，在<code>git push</code>的时候提示如下信息：</p>

<pre><code>ssh: connect to host github.com port 22: Connection timed out
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
</code></pre>

<p>看字面的意思就是连接超时了，什么原因造成的呢，这个估计是公司网络禁用了SSH的22端口导致的。所幸git提供了https、git、ssh三种协议来读写。</p>

<p>运行<code>git config --local -e</code>打开配置信息。 <br/>
修改其中的</p>

<pre><code>url = git@github.com:username/repo.git
</code></pre>

<p>为</p>

<pre><code>url = https://username@github.com/username/repo.git
</code></pre>

<p>这样就改为使用https协议了。提交什么的就OK了。</p>

<p>后来，我再使用Octopress提交博客的时候问题又出现了。也就是在<code>rake deploy</code>的时候，又走ssh了。此时只要进入_deploy目录，把上述步骤再执行一次就好了。就是每次提交都要输入用户名密码而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sonar的安装与使用]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/09/04/use-sonar/"/>
    <updated>2013-09-04T17:02:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/09/04/use-sonar</id>
    <content type="html"><![CDATA[<h3>什么是Sonar？</h3>

<p><a href="http://www.sonarqube.org/">Sonar</a>是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。</p>

<p><img src="http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png" alt="" />
使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。</p>

<h3>安装Sonar</h3>

<p>1.下载sonar,地址<a href="http://www.sonarqube.org/downloads/">http://www.sonarqube.org/downloads/</a>。通常选取稳定版本下载即可，这是一个zip文件。 <br/>
2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME  <br/>
3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行<code>./sonar.sh console</code>即可。在windows下是StartSonar.bat。<br/>
4.现在进入<a href="http://localhost:9000">http://localhost:9000</a>,就看到了界面。默认的登录使用admin:admin</p>

<p>这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。</p>

<!--more-->


<h3>配置Sonar数据库</h3>

<p>1.首先新建一个数据库。</p>

<pre><code>CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  
grant all privileges on sonar.* to 'sonar'@'%' identified by '你的密码';  
flush privileges; 
</code></pre>

<p>这样就准备好了数据库sonar,并授权给sonar这个用户。</p>

<p>2.找到$SONAR_HOME/conf/sonar.properties。
注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。</p>

<pre><code># Comment the following line to deactivate the default embedded database.
#sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar
#sonar.jdbc.driverClassName:                org.h2.Driver

-------------------
# The schema must be created first.
</code></pre>

<p>sonar.jdbc.username:                       sonar
sonar.jdbc.password:                       sonar</p>

<pre><code>#----- MySQL 5.x
# Comment the embedded database and uncomment the following line to use MySQL
sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true

# Optional properties
sonar.jdbc.driverClassName:                com.mysql.jdbc.Driver
</code></pre>

<p>配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。</p>

<h3>把Sonar变为中文</h3>

<p>英文看这不方便啊。有2种方法可以将Sonar变为中文界面。</p>

<p>1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。<br/>
2.直接下载<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar">http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar</a>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。</p>

<h3>把Sonar放到JEE容器内</h3>

<p>默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。 <br/>
Sonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。</p>

<h3>如何对源码进行检测</h3>

<p>1.配置maven的settings.xml,添加一下内容：</p>

<pre><code>    &lt;profile&gt;
         &lt;id&gt;sonar&lt;/id&gt;
         &lt;activation&gt;
             &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
         &lt;/activation&gt;
         &lt;properties&gt;
              &lt;sonar.jdbc.url&gt;
              jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8
              &lt;/sonar.jdbc.url&gt;
              &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt;
              &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt;
              &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt;
             &lt;sonar.host.url&gt;http://localhost:9000/sonar&lt;/sonar.host.url&gt;
         &lt;/properties&gt;
      &lt;/profile&gt;
</code></pre>

<p>其中的数据库配置以及sonar主机地址都依据实际进行修改即可。 <br/>
2.在maven项目种执行</p>

<pre><code>mvn clean install
mvn sonar:sonar
</code></pre>

<p>3.打开sonar主页，就可以看到结果了。</p>

<h3>Sonar与Jenkins的集成。</h3>

<p>1.安装<a href="http://docs.codehaus.org/display/SONAR/Jenkins+Plugin">jenkins-sonar-plugin</a>到Jenkins内。  <br/>
2.在Jenkins里的系统配置中，填写Sonar安装信息。  <br/>
3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《重构与模式》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes/"/>
    <updated>2013-06-28T13:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes</id>
    <content type="html"><![CDATA[<p>GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。</p>

<h3>写作缘由</h3>

<ul>
<li>过度设计：代码存在设计过度的情况</li>
<li>模式万灵丹：认为设计模式的万能的</li>
<li>设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”</li>
<li>测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”</li>
<li>重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构</li>
<li>演进式设计：将模式放到重构的背景中进行领会</li>
</ul>


<h3>什么是重构</h3>

<p>定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。 <br/>
重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。</p>

<p>重构的动机：</p>

<ul>
<li>使新代码的增加更容易</li>
<li>改善既有代码的设计</li>
<li>对代码理解更透彻</li>
<li>提高编程的趣味性</li>
</ul>


<!--more-->


<h3>什么是模式</h3>

<p>GoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。 <br/>
应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。</p>

<h3>代码坏味</h3>

<ul>
<li><p>1.重复代码（Duplicated Code）</p>

<blockquote><p>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；</p></blockquote></li>
<li><p>2.过长函数（Long Method）：</p>

<blockquote><p>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；</p></blockquote></li>
<li><p>3.条件逻辑太复杂（Conditional Complexity）：</p>

<blockquote><p>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;</p></blockquote></li>
<li><p>4.基本类型偏执（Primitive Obsession）:</p>

<blockquote><p>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。</p></blockquote></li>
<li><p>5.不恰当的暴露（Indecent Exposure）：</p>

<blockquote><p>用Factory封装类；</p></blockquote></li>
<li><p>6.解决方案蔓延（Solution Sprawl）：</p>

<blockquote><p>将创建知识搬移到Factory；</p></blockquote></li>
<li><p>7.异曲同工的类（Alternative Classes With Different Interfaces）：</p>

<blockquote><p>通过Adapter统一接口；</p></blockquote></li>
<li><p>8.冗赘类（Lazy Class）：</p>

<blockquote><p>内联Singeton；</p></blockquote></li>
<li>9.过大的类（Large Class）：

<blockquote><p>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；</p></blockquote></li>
<li>10.分支语句（Switch Statement）：

<blockquote><p>用Command替换条件调度程序；将聚集操作搬移到Visitor；</p></blockquote></li>
<li>11.组合爆炸（Combinatorial Explosion）：

<blockquote><p>用Interpreter替换隐式语言；</p></blockquote></li>
<li>12.怪异解决方案（Oddball Solution）：

<blockquote><p>通过Adapter统一接口；</p></blockquote></li>
</ul>


<h3>创建</h3>

<h4>用Creation Method替换构造函数</h4>

<p>如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。 <br/>
优缺点：<br/>
+比构造函数能够更好的表达所创建的实例的种类。 <br/>
+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。 <br/>
+更容易发现无用的创建代码。 <br/>
-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。</p>

<h4>将创建知识搬移到Factory</h4>

<p>当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。  <br/>
优缺点： <br/>
+合并创建逻辑和实例化/配置选项。 <br/>
+将客户代码与创建逻辑解耦。  <br/>
-如果可以直接实例化，会使设计复杂化。</p>

<h4>用Factory封装类</h4>

<p>如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。 <br/>
优缺点： <br/>
+通过意图导向的CreationMethod简化了不同种类实例的创建。  <br/>
+通过隐藏不需要公开的类减少了包结构的“概念重量”  <br/>
+帮助严格执行“面向接口编程，而不是面向实现”这一格言。  <br/>
-当需要创建新种类的实例时，必须新建/更新Creation Method。<br/>
-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。</p>

<h4>用Factory Method引入多态创建</h4>

<p>一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。 <br/>
优缺点： <br/>
+减少因创建自定义对象而产生的重复代码  <br/>
+有效的表达了对象创建发生的位置，以及如何重写对象的创建。 <br/>
+强制Factory Method使用的类必须实现统一的类型。 <br/>
-可能会向Factory Method的一些实现者传递不必要的参数。</p>

<h4>用Builder封装Composite</h4>

<p>构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。 <br/>
优缺点： <br/>
+简化了构造Composite的客户代码。 <br/>
+减少了创建Composite的重复和易出错的本性。<br/>
+在客户代码和Composite之间实现了松耦合。 <br/>
-接口可能不会很清楚的表达其意图。</p>

<h4>内联Singleton</h4>

<p>绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。 <br/>
优缺点： <br/>
+使对象的协作变得更明显和明确。 <br/>
+保护了单一的实例，且不要要特殊的代码。 <br/>
-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。</p>

<h3>简化</h3>

<h4>组合方法</h4>

<p>一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。 <br/>
优缺点：  <br/>
+清晰的描述了一个方法所实现的功能以及如何实现。 <br/>
+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。 <br/>
-可能会产生过多的小方法。 <br/>
-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。</p>

<h4>用Strategy替换条件逻辑</h4>

<p>当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。  <br/>
优缺点： <br/>
+通过减少或去除条件逻辑使算法变得清晰易懂。 <br/>
+通过把算法的变体搬移到类层次中简化了类。 <br/>
+允许在运行时用一种算法替换另一种算法。 <br/>
-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。 <br/>
-增加了算法如何获取或接受上下文类的数据的复杂度。</p>

<h4>将装饰功能搬移到Decorator</h4>

<p>如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。 <br/>
优缺点： <br/>
+把装饰功能从类中搬移去除，从而简化了类。 <br/>
+有效地把类的核心职责和装饰功能区分开来。 <br/>
+可以去除几个相关类中重复的装饰逻辑。 <br/>
-改变了被装饰对象的对象类型。 <br/>
-会使代码变得更难理解和调适。 <br/>
-当Decorator组合产生负面影响的时候，会增加设计的复杂度。</p>

<h4>用State替换状态改变条件语句</h4>

<p>如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。 <br/>
优缺点： <br/>
+减少或去除状态改变条件逻辑。<br/>
+简化了复杂的状态改变逻辑。 <br/>
+提供了观察状态改变逻辑的很好的鸟瞰图。<br/>
-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。</p>

<h4>用Composite替换隐含树</h4>

<p>有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。 <br/>
优缺点： <br/>
+封装重复的指令，如格式化、添加或删除结点。 <br/>
+提供了处理相似逻辑增长的一般性方法。 <br/>
+简化了客户代码的构造职责。  <br/>
-当构造隐式树更简单的时候，会增加设计的复杂度。</p>

<h4>用Command替换条件调度程序</h4>

<p>许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。  <br/>
优缺点： <br/>
+提供了用统一方法执行不同行为的简单机制。 <br/>
+允许在运行时改变所处理的请求，以及如何处理请求。 <br/>
+仅仅需要很少的代码实现。 <br/>
-当条件调度程序已经足够的时候，会增加设计的复杂度。</p>

<h3>泛化</h3>

<h4>形成Template Method</h4>

<p>借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。  <br/>
优点与缺点： <br/>
+通过把不变行为搬移到超类，去除子类中的重复代码  <br/>
+简化并有效地表达了一个通用算法的步骤。 <br/>
+允许子类很容易的定制一个算法  <br/>
-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。</p>

<h4>提取Composite</h4>

<p>在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。  <br/>
优缺点： <br/>
+去除重复的类存储逻辑和类处理逻辑。  <br/>
+能够有效的表达类处理逻辑的可继承性。</p>

<h4>用Composite替换一/多之分</h4>

<p>这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题： <br/>
如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。  <br/>
使用Composite扩展出And，Or等条件，简化客户端的处理。  <br/>
优缺点： <br/>
+去除与处理一个或多个对象相关联的重复代码。 <br/>
+提供了处理一个或多个对象的同一方法。 <br/>
+支持处理多个对象的更丰富的方法。（如OR表达式） <br/>
-可能会在Composite的构造过程中要求类型安全的运行时检查。</p>

<h4>用Observer替换硬编码的通知</h4>

<p>拒绝使用硬编码的通知，考虑使用Observer模式。 <br/>
优缺点： <br/>
+使主题及其观察者访问松散耦合 <br/>
+支持一个或多个观察者  <br/>
-当硬编码的通知已经足够的时候，会增加设计复杂度  <br/>
-当出现串联通知的时候，会增加代码的复杂度      <br/>
-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。</p>

<h4>通过Adapter统一接口</h4>

<p>全部满足以下条件，考虑使用Adapter:</p>

<ul>
<li>2个类所做的事情相同或者相似，但是具有不同的接口。</li>
<li>如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。</li>
<li>无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。</li>
</ul>


<p>比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。 <br/>
优缺点： <br/>
+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。 <br/>
+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。  <br/>
+统一了客户代码与不同的类的交互方式。  <br/>
-当类的接口可以改变的时候，会增加设计的复杂度。</p>

<h4>提取Adapter</h4>

<p>当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。  <br/>
优缺点：<br/>
+隔离了不同版本的组件，类库或API之间的不同之处。 <br/>
+使类只负责适配代码的一个版本。  <br/>
+避免频繁地修改代码   <br/>
-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。</p>

<h4>用Interpreter替换隐式语言</h4>

<p>在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。  <br/>
优缺点： <br/>
+比隐式语言更好的支持语言元素的组合。 <br/>
+不需要新的代码来支持语言元素的新组合。<br/>
+允许行为的运行时配置。
-会产生定义语法和修改客户代码的开销。 <br/>
-如果语言很复杂，则需要很多的编程工作。 <br/>
-如果语言本身就很简单，则会增加设计的复杂度。</p>

<h3>保护</h3>

<h4>用类替换类型代码</h4>

<p>字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。  <br/>
优缺点：  <br/>
+更好的避免非法赋值和比较。  <br/>
-比使用不安全类型要求更多的代码。</p>

<h4>用Singleton限制实例化</h4>

<p>有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。 <br/>
优缺点：  <br/>
+改进性能。  <br/>
-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。 <br/>
-当对象含有不能共享的状态的时候，本重构就无效了。</p>

<h4>引入Null Object</h4>

<p>代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。  <br/>
优缺点：   <br/>
+不需要重复的null逻辑就可以避免null错误。 <br/>
+通过最小化null测试简化了代码。  <br/>
-当系统不太需要null测试的时候，会增加设计的复杂度。 <br/>
-如果程序员不知道Null Object的存在，就会产生多余的null测试。 <br/>
-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。</p>

<h3>聚集操作</h3>

<h4>将聚集操作搬移到Collecting Parameter</h4>

<p>有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。  <br/>
优缺点：   <br/>
+帮助我们把很大的方法转换成更小的，更简单的多个方法。  <br/>
-使结果代码运行得更快。</p>

<h4>将聚集操作搬移到Visitor</h4>

<p>如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。   <br/>
优缺点：  <br/>
+调节多个算法，使其适用于不同的对象结构。 <br/>
+访问相同或不同继承结构中的类。 <br/>
+调用不同类上的类型特定方法，无需类型转换。  <br/>
-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。  <br/>
-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。  <br/>
-可能会破坏被访问类的封装性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DbUnit使用入门]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit/"/>
    <updated>2013-06-27T15:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit</id>
    <content type="html"><![CDATA[<p><a href="http://www.dbunit.org/">DbUnit</a>是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。</p>

<h3>DbUnit原理</h3>

<p>DbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。 <br/>
DbUnit包括三个核心部分:</p>

<ul>
<li>IDatabaseConnection ：描述DbUnit数据库连接接口；</li>
<li>IDataSet：数据集操作接口；</li>
<li>DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；</li>
</ul>


<!--more-->


<p>值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。</p>

<p>DatabaseOperation有以下的可选项：</p>

<ul>
<li>NONE：不执行任何操作，是getTearDownOperation的默认返回值。</li>
<li>UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。</li>
<li>INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。</li>
<li>REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。</li>
<li>DELETE：删除数据库中与数据集对应的记录。</li>
<li>DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。</li>
<li>TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。</li>
<li>CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。</li>
</ul>


<h3>开始使用DbUnit</h3>

<h4>DataSet数据集准备</h4>

<p>DataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以<a href="http://www.dbunit.org/components.html#FlatXmlDataSet">手工编写</a>。另外也可以从数据库读取，DbUnit提供了相关的API：</p>

<pre><code>    QueryDataSet dataSet = new QueryDataSet(getConnection());
    dataSet.addTable("user", "select * from user ");
    FlatXmlDataSet.write(dataSet, new FileOutputStream("data.xml"));
</code></pre>

<h4>继承DBTestCase来实现测试用例</h4>

<p>最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：</p>

<ul>
<li>JdbcBasedDBTestCase</li>
<li>DataSourceBasedDBTestCase</li>
<li>JndiBasedDBTestCase</li>
</ul>


<p>下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。</p>

<pre><code>public class SampleTest extends DBTestCase
{
    public SampleTest(String name)
    {
        super( name );
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, "org.h2.Driver");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, "jdbc:h2:~/dbunitdemo");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, "sa");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, "");

    protected IDataSet getDataSet() throws Exception
    {
        return new FlatXmlDataSetBuilder().build(new FileInputStream("dataset.xml"));
    }
}
</code></pre>

<p>那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。</p>

<pre><code>protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {
    return new JdbcDatabaseTester("org.h2.Driver", "jdbc:h2:~/dbunitdemo", "sa", "");
}
</code></pre>

<h4>定制测试执行前后的操作</h4>

<p>默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。</p>

<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception
{
    return DatabaseOperation.REFRESH;
}

protected DatabaseOperation getTearDownOperation() throws Exception
{
    return DatabaseOperation.NONE;
}
</code></pre>

<h4>DatabaseConfig设置</h4>

<p>有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。</p>

<pre><code>protected void setUpDatabaseConfig(DatabaseConfig config) {
        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));
        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);
}
</code></pre>

<p>比如，我在使用H2Database时，老是报一个这样的warn:</p>

<pre><code>WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory 'class org.dbunit.dataset.datatype.DefaultDataTypeFactory' might cause problems with the current database 'H2' (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.
</code></pre>

<p>那么，如何让这个WARN消失呢？加上这个配置：</p>

<pre><code>config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());
</code></pre>

<h4>Database数据验证</h4>

<p>DbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。</p>

<pre><code>public class Assertion
{
    public static void assertEquals(ITable expected, ITable actual)
    public static void assertEquals(IDataSet expected, IDataSet actual)
}
</code></pre>

<p>下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。</p>

<pre><code>    // Fetch database data after executing your code
    IDataSet databaseDataSet = getConnection().createDataSet();
    ITable actualTable = databaseDataSet.getTable("TABLE_NAME");

    // Load expected data from an XML dataset
    IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File("expectedDataSet.xml"));
    ITable expectedTable = expectedDataSet.getTable("TABLE_NAME");

    // Assert actual database table match expected table
    Assertion.assertEquals(expectedTable, actualTable);
</code></pre>

<h3>DbUnit的运行步骤</h3>

<p>由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：</p>

<pre><code>protected void setUp() throws Exception
{
    logger.debug("setUp() - start");

    super.setUp();
    final IDatabaseTester databaseTester = getDatabaseTester();
    assertNotNull( "DatabaseTester is not set", databaseTester );
    databaseTester.setSetUpOperation( getSetUpOperation() );
    databaseTester.setDataSet( getDataSet() );
    databaseTester.setOperationListener(getOperationListener());
    databaseTester.onSetup();
}

protected void tearDown() throws Exception
{
    logger.debug("tearDown() - start");

    try {
        final IDatabaseTester databaseTester = getDatabaseTester();
        assertNotNull( "DatabaseTester is not set", databaseTester );
        databaseTester.setTearDownOperation( getTearDownOperation() );
        databaseTester.setDataSet( getDataSet() );
        databaseTester.setOperationListener(getOperationListener());
        databaseTester.onTearDown();
    } finally {
        tester = null;
        super.tearDown();
    }
}
</code></pre>

<p>这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。</p>

<p>总结：</p>

<ul>
<li>1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。</li>
<li>2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。</li>
<li>3.运行测试。</li>
<li>4.测试运行完毕后，不执行任何操作。</li>
</ul>


<h3>使用什么数据库？</h3>

<p>由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。  <br/>
这里推荐一个数据库<a href="http://www.h2database.com/html/main.html">H2Database</a>，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：</p>

<table style="width: 470px;" border="1"><tr>
<th></th>
<th>H2</th>
<th><a href="http://db.apache.org/derby">Derby</a></th>
<th><a href="http://hsqldb.org">HSQLDB</a></th>
<th><a href="http://mysql.com">MySQL</a></th>
<th><a href="http://www.postgresql.org">PostgreSQL</a></th>
</tr><tr>
<td>Pure Java</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Memory Mode</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Encrypted Database</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>ODBC Driver</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Fulltext Search</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Multi Version Concurrency</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Footprint (jar/dll size)</td>
<td>~1 MB</td>
<td>~2 MB</td>
<td>~1 MB</td>
<td>~4 MB</td>
<td>~6 MB</td>
</tr>
</table>


<p>之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。  <br/>
有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个<a href="http://mojo.codehaus.org/sql-maven-plugin/">sql-maven-plugin</a>。它可以方便的执行数据库SQL脚本来创建数据库。</p>

<pre><code>            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;sql-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.5&lt;/version&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
                        &lt;artifactId&gt;h2&lt;/artifactId&gt;
                        &lt;version&gt;1.3.172&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;configuration&gt;
                    &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
                    &lt;url&gt;jdbc:h2:~/dbunitdemo&lt;/url&gt;
                    &lt;username&gt;sa&lt;/username&gt;
                    &lt;password&gt;&lt;/password&gt;
                    &lt;srcFiles&gt;
                        &lt;srcFile&gt;${project.basedir}/src/main/sql/dbunitdemo.sql&lt;/srcFile&gt;
                    &lt;/srcFiles&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;create-db&lt;/id&gt;
                        &lt;phase&gt;process-test-resources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;execute&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>

<p>这里，创建了一个H2Database。直接执行<code>mvn sql:execute</code>用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行<code>mvn test</code>就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief/"/>
    <updated>2013-06-21T21:29:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief</id>
    <content type="html"><![CDATA[<p>Mockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。</p>

<p>项目地址:<a href="https://code.google.com/p/mockito/">https://code.google.com/p/mockito/</a></p>

<h2>powermock 简介</h2>

<p>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。</p>

<p>项目地址:<a href="https://code.google.com/p/powermock/">https://code.google.com/p/powermock/</a></p>

<!--more-->


<h2>Mock 和Stub</h2>

<h3>Mock</h3>

<p>所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。</p>

<h3>Stub</h3>

<p>Stub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。</p>

<h3>Stub 与 Mock 的区别</h3>

<p>Stub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。</p>

<h2>Mockito 的使用</h2>

<h3>Maven</h3>

<p>通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mockito&lt;/groupId&gt;
&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
&lt;version&gt;1.9.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>在程序中可以<code>import org.mockito.Mockito</code>，然后调用它的static方法。</p>

<h3>Maven 程序</h3>

<h4>1.模拟对象</h4>

<p>创建 Mock 对象的语法为 mock(class or interface)。</p>

<h4>2.设置对象调用的预期返回值</h4>

<p>通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。</p>

<h4>3.验证被测试类方法</h4>

<p>Mock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。</p>

<h3>Demo</h3>

<h2>Mock 对象的创建</h2>

<pre><code>mock(Class&lt;T&gt; classToMock);
mock(Class&lt;T&gt; classToMock, String name)
mock(Class&lt;T&gt; classToMock, Answer defaultAnswer)
mock(Class&lt;T&gt; classToMock, MockSettings mockSettings)
mock(Class&lt;T&gt; classToMock, ReturnValues returnValues)
</code></pre>

<p>可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。</p>

<h2>Mock对象的期望行为和返回值设定</h2>

<p>假设我们创建了LinkedList类的mock对象：</p>

<pre><code>LinkedList mockedList = mock(LinkedList.class);
</code></pre>

<h3>对方法进行设定返回值和异常</h3>

<h4>对包含返回值的方法的设定</h4>

<pre><code>when(mockedList.get(0)).thenReturn("first");
when(mockedList.get(1)).thenThrow(new RuntimeException());   
</code></pre>

<p>Mockito支持迭代风格的返回值设定</p>

<pre><code>when(mockedList.get(anyInt()).thenReturn("first").thenThrow(new RuntimeException());
when(mockedList.get(anyInt()).thenReturn("first","second");
</code></pre>

<p>Stubbing的另一种风格</p>

<pre><code>doReturn("Hello").when(mockedList).get(0);
doReturn("Hello").doReturn("world").when(mockedList).get(anyInt());
</code></pre>

<p>抛出异常</p>

<pre><code>doThrow(new RuntimeException()).when(mockedList).get(0);
</code></pre>

<h4>对void方法进行方法预期设定</h4>

<pre><code>doNothing().when(mockedClass).SomeVoidMethod();
doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<p>迭代风格</p>

<pre><code>doNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<h2>参数匹配器</h2>

<p>在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。</p>

<pre><code>//stubbing using anyInt() argument matcher
when(mockedList.get(anyInt())).thenReturn("element");

//following prints "element"
System.out.println(mockedList.get(999));

//you can also verify using argument matcher
verify(mockedList).get(anyInt());   
</code></pre>

<p>需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(&#8220;third argument&#8221;)，直接修改为“third argument”会报错。</p>

<pre><code>verify(mockedClass).someMethod(anyObject(), anyString(), eq("third argument"));
</code></pre>

<h2>Mock对象行为的验证</h2>

<p>Mock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。</p>

<h3>调用次数验证</h3>

<pre><code>public static &lt;T&gt; T verify(T mock).someMethod()
public static &lt;T&gt; T verify(T mock, VerificationMode mode).someMethod()

Parameters:
    mock - to be verified
    mode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() 
Returns:
    mock object itself
</code></pre>

<h3>调用顺序验证</h3>

<pre><code>public static InOrder inOrder(java.lang.Object... mocks)
</code></pre>

<p>创建mock对象</p>

<pre><code>// Multiple mocks that must be used in a particular order
List firstMock = mock(List.class);
List secondMock = mock(List.class);
</code></pre>

<p>调用mock对象的方法</p>

<pre><code>//using mocks
firstMock.add("was called first");
secondMock.add("was called second");
</code></pre>

<p>创建InOrder对象</p>

<pre><code>//create inOrder object passing any mocks that need to be verified in order
InOrder inOrder = inOrder(firstMock, secondMock);
</code></pre>

<p>验证方法调用</p>

<pre><code>//following will make sure that firstMock was called before secondMock
inOrder.verify(firstMock).add("was called first");
inOrder.verify(secondMock).add("was called second");
</code></pre>

<h2><code>RETURN_SMART_NULLS和RETURN_DEEP_STUBS</code></h2>

<p><code>RETURN_SMART_NULLS</code> 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， <code>mock(class,answer)</code>。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空&#8221;&#8220;, int 会返回 0,List 会返回 null。</p>

<p>mock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。</p>

<h2>注解</h2>

<p>Mockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks</p>

<h3>Annotation 的初始化</h3>

<p>初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。</p>

<pre><code>public class ArticleManagerTest {

    @Mock private ArticleCalculator calculator;
    @Mock private ArticleDatabase database;
    @Mock private UserProvider userProvider;

    @Before public void setup() {
        MockitoAnnotations.initMocks(testClass);
    }
}
</code></pre>

<p>使用Mockito提供的Junit Runner可以省略上述步骤。</p>

<pre><code>@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {
    @Mock private List list;

    @Test public void shouldDoSomething() {
        list.add(100);
    }
}
</code></pre>

<h2>powermock 的使用</h2>

<h3>Maven配置</h3>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h2>PowerMock 在单元测试中的应用</h2>

<h3>模拟 Static 方法</h3>

<p>在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：</p>

<pre><code>@RunWith(PowerMockRunner.class)   
</code></pre>

<p>然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：</p>

<pre><code>@PrepareForTest( { YourClassWithEgStaticMethod.class })   
</code></pre>

<p>然后就可以开始写测试代码：</p>

<pre><code>1，首先，需要有一个含有 static 方法的代码 , 如
public class IdGenerator { 
    ... 
    public static long generateNewId() { 
        ... 
    } 
    ... 
 } 
2，然后，在被测代码中，引用了以上方法
public class ClassUnderTest { 
    ... 
    public void methodToTest() { 
    .. 
    final long id = IdGenerator.generateNewId(); 
    .. 
    } 
    ... 
} 

3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值
来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：

 @RunWith(PowerMockRunner.class) 
 @PrepareForTest(IdGenerator.class) 
 public class MyTestClass { 
    @Test 
    public void demoStaticMethodMocking() throws Exception { 
        PowerMockito.mockStatic(IdGenerator.class);  
        when(IdGenerator.generateNewId()).thenReturn(2L); 

        new ClassUnderTest().methodToTest(); 

        verifyStatic(); 
        IdGenerator.generateNewId(); 
    } 
 }
</code></pre>

<h3>模拟构造函数</h3>

<p>有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：</p>

<pre><code>public class DirectoryStructure { 
    public boolean create(String directoryPath) { 
        File directory = new File(directoryPath); 

        if (directory.exists()) { 
            throw new IllegalArgumentException(
            "\"" + directoryPath + "\" already exists."); 
        } 

        return directory.mkdirs(); 
    } 
 }    
</code></pre>

<p>为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(DirectoryStructure.class) 
 public class DirectoryStructureTest { 
    @Test 
    public void createDirectoryStructureWhenPathDoesntExist() 
    throws Exception { 
        final String directoryPath = "mocked path"; 

        File directoryMock = mock(File.class); 

        //File的初始化函数的mock
        whenNew(File.class).withArguments(directoryPath)
            .thenReturn(directoryMock); 

        // Standard expectations 
        when(directoryMock.exists()).thenReturn(false); 
        when(directoryMock.mkdirs()).thenReturn(true); 

        assertTrue(new NewFileExample()
            .createDirectoryStructure(directoryPath)); 

        // Optionally verify that a new File was "created". 
        verifyNew(File.class).withArguments(directoryPath); 
    } 
 } 
</code></pre>

<p>使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。</p>

<h3>模拟私有以及 Final 方法</h3>

<p>为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。</p>

<p>在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。</p>

<p>局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。</p>

<p>这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。
参考如下所示的被测代码：</p>

<pre><code> public final class PrivatePartialMockingExample { 
    public String methodToTest() { 
        return methodToMock("input"); 
    } 

    private String methodToMock(String input) { 
        return "REAL VALUE = " + input; 
    } 
 } 
</code></pre>

<p>为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(PrivatePartialMockingExample.class) 
 public class PrivatePartialMockingExampleTest { 
    @Test 
    public void demoPrivateMethodMocking() throws Exception { 
        final String expected = "TEST VALUE"; 
        final String nameOfMethodToMock = "methodToMock"; 
        final String input = "input"; 

        PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); 

        /* 
         * Setup the expectation to the private method using the method name 
         */ 
        when(underTest, nameOfMethodToMock, input).thenReturn(expected); 

        assertEquals(expected, underTest.methodToTest()); 

        // Optionally verify that the private method was actually called 
        verifyPrivate(underTest).invoke(nameOfMethodToMock, input); 
    } 
 } 
</code></pre>

<p>可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。</p>

<p>参考文献:<a href="http://www.ibm.com/developerworks/cn/java/j-lo-powermock/">http://www.ibm.com/developerworks/cn/java/j-lo-powermock/</a></p>

<hr />

<p>Thanks to：lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Github发布jar包到Maven Central]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/19/publishing-from-github-to-maven-central/"/>
    <updated>2013-06-19T19:50:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/19/publishing-from-github-to-maven-central</id>
    <content type="html"><![CDATA[<p>除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。</p>

<p>下面介绍下如何做：</p>

<h3>准备工作</h3>

<p>1.添加source code management信息到pom.xml:</p>

<pre><code>&lt;scm&gt;
    &lt;connection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/connection&gt;
    &lt;developerConnection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/developerConnection&gt;
    &lt;url&gt;git@github.com:blueshen/ut-maven-plugin.git&lt;/url&gt;
&lt;/scm&gt;
</code></pre>

<p>2.创建GPG的密钥对并发布公钥。参看<a href="https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven">Sonatype documentation</a>的具体步骤.推荐使用Linux,Mac来发布。</p>

<blockquote><p><code>gpg --gen-key</code> 创建key  <br/>
<code>gpg --list-keys</code> 查看所有的key <br/>
<code>gpg --send-keys --keyserver pool.sks-keyservers.net yourkey</code>   发布你的key到服务器上</p></blockquote>

<p>3.确保你的工程POM符合<a href="https://docs.sonatype.org/display/Repository/Central+Sync+Requirements">要求</a><br/>
4.创建一个<a href="https://issues.sonatype.org/">Sonatype JIRA</a>账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。</p>

<!--more-->


<h3>使用Maven来发布到Sonatype Nexus repository</h3>

<h4>pom.xml配置有2种方法：</h4>

<p>1.添加maven-release-plugin到pom.xml:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;configuration&gt;
        &lt;arguments&gt;-Dgpg.passphrase=${gpg.passphrase}&lt;/arguments&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>添加Sonatype repositories:</p>

<pre><code>&lt;distributionManagement&gt;
    &lt;snapshotRepository&gt;
        &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;
        &lt;name&gt;Sonatype Nexus snapshot repository&lt;/name&gt;
        &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;
    &lt;/snapshotRepository&gt;
    &lt;repository&gt;
        &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;
        &lt;name&gt;Sonatype Nexus release repository&lt;/name&gt;
        &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/distributionManagement&gt;
</code></pre>

<p>设置artifact signing:</p>

<pre><code>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;release-sign-artifacts&lt;/id&gt;
        &lt;activation&gt;
            &lt;property&gt;
                &lt;name&gt;performRelease&lt;/name&gt;
                &lt;value&gt;true&lt;/value&gt;
            &lt;/property&gt;
        &lt;/activation&gt;
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
                    &lt;version&gt;1.4&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;passphrase&gt;${gpg.passphrase}&lt;/passphrase&gt;
                    &lt;/configuration&gt;
                    &lt;executions&gt;
                        &lt;execution&gt;
                            &lt;id&gt;sign-artifacts&lt;/id&gt;
                            &lt;phase&gt;verify&lt;/phase&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;sign&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre>

<p>2.直接添加sonatype parent到POM.XML（推荐）</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.sonatype.oss&lt;/groupId&gt;
    &lt;artifactId&gt;oss-parent&lt;/artifactId&gt;
    &lt;version&gt;7&lt;/version&gt;
&lt;/parent&gt;
</code></pre>

<h4>maven settings.xml配置</h4>

<p>编辑或者创建~/.m2/settings.xml并包含验证信息:</p>

<pre><code>&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                      http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;
            &lt;username&gt;myusername&lt;/username&gt;
            &lt;password&gt;mypassword&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;
            &lt;username&gt;myusername&lt;/username&gt;
            &lt;password&gt;mypassword&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;

    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;id&gt;sign&lt;/id&gt;
            &lt;activation&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;/activation&gt;
            &lt;properties&gt;
                &lt;gpg.passphrase&gt;mypassphrase&lt;/gpg.passphrase&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
&lt;/settings&gt;
</code></pre>

<p>Maven有一个<a href="http://maven.apache.org/guides/mini/guide-encryption.html">避免使用明文的方法</a>,但我还没试用过。</p>

<h3>准备一个release版本</h3>

<p>为了准备一个release版本, 执行:</p>

<pre><code>$ mvn release:clean    
$ mvn release:prepare
</code></pre>

<p><a href="http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html">参考这个</a>.这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.</p>

<p>如果你要撤销release,可以使用<code>git reset --hard HEAD~2</code>进行<a href="http://stackoverflow.com/a/6866485/150884">回退</a>,使用<code>git tag -d ut-maven-plugin-0.1</code><a href="http://nathanhoad.net/how-to-delete-a-remote-git-tag">删除Tag</a>,然后使用<code>git push origin :refs/tags/ut-maven-plugin-0.1</code>提交.</p>

<h3>发布到Sonatype</h3>

<p>1.如果一切OK，你就可以使用<a href="http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html">mvn release:perform</a>来发布工程到Sonatype。<br/>
2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。 <br/>
3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些<a href="https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt">很好的指引</a>. 你可以使用<a href="http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html">Maven repository management plugin</a>来自动化这些步骤,尽管我自己还没有试过。   <br/>
4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。</p>

<p>参考文档<a href="http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html">http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Eclipse AST来解析Java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/19/use-eclipse-ast-to-parser-java/"/>
    <updated>2013-06-19T14:46:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/19/use-eclipse-ast-to-parser-java</id>
    <content type="html"><![CDATA[<p>Eclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。
另外，Eclipse有一个<a href="http://www.eclipse.org/jdt/ui/astview/">AST View</a>插件，使用这个能更加的清楚的看到解析后的效果。</p>

<p><img src="http://www.shenyanchao.cn/images/blog/eclipse-ast-view.png" alt="Eclipse AST View" /></p>

<!--more-->


<h4>依赖的jar包</h4>

<ul>
<li>org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar</li>
<li>org.eclipse.core.jobs_3.5.101.v20120113-1953.jar</li>
<li>org.eclipse.core.resources_3.7.101.v20120125-1505.jar</li>
<li>org.eclipse.core.runtime_3.7.0.v20110110.jar</li>
<li>org.eclipse.equinox.common_3.6.0.v20110523.jar</li>
<li>org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar</li>
<li>org.eclipse.jdt.core_3.7.3.v20120119-1537.jar</li>
<li>org.eclipse.osgi_3.7.2.v20120110-1415.jar</li>
</ul>


<p>这些包都可以在eclipse的plugin目录找到。可能版本有所区别。 <br/>
如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。</p>

<pre><code>          &lt;dependency&gt;
                &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;
                &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;
                &lt;version&gt;3.8.0.v_C03&lt;/version&gt;
            &lt;/dependency&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;
                 &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;
                 &lt;version&gt;3.6.0.v20100505&lt;/version&gt;
             &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;
                &lt;artifactId&gt;org.eclipse.core.resources&lt;/artifactId&gt;
                &lt;version&gt;3.6.0.v20100526-0737&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>

<h4>如何解析Java</h4>

<pre><code>package cn.shenyanchao.ast;

import org.apache.commons.io.FileUtils;
import org.eclipse.jdt.core.dom.*;

import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 *
 * @author shenyanchao
 *         Date:  6/13/13
 *         Time:  11:52 AM
 */
public class AstAnalyzer {
    public static void main(String[] args) throws IOException {

        String javaSource = FileUtils.readFileToString(new File("/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java"));

        ASTParser parser = ASTParser.newParser(AST.JLS3);
        parser.setSource(javaSource.toCharArray());

        // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)
        CompilationUnit result = (CompilationUnit) parser.createAST(null);

        result.imports();
        result.getPackage();
        result.getCommentList();
        System.out.println(result.getCommentList().toString());

        TypeDeclaration type = (TypeDeclaration) result.types().get(0);
        System.out.println("---------Type---------");
        System.out.println(type.toString());

        MethodDeclaration method = type.getMethods()[0];
        method.parameters();
        method.isConstructor();

        System.out.println("---------Method---------");
        System.out.println(method.toString());
        method.getName();
        method.getModifiers();
        Type returnType = method.getReturnType2();
        System.out.println("returnType = " + returnType.toString());


        Block methodBody = method.getBody();
        List&lt;Statement&gt; statementList = methodBody.statements();

        System.out.println(statementList.toString());

        statementList.get(0);

        ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);
        Assignment expression = (Assignment) ifs.getExpression();
        Expression exp = expression.getRightHandSide();

        System.out.println(result.toString());
    }
}
</code></pre>

<h4>如何创建Java</h4>

<pre><code>package cn.shenyanchao.ast;

import org.eclipse.jdt.core.dom.*;

/**
 * Created with IntelliJ IDEA.
 *
 * @author shenyanchao
 *         Date:  6/13/13
 *         Time:  11:27 AM
 */
public class AstHelloWorld {


    public static void main(String[] args) {
        AST ast = AST.newAST(AST.JLS3);
        CompilationUnit compilationUnit = ast.newCompilationUnit();

        // 创建类
        TypeDeclaration programClass = ast.newTypeDeclaration();
        programClass.setName(ast.newSimpleName("HelloWorld"));
        programClass.modifiers().add(
                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        compilationUnit.types().add(programClass);

        // 创建包
        PackageDeclaration packageDeclaration = ast.newPackageDeclaration();
        packageDeclaration.setName(ast.newName("cn.shenyanchao.hello"));
        compilationUnit.setPackage(packageDeclaration);

        MethodDeclaration main = ast.newMethodDeclaration();
        main.setName(ast.newSimpleName("main"));
        main.modifiers().add(
                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
        main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
        programClass.bodyDeclarations().add(main);
        Block mainBlock = ast.newBlock();
        main.setBody(mainBlock);

        // 给main方法定义String[]参数
        SingleVariableDeclaration mainParameter = ast
                .newSingleVariableDeclaration();
        mainParameter.setName(ast.newSimpleName("arg"));
        mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast
                .newName("String"))));
        main.parameters().add(mainParameter);

        MethodInvocation println = ast.newMethodInvocation();
        println.setName(ast.newSimpleName("println"));

        //生成String类型的常量
        StringLiteral s = ast.newStringLiteral();
        s.setLiteralValue("Hello World");
        println.arguments().add(s);

        println.setExpression(ast.newName("System.out"));

        mainBlock.statements().add(ast.newExpressionStatement(println));

        System.out.println(compilationUnit.toString());
    }
}
</code></pre>

<p>具体的使用手册，参见<a href="http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/">http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[write my maven plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/13/write-my-maven-plugin/"/>
    <updated>2013-06-13T20:35:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/13/write-my-maven-plugin</id>
    <content type="html"><![CDATA[<p>mvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin</p>

<p><a href="http://maven.apache.org/guides/plugin/guide-java-plugin-development.html">http://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a></p>
]]></content>
  </entry>
  
</feed>
