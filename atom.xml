<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blues 小站]]></title>
  <link href="http://blueshen.github.com/atom.xml" rel="self"/>
  <link href="http://blueshen.github.com/"/>
  <updated>2012-10-31T10:43:56+08:00</updated>
  <id>http://blueshen.github.com/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：装饰器（Decorator）in Java]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/30/decorator-in-java/"/>
    <updated>2012-10-30T21:25:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/30/decorator-in-java</id>
    <content type="html"><![CDATA[<p>1.认识装饰器模式</p>

<p>装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。</p>

<!--more-->


<p>2.模式结构和说明</p>

<p>装饰模式的结构如下图所示。</p>

<p>Component：组件对象的接口，可以给这些对象动态的添加职责；</p>

<p>ConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；</p>

<p>Decorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。</p>

<p>ConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。</p>

<p>装饰器模式的示例代码如下(Java语言描述)：</p>

<p>   (1)组件对象的接口，可以给这些对象动态的添加职责</p>

<pre><code>public abstract class Component {  
    public abstract void operation();  
}  
</code></pre>

<p>(2)具体实现组件对象接口的对象</p>

<pre><code>public class ConcreteComponent extends Component {  

    public void operation() {  
        //相应的功能处理  
    }  
}  
</code></pre>

<p>(3)装饰器接口，维持一个指向组件对象的接口对象， 并定义一个与组件接口一致的接口</p>

<pre><code>public abstract class Decorator extends Component {  
    /** 
    * 持有组件对象 
    */  
    protected Component component;  

    /** 
    * 构造方法，传入组件对象 
    * @param component 组件对象 
    */  
    public Decorator(Component component) {  
        this.component = component;  
    }  

    public void operation() {  
        //转发请求给组件对象，可以在转发前后执行一些附加动作  
        component.operation();  
    }   
}  
</code></pre>

<p>(4)装饰器的具体实现对象，向组件对象添加职责，operationFirst()，operationLast()为前后需要添加的功能。具体的装饰器类ConcreteDecoratorB代码相似，不在给出。</p>

<pre><code>public class ConcreteDecoratorA extends Decorator {  
    public ConcreteDecoratorA(Component component) {  
        super(component);  
    }  
   private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  
   private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  
   public void operation() {  
       //调用父类的方法，可以在调用前后执行一些附加动作  
       operationFirst(); //添加的功能  
       super.operation();  //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能  
       operationLast(); //添加的功能  
    }  
}  
</code></pre>

<p>(5) 客户端使用装饰器的代码</p>

<pre><code>public class Client{  
    public static void main(String[] args){  
    Component c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  
    Decorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  
    decoratorA .operation();  
    Decorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  
    decoratorB .operation();  
    Decorator decoratorBandA = new ConcreteDecoratorB(decoratorA);//装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  
    decoratorBandA.operation();  
    }  
}  
</code></pre>

<p>3.小结</p>

<p>Java中的IO是明显的装饰器模式的运用。FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以给我们提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。我们使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。</p>

<p>BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); //其中file为某个具体文件的File或者FileDescription对象</p>

<pre><code>在以下两种情况下可以考虑使用装饰器模式：

(1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。

(2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。
</code></pre>

<p>参考文档：<a href="http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html">http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：适配器（Adapter）in Java]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/30/adapter-in-java/"/>
    <updated>2012-10-30T21:24:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/30/adapter-in-java</id>
    <content type="html"><![CDATA[<p><strong>类适配器</strong>:客户的开发人员定义了一个接口，期望用这个接口来完成整数的求和操作，接口定义如下：   <br/>
Java代码</p>

<pre><code>public interface Operation{  
    public int add(int a,int b);  
}  
</code></pre>

<p>开发人员在了解这个接口的定义后，发现一个第三方类，里面有一个方法能实现他们期望的功能，其代码如下：  <br/>
Java代码</p>

<pre><code>public class OtherOperation{  
    public int otherAdd(int a,int b){  
        return a + b;  
    }  
}  
</code></pre>

<!--more-->


<p>以上第三方类OtherOperation的方法public int otherAdd(int a,int b)所提供的功能，完全能符合客户的期望，所以只需要想办法把OtherOperation的otherAdd(int a,int b)和客户的Operation接口联系起来，让这个第三方类来为客户提供他们期望的服务就行了，这样就避免了开发人员再度去研究类似OtherOperation的otherAdd(int a,int b)方法的实现（利用已有的轮子，避免重复发明），这方法之一，就是用适配器模式： <br/>
Java代码</p>

<pre><code>public class AdapterOperation extends OtherOperation implements Operation{  
    public int add(int a,int b){  
       return otherAdd(a,b);  
     }  
}  
</code></pre>

<p>以上就是适配器的实现方法之一，<strong>类适配器</strong>，在以上实现中存在着三中角色分别是：  <br/>
1：适配目标角色：Operation。<br/>
2：适配类（原）角色：OtherOperation。<br/>
3：适配器角色：AdapterOperation。<br/>
其中适配器角色是适配器模式的核心。
适配器的主要工作就是通过封装现有的功能，使他满足需要的接口。</p>

<p><strong>对象适配器</strong><br/>
我们再来看看另一种情况：
假如客户接口期望的功能不止一个，而是多个： <br/>
Java代码</p>

<pre><code>public interface Operation{  
    public int add(int a,int b);  
    public int minus(int a,int b);  
    public int multiplied(int a,int b);  
}  
</code></pre>

<p>而能提供这些实现的原可能不止一个： <br/>
Java代码</p>

<pre><code>public class OtherAdd{  
    public int otherAdd(int a,int b){  
         return a + b;  
    }  
}  

public class OtherMinus{  
    public int minus(int a,int b){  
       return a - b;  
    }  
}  

public class OtherMultiplied{  
    public int multiplied(int a,int b){  
       return a * b;  
    }  
}  
</code></pre>

<p>由于java是不能实现多继承的，所以我们不能通过构建一个适配器，让他来继承所有原以完成我们的期望，这时候怎么办呢?只能用适配器的另一种实现&#8211;对象适配器：<br/>
Java代码</p>

<pre><code>public class AdapterOperation implements Operation{  
    private OtherAdd add;  
    private OtherMinus minus;  
    private OtherMultiplied multiplied;  

    public void setAdd(OtherAdd add){  
        this.add = add;  
    }  

    public void setMinus(OtherMinus minus){  
        this.minus = minus;  
    }  

    public void setMultiplied(OtherMultiplied multiplied){  
        this.multiplied = multiplied;  
    }  

    //适配加法运算  
    public int add(int a,int b){  
       return add.otherAdd(a,b);  
    }  

    //适配减法运算  
    public int minus(int a,int b){  
      return minus.minus(a,b);  
    }  

    //适配乘法运算  
    public int multiplied(int a,int b){  
     return multiplied.multiplied(a,b);  
    }  
}  
</code></pre>

<p>上面代码很明显，适配器并不是通过继承来获取适配类（原）的功能的，而是通过适配类的对象来获取的，这就解决了java不能多继承所带来的不便了。这也是java提倡的编程思想之一，即尽量使用聚合不要使用继承。<br/>
还有一种情况是需要使用对象适配器的。我们来看看，
单我们的客户提供的需求并不是一个明确的接口，而是一个类，并没有定义期望的方法，如下 <br/>
Java代码</p>

<pre><code>public class A{  
    public int add(int a,int b){  
        return a + b;  
    }  
}  
</code></pre>

<p>现在客户要一个新类B，要求能在保留类A功能的情况下增加一个运算减法的功能，并要求B能随时替换掉A但不能对已有系统造成影响。这样我们只能新建一个类B，并让B继承A。 <br/>
Java代码</p>

<pre><code>public class B extends A{  
    B(){  
        super();  
        }  

    public int minus(int a,int b){  
       //待实现的减法运算函数..  
    }  
}  
</code></pre>

<p>这时候，我们发现类C已经提供了实现减法的函数，    <br/>
Java代码</p>

<pre><code>public class C{  
    public int minus(int a,int b){  
       return a - b;  
    }  
}  
</code></pre>

<p>为了避免重复去设计该函数，我们决定引入C类，通过适配C类来达到我们的期望，但问题是A和C都是一个具体类，我们无法让B同时继承这个两个类，而B继承A又是必须的，所以我们只能考虑把C给内聚到B内部，对象适配器又得派上用场了。<br/>
Java代码</p>

<pre><code>public class B extends A{  
    private C c;  

    B(){  
        super();  
        }  

    public void setMinus(C c){  
        this.c= c;  
    }  

    public int minus(int a,int b){  
       return c.minus(a,b);  
    }  
}  
</code></pre>

<p>这样，在需要A类的地方都能用B类来代替，同时又保证了新的功能的引入。</p>

<p>更灵活的实现&#8211;<strong>隐藏目标接口的抽象适配器</strong></p>

<p>做java 桌面应用的都知道WindowListener接口， <br/>
Java代码</p>

<pre><code>public interface WindowListener extends EventListener{  
     public void windowActivated(WindowEvent e)；  
     public void windowClosed(WindowEvent e)；  
     public void windowClosing(WindowEvent e)；  
     public void windowDeactivated(WindowEvent e)；  
     public void windowDeiconified(WindowEvent e)；  
     public void windowIconified(WindowEvent e)；  
     public void windowOpened(WindowEvent e)；  
}  
</code></pre>

<p>要实现这个接口，我们就必须实现它所定义的所有方法，但是实际上，我们很少需要同时用到所有的方法，我们要的只是其中的两三个。为了不使我们实现多余的方法，     <br/>
jdk WindowListener提供了一个WindowListener的默认实现类WindowAdapter类，这是一个抽象类， <br/>
Java代码</p>

<pre><code>public abstract class WindowAdapter implements WindowListener{  
    public void windowActivated(WindowEvent e){}  
    public void windowClosed(WindowEvent e){}  
    public void windowClosing(WindowEvent e){}  
    public void windowDeactivated(WindowEvent e){}  
    public void windowDeiconified(WindowEvent e){}  
    public void windowIconified(WindowEvent e){}  
    public void windowOpened(WindowEvent e){}  
}  
</code></pre>

<p>WindowAdapter类对WindowListener接口的所有有方法都提供了空实现，
有了WindowAdapter类，我们只需要去继承WindowAdapter，然后选择我们所关心的方法来实现就行了，这样就避免了直接去实现WindowListener接口。</p>

<p>参考文献：<a href="http://chjl2020.iteye.com/blog/262370">http://chjl2020.iteye.com/blog/262370</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[云南之行]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/30/travel-in-yunnan/"/>
    <updated>2012-10-30T17:47:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/30/travel-in-yunnan</id>
    <content type="html"><![CDATA[<h2>拉市海</h2>

<p>我是有多胖，真得减肥了！</p>

<p><img src="http://blueshen.github.com/images/blog/psb.jpg" alt="" /></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java字符编码及其使用详解]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/23/encode-in-java/"/>
    <updated>2012-10-23T18:58:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/23/encode-in-java</id>
    <content type="html"><![CDATA[<h2>Java的编译存储</h2>

<p>Java是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。<br/>
<strong>简言之</strong></p>

<p>.java(任意编码) &#8212;> .class(Unicode) &#8212;> JVM内（Unicode）</p>

<!--more-->


<h2>是什么导致了乱码的出现？</h2>

<p>在JVM内，从class文件加载的源码全部以UNICODE编码。即使如<code>String str = "中国";</code>这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。</p>

<h2>Java中如何实现字符编码转换？</h2>

<p>String类提供了三个重要的函数：</p>

<pre><code>getBytes(String charsetName)
getBytes()
new String(byte[],String charsetName)
</code></pre>

<p><code>getBytes(String charset)</code>的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode&#8211;>charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode->ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。</p>

<p><code>getBytes()</code>与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过<code>Charset.defaultCharset()</code>来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地扑面而来了。哭吧！</p>

<p><code>new String(byte[],String charsetName)</code>的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。</p>

<p>因此，使用诸如<code>new String(str.getBytes("utf-8"), "gbk")</code>这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。</p>

<p><strong>完美解决方案：</strong> <br/>
考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是： <br/>
任意编码的字符 &#8211;> unicode &#8212;>任意编码的目标字符
也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。
以OutputStream为例：</p>

<pre><code>String str = "123中文";
System.out.println(str);
System.out.println("默认字符:" +Charset.defaultCharset());
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File("e://encode.txt")),"GBK"));
writer.write(str);
writer.close();
</code></pre>

<p>在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。</p>

<p>在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？<code>System.out.println()</code>是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。 <br/>
好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数<code>-encoding</code>来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为<code>Charset.defaultCharset()</code>,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。<code>System.out.println()</code>只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。</p>

<pre><code>javac -encoding utf-8 *.java    
</code></pre>

<p>这也就可以理解，maven中pom.xml定义编码的原因了：</p>

<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
</code></pre>

<p>同样Ant的build.xml中，也有相应的编码配置选项：</p>

<pre><code>&lt;javac destdir="${build.dir}" encoding="UTF-8"&gt;
    &lt;src path="${src.dir}" /&gt;
    &lt;classpath refid="project.classpath" /&gt;
&lt;/javac&gt;
</code></pre>

<h2>HTTP的request与response乱码问题</h2>

<p>1.HTTP请求主要分为POST,GET两种情况。</p>

<blockquote><p>POST的情况下，如何设置数据的编码格式呢。首先可以通过<code>&lt;form accept-charset= "UTF-8"&gt;</code>来设置表单的编码格式。如果不设置，浏览器会直接使用网页的编码。JSP的网页编码一般通过<code>&lt;%@page pageEncoding="UTF-8"%&gt;</code>来指定JSP文件的<strong>存储编码</strong>。而通过<code>&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;</code>来指定<strong>输出内容编码</strong>。<code>&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;</code>这一meta设置，用来指定<strong>网页编码</strong>，这一设置同样使用于静态页面。</p>

<p>GET情况下，参数都是放在URL内的，这时处理起来都比较麻烦。URL中的中文字符，一般都会进行<code>UrlEncode.encode()</code>处理,此时编码方式以系统默认编码为准，而在服务器端通过<code>getParameter</code>获得字符串是通过ISO-8859-1进行编码的。因此，需要从web服务器、浏览器端来同时考虑解决问题。服务器端的默认编码一般由<code>LC_ALL,LANG</code>决定的。通常可以设置为zh_CN.UTF-8。至于从浏览器端来解决，则没有统一的方法，毕竟环境多样。</p></blockquote>

<p>2.setCharacterEncoding()方法 <br/>
这一函数用来设置HTTP请求与相应的编码。前面提到过，通过<code>getParameter()</code>获得的字符串默认是以ISO-8859-1编码的。然而，如果使用了<code>request.setCharacterEncoding()</code>,则改变了其默认编码。同理，使用了<code>response.setCharacterEncoding</code>则保证了页面输出内容的编码，告诉浏览器输出内容采用什么编码。 <br/>
在spring的WEB项目中，有这样一个常用的filter：</p>

<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre>

<p>这个filter，一看就知道是给编码有关，但是它具体做了哪些操作呢？源码来了：</p>

<pre><code>protected void doFilterInternal(
        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) {
        request.setCharacterEncoding(this.encoding);**
        if (this.forceEncoding) {
            response.setCharacterEncoding(this.encoding);
        }
    }
    filterChain.doFilter(request, response);
}
</code></pre>

<p>可以看出，就是做了request、response的setCharacterEncoding()操作，防止乱码的问题出现。</p>

<h2>数据库乱码</h2>

<p>前面讲到过，乱码的原因是JVM内可能会读到外界的未知编码字符，导致在内存中的Unicode编码为乱码。显然数据库就是其中之一，并且是经常遇到的问题。<br/>
1.首先，数据库要支持多语言，应该考虑将数据库设置成UTF或者Unicode编码，而UTF更适合存储（UTF是变长存储的）。如果中文数据中包含的英文字符很少，建议Unicode。数据库编码设置，一般通过在配置文件设置<code>default-character-set=utf8</code>，这个在建库的时间也可以直接指定。 <br/>
2.读库的时候，可以在JDBC连接串中指定读取编码。如<code>useUnicode=true&amp;characterEncoding=UTF-8</code>。并保证两者一致。</p>

<h2>SecureCRT类似工具乱码</h2>

<p>这种问题，通常是由于SecureCRT等客户端与LINUX环境编码不一致造成的。同样的，在这些客户端读取数据库内容进行显示出现乱码，也是由于编码不一致的问题。 <br/>
可以通过设置客户端的编码，以及设置Linux环境的编码，使其保持一致来解决。</p>

<p>参考文档：<a href="http://blog.csdn.net/qinysong/article/details/1179513">http://blog.csdn.net/qinysong/article/details/1179513</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是BOM(Byte Order Mark)?]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/23/bom-in-utf8-text/"/>
    <updated>2012-10-23T17:05:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/23/bom-in-utf8-text</id>
    <content type="html"><![CDATA[<h3>引子</h3>

<p>在使用诸如UltraEditor,NotePad++等编辑工具时，经常会遇到encode进行转换的情况。以NotePad++为例，一篇ASCII编码的文本，通过菜单栏Encoding->convert to **进行编码格式的转换。我却发现一个奇怪的问题，下拉框里有这样两个选项：</p>

<ul>
<li>Convert to UTF-8</li>
<li>Convert to UTF-8 without BOM</li>
</ul>


<p>同样的是转化为UTF-8编码，为什么还牵涉到BOM呢。</p>

<!--more-->


<h3>原因</h3>

<p>1、big endian和little endian</p>

<p>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。那么在读文件的时间 “endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。
我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。<br/>
UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？</p>

<p>2.如何解决以上问题？</p>

<p>在UCS 编码中有一个叫做&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;又被称作BOM。</p>

<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>

<p>3.BOM在XML中的使用</p>

<p> W3C定义了三条XML解析器如何正确读取XML文件的编码的规则：</p>

<ul>
<li>如果文档有BOM(字节顺序标记，一般来说，如果保存为unicode格式，则包含BOM，ANSI则无)，就定义了文件编码</li>
<li>如果没有BOM，就查看XML声明的编码属性</li>
<li>如果上述两个都没有，就假定XML文挡采用UTF-8编码</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[23个经典JDK设计模式]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/22/design-pattern-in-jdk-index/"/>
    <updated>2012-10-22T20:49:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/22/design-pattern-in-jdk-index</id>
    <content type="html"><![CDATA[<p>下面是JDK中有关23个经典设计模式的示例：</p>

<!--more-->


<h2>Structural（结构模式）</h2>

<p><strong>Adapter:</strong></p>

<p>把一个接口或是类变成另外一种。</p>

<p>● java.util.Arrays#asList()<br/>
● javax.swing.JTable(TableModel)<br/>
● java.io.InputStreamReader(InputStream) <br/>
● java.io.OutputStreamWriter(OutputStream) <br/>
● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br/>
● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()</p>

<p><strong>Bridge:</strong></p>

<p>把抽象和实现解藕，于是接口和实现可在完全独立开来。</p>

<p>● AWT (提供了抽象层映射于实际的操作系统)<br/>
● JDBC</p>

<p><strong>Composite:</strong></p>

<p>让使用者把单独的对象和组合对象混用。</p>

<p>● javax.swing.JComponent#add(Component) <br/>
● java.awt.Container#add(Component) <br/>
● java.util.Map#putAll(Map) <br/>
● java.util.List#addAll(Collection) <br/>
● java.util.Set#addAll(Collection)</p>

<p><strong>Decorator:</strong></p>

<p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。</p>

<p>● java.io.BufferedInputStream(InputStream) <br/>
● java.io.DataInputStream(InputStream) <br/>
● java.io.BufferedOutputStream(OutputStream) <br/>
● java.util.zip.ZipOutputStream(OutputStream) <br/>
● java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()</p>

<p><strong>Facade:</strong></p>

<p>用一个简单的接口包状一组组件，接口，抽象或是子系统。</p>

<p>● java.lang.Class <br/>
● javax.faces.webapp.FacesServlet</p>

<p><strong>Flyweight:</strong></p>

<p>有效率地存储大量的小的对象。</p>

<p>● java.lang.Integer#valueOf(int) <br/>
● java.lang.Boolean#valueOf(boolean) <br/>
● java.lang.Byte#valueOf(byte) <br/>
● java.lang.Character#valueOf(char)</p>

<p><strong>Proxy:</strong></p>

<p>用一个简单的对象来代替一个复杂的对象。</p>

<p>● java.lang.reflect.Proxy <br/>
● RMI</p>

<h2>Creational（创建模式）</h2>

<p><strong>Abstract factory:</strong></p>

<p>创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p>

<p>● java.util.Calendar#getInstance()  <br/>
● java.util.Arrays#asList() <br/>
● java.util.ResourceBundle#getBundle() <br/>
● java.sql.DriverManager#getConnection() <br/>
● java.sql.Connection#createStatement() <br/>
● java.sql.Statement#executeQuery() <br/>
● java.text.NumberFormat#getInstance() <br/>
● javax.xml.transform.TransformerFactory#newInstance()</p>

<p><strong>Builder:</strong></p>

<p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。</p>

<p>● java.lang.StringBuilder#append() <br/>
● java.lang.StringBuffer#append() <br/>
● java.sql.PreparedStatement <br/>
● javax.swing.GroupLayout.Group#addComponent()</p>

<p><strong>Factory:</strong></p>

<p>简单来说，按照需求返回一个类型的实例。</p>

<p>● java.lang.Proxy#newProxyInstance() <br/>
● java.lang.Object#toString() <br/>
● java.lang.Class#newInstance() <br/>
● java.lang.reflect.Array#newInstance() <br/>
● java.lang.reflect.Constructor#newInstance() <br/>
● java.lang.Boolean#valueOf(String) <br/>
● java.lang.Class#forName()</p>

<p><strong>Prototype:</strong></p>

<p>使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。</p>

<p>● java.lang.Object#clone() <br/>
● java.lang.Cloneable</p>

<p><strong>Singleton:</strong></p>

<p>只允许一个实例。在 Effective Java中建议使用Emun.</p>

<p>● java.lang.Runtime#getRuntime() <br/>
● java.awt.Toolkit#getDefaultToolkit() <br/>
● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment() <br/>
● java.awt.Desktop#getDesktop()</p>

<h2>Behavioral(行为模式)</h2>

<p><strong>Chain of responsibility:</strong></p>

<p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。</p>

<p>● java.util.logging.Logger#log() <br/>
● javax.servlet.Filter#doFilter()</p>

<p><strong>Command:</strong></p>

<p>把一个或一些命令封装到一个对象中。</p>

<p>● java.lang.Runnable <br/>
● javax.swing.Action</p>

<p><strong>Interpreter:</strong></p>

<p>一个语法解释器的模式。</p>

<p>● java.util.Pattern  <br/>
● java.text.Normalizer <br/>
● java.text.Format</p>

<p><strong>Iterator:</strong></p>

<p>提供一种一致的方法来顺序遍历一个容器中的所有元素。</p>

<p>● java.util.Iterator <br/>
● java.util.Enumeration</p>

<p><strong>Mediator:</strong></p>

<p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。</p>

<p>● java.util.Timer <br/>
● java.util.concurrent.Executor#execute() <br/>
● java.util.concurrent.ExecutorService#submit() <br/>
● java.lang.reflect.Method#invoke()</p>

<p><strong>Memento:</strong></p>

<p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。</p>

<p>● java.util.Date <br/>
● java.io.Serializable</p>

<p><strong>Null Object:</strong></p>

<p>这个模式用来解决如果一个Collection中没有元素的情况。</p>

<p>● java.util.Collections#emptyList() <br/>
● java.util.Collections#emptyMap() <br/>
● java.util.Collections#emptySet()</p>

<p><strong>Observer:</strong></p>

<p>允许一个对象向所有的侦听的对象广播自己的消息或事件。</p>

<p>● java.util.EventListener <br/>
● javax.servlet.http.HttpSessionBindingListener <br/>
● javax.servlet.http.HttpSessionAttributeListener <br/>
● javax.faces.event.PhaseListener</p>

<p><strong>State:</strong></p>

<p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。</p>

<p>● java.util.Iterator <br/>
● javax.faces.lifecycle.LifeCycle#execute()</p>

<p><strong>Strategy:</strong></p>

<p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>

<p>● java.util.Comparator#compare() <br/>
● javax.servlet.http.HttpServlet <br/>
● javax.servlet.Filter#doFilter()</p>

<p><strong>Template method:</strong></p>

<p>允许子类重载部分父类而不需要完全重写。</p>

<p>● java.util.Collections#sort() <br/>
● java.io.InputStream#skip() <br/>
● java.io.InputStream#read() <br/>
● java.util.AbstractList#indexOf()</p>

<p><strong>Visitor:</strong></p>

<p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.</p>

<p>● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor <br/>
● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor</p>

<p>在stakeoverflow也有相应的讨论：</p>

<p><a href="http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns">http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns</a></p>

<p>摘自：<a href="http://www.csdn.net/article/2010-11-29/282644">http://www.csdn.net/article/2010-11-29/282644</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP Header]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/22/http-header/"/>
    <updated>2012-10-22T20:34:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/22/http-header</id>
    <content type="html"><![CDATA[<p>HTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而 言，包括message-header和message-body两部分。首先传递message-header，即http header消息。http header 消息通常被分为4个部分：general; header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分.</p>

<!--more-->


<p> <br/>
<strong>Response部分</strong></p>

<div>
<table border="1" width="90%" >
    <tbody>
        <tr>
            <th>
                Header</th>
            <th>
                解释</th>
            <th>
                示例</th>
        </tr>
        <tr>
            <td >
                Accept-Ranges</td>
            <td >
                表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
            <td >
                Accept-Ranges: bytes</td>
        </tr>
        <tr>
            <td >
                Age</td>
            <td >
                从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
            <td >
                Age: 12</td>
        </tr>
        <tr>
            <td >
                Allow</td>
            <td >
                对某网络资源的有效的请求行为，不允许则返回405</td>
            <td >
                Allow: GET, HEAD</td>
        </tr>
        <tr>
            <td >
                Cache-Control</td>
            <td >
                告诉所有的缓存机制是否可以缓存及哪种类型</td>
            <td >
                Cache-Control: no-cache</td>
        </tr>
        <tr>
            <td >
                Content-Encoding</td>
            <td >
                web服务器支持的返回内容压缩编码类型。</td>
            <td >
                Content-Encoding: gzip</td>
        </tr>
        <tr>
            <td >
                Content-Language</td>
            <td >
                响应体的语言</td>
            <td >
                Content-Language: en,zh</td>
        </tr>
        <tr>
            <td >
                Content-Length</td>
            <td >
                响应体的长度</td>
            <td >
                Content-Length: 348</td>
        </tr>
        <tr>
            <td >
                Content-Location</td>
            <td >
                请求资源可替代的备用的另一地址</td>
            <td >
                Content-Location: /index.htm</td>
        </tr>
        <tr>
            <td >
                Content-MD5</td>
            <td >
                返回资源的MD5校验值</td>
            <td >
                Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
        </tr>
        <tr>
            <td >
                Content-Range</td>
            <td >
                在整个返回体中本部分的字节位置</td>
            <td >
                Content-Range: bytes 21010-47021/47022</td>
        </tr>
        <tr>
            <td >
                Content-Type</td>
            <td >
                返回内容的MIME类型</td>
            <td >
                Content-Type: text/html; charset=utf-8</td>
        </tr>
        <tr>
            <td >
                Date</td>
            <td >
                原始服务器消息发出的时间</td>
            <td >
                Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
        </tr>
        <tr>
            <td >
                ETag</td>
            <td >
                请求变量的实体标签的当前值</td>
            <td >
                ETag: “737060cd8c284d8af7ad3082f209582d”</td>
        </tr>
        <tr>
            <td >
                Expires</td>
            <td >
                响应过期的日期和时间</td>
            <td >
                Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
        </tr>
        <tr>
            <td >
                Last-Modified</td>
            <td >
                请求资源的最后修改时间</td>
            <td >
                Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
        </tr>
        <tr>
            <td >
                Location</td>
            <td >
                用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
            <td >
                Location: http://www.zcmhi.com/archives/94.html</td>
        </tr>
        <tr>
            <td >
                Pragma</td>
            <td >
                包括实现特定的指令，它可应用到响应链上的任何接收方</td>
            <td >
                Pragma: no-cache</td>
        </tr>
        <tr>
            <td >
                Proxy-Authenticate</td>
            <td >
                它指出认证方案和可应用到代理的该URL上的参数</td>
            <td >
                Proxy-Authenticate: Basic</td>
        </tr>
        <tr>
            <td >
                refresh</td>
            <td >
                应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
            <td >
                <div>
                    &nbsp;</div>
                <p style="margin-left:auto;">
                    &nbsp;</p>
                <div id="_mcePaste">
                    Refresh: 5; url=</div>
                <div>
                    http://www.zcmhi.com/archives/94.html</div>
            </td>
        </tr>
        <tr>
            <td >
                Retry-After</td>
            <td >
                如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
            <td >
                Retry-After: 120</td>
        </tr>
        <tr>
            <td >
                Server</td>
            <td >
                web服务器软件名称</td>
            <td >
                Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
        </tr>
        <tr>
            <td >
                Set-Cookie</td>
            <td >
                设置Http Cookie</td>
            <td >
                Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
        </tr>
        <tr>
            <td >
                Trailer</td>
            <td >
                指出头域在分块传输编码的尾部存在</td>
            <td >
                Trailer: Max-Forwards</td>
        </tr>
        <tr>
            <td >
                Transfer-Encoding</td>
            <td >
                文件传输编码</td>
            <td >
                Transfer-Encoding:chunked</td>
        </tr>
        <tr>
            <td >
                Vary</td>
            <td >
                告诉下游代理是使用缓存响应还是从原始服务器请求</td>
            <td >
                Vary: *</td>
        </tr>
        <tr>
            <td >
                Via</td>
            <td >
                告知代理客户端响应是通过哪里发送的</td>
            <td >
                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
        </tr>
        <tr>
            <td >
                Warning</td>
            <td >
                警告实体可能存在的问题</td>
            <td >
                Warning: 199 Miscellaneous warning</td>
        </tr>
        <tr>
            <td >
                WWW-Authenticate</td>
            <td >
                表明客户端请求实体应该使用的授权方案</td>
            <td >
                WWW-Authenticate: Basic</td>
        </tr>
    </tbody>
</table>

更多参见 [w3c官网](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
<table border="1" width="90%" >
    <tbody>
        <tr>
            <td >
                Content-Type</td>
            <td >
                请求的与实体对应的MIME信息</td>
            <td >
                Content-Type: application/x-www-form-urlencoded</td>
        </tr>
        <tr>
            <td >
                Date</td>
            <td >
                请求发送的日期和时间</td>
            <td >
                Date: Tue, 15 Nov&nbsp;2010 08:12:31 GMT</td>
        </tr>
        <tr>
            <td >
                Expect</td>
            <td >
                请求的特定的服务器行为</td>
            <td >
                Expect: 100-continue</td>
        </tr>
        <tr>
            <td >
                From</td>
            <td >
                发出请求的用户的Email</td>
            <td >
                From: user@email.com</td>
        </tr>
        <tr>
            <td >
                Host</td>
            <td >
                指定请求的服务器的域名和端口号</td>
            <td >
                Host: www.zcmhi.com</td>
        </tr>
        <tr>
            <td >
                If-Match</td>
            <td >
                只有请求内容与实体相匹配才有效</td>
            <td >
                If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
        </tr>
        <tr>
            <td >
                If-Modified-Since</td>
            <td >
                如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
            <td >
                If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
        </tr>
        <tr>
            <td >
                If-None-Match</td>
            <td >
                如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
            <td >
                If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
        </tr>
        <tr>
            <td >
                If-Range</td>
            <td >
                如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
            <td >
                If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
        </tr>
        <tr>
            <td >
                If-Unmodified-Since</td>
            <td >
                只在实体在指定时间之后未被修改才请求成功</td>
            <td >
                If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
        </tr>
        <tr>
            <td >
                Max-Forwards</td>
            <td >
                限制信息通过代理和网关传送的时间</td>
            <td >
                Max-Forwards: 10</td>
        </tr>
        <tr>
            <td >
                Pragma</td>
            <td >
                用来包含实现特定的指令</td>
            <td >
                Pragma: no-cache</td>
        </tr>
        <tr>
            <td >
                Proxy-Authorization</td>
            <td >
                连接到代理的授权证书</td>
            <td >
                Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
        </tr>
        <tr>
            <td >
                Range</td>
            <td >
                只请求实体的一部分，指定范围</td>
            <td >
                Range: bytes=500-999</td>
        </tr>
        <tr>
            <td >
                Referer</td>
            <td >
                先前网页的地址，当前请求网页紧随其后,即来路</td>
            <td >
                Referer: http://www.zcmhi.com/archives/71.html</td>
        </tr>
        <tr>
            <td >
                TE</td>
            <td >
                客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
            <td >
                TE: trailers,deflate;q=0.5</td>
        </tr>
        <tr>
            <td >
                Upgrade</td>
            <td >
                向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
            <td >
                Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
        </tr>
        <tr>
            <td >
                User-Agent</td>
            <td >
                User-Agent的内容包含发出请求的用户信息</td>
            <td >
                User-Agent: Mozilla/5.0 (Linux; X11)</td>
        </tr>
        <tr>
            <td >
                Via</td>
            <td >
                通知中间网关或代理服务器地址，通信协议</td>
            <td >
                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
        </tr>
        <tr>
            <td >
                Warning</td>
            <td >
                关于消息实体的警告信息</td>
            <td >
                Warn: 199 Miscellaneous warning<br />
                &nbsp;</td>
        </tr>
    </tbody>
</table>

**Requests部分**
<table border="1"  width="90%">
    <tbody>
        <tr>
            <th>
                Header</th>
            <th>
                解释</th>
            <th>
                示例</th>
        </tr>
        <tr>
            <td >
                Accept</td>
            <td >
                指定客户端能够接收的内容类型</td>
            <td >
                Accept: text/plain, text/html</td>
        </tr>
        <tr>
            <td >
                Accept-Charset</td>
            <td >
                浏览器可以接受的字符编码集。</td>
            <td >
                Accept-Charset: iso-8859-5</td>
        </tr>
        <tr>
            <td >
                Accept-Encoding</td>
            <td >
                指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
            <td >
                Accept-Encoding: compress, gzip</td>
        </tr>
        <tr>
            <td >
                Accept-Language</td>
            <td >
                浏览器可接受的语言</td>
            <td >
                Accept-Language: en,zh</td>
        </tr>
        <tr>
            <td >
                Accept-Ranges</td>
            <td >
                可以请求网页实体的一个或者多个子范围字段</td>
            <td >
                Accept-Ranges: bytes</td>
        </tr>
        <tr>
            <td >
                Authorization</td>
            <td >
                HTTP授权的授权证书</td>
            <td >
                Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
        </tr>
        <tr>
            <td >
                Cache-Control</td>
            <td >
                指定请求和响应遵循的缓存机制</td>
            <td >
                Cache-Control: no-cache</td>
        </tr>
        <tr>
            <td >
                Connection</td>
            <td >
                表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
            <td >
                Connection: close</td>
        </tr>
        <tr>
            <td >
                Cookie</td>
            <td >
                HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
            <td >
                Cookie: $Version=1; Skin=new;</td>
        </tr>
        <tr>
            <td >
                Content-Length</td>
            <td >
                请求的内容长度</td>
            <td >
                Content-Length: 348</td>
        </tr>
    </tbody>
</table>

</div>


<p>参考文档：<a href="http://www.itniwo.net/blog/v/26466.html">http://www.itniwo.net/blog/v/26466.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符集编码]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/22/word-charset/"/>
    <updated>2012-10-22T20:29:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/22/word-charset</id>
    <content type="html"><![CDATA[<h2>GB2312字符集</h2>

<p>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施，是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。</p>

<!--more-->


<p>GB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。</p>

<p>GB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码。</p>

<p>它是用双字节表示的，两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为“高字节” ，而称第二字节为“低字节”。“高位字节”使用了0xA1-0xF7(把01-87区的区号加上0xA0)，“低位字节”使用了0xA1-0xFE(把01-94加上0xA0)。</p>

<p>以GB2312字符集的第一个汉字“啊”字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。</p>

<h2>GBK字符集</h2>

<p>GBK字符集是GB2312的扩展(K)，GBK1.0收录了21886个符号，它分为汉字区和图形符号区，汉字区包括21003个字符。GBK字符集主要扩展了繁体中文字的支持。</p>

<h2>BIG5 字符集</h2>

<p>BIG5又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五间软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。</p>

<p>Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。</p>

<p>Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。</p>

<p>尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。</p>

<p>例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等) 也没有收录到Big5之中。</p>

<h2>GB18030 字符集</h2>

<p>GB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。GB 18030字符集标准的出台经过广泛参与和论证，来自国内外知名信息技术行业的公司，信息产业部和原国家质量技术监督局联合实施。</p>

<p>GB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。</p>

<p>编码方法：<br/>
GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。</p>

<p>按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。</p>

<p>接着是国际通用的unicode字符集</p>

<h2>Unicode字符集（简称为UCS）</h2>

<p>1．名称的由来</p>

<p>Unicode字符集编码是（Universal Multiple-Octet Coded Character Set） 通用多八位编码字符集的简称，支持世界上超过650种语言的国际字符集。Unicode允许在同一服务器上混合使用不同语言组的不同语言。它是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。该编码于1990年开始研发，1994年正式公布，最新版本是2005年3月31日的Unicode 4.1.0。Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>

<p>2．编码方法</p>

<p>Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，例如字母“A”的编码为 004116 。所以“A”的编码书写为“U+0041”。</p>

<p>3．UTF-8 编码 <br/>
UTF-8是Unicode的其中一个使用方式。 UTF是 Unicode Translation Format，即把Unicode转做某种格式的意思。</p>

<p>UTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的Unicode能够在现存的处理单字节的系统上正确传输。</p>

<p>UTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。</p>

<p>4．UTF-16 和 UTF-32 编码  <br/>
UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案，UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码；UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数</p>

<p>通过一个问题了解unicode编码</p>

<p><strong>问题：</strong>使用Windows记事本的“另存为”，可以在ANSI、GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows怎样识别编码方式的呢？  <br/>
我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？</p>

<p><strong>答案：</strong></p>

<p>ANSI字符集定义：ASCII字符集，以及由此派生并兼容的字符集，如：GB2312，正式的名称为MBCS(Multi-Byte Chactacter System，多字节字符系统)，通常也称为ANSI字符集。</p>

<h2>UNICODE 与 UTF8、UTF16</h2>

<p>由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits(两个字节)来表示一个字符，共可以表示65536个字符  <br/>
标准的 Unicode 称为UTF-16(UTF:UCS Transformation Format )。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。(Unicode字符集有多种编码形式)  <br/>
例如&#8221;连通&#8221;两个字的Unicode标准编码UTF-16 (big endian)为：DE 8F 1A 90 <br/>
而其UTF-8编码为：E8 BF 9E E9 80 9A</p>

<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：
检测文件头标识，提示用户选择，根据一定的规则猜测
最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：<br/>
EF BB BF UTF-8<br/>
FE FF UTF-16/UCS-2, little endian  <br/>
FF FE UTF-16/UCS-2, big endian  <br/>
FF FE 00 00 UTF-32/UCS-4, little endian. <br/>
00 00 FE FF UTF-32/UCS-4, big-endian.</p>

<p>1、big endian和little endian <br/>
big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。
“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。 <br/>
我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。</p>

<p>2、字符编码、内码，顺带介绍汉字编码  <br/>
字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。  <br/>
GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72<em>94=6768。其中有5个空位是D7FA-D7FE。 <br/>
GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。  <br/>
从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。  <br/>
有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。 <br/>
这里还有一些细节： <br/>
GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。 <br/>
在DBCS中，GB内码的存储格式始终是big endian，即高位在前。 <br/>
GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128</em>128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。</p>

<p>3、Unicode、UCS和UTF(UCS Transformation Format)  <br/>
前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。</p>

<p>UCS规定了怎么用多个字节表示各种文字。而怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的！常见的UTF规范包括UTF-8、UTF-7、UTF-16。</p>

<p>4、UTF的字节序和BOM <br/>
UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？ <br/>
Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：   <br/>
在UCS编码中有一个叫做&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;。
这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;又被称作BOM。  <br/>
UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符&#8221;ZERO WIDTH NO-BREAK SPACE&#8221;的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。  <br/>
Windows就是使用BOM来标记文本文件的编码方式的。</p>

<p>写到这里对编码有了大致的了解了，就可以理解网上一些文章的话了，比如有一篇很流行的文章《URL编码与SQL注射》里面有一段是这么说的：</p>

<p>其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\”，它的ascii码是92，92的十六进制是5c，所以“\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。呵呵，知道怎么转换的了吧。</p>

<p>这得从ASCII说起，扩展的ASCII字符集采用8bit255个字符显然不够用，于是各个国家纷纷制定了自己的文字编码规范，其中中文的文字编码规范叫做“GB2312-80”（就是GB2312)，它是和ASCII兼容的一种编码规范，其实就是用扩展ASCII没有真正标准化这一点，把一个中文字符用两个扩展ASCII字符来表示。文中说的的中文ASCII码实际上就是简体中文的编码2312GB！它把ASCII又扩充了一个字节，由于高位的第一位是0，所以会出现负数的形式，url编码就是将汉字的这个GB2312编码转化成UTF-8的编码并且每8位即一个字节前面加上%符号表示。</p>

<p>那为何UTF-8是进行网络的规范传输编码呢？</p>

<p>在Unicode里，所有的字符被一视同仁。汉字不再使用“两个扩展ASCII”，而是使用“1个Unicode”，注意，现在的汉字是“一个字符”了，于是，拆字、统计字数这些问题也就自然而然的解决了。但是，这个世界不是理想的，不可能在一夜之间所有的系统都使用Unicode来处理字符，所以Unicode在诞生之日，就必须考虑一个严峻的问题：和ASCII字符集之间的不兼容问题。</p>

<p>我们知道，ASCII字符是单个字节的，比如“A”的ASCII是65。而Unicode是双字节的，比如“A”的Unicode是0065，这就造成了一个非常大的问题：以前处理ASCII的那套机制不能被用来处理Unicode了</p>

<p>另一个更加严重的问题是，C语言使用&#8217;\0&#8217;作为字符串结尾，而Unicode里恰恰有很多字符都有一个字节为0，这样一来，C语言的字符串函数将无法正常处理Unicode，除非把世界上所有用C写的程序以及他们所用的函数库全部换掉</p>

<p>于是，比Unicode更伟大的东东诞生了，之所以说它更伟大是因为它让Unicode不再存在于纸上，而是真实的存在于我们大家的电脑中。那就是：UTF</p>

<p>UTF= UCS Transformation Format UCS转换格式，它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16</p>

<p>其中UTF-16和上面提到的Unicode本身的编码规范是一致的，这里不多说了。而UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容，这样做的好处是压缩了字符在西欧一些国家的内存消耗，减少了不必要的资源浪费，这在实际应用中是非常有必要的。</p>

<p>UTF-8有点类似于Haffman编码，它将Unicode编码为：<br/>
00000000-0000007F的字符，用单个字节来表示；</p>

<p>00000080-000007FF的字符用两个字节表示 （中文的编码范围）</p>

<p>00000800-0000FFFF的字符用3字节表示</p>

<p>因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。</p>

<p>在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的）。</p>

<p>看看编码之多：ANSI,AscII,GB2312,GBK,BIG5,GB18030,Unicode,UCS（就是unicode）Utf-8,utf-16,utf-32 整整10种编码～，算是够复杂了
可是这还仅仅是个开始，应用方面变化无穷，不过现在看到这些东西起码再不会头大了！呼呼～</p>

<p>哦，漏了一个加密的base64编码。</p>

<h2>什么是Base64？</h2>

<p>按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.）</p>

<p><strong>为什么要使用Base64？</strong></p>

<p>在设计这个编码的时候，我想设计人员最主要考虑了3个问题： <br/>
1.是否加密？  <br/>
2.加密算法复杂程度和效率  <br/>
3.如何处理传输？</p>

<p>加密是肯定的，但是加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”。即达到一眼望去完全看不出内容即可。 <br/>
基于这个目的加密算法的复杂程度和效率也就不能太大和太低。和上一个理由类似，MIME协议等用于发送Email的协议解决的是如何收发Email，而并不是如何安全的收发Email。因此算法的复杂程度要小，效率要高，否则因为发送Email而大量占用资源，路就有点走歪了。</p>

<p>但是，如果是基于以上两点，那么我们使用最简单的恺撒法即可，为什么Base64看起来要比恺撒法复杂呢？这是因为在Email的传送过程中，由于历史原因，Email只被允许传送ASCII字符，即一个8位字节的低7位。因此，如果您发送了一封带有非ASCII字符（即字节的最高位是1）的Email通过有“历史问题”的网关时就可能会出现问题。网关可能会把最高位置为0！很明显，问题就这样产生了！因此，为了能够正常的传送Email，这个问题就必须考虑！所以，单单靠改变字母的位置的恺撒之类的方案也就不行了。关于这一点可以参考RFC2046。  <br/>
基于以上的一些主要原因产生了Base64编码。</p>

<p>参考文档：<a href="http://cafardcn.iteye.com/blog/300239">http://cafardcn.iteye.com/blog/300239</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符集与编码的故事]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/22/encode-story/"/>
    <updated>2012-10-22T20:13:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/22/encode-story</id>
    <content type="html"><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为&#8221;字节&#8221;。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为&#8221;计算机&#8221;。</p>

<!--more-->


<p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为&#8221;控制码&#8221;。</p>

<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的&#8221;ASCII&#8221;编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p>

<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称&#8221;扩展字符集&#8221;。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！</p>

<p>等中国人得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&#8221;全角&#8221;字符，而原来在127号以下的那些就叫&#8221;半角&#8221;字符了。  中国人民看到这样很不错，于是就把这种汉字方案叫做 &#8220;GB2312&#8221;。GB2312 是对 ASCII 的中文扩展。</p>

<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。  后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p>

<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 &#8220;DBCS&#8221;（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。</p>

<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。当时的中国人想让电脑显示汉字，就必须装上一个&#8221;汉字系统&#8221;，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么&#8221;倚天汉字系统&#8221;才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！</p>

<p>正在这时，大天使加百列及时出现了：一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它&#8221;Universal Multiple-Octet Coded Character Set&#8221;，简称 UCS, 俗称 &#8220;UNICODE&#8221;。</p>

<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些&#8221;半角&#8221;字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于&#8221;半角&#8221;英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p>

<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p>

<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p>

<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p>

<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p>

<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符。如果之后的文本是高位在位，那就发送&#8221;FEFF&#8221;，反之，则发送&#8221;FFFE&#8221;。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？</p>

<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入&#8221;联通&#8221;两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p>

<p>原文：<a href="http://turandot.iteye.com/blog/1703258">http://turandot.iteye.com/blog/1703258</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 命令]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/20/git-command/"/>
    <updated>2012-10-20T10:56:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/20/git-command</id>
    <content type="html"><![CDATA[<h2>Git 命令结构图：</h2>

<!--more-->


<p><img src="http://blueshen.github.com/images/blog/git-command.png" alt="git command" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xpath 详解]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/20/xpath/"/>
    <updated>2012-10-20T10:43:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/20/xpath</id>
    <content type="html"><![CDATA[<div id="intro">
<p><strong>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</strong></p>
</div>




<div>
<h2>XML 实例文档</h2>
<p>我们将在下面的例子中使用这个 XML 文档。</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;bookstore&gt;

&lt;book&gt;
  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;
  &lt;price&gt;29.99&lt;/price&gt;
&lt;/book&gt;

&lt;book&gt;
  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;
  &lt;price&gt;39.95&lt;/price&gt;
&lt;/book&gt;

&lt;/bookstore&gt;</pre>
</div>


<!--more-->




<div>
<h2>选取节点</h2>

<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p>

<h3>下面列出了最有用的路径表达式：</h3>

<table class="dataintable">
<tr>
<th style="width:25%;">表达式</th>
<th>描述</th>
</tr>

<tr>
<td>nodename</td>
<td>选取此节点的所有子节点。</td>
</tr>

<tr>
<td>/</td>
<td>从根节点选取。</td>
</tr>

<tr>
<td>//</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>

<tr>
<td>.</td>
<td>选取当前节点。</td>
</tr>

<tr>
<td>..</td>
<td>选取当前节点的父节点。</td>
</tr>

<tr>
<td>@</td>
<td>选取属性。</td>
</tr>
</table>

<h3>实例</h3>

<p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p>

<table class="dataintable">
<tr>
<th style="width:25%;">路径表达式</th>
<th>结果</th>
</tr>

<tr>
<td>bookstore</td>
<td>选取 bookstore 元素的所有子节点。</td>
</tr>

<tr>
<td>/bookstore</td>
<td>
<p>选取根元素 bookstore。</p>
<p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p>
</td>
</tr>

<tr>
<td>bookstore/book</td>
<td>选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>

<tr>
<td>//book</td>
<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>

<tr>
<td>bookstore//book</td>
<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>

<tr>
<td>//@lang</td>
<td>选取名为 lang 的所有属性。</td>
</tr>
</table>
</div>




<div>
<h2>谓语（Predicates）</h2>

<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>
<p>谓语被嵌在方括号中。</p>

<h3>实例</h3>

<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>

<table class="dataintable">
<tr>
<th style="width:35%;">路径表达式</th>
<th>结果</th>
</tr>

<tr>
<td>/bookstore/book[1]</td>
<td>选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>

<tr>
<td>/bookstore/book[last()]</td>
<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>

<tr>
<td>/bookstore/book[last()-1]</td>
<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>

<tr>
<td>/bookstore/book[position()&lt;3]</td>
<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>

<tr>
<td>//title[@lang]</td>
<td>选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>

<tr>
<td>//title[@lang=&#8217;eng&#8217;]</td>
<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>

<tr>
<td>/bookstore/book[price&gt;35.00]</td>
<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>

<tr>
<td>/bookstore/book[price&gt;35.00]/title</td>
<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
</table>
</div>




<div>
<h2>选取未知节点</h2>

<p>XPath 通配符可用来选取未知的 XML 元素。</p>

<table class="dataintable">
<tr>
<th style="width:25%;">通配符</th>
<th>描述</th>
</tr>

<tr>
<td>*</td>
<td>匹配任何元素节点。</td>
</tr>

<tr>
<td>@*</td>
<td>匹配任何属性节点。</td>
</tr>

<tr>
<td>node()</td>
<td>匹配任何类型的节点。</td>
</tr>
</table>

<h3>实例</h3>

<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>

<table class="dataintable">
<tr>
<th style="width:25%;">路径表达式</th>
<th>结果</th>
</tr>

<tr>
<td>/bookstore/*</td>
<td>选取 bookstore 元素的所有子元素。</td>
</tr>

<tr>
<td>//*</td>
<td>选取文档中的所有元素。</td>
</tr>

<tr>
<td>//title[@*]</td>
<td>选取所有带有属性的 title 元素。</td>
</tr>
</table>
</div>




<div>
<h2>选取若干路径</h2>

<p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>

<h3>实例</h3>

<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>

<table class="dataintable">
<tr>
<th style="width:35%;">路径表达式</th>
<th>结果</th>
</tr>

<tr>
<td>//book/title | //book/price</td>
<td>选取 book 元素的所有 title 和 price 元素。</td>
</tr>

<tr>
<td>//title | //price</td>
<td>选取文档中的所有 title 和 price 元素。</td>
</tr>

<tr>
<td>/bookstore/book/title | //price</td>
<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>
</tr>
</table>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安装配置Maven]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/19/install-maven/"/>
    <updated>2012-10-19T23:40:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/19/install-maven</id>
    <content type="html"><![CDATA[<h2>Maven安装</h2>

<p>1.下载Maven：从<a href="http://maven.apache.org/download.html">Maven官方</a>下载,并解压。比如解压到：D:\apache-maven-3.0.4   <br/>
2.配置环境变量：</p>

<ul>
<li>M2_HOME：D:\apache-maven-3.0.4</li>
<li>path：%M2_HOME%\bin;</li>
</ul>


<p>打开cmd命令窗口,验证配置是否成功：<code>mvn -v</code>。成功后会显示正确的版本信息。<br/>
3.修改默认的repository <br/>
maven默认放在C:\Users\user.m2\repository目录下（不同系统可能不一样）。Window下一般不建议放在C盘。可以通过如下方式修改： <br/>
进入%M2_HOME%\conf\settings.xml中，添加<code>&lt;localRepository&gt;e:/repo&lt;/localRepository&gt;</code>这样一行。默认的路径就指向新的目录了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存溢出详解]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/19/jvm-out-of-memory/"/>
    <updated>2012-10-19T23:12:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/19/jvm-out-of-memory</id>
    <content type="html"><![CDATA[<p>一、常见的Java内存溢出有以下三种：</p>

<ol>
<li><code>java.lang.OutOfMemoryError: Java heap space</code> &#8212;-JVM Heap（堆）溢出
JVM在启动的时候会自动设置JVM Heap的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)不可超过物理内存。
可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。
在JVM中如果98％的时间是用于GC，且可用的Heap size 不足2％的时候将抛出此异常信息。
解决方法：手动设置JVM Heap（堆）的大小。  <br/>
<!--more--></li>
<li><p><code>java.lang.OutOfMemoryError: PermGen space</code>  &#8212;- PermGen space溢出。
PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。
为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信 息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。
解决方法： 手动设置MaxPermSize大小</p></li>
<li><p><code>java.lang.StackOverflowError</code>  &#8212;- 栈溢出
栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。
调用构造函数的 “层”太多了，以致于把栈区溢出了。
通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。
通常递归也不要递归的层次过多，很容易溢出。
解决方法：修改程序。</p></li>
</ol>


<p>二、解决方法</p>

<p>在生产环境中tomcat内存设置不好很容易出现jvm内存溢出。</p>

<p>1、 linux下的tomcat：<br/>
修改TOMCAT_HOME/bin/catalina.sh
在“echo &#8220;Using CATALINA_BASE: $CATALINA_BASE&#8221;”上面加入以下行：
<code>JAVA_OPTS="-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code>&#8221;</p>

<p>2、 如果tomcat 5 注册成了windows服务，以services方式启动的，则需要修改注册表中的相应键值。
修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Apache Software Foundation\Tomcat Service Manager\Tomcat5\Parameters\Java，右侧的Options
原值为</p>

<pre><code>-Dcatalina.home="C:\ApacheGroup\Tomcat 5.0"
-Djava.endorsed.dirs="C:\ApacheGroup\Tomcat 5.0\common\endorsed"
</code></pre>

<p>-Xrs
加入 -Xms256m -Xmx512m
重起tomcat服务,设置生效</p>

<p>3、 如果tomcat 6 注册成了windows服务，或者windows2003下用tomcat的安装版，
在/bin/tomcat6w.exe里修改就可以了 。</p>

<p>4、 如果要在myeclipse中启动tomcat，上述的修改就不起作用了，可如下设置：
Myeclipse->preferences->myeclipse->servers->tomcat->tomcat×.×->JDK面板中的
Optional Java VM arguments中添加：<code>-Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code></p>

<p>三、jvm参数说明：</p>

<p>-server:一定要作为第一个参数，在多个CPU时性能佳  <br/>
-Xms：java Heap初始大小。 默认是物理内存的1/64。 <br/>
-Xmx：java heap最大值。建议均设为物理内存的一半。不可超过物理内存。<br/>
-XX:PermSize:设定内存的永久保存区初始大小，缺省值为64M。（我用visualvm.exe查看的） <br/>
-XX:MaxPermSize:设定内存的永久保存区最大 大小，缺省值为64M。（我用visualvm.exe查看的） <br/>
-XX:SurvivorRatio=2  :生还者池的大小,默认是2，如果垃圾回收变成了瓶颈，您可以尝试定制生成池设置  <br/>
-XX:NewSize: 新生成的池的初始大小。 缺省值为2M。<br/>
-XX:MaxNewSize: 新生成的池的最大大小。   缺省值为32M。 <br/>
如果 JVM 的堆大小大于 1GB，则应该使用值：-XX:newSize=640m -XX:MaxNewSize=640m -XX:SurvivorRatio=16，或者将堆的总大小的 50% 到 60% 分配给新生成的池。调大新对象区，减少Full GC次数。<br/>
+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。 <br/>
-Xss：每个线程的Stack大小，“-Xss 15120” 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.  <br/>
-verbose:gc 现实垃圾收集信息  <br/>
-Xloggc:gc.log 指定垃圾收集日志文件<br/>
-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一  <br/>
-XX:+UseParNewGC ：缩短minor收集的时间  <br/>
-XX:+UseConcMarkSweepGC ：缩短major收集的时间 此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。 <br/>
-XX:userParNewGC 可用来设置并行收集【多CPU】 <br/>
-XX:ParallelGCThreads 可用来增加并行度【多CPU】 <br/>
-XX:UseParallelGC 设置后可以使用并行清除收集器【多CPU】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM参数选项]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/19/java6-jvm-params/"/>
    <updated>2012-10-19T23:01:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/19/java6-jvm-params</id>
    <content type="html"><![CDATA[<p>详情请看：<a href="http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven生命周期详解]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/19/maven-life-cycle/"/>
    <updated>2012-10-19T22:21:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/19/maven-life-cycle</id>
    <content type="html"><![CDATA[<p>Maven强大的一个重要的原因是它有一个十分完善的生命周期模型(lifecycle)，这个生命周期可以从两方面来理解，第一，顾名思义，运行Maven的每个步骤都由它来定义的，这种预定义的默认行为使得我们使用Maven变得简单，相比而言，Ant的每个步骤都要你手工去定义。第二，这个模型是一种标准，在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，一般情况下，mvn clean install 这样的命令是通用的。我想，一定是吸收了许多项目的经验，Maven才能定义出如此完善的模型。</p>

<!--more-->


<p>
Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：</p>

<ul>
<li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</li>
<li>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</li>
<li>Site Lifecycle 生成项目报告，站点，发布站点。</li>
</ul>


<p>我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。</p>

<p>知道了每套生命周期的大概用途和相互关系以后，来逐个详细看一下每套生命周期，Clean和Site相对比较简单，先解释一下。</p>

<p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：</p>

<ul>
<li>pre-clean  执行一些需要在clean之前完成的工作</li>
<li>clean  移除所有上一次构建生成的文件</li>
<li>post-clean  执行一些需要在clean之后立刻完成的工作</li>
</ul>


<p>mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。</p>

<p>下面看一下Site生命周期的各个阶段：</p>

<ul>
<li>pre-site     执行一些需要在生成站点文档之前完成的工作</li>
<li>site    生成项目的站点文档</li>
<li>post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy     将生成的站点文档部署到特定的服务器上</li>
</ul>


<p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</p>

<p>最后，来看一下Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：</p>

<ul>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources     复制并处理资源文件，至目标目录，准备打包。</li>
<li>compile     编译项目的源代码。</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources     复制并处理资源文件，至目标测试目录。</li>
<li>test-compile     编译测试源代码。</li>
<li>process-test-classes</li>
<li>test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>
<li>prepare-package</li>
<li>package     接受编译好的代码，打包成可发布的格式，如 JAR 。</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install     将包安装至本地仓库，以让其它项目依赖。</li>
<li>deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。</li>
</ul>


<p>基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>

<p>记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。</p>

<p>此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，在之后的文章里，我将会进一步解释Maven的插件机制。</p>

<p>转摘自：<a href="http://juvenshun.iteye.com/blog/213959">http://juvenshun.iteye.com/blog/213959</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PageObjects 设计模式]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/16/pageobjects-design-pattern/"/>
    <updated>2012-10-16T16:40:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/16/pageobjects-design-pattern</id>
    <content type="html"><![CDATA[<h2>什么是Page Objects(翻译为：页面对象？)&#8230;</h2>

<p>简单的说，Page Objects是指UI界面上用于与用户进行交互的对象。它可以指整个页面，也可以指Page上的某个区域。Page Objects是你的test code的交互对象，是对实际UI的一种抽象模型化。通过Page Objects可以减少重复代码的编写，例如，很多页面都有同样的header，footer，navigator等部分，如果对这些进行抽象，只写一次就可以在其他地方通用了。</p>

<p><strong>注意PageObjects与Page Objects是不一样的</strong>，PageObjects用于特指采用Page Objects进行封装的一种设计模式（Design Pattern）,而不仅仅是多一个空格的区别。哈。</p>

<h2>如何实现PageObjects设计模式？</h2>

<p>一般情况下，对于一个Page Objects对象，它有两个方面的特征：</p>

<ul>
<li>自身元素(WebElement)</li>
<li>实现功能 (Services)</li>
</ul>


<!--more-->


<p></p>

<p>自身元素很好理解，就是实实在在的页面元素。而Page Object通常也都是实现一定的功能的。就Test的开发人员来说，更关心的是Page Objects它们实现了什么交互功能，而不是其内部的实现，因此，这里的功能与开发人员理解的功能是<strong>不一样的</strong>。</p>

<p>以用户登录为例：在登录界面，点击登录后要么成功，转向首页。要么失败，出现提示出错信息。 <br/>
相信这是一个很容易理解的场景吧！<br/>
Java Code可能类似如下：</p>

<pre><code>public class LoginPage {
    //用户名录入框
    private WebElement usernameBox;
    //密码录入框
    private WebElement passwordBox;
    //提交按钮
    private WebElement submitButton;

    public HomePage loginAs(String username, String password) {
        usernameBox.sendKeys(username);
        passwordBox.sendKeys(password);
        submitButton.submit();
        return new HomePage(...)
    }

    public LoginPage loginAsExpectingError(String username, String password) {
         //  出错的username,password 仍留在LoginPage
     }

    public String getErrorMessage() {
    // 获取错误信息
    }
}   
</code></pre>

<p>从上面可以看出，同时封装了元素以及功能。此处样例，元素是没有初始化的。可以通过类似于<code>driver.findElement()</code>的函数来直接进行初始化，另外WebDriver提供了一个PageFactory用于对PageObjects设计模式进行支持，下面将会讲到。<br/>
通过上面的这段代码，也展现出了一个重要的问题，那就是assertion不应该在Page Objects内部，而应该由tests进行处理。Page Objects只是返回需要验证的信息即可。</p>

<h2>总结</h2>

<ul>
<li>public方法代表Page提供的功能</li>
<li>尽量不要暴露Page的内部细节</li>
<li>不要assertion</li>
<li>方法可以返回其他Page Objects</li>
<li>Page Objects不用代表整个页面，可以是任意一个部分</li>
<li>一样的操作，不同的结果应该分开（正确登录，错误登录）</li>
</ul>


<h2>样例</h2>

<pre><code>public class LoginPage {
    private final WebDriver driver;
    // 用户名录入框
    private WebElement usernameBox;
    // 密码录入框
    private WebElement passwordBox;
    // 提交按钮
    private WebElement submitButton;

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        if (!"Login".equals(driver.getTitle())) {
            throw new IllegalStateException("This is not the login page");
        }
        this.usernameBox = driver.findElement(By.id("username"));
        this.passwordBox = driver.findElement(By.id("passwd"));
        this.submitButton = driver.findElement(By.id("login"));
    }

    public HomePage loginAs(String username, String password) {
        usernameBox.sendKeys(username);
        passwordBox.sendKeys(password);
        submitButton.submit();
        return new HomePage(driver);
    }
}
</code></pre>

<h2>PageFactory</h2>

<p>从上面的样例中，有没有发现每个元素都要进行<code>driver.findElement()</code>这样的操作，写起来好累啊，一堆重复性的代码。有没有更好的，更优雅的处理方法呢？<strong><code>org.openqa.selenium.support.PageFactory</code></strong>就是用来负责处理这个的，真Happy! <br/>
下面以<a href="http://www.baidu.com">百度搜索</a>作为样例场景，搜索一个关键字：</p>

<pre><code>import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;
import org.openqa.selenium.support.PageFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
* @author shenyanchao
* 
 */
public class BaiduSearchPage {
    public static final Logger LOG = LoggerFactory
        .getLogger(BaiduSearchPage.class);
    private WebElement wd;

    public void searchFor(String keyword) {
        wd.sendKeys(keyword);
        wd.submit();
    }

    public static void main(String[] args) {
        WebDriver driver = new HtmlUnitDriver();
        driver.get("http://www.baidu.com");
        BaiduSearchPage baiduPage = PageFactory.initElements(driver,
            BaiduSearchPage.class);
        LOG.info("before search url is:{}",driver.getCurrentUrl());
        baiduPage.searchFor("blueshen");
        LOG.info("after search url is:{}",driver.getCurrentUrl());
    }
}
</code></pre>

<p>运行以上代码，发现已经可以正常运行，结果如下：</p>

<pre><code>......
before search url is:http://www.baidu.com/
......
after search url is:http://www.baidu.com/s?wd=blueshen&amp;rsv_bp=0&amp;rsv_spt=3
</code></pre>

<p>可见，搜索后，已经转向了正确的搜索结果页面。然而WebElement是如何初始化的呢？玄机就在<code>BaiduSearchPage baiduPage = PageFactory.initElements(driver,BaiduSearchPage.class);</code>这行代码。PageFactory负责初始化了Page里的元素，amazing，用起来就是这么的优雅。 <br/>
那么下来，我就要问了：PageFactory是怎么定位元素的呢？</p>

<blockquote><p>原来PageFactory初始化元素有一个惯例，样例中将WebElement的名称定为wd,那么PageFactory将按类似以下的形式对其进行初始化：  <br/>
<code>driver.findElement(By.id("wd"));</code><br/>
PageFactory认为wd是HTML元素的id或者name字段的值,并且优先从id开始查找。至此，我们终于知道怎么回事了。</p></blockquote>

<p>随着项目的变大，以及使用的更加深入，HTML元素的id，name字段并不一定唯一，并且Java Class的属性看起来都是一堆无意义的名称。这些要求我们必须要进行改进。幸好PageFactory已经提前考虑到了这一切，它支持annotations来显式定位元素。那么上述的百度搜索样例，可以修改为如下形式：</p>

<pre><code>public class BaiduSearchPage {
    public static final Logger LOG = LoggerFactory
        .getLogger(BaiduSearchPage.class);
    @FindBy(how = How.NAME, using = "wd")
    @CacheLookup
    private WebElement serachBox;

    public void searchFor(String keyword) {
        serachBox.sendKeys(keyword);
        serachBox.submit();
    }
......
}
</code></pre>

<p>明确的指定HOW.NAME,using=&#8221;wd&#8221;,意为查找name=&#8221;wd&#8221;的元素，并将其初始化赋值给searchBox这一有意义的属性名。其中@CacheLookup用于标识其只初始化一次，然后缓存起来备用。</p>

<p>感觉还不够简洁吗？继续修改：</p>

<pre><code>@FindBy(name = "wd")
private WebElement searchBox;
</code></pre>

<p>这是其简略模式，还支持各种定位方式。</p>

<pre><code>    @FindBy(id="...")
    @FindBy(className="...")
    @FindBy(name="...")
    @FindBy(xpath="...")
    @FindBy(linkText="...")
    @FindBy(partialLinkText="...")
    @FindBy(tagName="...")
    @FindBy(css="...")
</code></pre>

<p>同时支持<code>@FindBys</code>用于支持列表元素查找定位，返回<code>List&lt;WebElement&gt;</code>类型。</p>

<p><strong>总之，利用PageObjects设计模式并且配合PageFactory使用，将使你的自动化测试优雅、易度、易维护。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Selenium WebDriver的多浏览器支持]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/12/selenium-multiple-browser-support/"/>
    <updated>2012-10-12T14:56:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/12/selenium-multiple-browser-support</id>
    <content type="html"><![CDATA[<h2>Selenium WebDriver支持哪儿些浏览器？</h2>

<p>按照官方文档的说法，现阶段有以下的drivers:</p>

<blockquote><ul>
<li>ChromeDriver</li>
<li>InternetExplorerDriver</li>
<li>FirefoxDriver</li>
<li>OperaDriver</li>
<li>HtmlUnitDriver</li>
<li>AndroidDriver(mobile testing)</li>
<li>OperaMobileDriver(mobile testing)</li>
<li>IPhoneDriver(mobile testing)</li>
</ul>
</blockquote>

<!--more-->


<p></p>

<h2>为什么selenium自动化case在一个浏览器运行的很好，换为另外一个浏览器则不行？</h2>

<h3>一个Driver可以打开浏览器，另外一个Driver却不行？</h3>

<p>WebDriver是通过调用native浏览器来操作的，浏览器之间的差异注定会出现一些问题。下面以InternetExplorer,Firefox,Chrome为例进行说明：</p>

<h4>InternetExplorer：</h4>

<blockquote><p>1.它分不同的版本，版本之间差异很大。InternetExplorerDriver支持IE6、7、8、9。操作系统支持XP、Vista、Windows 7。 <br/>
2.InternetExplorerDriver同时支持32/64bit的浏览器，这个取决于你用的是什么版本的<a href="http://code.google.com/p/selenium/downloads/list">IEDriverServer.exe</a>。 <br/>
3.要求条件如下：</p>

<blockquote><ul>
<li><a href="http://code.google.com/p/selenium/downloads/list">IEDriverServer</a>在系统环境的PATH内（selenium2.26.0+版本推荐方式）。或者设置<code>webdriver.ie.driver</code>系统属性。 <br/>
   <code>System.setProperty("webdriver.ie.driver", "D:\\IEDriverServer.exe");</code><br/>
  <code>WebDriver driver = new InternetExplorerDriver();</code></li>
<li>在windows vista、windows7操作系统中，如果使用IE7+的浏览器，应该保证浏览器的<strong>保护模式</strong>都处于<strong>同一状态</strong>[开启或者关闭]。如果不一致，那么报错信息类似于<code>Caused by: org.openqa.selenium.WebDriverException: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones. (WARNING: The server did not provide any stacktrace information)</code> <br/>
不会设置吗？ <br/>
操作如下：打开浏览器->Internet选项 ->安全->启用保护模式。保证Internet、本地Intranet、受信任的站点、受限制的站点4个zone保护模式一致就OK</li>
<li>为了确保能获得正确的坐标点，要把浏览器的缩放设为100%。 <br/>
设置方法：打开浏览器->页面->缩放(Z)->100%</li>
</ul>
</blockquote></blockquote>

<p>参考<a href="http://code.google.com/p/selenium/wiki/InternetExplorerDriver">http://code.google.com/p/selenium/wiki/InternetExplorerDriver</a></p>

<h4>Firefox:</h4>

<blockquote><p>1.Firefox不像InternetExplorer一样，用户可以自定义安装路径。因此使用时，需要制定firefox.exe的安装路径。<br/>
怎么指定?</p>

<blockquote><ul>
<li>java code: <code>System.setProperty()</code></li>
<li>命令行：<code>-DpropertyName='value'</code></li>
</ul>
</blockquote>

<p>2.系统变量的值为：<code>webdriver.firefox.bin</code>，以及其他的key值，详见参考页面。webdriver.firefox.bin用来指定Firefox的安装路径。如不设置，默认从%PROGRAMFILES%\Mozilla Firefox\firefox.exe加载。<strong>个人强烈建议，即使安装在默认路径也进行指定</strong>。 <br/>
3.Java代码如下：</p>

<pre><code>System.setProperty("webdriver.firefox.bin", "C://Mozila/firefox.exe");  
WebDriver driver = new FirefoxDriver();  
</code></pre>

<p>其中firefox的安装路径，按情况自行替换。</p></blockquote>

<p>参考<a href="http://code.google.com/p/selenium/wiki/FirefoxDriver">http://code.google.com/p/selenium/wiki/FirefoxDriver</a></p>

<h4>Chrome:</h4>

<p>chrome要求条件如下：</p>

<blockquote><p>1.Chrome应当安装在默认路径下（如果是从官方下载的，安装后直接都是默认路径）。
<table border=”1px">
<tbody>
<tr><td>OS</td><td>默认位置</td></tr>
<tr><td>Linux</td><td>/usr/bin/google-chrome</td></tr>
<tr><td>Mac</td><td>/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome</td></tr>
<tr><td>Windwos XP</td><td>%HOMEPATH%\Local Settings\Application Data\Google\Chrome\Application\chrome.exe</td></tr>
<tr><td>Windwos Vista</td><td>C:\Users\%USERNAME%\AppData\Local\Google\Chrome\Application\chrome.exe</td></tr>
</tbody>
</table>  <br/>
2.需要下载相应版本的<a href="http://code.google.com/p/chromedriver/downloads/list">chromedriver</a>，用来架起chrome浏览器与webdriver之间的桥梁。 <br/>
3.与FirefoxDriver差不多，需要设置chromedriver的路径。key值为：webdriver.chrome.driver. <br/>
4.Java代码如下：</p>

<pre><code>System.setProperty("webdriver.chrome.driver", "C://drivers/chromedriver.exe");  
WebDriver driver = new ChromeDriver();    
</code></pre>

<p>需要注意的是，chrome浏览器会自动更新，而<a href="http://code.google.com/p/chromedriver/downloads/list">chromedriver</a>也是不断更新的。如果chrome版本太新，而chromedriver没有相应的更换，会造成只是打开chrome浏览器，而不进行任何操作的问题。另外，ChromeDriver只适用于chrome 12.0.712.0+,如果需要使用更老的版本，见参考页面的详细描述。</p></blockquote>

<p>参考<a href="http://code.google.com/p/selenium/wiki/ChromeDriver">http://code.google.com/p/selenium/wiki/ChromeDriver</a></p>

<h3>在一个浏览器里，元素可以找到或者可以操作，而在另外一个浏览器内则不行，为什么？</h3>

<p>不同浏览器之间解析DOM以及响应事件的机制不同，难免会有一些不兼容性。解决方法：</p>

<blockquote><p>1.元素定位，通常是由于DOM解析不同造成的，可以使用不同的findElement方法进行实验，如id,class,xpath等。这个没有统一的结论，大多数情况下id是最靠谱的。<strong>推荐！</strong> <br/>
2.事件的响应，这个如果存在问题，一般比较难解决。通常是由于浏览器之间的差异造成的。可以通过使用selenium更高的版本，或者更换浏览器的版本来解决。或者想一下，有没有其他的方式，换个事件来绕过去，总有办法的。如果实在解决不了，那也只能暂时是这样了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium FAQ:如何处理JavaScript弹出的alert、prompt窗口]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/12/selenium-faq-alerts-and-prompts/"/>
    <updated>2012-10-12T14:39:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/12/selenium-faq-alerts-and-prompts</id>
    <content type="html"><![CDATA[<h2>经常会碰到，页面操作后，出现一个alert窗口或者prompt确认窗口的情况，这时需要获得窗口的提示信息以及点击确定或取消的情况。</h2>

<pre><code>// Get a handle to the open alert, prompt or confirmation
Alert alert = driver.switchTo().alert();
// Get the text of the alert or prompt
alert.getText();  
// And acknowledge the alert (equivalent to clicking "OK")
alert.accept();
</code></pre>

<p>这是通用的处理方法。但是如果弹出的窗口不是<code>alert()</code>或者<code>prompt()</code>弹出来的则不适用。请注意。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium FAQ:怎么样调用Javascript？]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/12/selenium-faq-how-to-use-javascript/"/>
    <updated>2012-10-12T14:30:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/12/selenium-faq-how-to-use-javascript</id>
    <content type="html"><![CDATA[<h2>selenium自动化开发中，难免需要用到直接调用javascript，怎么用呢？</h2>

<pre><code>WebDriver driver; // Assigned elsewhere
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("return document.title");
</code></pre>

<p>直接将driver强制转化为JavascriptExecutor,然后执行javascript即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apache mpm介绍[转]]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/12/apache-mpm/"/>
    <updated>2012-10-12T12:45:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/12/apache-mpm</id>
    <content type="html"><![CDATA[<h2>什么是MPM？</h2>

<p>MPM（Multi -Processing Modules，多路处理模块）是Apache2.x中影响性能的最核心特性。</p>

<p>是Apache 2.x才支持的一个可插入的并发模型，在编译的时候，我们只可以选择一个并发模型。</p>

<p>配置文件：/usr/local/apache2/conf/extra/httpd-mpm.conf</p>

<p>如果apache是默认安装的可能配置在httpd.conf文件中。根据实际情况查找配置。</p>

<p>使用格式：
进入apache的目录，对apache进行如下编译：</p>

<p>Linux代码
<code>./configure --help|grep mpm </code></p>

<!--more-->


<p>显示内容如下：</p>

<p>Linux代码</p>

<pre><code>--with-mpm=MPM  
Choose the process model for Apache to use.  
MPM={beos|worker|prefork|mpmt_os2| perchild|leader|threadpool}  
</code></pre>

<ul>
<li><p>1、Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM。</p></li>
<li><p>2、perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程，这在运行多个需要CGI的虚拟主机时特别有用，会比1.3版中的SuExec 机制做得更好。</p></li>
<li><p>3、leader和threadpool都是基于worker的变体，还处于实验性阶段，某些情况下并不会按照预期设想的那样工作，所以 Apache官方也并不推荐使用。</p></li>
<li><p>4、prefork如果不用“–with-mpm ”显式指定某种MPM，prefork就是LInux/Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的，这也使其成为最稳定的MPM之一。<br/>
prefork的工作原理是，控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个，直到满足MinSpareServers设置的值为止。这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。</p></li>
<li><p>5、worker相对于prefork,worker是2.x版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理,所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器.但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.x的发展趋势。  <br/>
worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild 线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。</p></li>
</ul>


<h2>如何判断当前的服务器使用那种MPM 模块?</h2>

<p>若使用prefork，在make编译和make install安装后，使用“httpd -l”来确定当前使用的MPM，
如下示:</p>

<pre><code>[aaron@webslave1 extra]$ /usr/local/apache2/bin/httpd -l 
Compiled in modules: 
core.c 
...... 
prefork.c 
...... 
</code></pre>

<p>应该会看到prefork.c（如果看到worker.c说明使用的是worker MPM，依此类推）。再查看缺省生成的httpd.conf配置文件，里面包含如下配置段：</p>

<p>Linux代码</p>

<pre><code>&lt;IfModule prefork.c&gt;  
StartServers 5  
MinSpareServers 5  
MaxSpareServers 10  最大的空闲进程数 
MaxClients 150  Apache可以同时处理的请求(最重要)--即为常说的并发连接数!! 
MaxRequestsPerChild 0  每个子进程可处理的请求数 
&lt;/IfModule&gt;  
</code></pre>

<p>MaxSpareServers设置了最大的空闲进程数，如果空闲进程数大于这个值，Apache会自动kill掉一些多余进程。这个值不要设得过大，但如果设的值比MinSpareServers小，Apache会自动把其调整为MinSpareServers+1。如果站点负载较大，可考虑同时加大MinSpareServers和MaxSpareServers。</p>

<p>MaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处：</p>

<p>可防止意外的内存泄漏；
在服务器负载下降的时侯会自动减少子进程数。</p>

<p>因此，可根据服务器的负载来调整这个值。笔者认为10000左右比较合适。</p>

<p>MaxClients是这些指令中最为重要的一个，设定的是Apache可以同时处理的请求，是对Apache性能影响最大的参数。<br/>
其缺省值150是远远不够的，如果请求总数已达到这个值（可通过ps -ef|grep http|wc -l来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。系统管理员可以根据硬件配置和负载情况来动态调整这个值。<br/>
虽然理论上这个值越大，可以处理的请求就越多，但Apache默认的限制不能大于256。如果把这个值设为大于256，那么Apache将无法起动。事实上，256对于负载稍重的站点也是不够的。在Apache 1.3中，这是个硬限制。如果要加大这个值，必须在“configure”前手工修改的源代码树下的src/include/httpd.h中查找256，就会发现“#define HARD_SERVER_LIMIT 256”这行。把256改为要增大的值（如4000），然后重新编译Apache即可。在Apache 2.0中新加入了ServerLimit指令，使得无须重编译Apache就可以加大MaxClients。下面是笔者的prefork配置段：</p>

<p>Linux代码</p>

<pre><code>&lt;IfModule prefork.c&gt;  
StartServers 10  
MinSpareServers 10  
MaxSpareServers 15  
ServerLimit 2000  
MaxClients 1000  
MaxRequestsPerChild 10000  
&lt;/IfModule&gt;  
</code></pre>

<p>　上述配置中，ServerLimit的最大值是20000，对于大多数站点已经足够。如果一定要再加大这个数值，对位于源代码目录下
/httpd-2.2.15/server/mpm/prefork/prefork.c中以下两行做相应修改即可：<br/>
Linux代码</p>

<pre><code>#define DEFAULT_SERVER_LIMIT 256  
#define MAX_SERVER_LIMIT 20000  
</code></pre>

<p>worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。</p>

<p>MinSpareThreads和MaxSpareThreads的最大缺省值分别是75和250。这两个参数对Apache的性能影响并不大，可以按照实际情况相应调节。
ThreadsPerChild是worker MPM中与性能相关最密切的指令。ThreadsPerChild的最大缺省值是64，如果负载较大，64也是不够的。这时要显式使用ThreadLimit指令，它的最大缺省值是20000。上述两个值位于源码树server/mpm/worker/worker.c中的以下两行：</p>

<p>Linux代码</p>

<pre><code>#define DEFAULT_THREAD_LIMIT 64  
#define MAX_THREAD_LIMIT 20000  
</code></pre>

<p>这两行对应着ThreadsPerChild和ThreadLimit的限制数。最好在configure之前就把64改成所希望的值。注意，不要把这两个值设得太高，超过系统的处理能力，从而因Apache不起动使系统很不稳定。
Worker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的，应该大于等于MaxClients。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时也需要显式声明ServerLimit（最大值是20000）。这两个值位于源码树server/mpm/worker/worker.c中的以下两行：</p>

<p>Linux代码</p>

<pre><code>#define DEFAULT_SERVER_LIMIT 16  
#define MAX_SERVER_LIMIT 20000  
</code></pre>

<p>需要注意的是，如果显式声明了ServerLimit，那么它乘以ThreadsPerChild的值必须大于等于MaxClients，而且MaxClients必须是ThreadsPerChild的整数倍，否则Apache将会自动调节到一个相应值（可能是个非期望值）。下面是笔者的worker配置段：</p>

<p>Linux代码</p>

<pre><code>&lt;IfModule worker.c&gt;  
StartServers 3  
MaxClients 2000  
ServerLimit 25  
MinSpareThreads 50  
MaxSpareThreads 200  
ThreadLimit 200  
ThreadsPerChild 100  
MaxRequestsPerChild 0  
&lt;/IfModule&gt;  
</code></pre>

<p>通过上面的叙述，可以了解到Apache 2.0中prefork和worker这两个重要MPM的工作原理，并可根据实际情况来配置Apache相关的核心参数，以获得最大的性能和稳定性。</p>
]]></content>
  </entry>
  
</feed>
