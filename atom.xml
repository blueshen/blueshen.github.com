<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blues小站</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2016-08-14T08:56:22.000Z</updated>
  <id>http://www.shenyanchao.cn/</id>
  
  <author>
    <name>shenyanchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于接口定义的一些想法</title>
    <link href="http://www.shenyanchao.cn/2016/08/14/2015-11-04-about-interface-define/"/>
    <id>http://www.shenyanchao.cn/2016/08/14/2015-11-04-about-interface-define/</id>
    <published>2016-08-14T08:56:22.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。</p>
<h3 id="使用RESTFul接口"><a href="#使用RESTFul接口" class="headerlink" title="使用RESTFul接口"></a>使用RESTFul接口</h3><p>RESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.</p>
<h3 id="解决接口联调的苦难"><a href="#解决接口联调的苦难" class="headerlink" title="解决接口联调的苦难"></a>解决接口联调的苦难</h3><p>作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。<br>因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。</wwww.swagger.io></p>
<ul>
<li>swagger-maven-plugin</li>
<li>swagger-ui</li>
</ul>
<h3 id="项目中遇到的一些教训"><a href="#项目中遇到的一些教训" class="headerlink" title="项目中遇到的一些教训"></a>项目中遇到的一些教训</h3><p>作为技术负责人</p>
<ul>
<li>提前制定接口，方便联调</li>
<li>提前规划返回接口类型，统一字段名称。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。&lt;/p&gt;
&lt;h3 id=&quot;使用RESTFul接口&quot;&gt;&lt;a href=&quot;#使用RESTFul接口&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="java" scheme="http://www.shenyanchao.cn/categories/java/"/>
    
    
      <category term="spring" scheme="http://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="restful" scheme="http://www.shenyanchao.cn/tags/restful/"/>
    
      <category term="interface" scheme="http://www.shenyanchao.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Restful Spring MVC</title>
    <link href="http://www.shenyanchao.cn/2015/11/03/2015-11-03-restful-springmvc/"/>
    <id>http://www.shenyanchao.cn/2015/11/03/2015-11-03-restful-springmvc/</id>
    <published>2015-11-03T05:53:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC本身对Restful支持非常好。它的<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@ResponseBody</code>注解很好的支持了REST。<a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html" target="_blank" rel="external">18.2 Creating RESTful services</a></p>
<h3 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1. @RequestMapping"></a>1. <code>@RequestMapping</code></h3><p>Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。</p>
<h3 id="2-PathVariable"><a href="#2-PathVariable" class="headerlink" title="2. @PathVariable"></a>2. <code>@PathVariable</code></h3><p>The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是<code>@RequestParam</code>做的事情。）</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
        // ...
}
</code></pre><p>如果变量名与pathVariable名不一致，那么需要指定：</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) {
    // implementation omitted
}
</code></pre><blockquote>
<p><strong>Tip</strong></p>
<p>method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.</p>
</blockquote>
<h3 id="3-RequestParam"><a href="#3-RequestParam" class="headerlink" title="3. @RequestParam"></a>3. <code>@RequestParam</code></h3><p>官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟<code>@PathVariable</code>功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。</p>
<p>对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(&quot;name&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(), 
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><p>还可以设置defaultValue：</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;arganzheng&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(), 
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><h3 id="4-RequestBody和-ResponseBody"><a href="#4-RequestBody和-ResponseBody" class="headerlink" title="4. @RequestBody和@ResponseBody"></a>4. <code>@RequestBody</code>和<code>@ResponseBody</code></h3><p>这两个注解其实用到了Spring的一个非常灵活的设计——<code>HttpMessageConverter</code> <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion" target="_blank" rel="external">18.3.2 HTTP Message Conversion</a></p>
<p>与<code>@RequestParam</code>不同，<code>@RequestBody</code>和<code>@ResponseBody</code>是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。</p>
<p><code>HtppMessageConverter</code>负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。</p>
<pre><code>public interface HttpMessageConverter&lt;T&gt; {

    // Indicate whether the given class is supported by this converter.
    boolean supports(Class&lt;? extends T&gt; clazz);

    // Return the list of MediaType objects supported by this converter.
    List&lt;MediaType&gt; getSupportedMediaTypes();

    // Read an object of the given type form the given input message, and returns it.
    T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException, 
                                                                    HttpMessageNotReadableException;

    // Write an given object to the given output message.
    void write(T t, HttpOutputMessage outputMessage) throws IOException, 
                                                            HttpMessageNotWritableException;

}        
</code></pre><p>Spring MVC对<code>HttpMessageConverter</code>有多种默认实现，基本上不需要自己再自定义<code>HttpMessageConverter</code><br>&gt;</p>
<ul>
<li>StringHttpMessageConverter - converts strings</li>
<li>FormHttpMessageConverter - converts form data to/from a MultiValueMap<string, string=""></string,></li>
<li>ByteArrayMessageConverter - converts byte arrays</li>
<li>SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source</li>
<li>RssChannelHttpMessageConverter - convert to/from RSS feeds</li>
<li>MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson’s ObjectMapper</li>
<li>etc…</li>
</ul>
<p>然而对于RESTful应用，用的最多的当然是<code>MappingJacksonHttpMessageConverter</code>。</p>
<p>但是<code>MappingJacksonHttpMessageConverter</code>不是默认的<code>HttpMessageConverter</code>：</p>
<pre><code>public class AnnotationMethodHandlerAdapter extends WebContentGenerator
implements HandlerAdapter, Ordered, BeanFactoryAware {

    ...

    public AnnotationMethodHandlerAdapter() {
        // no restriction of HTTP methods by default
        super(false);

        // See SPR-7316
        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
        stringHttpMessageConverter.setWriteAcceptCharset(false);
        this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,
        new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};
    }
}   
</code></pre><p>如上：默认的<code>HttpMessageConverter</code>是<code>ByteArrayHttpMessageConverter</code>、<code>stringHttpMessageConverter</code>、<code>SourceHttpMessageConverter</code>和<code>XmlAwareFormHttpMessageConverter</code>转换器。所以需要配置一下：</p>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;list&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
        &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;text/plain;charset=GBK&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot; /&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>配置好了之后，就可以享受<code>@Requestbody</code>和<code>@ResponseBody</code>对JONS转换的便利之处了：</p>
<pre><code>@RequestMapping(value = &quot;api&quot;, method = RequestMethod.POST)
@ResponseBody
public boolean addApi(@RequestBody
    Api api, @RequestParam(value = &quot;afterApiId&quot;, required = false)
    Integer afterApiId) {
        Integer id = apiMetadataService.addApi(api);
        return id &gt; 0;
}

@RequestMapping(value = &quot;api/{apiId}&quot;, method = RequestMethod.GET)
@ResponseBody
public Api getApi(@PathVariable(&quot;apiId&quot;)
    int apiId) {
        return apiMetadataService.getApi(apiId, Version.primary);
}
</code></pre><p>一般情况下我们是不需要自定义<code>HttpMessageConverter</code>，不过对于Restful应用，有时候我们需要返回jsonp数据：</p>
<pre><code>package me.arganzheng.study.springmvc.util;

import java.io.IOException;
import java.io.PrintStream;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

public class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {

    public MappingJsonpHttpMessageConverter() {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));
    setObjectMapper(objectMapper);
    }

    @Override
    protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    String jsonpCallback = null;

    RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();
    if(reqAttrs instanceof ServletRequestAttributes){
        jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(&quot;jsonpCallback&quot;);
    }

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).print(jsonpCallback + &quot;(&quot;);
    }

    super.writeInternal(o, outputMessage);

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).println(&quot;);&quot;);
    }
    }
}
</code></pre><p>如果请求的参数中带有<code>jsonpCallback</code>，那么会返回jsonp格式数据。比如：<br><a href="http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。" target="_blank" rel="external">http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。</a><br>会返回<code>clientFunction(…);</code></p>
<h3 id="5-CookieValue"><a href="#5-CookieValue" class="headerlink" title="5. @CookieValue"></a>5. <code>@CookieValue</code></h3><p><code>@CookieValue</code>用于将请求的Cookie数据映射到功能处理方法的参数上。</p>
<pre><code>public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId){
    ...
}
</code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>
<pre><code>public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId){
    ...
}
</code></pre><p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>
<p><strong>TIPS</strong> 如果是使用cookies值来保持回话状态的话，推荐使用Spring的<a href="http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html" target="_blank" rel="external">Bean Scopes</a>机制，具体参见笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/spring-bean-scopes.html" target="_blank" rel="external">Spring的Bean Scopes</a>。非常方便。</p>
<h3 id="6-RequestHeader"><a href="#6-RequestHeader" class="headerlink" title="6. @RequestHeader"></a>6. <code>@RequestHeader</code></h3><p><code>@RequestHeader</code>用于将请求的头信息区数据映射到功能处理方法的参数上。</p>
<pre><code>@RequestMapping(value=&quot;/header&quot;)  
public String test(  
   @RequestHeader(&quot;User-Agent&quot;) String userAgent,  
   @RequestHeader(value=&quot;Accept&quot;) String[] accepts)  
</code></pre><p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。</p>
<h3 id="7-返回多种表现形式-Returning-multiple-representations"><a href="#7-返回多种表现形式-Returning-multiple-representations" class="headerlink" title="7. 返回多种表现形式(Returning multiple representations)"></a>7. 返回多种表现形式(Returning multiple representations)</h3><p>对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？</p>
<p>一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：</p>
<ol>
<li>使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如<a href="http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式" target="_blank" rel="external">http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式</a>.</li>
<li>使用一个请求参数告诉服务器希望得到的资源格式。如format=json。</li>
<li>使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求<a href="http://blog.arganzheng.me/users/argan，如果带上`text/xml`" target="_blank" rel="external">http://blog.arganzheng.me/users/argan，如果带上`text/xml`</a> accept header表示请求一个XML资源，带上<code>application/pdf</code>则表示期望收到pdf格式资源。</li>
</ol>
<p>这其实就是Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>Spring提供了<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html" target="_blank" rel="external"><code>ContentNegotiatingViewResolver</code></a>来解决这个问题：</p>
<pre><code>public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {

    private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);

    private static final String ACCEPT_HEADER = &quot;Accept&quot;;

    private static final boolean jafPresent =
        ClassUtils.isPresent(&quot;javax.activation.FileTypeMap&quot;, ContentNegotiatingViewResolver.class.getClassLoader());

    private static final UrlPathHelper urlPathHelper = new UrlPathHelper();


    private int order = Ordered.HIGHEST_PRECEDENCE;

    private boolean favorPathExtension = true;

    private boolean favorParameter = false;

    private String parameterName = &quot;format&quot;;

    private boolean useNotAcceptableStatusCode = false;

    private boolean ignoreAcceptHeader = false;

    private boolean useJaf = true;

    private ConcurrentMap&lt;String, MediaType&gt; mediaTypes = new ConcurrentHashMap&lt;String, MediaType&gt;();

    private List&lt;View&gt; defaultViews;

    private MediaType defaultContentType;

    private List&lt;ViewResolver&gt; viewResolvers;


    // ignore some setter and getter...    

    public void setMediaTypes(Map&lt;String, String&gt; mediaTypes) {
      Assert.notNull(mediaTypes, &quot;&apos;mediaTypes&apos; must not be null&quot;);
      for (Map.Entry&lt;String, String&gt; entry : mediaTypes.entrySet()) {
        String extension = entry.getKey().toLowerCase(Locale.ENGLISH);
        MediaType mediaType = MediaType.parseMediaType(entry.getValue());
        this.mediaTypes.put(extension, mediaType);
      }
    }

    public void setDefaultViews(List&lt;View&gt; defaultViews) {
      this.defaultViews = defaultViews;
    }

    public void setDefaultContentType(MediaType defaultContentType) {
      this.defaultContentType = defaultContentType;
    }

    public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {
      this.viewResolvers = viewResolvers;
    }


    @Override
    protected void initServletContext(ServletContext servletContext) {
      if (this.viewResolvers == null) {
        Map&lt;String, ViewResolver&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);
        this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.size());
        for (ViewResolver viewResolver : matchingBeans.values()) {
          if (this != viewResolver) {
            this.viewResolvers.add(viewResolver);
          }
        }
      }
      if (this.viewResolvers.isEmpty()) {
        logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &quot; +
            &quot;&apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);
      }
      OrderComparator.sort(this.viewResolvers);
    }

    public View resolveViewName(String viewName, Locale locale) throws Exception {
      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
      Assert.isInstanceOf(ServletRequestAttributes.class, attrs);
      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
      if (requestedMediaTypes != null) {
        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
        View bestView = getBestView(candidateViews, requestedMediaTypes);
        if (bestView != null) {
          return bestView;
        }
      }
      if (this.useNotAcceptableStatusCode) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
        }
        return NOT_ACCEPTABLE_VIEW;
      }
      else {
        logger.debug(&quot;No acceptable view found; returning null&quot;);
        return null;
      }
    }


    protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {
      if (this.favorPathExtension) {
        String requestUri = urlPathHelper.getRequestUri(request);
        String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);
        MediaType mediaType = getMediaTypeFromFilename(filename);
        if (mediaType != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on filename &apos;&quot; + filename + &quot;&apos;)&quot;);
          }
          return Collections.singletonList(mediaType);
        }
      }
      if (this.favorParameter) {
        if (request.getParameter(this.parameterName) != null) {
          String parameterValue = request.getParameter(this.parameterName);
          MediaType mediaType = getMediaTypeFromParameter(parameterValue);
          if (mediaType != null) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on parameter &apos;&quot; +
                  this.parameterName + &quot;&apos;=&apos;&quot; + parameterValue + &quot;&apos;)&quot;);
            }
            return Collections.singletonList(mediaType);
          }
        }
      }
      if (!this.ignoreAcceptHeader) {
        String acceptHeader = request.getHeader(ACCEPT_HEADER);
        if (StringUtils.hasText(acceptHeader)) {
          try {
                      List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(acceptHeader);
                      MediaType.sortByQualityValue(mediaTypes);
                      if (logger.isDebugEnabled()) {
                          logger.debug(&quot;Requested media types are &quot; + mediaTypes + &quot; (based on Accept header)&quot;);
                      }
                      return mediaTypes;
          }
          catch (IllegalArgumentException ex) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Could not parse accept header [&quot; + acceptHeader + &quot;]: &quot; + ex.getMessage());
            }
            return null;
          }
        }
      }
      if (this.defaultContentType != null) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;Requested media types is &quot; + this.defaultContentType +
              &quot; (based on defaultContentType property)&quot;);
        }
        return Collections.singletonList(this.defaultContentType);
      }
      else {
        return Collections.emptyList();
      }
    }


    protected MediaType getMediaTypeFromFilename(String filename) {
      String extension = StringUtils.getFilenameExtension(filename);
      if (!StringUtils.hasText(extension)) {
        return null;
      }
      extension = extension.toLowerCase(Locale.ENGLISH);
      MediaType mediaType = this.mediaTypes.get(extension);
      if (mediaType == null &amp;&amp; this.useJaf &amp;&amp; jafPresent) {
        mediaType = ActivationMediaTypeFactory.getMediaType(filename);
        if (mediaType != null) {
          this.mediaTypes.putIfAbsent(extension, mediaType);
        }
      }
      return mediaType;
    }


    protected MediaType getMediaTypeFromParameter(String parameterValue) {
      return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));
    }

    private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)
        throws Exception {

      List&lt;View&gt; candidateViews = new ArrayList&lt;View&gt;();
      for (ViewResolver viewResolver : this.viewResolvers) {
        View view = viewResolver.resolveViewName(viewName, locale);
        if (view != null) {
          candidateViews.add(view);
        }
        for (MediaType requestedMediaType : requestedMediaTypes) {
          List&lt;String&gt; extensions = getExtensionsForMediaType(requestedMediaType);
          for (String extension : extensions) {
            String viewNameWithExtension = viewName + &quot;.&quot; + extension;
            view = viewResolver.resolveViewName(viewNameWithExtension, locale);
            if (view != null) {
              candidateViews.add(view);
            }
          }

        }
      }
      if (!CollectionUtils.isEmpty(this.defaultViews)) {
        candidateViews.addAll(this.defaultViews);
      }
      return candidateViews;
    }

    private List&lt;String&gt; getExtensionsForMediaType(MediaType requestedMediaType) {
      List&lt;String&gt; result = new ArrayList&lt;String&gt;();
      for (Entry&lt;String, MediaType&gt; entry : this.mediaTypes.entrySet()) {
        if (requestedMediaType.includes(entry.getValue())) {
          result.add(entry.getKey());
        }
      }
      return result;
    }

    private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes) {
      MediaType bestRequestedMediaType = null;
      View bestView = null;
      for (MediaType requestedMediaType : requestedMediaTypes) {
        for (View candidateView : candidateViews) {
          if (StringUtils.hasText(candidateView.getContentType())) {
            MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
            if (requestedMediaType.includes(candidateContentType)) {
              bestRequestedMediaType = requestedMediaType;
              bestView = candidateView;
              break;
            }
          }
        }
        if (bestView != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Returning [&quot; + bestView + &quot;] based on requested media type &apos;&quot; +
                bestRequestedMediaType + &quot;&apos;&quot;);
          }
          break;
        }
      }
      return bestView;

    }

    ...

}
</code></pre><p>可以看到<code>ContentNegotiationViewResolver</code>有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。</p>
<p>所以关键在两点：</p>
<h4 id="1-content-negotiation策略-ContentNegotiationStrategy"><a href="#1-content-negotiation策略-ContentNegotiationStrategy" class="headerlink" title="1. content negotiation策略 (ContentNegotiationStrategy)"></a>1. content negotiation策略 (<code>ContentNegotiationStrategy</code>)</h4><blockquote>
<p>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:</p>
<ol>
<li>If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.</li>
<li>If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.</li>
<li>If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.</li>
<li>If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.</li>
</ol>
<p>Once the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view’s content type). The most compatible view is returned.</p>
</blockquote>
<p>这个就是上面提到的Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>关于<code>ContentNegotiationStrategy</code>，可以参考笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html" target="_blank" rel="external">content negotiation using spring mvc</a>。有具体的实际案例。</p>
<h5 id="2-供选择的SingleViewResolver"><a href="#2-供选择的SingleViewResolver" class="headerlink" title="2. 供选择的SingleViewResolver"></a>2. 供选择的SingleViewResolver</h5><blockquote>
<ol>
<li><p>The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)</p>
<p> 说明：即<code>private List&lt;ViewResolver&gt; viewResolvers;</code>属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到<code>ContentNegotiationViewResolover</code>的<code>viewResolvers</code>属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由<code>ContentNegotiationViewResolover</code>来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给<code>ContentNegotiationViewResolover</code>配置最高的order(其实默认就是最高了)。</p>
</li>
<li><p>Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.</p>
<p> 说明：即<code>private List&lt;View&gt; defaultViews;</code>和<code>private MediaType defaultContentType;</code>属性。</p>
</li>
</ol>
</blockquote>
<p>关于<code>ContentNegotiatingViewResolver</code>，下面两篇文章都不错，值得一看：</p>
<ol>
<li><a href="http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html" target="_blank" rel="external">Content Negotiation using Spring MVC’s ContentNegotiatingViewResolver</a>:使用了<code>viewResolvers</code>配置。</li>
<li><a href="http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/" target="_blank" rel="external">ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING’S REST SUPPORT</a>:使用了<code>ViewResolvers</code>配置。</li>
<li><a href="http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/" target="_blank" rel="external">Spring 3 MVC ContentNegotiatingViewResolver Example</a>:使用了<code>defaultViews</code>配置。</li>
</ol>
<p>注意：<code>@ResponseBody</code>是为了单个View准备的，即它只能转换成一种格式，对于<code>ContentNegotiatingViewResolver</code>，需要多个<strong>Single</strong>ViewResolver来接收。</p>
<h3 id="8-客户端调用-Accessing-RESTful-services-on-the-Client"><a href="#8-客户端调用-Accessing-RESTful-services-on-the-Client" class="headerlink" title="8. 客户端调用 Accessing RESTful services on the Client"></a>8. 客户端调用 <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate" target="_blank" rel="external">Accessing RESTful services on the Client</a></h3><p>Spring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。</p>
<p>以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：</p>
<pre><code>String uri = &quot;http://example.com/hotels/1/bookings&quot;;

PostMethod post = new PostMethod(uri);
String request = // create booking request content
post.setRequestEntity(new StringRequestEntity(request));

httpClient.executeMethod(post);

if (HttpStatus.SC_CREATED == post.getStatusCode()) {
  Header location = post.getRequestHeader(&quot;Location&quot;);
  if (location != null) {
    System.out.println(&quot;Created new booking at :&quot; + location.getValue());
  }
}
</code></pre><p>太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a><a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external">RestTemplate</a></h4><p>RestTemplate是client-site HTTP access的核心类。正如它的名称所示，<code>RestTemplate</code>非常类似于<code>JdbcTemplate</code>, <code>JmsTemplate</code>等XXXTemplate。这意味着<code>RestTemplate</code>是线程安全的并且可以通过callback来定制它的行为。</p>
<p><strong>TIPS</strong> Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。</p>
<p>RestTemplate默认使用<code>java.net</code>包下的基础类来创建HTTP请求。你可以实现<code>ClientHttpRequestFactory</code>接口，提供你自己的Http请求工厂类。Spring提供了<code>CommonsClientHttpRequestFactory</code>，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。</p>
<p><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="external">RestTemplate提供的方法如下</a>：</p>
<blockquote>
<p><strong>HTTP Method</strong>    <strong>RestTemplate Method</strong></p>
<ul>
<li>DELETE    delete(String url, String… urlVariables)</li>
<li>GET    getForObject(String url, Class<t> responseType, String… urlVariables)</t></li>
<li>HEAD    headForHeaders(String url, String… urlVariables)</li>
<li>OPTIONS    optionsForAllow(String url, String… urlVariables)</li>
<li>POST    postForLocation(String url, Object request, String… urlVariables)</li>
<li>PUT    put(String url, Object request, String…urlVariables)</li>
<li>ANY    exchange(String, HttpMethod, HttpEntity, Class, Object…)<pre><code>execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)
</code></pre></li>
</ul>
</blockquote>
<p>方法名称很有规律，都是这个pattern——<code>${HTTP Method}${WhatIsReturne}</code>。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.</p>
<p>其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过<code>HttpMessageConverter</code>来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的<code>@RequestBody</code>和<code>@ResponseBody</code>是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。</p>
<p>另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得<code>@PathVariable</code>吗:)哦。参数有两种方式绑定值：</p>
<ol>
<li><p>作为字符串变量数组(String variable arguments array)</p>
<pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, &quot;42&quot;, &quot;21&quot;);
</code></pre><p> 会转换为一个对<code>http://example.com/hotels/42/bookings/21</code>的GET请求。</p>
</li>
<li><p>或者Map对象(Map)</p>
<p>The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.</p>
<pre><code>Map&lt;String, String&gt; vars = new HashMap&lt;String, String&gt;();
vars.put(&quot;hotel&quot;, &quot;42&quot;);
vars.put(&quot;booking&quot;, &quot;21&quot;);
String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, vars);
会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。
</code></pre></li>
</ol>
<p>关于RestTemplate使用的具体例子可以参考这篇文章<a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external"><br>REST IN SPRING 3: RESTTEMPLATE</a>。写的非常好，强烈推荐！</p>
<h3 id="9-支持RESTful的URL"><a href="#9-支持RESTful的URL" class="headerlink" title="9. 支持RESTful的URL"></a>9. 支持RESTful的URL</h3><p>在开发功能模块之前，应该先把URL设计好。比查对 <strong>消息</strong> 这个资源的操作URL可以这么设计：</p>
<pre><code>http://arganzheng.me/messages/show/123456
http://arganzheng.me/messages/preview/123456
http://arganzheng.me/messages/delete/123456
http://arganzheng.me/messages/new
http://arganzheng.me/message/update
</code></pre><p>说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。</p>
<p>要支持这种URL，web.xml需要这么配置：</p>
<pre><code>&lt;!-- REST servlet-mapping --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;srvlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;srvlet-mapping&gt;
</code></pre><p>但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources" target="_blank" rel="external">16.14.5 Configuring Serving of Resources</a>：</p>
<pre><code>&lt;!-- Forwards requests to the &quot;/&quot; resource to the &quot;welcome&quot; view --&gt;
  &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;

  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory --&gt;
  &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt;
  &lt;!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 
      @see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined 
  --&gt;
  &lt;mvc:annotation-driven /&gt;
</code></pre><p>这样所有请求：<code>http://arganzheng.me/resources/**</code>会映射到webapp下的resources目录，而不是找我们的controller处理。</p>
<p>但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个<code>&lt;mvc:annotation-driven /&gt;</code>配置。具体参见<a href="http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined" target="_blank" rel="external">The handler mapping from the mvc:resource override other mappings which defined with annotation</a>。</p>
<p>另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：<a href="http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：" target="_blank" rel="external">http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：</a></p>
<pre><code>&lt;!-- 避免被Spring DispatcherServlet接管 --&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;default&lt;srvlet-name&gt;
      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
  &lt;srvlet-mapping&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring MVC本身对Restful支持非常好。它的&lt;code&gt;@RequestMapping&lt;/code&gt;、&lt;code&gt;@RequestParam&lt;/code&gt;、&lt;code&gt;@PathVariable&lt;/code&gt;、&lt;code&gt;@ResponseBody&lt;/code&gt;
    
    </summary>
    
      <category term="spring" scheme="http://www.shenyanchao.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="http://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="restful" scheme="http://www.shenyanchao.cn/tags/restful/"/>
    
      <category term="mvc" scheme="http://www.shenyanchao.cn/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>关于C3P0容错和自动重连特性的研究</title>
    <link href="http://www.shenyanchao.cn/2015/03/26/2015-03-26-c3p0-config/"/>
    <id>http://www.shenyanchao.cn/2015/03/26/2015-03-26-c3p0-config/</id>
    <published>2015-03-26T05:07:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。</p>
<p>####1）C3P0容错和自动重连与以下配置参数有关：</p>
<p><code>breakAfterAcquireFailure</code> ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false<br><a id="more"></a><br><code>idleConnectionTestPeriod</code> ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。</p>
<p><code>testConnectionOnCheckout</code> ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。</p>
<p><code>testConnectionOnCheckin</code> ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。</p>
<p><code>acquireRetryAttempts 和acquireRetryDelay</code> ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数&gt;池内能提供的连接数</p>
<p><code>automaticTestTable 、connectionTesterClassName 、preferredTestQuery</code> ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释</p>
<p><code>maxIdleTime 和 maxConnectionAge</code> ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间</p>
<p>####2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。</p>
<p>####3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection</p>
<p>####4）breakAfterAcquireFailure=false是关键。<br>如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接</p>
<p>####5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。</p>
<p>####6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性</p>
<p>####7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行</p>
<p>综上所述，要想保证性能的前提下，本人推荐的配置组合如下：</p>
<pre><code>breakAfterAcquireFailure: false
testConnectionOnCheckout: false
testConnectionOnCheckin: false
idleConnectionTestPeriod: 60
acquireRetryAttempts: 10
acquireRetryDelay: 1000
</code></pre><p>但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。</p>
<p>在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：</p>
<ul>
<li><p>1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。</p>
</li>
<li><p>2）根据请求情况和配置，pool向数据库请求新连接并加入池内</p>
</li>
<li><p>3）应用端getConnection-&gt;是否发生异常-&gt;如果发生异常，检验其有效性，并剔除出pool-&gt;如果没有发生异常（自动检查task之前已检测），调用成功</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。&lt;/p&gt;
&lt;p&gt;####1）C3P0容错和自动重连与以下配置参数有关：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breakAfterAcquireFailure&lt;/code&gt; ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false&lt;br&gt;
    
    </summary>
    
      <category term="c3p0" scheme="http://www.shenyanchao.cn/categories/c3p0/"/>
    
    
      <category term="c3p0" scheme="http://www.shenyanchao.cn/tags/c3p0/"/>
    
      <category term="dhcp" scheme="http://www.shenyanchao.cn/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>如何在Solr中更好的处理同义词</title>
    <link href="http://www.shenyanchao.cn/2014/11/25/2014-11-25-better-synonym-handling-in-solr/"/>
    <id>http://www.shenyanchao.cn/2014/11/25/2014-11-25-better-synonym-handling-in-solr/</id>
    <published>2014-11-25T05:53:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?</p>
<p><img src="/images/blog/2014/File-Licking_the_staffy_pup.JPG" alt="小狗"></p>
<p>叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。</p>
<p>事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。</p>
<a id="more"></a>
<p>###The SynonymFilterFactory</p>
<p>Solr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。   </p>
<p>举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。</p>
<p>当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。</p>
<p>###Index-time vs. query-time</p>
<p>下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。</p>
<p><img src="/images/blog/2014/index_vs_query_expansion2.png" alt="Index-time vs. query-time expansion."></p>
<p>你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：</p>
<ul>
<li>索引大小不会变化</li>
<li>同义词可以随时更换，不用更新索引</li>
<li>同义词实时生效，不需要重新索引</li>
</ul>
<p>然而，按<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory" target="_blank" rel="external">Solr Docs</a>所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：</p>
<ul>
<li>多字同义词并不能识别为短语查询</li>
<li>罕见同义词的IDF会被加权，导致不可想象的搜索结果</li>
<li>多字同义词不会匹配查询</li>
</ul>
<p>这有点复杂，因此也值得我们一一解决这些问题。</p>
<p>###多字同义词并不能识别为短语查询</p>
<p>在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词： </p>
<pre><code>breast neoplasm
breast neoplasms
breast tumor
breast tumors
cancer of breast
cancer of the breast
</code></pre><p>因此在正常情况下，如果SynonymFilterFactory配置了<code>expand=&quot;true&quot;</code>,查询”breast cancer“就变成了： </p>
<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)
</code></pre><p>这将命中包含”breast neoplasms“,”cancer of the breast”等等的文档。</p>
<p>然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。</p>
<p>啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：</p>
<p><img src="/images/blog/2014/graph11.png" alt=""></p>
<p>但是，它真正构建的是下面这样的：   </p>
<p><img src="/images/blog/2014/graph22.png" alt=""></p>
<p>简直是一碗意大利面。</p>
<p>你可怜的文档必须依序包含所有的4个部分。让人惊讶。</p>
<p>同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置<code>mm=100%</code>将需要所有4个部分都匹配。</p>
<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4
</code></pre><h3 id="罕见同义词的IDF会被加权"><a href="#罕见同义词的IDF会被加权" class="headerlink" title="罕见同义词的IDF会被加权"></a>罕见同义词的IDF会被加权</h3><p>即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog”,”hound”,”pooch”例子，查询3个里面的任意一个都会被扩展为：</p>
<pre><code>+(dog hound pooch)
</code></pre><p>由于“hound”和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。</p>
<p>索引时扩展通过给”dog”,”hound”,”pooch”赋予相同的IDF值，而不管原始文档是什么。</p>
<p>###多字同义词不会匹配查询<br>最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。  </p>
<p>比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[“cancer”,”of”,”the”,”breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。</p>
<p>###其他问题<br>最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。   </p>
<p>当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。</p>
<p><img src="/images/blog/2014/breast_cancer_highlighting2.png" alt=""></p>
<p>看完这个<a href="https://issues.apache.org/jira/browse/SOLR-3390" target="_blank" rel="external">solr bug</a>,这和前面提到的Solr多字同义词扩展是一个原因。</p>
<p>使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。</p>
<p><img src="/images/blog/2014/graph33.png" alt=""></p>
<p>这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。</p>
<p>从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。</p>
<p>查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。</p>
<p>###总结</p>
<p>所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。</p>
<p>总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。   </p>
<p><strong>Index-time</strong></p>
<ul>
<li>索引爆炸</li>
<li>同义词不能立即生效，所有文档需重新索引</li>
<li>同义词不能立即删除</li>
<li>多字同义词导致多余的文字被高亮</li>
</ul>
<p><strong>Query-time</strong></p>
<ul>
<li>短语查询不支持</li>
<li>罕见同义词被认为加权了</li>
<li>多字同义词不匹配查询</li>
</ul>
<p>我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。</p>
<p>回到”dog“/“hound”/“pooch”的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy &amp; Scratchy &amp; Poochy Show”). 一视同仁感觉是错误的。</p>
<p>同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。  </p>
<p>在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。 </p>
<p>###Solution</p>
<p>我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。</p>
<p>因此，搜索“dog”为被解析为类似这样：   </p>
<pre><code>+((dog)^1.2 (hound pooch)^1.1)
</code></pre><p>1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,”hound”或者“pooch”，但是“dog”更优先显示。</p>
<p>这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：   </p>
<pre><code>+((&quot;breast cancer&quot;)^1.2 ((&quot;breast neoplasm&quot;) (&quot;breast tumor&quot;) (&quot;cancer ? breast&quot;) (&quot;cancer ? ? breast&quot;))^1.1)
</code></pre><p>(问号?的出现是由于停用词“of”和“the”)</p>
<p>这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。  </p>
<p>我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：</p>
<pre><code>dog,hound,pooch
bite,nibble
</code></pre><p>… then the query will be expanded into:</p>
<p>查询将会被扩展为：</p>
<pre><code>dog bite
hound bite
pooch bite
dog nibble
hound nibble
pooch nibble
</code></pre><a href="!--

###尝试一下

使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms">!--

###尝试一下

使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms</a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>—<br>原文：<a href="http://nolanlawson.com/2012/10/31/better-synonym-handling-in-solr/" target="_blank" rel="external">Better synonym handling in Solr</a><br><br>–&gt;]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2014/File-Licking_the_staffy_pup.JPG&quot; alt=&quot;小狗&quot;&gt;&lt;/p&gt;
&lt;p&gt;叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。&lt;/p&gt;
&lt;p&gt;事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。&lt;/p&gt;
    
    </summary>
    
      <category term="solr" scheme="http://www.shenyanchao.cn/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.shenyanchao.cn/tags/solr/"/>
    
      <category term="lucene" scheme="http://www.shenyanchao.cn/tags/lucene/"/>
    
      <category term="同义词" scheme="http://www.shenyanchao.cn/tags/%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>使用mahout对Sogou语料库进行分类</title>
    <link href="http://www.shenyanchao.cn/2014/11/14/2014-11-14-use-mahout-to-classify-sogou-corpus/"/>
    <id>http://www.shenyanchao.cn/2014/11/14/2014-11-14-use-mahout-to-classify-sogou-corpus/</id>
    <published>2014-11-14T05:26:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###软件版本</p>
<ul>
<li>Ubuntu Linux</li>
<li><a href="http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz" target="_blank" rel="external">mahout-0.9</a>,本文写作的时候的最新版本</li>
<li><a href="http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz" target="_blank" rel="external">Sogou语料库</a>精简版</li>
<li><a href="https://github.com/blueshen/ik-analyzer" target="_blank" rel="external">ik-analyzer</a>, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。</li>
</ul>
<p>###Sogou语料库处理<br>下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.<br>语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：</p>
<pre><code>find sogou -type d -exec mkdir -p utf/{} \;
find sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \;
</code></pre><p>###使用mahout生成sequence file<br>进入utf/sogou目录，执行：</p>
<pre><code>mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow
</code></pre><p>生成的sequence file存放在sogou-seq目录内。<br>可以通过seqdumper命令查看：<br><a id="more"></a><br>    mahout seqdumper -i sogou-seq/part-m-00000 | more<br><img src="/images/blog/2014/sogou-seqfile.png" alt=""></p>
<p>如果是在hadoop上跑，可以这样看。</p>
<pre><code>hadoop fs -text sogou-seq/part-m-00000 | more
</code></pre><p>###使用seq2sparse生成Vectors<br>执行命令：</p>
<pre><code>mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow
</code></pre><p>查看生成的vector</p>
<p>mahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more</p>
<p><img src="/images/blog/2014/sogou-vector.png" alt=""></p>
<p>需要注意的是<code>org.wltea.analyzer.lucene.IKAnalyzer</code>，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code>，空格分割明显不适用中文。</p>
<p>###切分训练集和测试集</p>
<pre><code>mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential
</code></pre><p>###使用Native Bayes训练model</p>
<pre><code>mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c
</code></pre><p>###使用测试集来查看效果</p>
<pre><code>mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c
</code></pre><p><img src="/images/blog/2014/sogou-result.png" alt=""></p>
<p>可以看出87%的正确率还是不错的。</p>
<hr>
<p>参考文档：</p>
<p><a href="http://mahout.apache.org/users/classification/twenty-newsgroups.html" target="_blank" rel="external">http://mahout.apache.org/users/classification/twenty-newsgroups.html</a><br><a href="http://www.sogou.com/labs/dl/c.html" target="_blank" rel="external">http://www.sogou.com/labs/dl/c.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###软件版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu Linux&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz&quot;&gt;mahout-0.9&lt;/a&gt;,本文写作的时候的最新版本&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz&quot;&gt;Sogou语料库&lt;/a&gt;精简版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/blueshen/ik-analyzer&quot;&gt;ik-analyzer&lt;/a&gt;, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###Sogou语料库处理&lt;br&gt;下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.&lt;br&gt;语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find sogou -type d -exec mkdir -p utf/{} \;
find sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###使用mahout生成sequence file&lt;br&gt;进入utf/sogou目录，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成的sequence file存放在sogou-seq目录内。&lt;br&gt;可以通过seqdumper命令查看：&lt;br&gt;
    
    </summary>
    
      <category term="mahout" scheme="http://www.shenyanchao.cn/categories/mahout/"/>
    
    
      <category term="mahout" scheme="http://www.shenyanchao.cn/tags/mahout/"/>
    
      <category term="sogou" scheme="http://www.shenyanchao.cn/tags/sogou/"/>
    
      <category term="ik-analyzer" scheme="http://www.shenyanchao.cn/tags/ik-analyzer/"/>
    
      <category term="ubuntu" scheme="http://www.shenyanchao.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux中文件编码转换</title>
    <link href="http://www.shenyanchao.cn/2014/11/13/2014-11-13-encode-convert-in-linux/"/>
    <id>http://www.shenyanchao.cn/2014/11/13/2014-11-13-encode-convert-in-linux/</id>
    <published>2014-11-13T08:20:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>
<p>Linux命令-enca 查看文件的编码</p>
<p>Enca语法</p>
<pre><code>Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...
        enconv [-L LANGUAGE] [OPTION]... [FILE]...
        Detect encoding of text files and convert them if required.
</code></pre><p>Enca用法</p>
<pre><code>$ enca -L zh_CN file 检查文件的编码
$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&quot;UTF-8&quot;编码
$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样
</code></pre><p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。<br><a id="more"></a><br>转换单个文件的编码</p>
<pre><code>$ enca -L none -x utf-8  index.html
</code></pre><p>转换多个文件的编码</p>
<pre><code>$ enca -x utf-8 *
</code></pre><p>Linux文件名编码批量转换–convmv</p>
<p>Convmv语法</p>
<pre><code>$ convmv -f 源编码 -t 新编码 [选项] 文件名
</code></pre><p>Convmv 常用参数</p>
<pre><code>-r 递归处理子文件夹
–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。
–list 显示所有支持的编码
–unescap 可以做一下转义，比如把%20变成空格
</code></pre><p>示例</p>
<p>转换一个文件由GBK转换成UTF-8</p>
<pre><code>convmv -f GBK -t UTF-8 --notest utf8 filename
</code></pre><p>GBK-&gt;UTF-8文件编码批量转换脚本</p>
<pre><code>$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \;
</code></pre><p>使用iconv 转换</p>
<p>Iconv语法</p>
<pre><code>iconv -f encoding -t encoding inputfile
</code></pre><p>示例</p>
<p>单个文件转换</p>
<pre><code>$ iconv -f GBK -t UTF-8 file1 -o file2
</code></pre><p>批量转换</p>
<pre><code>$ find default -type d -exec mkdir -p utf/{} \;
$ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \;
</code></pre><p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>
<hr>
<p>原文:<a href="http://blog.csdn.net/a280606790/article/details/8504133" target="_blank" rel="external">http://blog.csdn.net/a280606790/article/details/8504133</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&amp;gt;UTF-8文件编码批量转换。&lt;/p&gt;
&lt;p&gt;Linux命令-enca 查看文件的编码&lt;/p&gt;
&lt;p&gt;Enca语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...
        enconv [-L LANGUAGE] [OPTION]... [FILE]...
        Detect encoding of text files and convert them if required.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enca用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ enca -L zh_CN file 检查文件的编码
$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&amp;quot;UTF-8&amp;quot;编码
$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.shenyanchao.cn/categories/linux/"/>
    
    
      <category term="编码" scheme="http://www.shenyanchao.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="enca" scheme="http://www.shenyanchao.cn/tags/enca/"/>
    
      <category term="iconv" scheme="http://www.shenyanchao.cn/tags/iconv/"/>
    
      <category term="convmv" scheme="http://www.shenyanchao.cn/tags/convmv/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop1.2.1安装部署</title>
    <link href="http://www.shenyanchao.cn/2014/11/13/2014-11-13-install-hadoop/"/>
    <id>http://www.shenyanchao.cn/2014/11/13/2014-11-13-install-hadoop/</id>
    <published>2014-11-13T05:24:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###安装需求</p>
<ul>
<li>Java 1.6</li>
<li>ssh,sshd正常安装</li>
</ul>
<p>确保可以ssh到localhost，并且不需要密码</p>
<pre><code>ssh localhost
</code></pre><p> 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。<br> 运行：  </p>
<pre><code>ps -ef | grep sshd 
</code></pre><p>查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。</p>
<pre><code>sudo apt-get install openssh-server
</code></pre><p>然后再执行<code>ssh localhost</code>,如果不能无密码登陆，需要做一下操作：</p>
<pre><code>ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa 
cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre><a id="more"></a>
<p>###相关软件<br>Ubuntu Linux为例：</p>
<pre><code>sudo apt-get install ssh 
sudo apt-get install rsync
</code></pre><p>###Hadoop下载<br>从<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Hadoop官网</a>下载一个稳定版，这里就是1.2.1版本啦。</p>
<pre><code>wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz
</code></pre><p> ###启动Hadoop</p>
<p> 1.解压<code>tar -xzvf hadoop-1.2.1.tar.gz</code>，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。</p>
<pre><code>export JAVA_HOME=/path/to/java/home
</code></pre><p> 2.进入/hadoop-1.2.1目录，运行<code>bin\hadoop</code>,会显示hadoop的使用说明信息。 </p>
<pre><code>  Usage: hadoop [--config confdir] COMMAND
  where COMMAND is one of:
  namenode -format     format the DFS filesystem
  secondarynamenode    run the DFS secondary namenode
  namenode             run the DFS namenode
  datanode             run a DFS datanode
  dfsadmin             run a DFS admin client
  mradmin              run a Map-Reduce admin client
  fsck                 run a DFS filesystem checking utility
  fs                   run a generic filesystem user client
  balancer             run a cluster balancing utility
  oiv                  apply the offline fsimage viewer to an fsimage
  fetchdt              fetch a delegation token from the NameNode
  jobtracker           run the MapReduce job Tracker node
  pipes                run a Pipes job
  tasktracker          run a MapReduce task Tracker node
  historyserver        run job history servers as a standalone daemon
  job                  manipulate MapReduce jobs
  queue                get information regarding JobQueues
  version              print the version
  jar &lt;jar&gt;            run a jar file
  distcp &lt;srcurl&gt; &lt;desturl&gt; copy file or directories recursively
  distcp2 &lt;srcurl&gt; &lt;desturl&gt; DistCp version 2
  archive -archiveName NAME -p &lt;parent path&gt; &lt;src&gt;* &lt;dest&gt; create a hadoop archive
  classpath            prints the class path needed to get the
                       Hadoop jar and the required libraries
  daemonlog            get/set the log level for each daemon
 or
  CLASSNAME            run the class named CLASSNAME
Most commands print help when invoked w/o parameters.
</code></pre><p>  你可以下3中模式来启动hadoop：</p>
<ul>
<li>本地(standalone)模式</li>
<li>伪分布(Pseudo-Distributed)式</li>
<li>全分布(Full-Distributed)式</li>
</ul>
<p>####本地(Standalone)模式安装<br>  默认情况下，Hadoop就是单机本地模式。方便调试。<br>  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录</p>
<pre><code>$ mkdir input 
$ cp conf/*.xml input 
$ bin/hadoop jar hadoop-examples-*.jar grep input output &apos;dfs[a-z.]+&apos; 
$ cat output/*
</code></pre><p>####伪分布(Pseudo-Distributed)式<br>配置conf/core-site.xml</p>
<pre><code>&lt;configuration&gt;
     &lt;property&gt;
         &lt;name&gt;fs.default.name&lt;/name&gt;
         &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;
     &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>配置conf/hdfs-site.xml</p>
<pre><code>&lt;configuration&gt;
     &lt;property&gt;
         &lt;name&gt;dfs.replication&lt;/name&gt;
         &lt;value&gt;1&lt;/value&gt;
     &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>配置conf/mapred-site.xml:</p>
<pre><code>&lt;configuration&gt;
     &lt;property&gt;
         &lt;name&gt;mapred.job.tracker&lt;/name&gt;
         &lt;value&gt;localhost:9001&lt;/value&gt;
     &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>  格式化一个新的distributed-filesystem</p>
<pre><code>bin/hadoop namenode -format
</code></pre><p> 启动hadoop：</p>
<pre><code>bin/start-all.sh
</code></pre><p>  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker</p>
<ul>
<li>NameNode - <a href="http://localhost:50070/dfshealth.jsp/" target="_blank" rel="external">http://localhost:50070/dfshealth.jsp/</a></li>
<li>JobTracker - <a href="http://localhost:50030/jobtracker.jsp/" target="_blank" rel="external">http://localhost:50030/jobtracker.jsp/</a></li>
<li><p>TaskTracker - <a href="http://localhost:50060/tasktracker.jsp" target="_blank" rel="external">http://localhost:50060/tasktracker.jsp</a></p>
<p>下面使用distributed filesystem来跑样例:<br>拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。</p>
<p>  $ bin/hadoop fs -put conf input</p>
</li>
</ul>
<p>运行:<br>    $ bin/hadoop jar hadoop-examples-*.jar grep input output ‘dfs[a-z.]+’</p>
<p>检查结果：</p>
<p>拷贝output目录到本地并检查:<br>    $ bin/hadoop fs -get output output<br>    $ cat output/*</p>
<p>或者直接在distributed filesystem查看: </p>
<pre><code>$ bin/hadoop fs -cat output/*
</code></pre><p>使用完，可以这样来关闭：</p>
<pre><code>$ bin/stop-all.sh
</code></pre><p>####Hadoop分布式部署<br> 详见<a href="http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html</a></p>
<hr>
<p>参考文档：<a href="http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###安装需求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 1.6&lt;/li&gt;
&lt;li&gt;ssh,sshd正常安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保可以ssh到localhost，并且不需要密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh localhost
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。&lt;br&gt; 运行：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep sshd 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后再执行&lt;code&gt;ssh localhost&lt;/code&gt;,如果不能无密码登陆，需要做一下操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t dsa -P &amp;apos;&amp;apos; -f ~/.ssh/id_dsa 
cat ~/.ssh/id_dsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.shenyanchao.cn/categories/hadoop/"/>
    
    
      <category term="linux" scheme="http://www.shenyanchao.cn/tags/linux/"/>
    
      <category term="hadoop" scheme="http://www.shenyanchao.cn/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>oryx介绍</title>
    <link href="http://www.shenyanchao.cn/2014/11/11/2014-11-11-introduce-oryx/"/>
    <id>http://www.shenyanchao.cn/2014/11/11/2014-11-11-introduce-oryx/</id>
    <published>2014-11-11T11:31:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业<a href="https://github.com/myrrix/myrrix-recommender]" target="_blank" rel="external">Myrrix</a>——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。</p>
<p>　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为<a href="https://github.com/cloudera/oryx" target="_blank" rel="external">Oryx</a>的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。</p>
<a id="more"></a>
<p>　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”</p>
<p>　　作为Hadoop当中实现机器学习模式创建的传统途径，<a href="http://mahout.apache.org/" target="_blank" rel="external">Apache Mahout</a>“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。</p>
<p>　　开放而且简便的推荐引擎</p>
<p>　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。</p>
<p>　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。</p>
<p>　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。</p>
<p>　　还只是个项目而非产品</p>
<p>　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”</p>
<p>　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”</p>
<p>　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。</p>
<p>　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”</p>
<p>　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。</p>
<hr>
<p>参考：<br><a href="http://storage.chinabyte.com/134/12873634.shtml" target="_blank" rel="external">http://storage.chinabyte.com/134/12873634.shtml</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业&lt;a href=&quot;https://github.com/myrrix/myrrix-recommender]&quot;&gt;Myrrix&lt;/a&gt;——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。&lt;/p&gt;
&lt;p&gt;　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为&lt;a href=&quot;https://github.com/cloudera/oryx&quot;&gt;Oryx&lt;/a&gt;的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。&lt;/p&gt;
    
    </summary>
    
      <category term="oryx" scheme="http://www.shenyanchao.cn/categories/oryx/"/>
    
    
      <category term="cloudera" scheme="http://www.shenyanchao.cn/tags/cloudera/"/>
    
      <category term="oryx" scheme="http://www.shenyanchao.cn/tags/oryx/"/>
    
      <category term="myrrix" scheme="http://www.shenyanchao.cn/tags/myrrix/"/>
    
  </entry>
  
  <entry>
    <title>solr中的tie breaker</title>
    <link href="http://www.shenyanchao.cn/2014/10/22/2014-10-22-tie-breaker-in-solr/"/>
    <id>http://www.shenyanchao.cn/2014/10/22/2014-10-22-tie-breaker-in-solr/</id>
    <published>2014-10-22T09:14:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>solr 查询参数中有tie这样的一个参数，下面是它的官方解释：</p>
<p><strong>The tie (Tie Breaker) Parameter</strong></p>
<p>The tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.</p>
<p>When a term from the user’s input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.</p>
<p>A value of “0.0” makes the query a pure “disjunction max query”: that is, only the maximum scoring subquery contributes to the final score. A value of “1.0” makes the query a pure “disjunction sum query” where it doesn’t matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.</p>
<p>读起来比较令人费解。</p>
<p>简单解释就是：</p>
<p>这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。</p>
<p>如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.</p>
<p>也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。</p>
<p>通常情况下呢，官方推荐tie=0.1。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solr 查询参数中有tie这样的一个参数，下面是它的官方解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The tie (Tie Breaker) Parameter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The tie parameter specifies a float value
    
    </summary>
    
      <category term="solr" scheme="http://www.shenyanchao.cn/categories/solr/"/>
    
    
      <category term="solr" scheme="http://www.shenyanchao.cn/tags/solr/"/>
    
      <category term="lucene" scheme="http://www.shenyanchao.cn/tags/lucene/"/>
    
      <category term="tie" scheme="http://www.shenyanchao.cn/tags/tie/"/>
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="http://www.shenyanchao.cn/2014/08/27/2014-08-27-java-new-feature/"/>
    <id>http://www.shenyanchao.cn/2014/08/27/2014-08-27-java-new-feature/</id>
    <published>2014-08-27T06:43:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>##Java7新特性</p>
<p>###Java7语法特性<br>根据JSR 334，Java7添加了数个语法方面的新特性：</p>
<p>####1. switch可以消化String</p>
<p>比如：</p>
<pre><code>public static void switchString(String s){
    switch (s){
    case &quot;db&quot;: ...
    case &quot;wls&quot;: ...
    case &quot;ibm&quot;: ...
    case &quot;soa&quot;: ...
    case &quot;fa&quot;: ...
    default: ...
    }
}
</code></pre><a id="more"></a>
<p>####2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。</p>
<ul>
<li><p>a. 表示二进制字面值的前缀, 0b:<br>比如以下三个变量的值相同：</p>
<pre><code>byte b1 = 0b00100001;     // New
byte b2 = 0x21;        // Old
byte b3 = 33;        // Old
</code></pre></li>
<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>
<pre><code>long phone_nbr = 021_1111_2222;
</code></pre></li>
</ul>
<p>####3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价：</p>
<pre><code>ArrayList&lt;String&gt; al1 = new ArrayList&lt;String&gt;();    // Old
ArrayList&lt;String&gt; al2 = new ArrayList&lt;&gt;();        // New
</code></pre><p>####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</p>
<pre><code>ClassNotFoundException, 
IllegalAccessException, 
InstantiationException, 
InvocationTargetException, 
NoSuchFieldException, 
NoSuchMethodException
</code></pre><p>####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</p>
<pre><code>try{
    // code
}
catch (SQLException | IOException ex) {
    // ...
}
</code></pre><p>####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</p>
<pre><code>public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类
    try{
        // code
    }
    catch (RelectiveOperationException ex){    // 父类
        throws ex;
    }
}
</code></pre><p>####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“：<br>    try(BufferedReader br = new BufferedReader(new FileReader(“/home/oracle/temp.txt”))){<br>        … br.readLine() …<br>    }<br>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>
<p>###Java7 NIO 新方法<br>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>
<p>####1.增加<code>java.nio.file.Paths</code>用于目录操作</p>
<pre><code>Path path = Paths.get(&quot;/home/shenyanchao&quot;, &quot;Desktop&quot;);
System.out.println(path.toAbsolutePath());
System.out.println(path.getParent());
System.out.println(path.getFileSystem().isOpen());
</code></pre><p>####2.增加<code>java.nio.file.Files</code>工具类来处理文件</p>
<pre><code>Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);

Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);

Files.createLink(src,dest);
Files.createSymbolicLink(src,dest);
Files.deleteIfExists(dest);

Files.readAllLines(src);

Files.createTempFile(src,&quot;aa&quot;,&quot;bb&quot;);
</code></pre><p>####3.目录树遍历<br>使用<code>FileVisitor</code>来实现访问者模式。</p>
<pre><code>preVisitDirectory(T dir, BasicFileAttributes attrs);
visitFile(T dir, BasicFileAttributes attrs);
visitFileFailed(T dir, IOException exc);
postVisitDirectory(T dir, IOException exc);
</code></pre><p>####4.使用WatchService来监控目录，变化请通知</p>
<pre><code>WatchService watchService = FileSystems.getDefault().newWatchService();
Path path = Paths.get(&quot;/home/shenyanchao/Documents&quot;);
WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
        StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
while (true) {
    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();
    for (WatchEvent&lt;?&gt; watchEvent : watchEvents) {
        System.out.printf(&quot;[%s]文件发生了[%s]事件。%n&quot;, watchEvent.context(), watchEvent.kind());
    }
    boolean valid = watchKey.reset();
    if (!valid){
        break;
    }
}
</code></pre><p>###Java7并发（JSR166Y）</p>
<p>####Fork Join框架，大任务分解为小任务<br>通过ForkJoinPool，ForkJoinTask来实现的。</p>
<pre><code>public class Fibonacci extends RecursiveTask&lt;Integer&gt; {

    final int n;

    Fibonacci(int n) {
        this.n = n;
    }

    @Override
    protected Integer compute() {
        if (n &lt;= 1)
            return n;
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();
        Fibonacci f2 = new Fibonacci(n - 2);
        f2.fork();
        return f1.join() + f2.join();
    }

    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci(4);
        System.out.println(fibonacci.compute());
    }
}
</code></pre><p>####TransferQueue，ConcurrentLinkedDeque等新类<br>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>
<p>####ThreadLocalRandom用于生成随机数</p>
<pre><code>ThreadLocalRandom.current().nextInt (...)
</code></pre><p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>
<p>###Java7 client<br>诸如更新了很多swing显示相关的api.<br>更好的支持linux fonts</p>
<p>###Java7 VM新特性</p>
<p>####1.引入Garbage First回收算法<br>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>
<hr>
<p>参考文档：<a href="http://www.slideshare.net/boulderjug/55-things-in-java-7" target="_blank" rel="external">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>
<p>##Java8新特性</p>
<p>###1.接口默认方法[接口允许有实现啦]<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>
<pre><code>interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
</code></pre><p>###2.Lambda表达式<br>据说借鉴了各种动态语言的新特性，比如scala，python<br>首先看看在老版本的Java中是如何排列字符串的：</p>
<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&lt;String&gt;() {
@Override
public int compare(String a, String b) {
    return b.compareTo(a);
}
});
</code></pre><p>Java 8 提供了更为简介的语法，lambda表达式：</p>
<pre><code>Collections.sort(names, (String a, String b) -&gt; {
    return b.compareTo(a);
});
</code></pre><p>可以更短：</p>
<pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
</code></pre><p>再短： </p>
<pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</code></pre><p>###3.@FunctionalInterface<br>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>
<pre><code>@FunctionalInterface
interface Converter&lt;F, T&gt; {
    T convert(F from);
}

Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123
</code></pre><p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>
<p>####(1)方法与构造函数的引用::<br>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>
<pre><code>Converter&lt;String, Integer&gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123
</code></pre><p>当然也可以引用一个对象的方法：</p>
<pre><code>converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;
</code></pre><p>那么如何引用构造函数呢？</p>
<pre><code>class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre><p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>
<pre><code>interface PersonFactory&lt;P extends Person&gt; {
    P create(String firstName, String lastName);
}
</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);
</code></pre><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<p>####(2)内嵌的Functional Interfaces<br>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>
<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>
<ul>
<li>Predicates   </li>
</ul>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;

predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false

Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;
Predicate&lt;Boolean&gt; isNull = Objects::isNull;

Predicate&lt;String&gt; isEmpty = String::isEmpty;
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();
</code></pre><ul>
<li>Function</li>
</ul>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<pre><code>Function&lt;String, Integer&gt; toInteger = Integer::valueOf;
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);

backToString.apply(&quot;123&quot;);     // &quot;123&quot;
</code></pre><ul>
<li>Supplier</li>
</ul>
<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>
<pre><code>Supplier&lt;Person&gt; personSupplier = Person::new;
personSupplier.get();   // new Person
</code></pre><ul>
<li>Consumer</li>
</ul>
<p>Consumer在一个输入参数上做一些操作。</p>
<pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));
</code></pre><ul>
<li>Comparator</li>
</ul>
<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>
<pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);

Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);

comparator.compare(p1, p2);             // &gt; 0
comparator.reversed().compare(p1, p2);  // &lt; 0
</code></pre><ul>
<li>Optional</li>
</ul>
<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>
<pre><code>Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);

optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;

optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
</code></pre><ul>
<li>Stream</li>
</ul>
<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。<br>首先，新建一个数组。</p>
<pre><code>List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
stringCollection.add(&quot;ddd2&quot;);
stringCollection.add(&quot;aaa2&quot;);
stringCollection.add(&quot;bbb1&quot;);
stringCollection.add(&quot;aaa1&quot;);
stringCollection.add(&quot;bbb3&quot;);
stringCollection.add(&quot;ccc&quot;);
stringCollection.add(&quot;bbb2&quot;);
stringCollection.add(&quot;ddd1&quot;);
</code></pre><p>具体使用如下：</p>
<pre><code>stringCollection
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa1&quot;, &quot;aaa2&quot;
</code></pre><p>map()函数可以把每个值转换为另外的值。</p>
<pre><code>stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);

// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;        
</code></pre><p>另外提供有各种match方法。</p>
<pre><code>boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));

System.out.println(noneStartsWithZ);      // true
</code></pre><p>count()方法返回的是一个值。</p>
<pre><code>long startsWithB =
    stringCollection
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();

System.out.println(startsWithB);    // 3        
</code></pre><p>reduce则进行了归一化处理：</p>
<pre><code>Optional&lt;String&gt; reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);

reduced.ifPresent(System.out::println);
// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;
</code></pre><ul>
<li>ParallelStream </li>
</ul>
<p>它是一个并行的。速度要比stream快的多。</p>
<ul>
<li>Map</li>
</ul>
<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>
<pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

for (int i = 0; i &lt; 10; i++) {
    map.putIfAbsent(i, &quot;val&quot; + i);
}

map.forEach((id, val) -&gt; System.out.println(val));

map.computeIfPresent(3, (num, val) -&gt; val + num);
map.get(3);             // val33

map.computeIfPresent(9, (num, val) -&gt; null);
map.containsKey(9);     // false

map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);
map.containsKey(23);    // true

map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);
map.get(3);             // val33

map.remove(3, &quot;val3&quot;);
map.get(3);             // val33

map.remove(3, &quot;val33&quot;);
map.get(3);             // null

map.getOrDefault(42, &quot;not found&quot;);  // not found

map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9

map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9concat
</code></pre><p>###4.时间API<br>Java8更新了Date API,这个新的api与joda-time类似。</p>
<p>####(1)Clock<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<pre><code>Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // legacy java.util.Date
</code></pre><p>####(2)TimeZones<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>
<pre><code>System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);
ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]
</code></pre><p>####(3)LocalTime<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<pre><code>LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239
</code></pre><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>
<pre><code>LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);
System.out.println(leetTime);   // 13:37
</code></pre><p>####(4)LocalDate<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<pre><code>LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);
System.out.println(xmas);   // 2014-12-24
</code></pre><p>####(5)LocalDateTime<br>        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>
<pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // WEDNESDAY

Month month = sylvester.getMonth();
System.out.println(month);          // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439

Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014

DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);

LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13
</code></pre><p>###5.支持重复注解了，注解也可以用在任何地方了<br>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>
<pre><code>new @Interned MyObject();
myString = (@NonNull String) str;

void monitorTemperature() throws @Critical TemperatureException { ... }
</code></pre><p>之前要实现重复注解需要这样：</p>
<pre><code>public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseOldVersion {

    @Authorities({@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)})
    public void doSomeThing(){
    }
}
</code></pre><p>而现在：</p>
<pre><code>@Repeatable(Authorities.class)
public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseNewVersion {
    @Authority(role=&quot;Admin&quot;)
    @Authority(role=&quot;Manager&quot;)
    public void doSomeThing(){ }
}
</code></pre><p>###6.Nashorn JavaScript 引擎<br>简单的说，它是 Rhino 的接替者.升级啦。</p>
<p>###7.StampedLock<br>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<p>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<pre><code>class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();
   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }
  //下面看看乐观读锁案例
   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁
     double currentX = x, currentY = y; //将两个字段读入本地局部变量
     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁
        try {
          currentX = x; // 将两个字段读入本地局部变量
          currentY = y; // 将两个字段读入本地局部变量
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }
//下面是悲观读锁案例
   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合
         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁
         if (ws != 0L) { //这是确认转为写锁是否成功
           stamp = ws; //如果成功 替换票据
           x = newX; //进行状态改变
           y = newY; //进行状态改变
           break;
         }
         else { //如果不能成功转换为写锁
           sl.unlockRead(stamp); //我们显式释放读锁
           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试
         }
       }
     } finally {
       sl.unlock(stamp); //释放读锁或写锁
     }
   }
 }
</code></pre><hr>
<p>参考文档：<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##Java7新特性&lt;/p&gt;
&lt;p&gt;###Java7语法特性&lt;br&gt;根据JSR 334，Java7添加了数个语法方面的新特性：&lt;/p&gt;
&lt;p&gt;####1. switch可以消化String&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void switchString(String s){
    switch (s){
    case &amp;quot;db&amp;quot;: ...
    case &amp;quot;wls&amp;quot;: ...
    case &amp;quot;ibm&amp;quot;: ...
    case &amp;quot;soa&amp;quot;: ...
    case &amp;quot;fa&amp;quot;: ...
    default: ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.shenyanchao.cn/categories/java/"/>
    
    
      <category term="java7" scheme="http://www.shenyanchao.cn/tags/java7/"/>
    
      <category term="java8" scheme="http://www.shenyanchao.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>使用 jXLS导出报表</title>
    <link href="http://www.shenyanchao.cn/2014/06/24/2014-06-24-export-excel-by-jxls/"/>
    <id>http://www.shenyanchao.cn/2014/06/24/2014-06-24-export-excel-by-jxls/</id>
    <published>2014-06-24T07:17:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###常用的excel操作工具</p>
<ul>
<li>Apache POI</li>
<li>jexcelApi</li>
</ul>
<p>它们都提供了完善的API来支持EXCEL的读写。</p>
<p>###jXLS是什么？</p>
<p>jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>
<p>jXLS的基本功能：</p>
<ul>
<li>支持Excel 95-2000的所有版本</li>
<li>生成Excel 2000标准格式</li>
<li>支持字体、数字、日期操作</li>
<li>能够修饰单元格属性</li>
<li><p>支持图像和图表</p>
<pre><code>&lt;dependency&gt;
       &lt;groupId&gt;net.sf.jxls&lt;/groupId&gt;
       &lt;artifactId&gt;jxls-core&lt;/artifactId&gt;
       &lt;version&gt;1.0.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
</ul>
<a id="more"></a>
<p>jXLS的API也很简单：</p>
<pre><code>Map beans = new HashMap();
beans.put(&quot;department&quot;, department);
XLSTransformer transformer = new XLSTransformer();
transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);
</code></pre><p>###jXLS是如何解析模板生成数据的？</p>
<p>查看<code>net.sf.jxls.transformer.CellTransformer</code>可以看到：</p>
<pre><code>Object value = ((Expression) cell.getExpressions().get(0)).evaluate();
</code></pre><p>而evaluate()方法如下：</p>
<pre><code>public Object evaluate() throws Exception {
    if (beans != null &amp;&amp; !beans.isEmpty()) {
        JexlContext context = new MapContext(beans);
        Object ret = jexlExpresssion.evaluate(context);
        if (aggregateFunction != null) {
            return calculateAggregate(aggregateFunction, aggregateField, ret);
        }
        return ret;
    }
    return expression;
}
</code></pre><p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>
<p>###让jXLS支持hyperlink</p>
<p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>
<pre><code>if (cell.getStringCellValue().toLowerCase().startsWith(&quot;${href}&quot;) &amp;&amp; cell.getExpressions().size() == 3){
       //是链接类型的cell
       HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();
       Expression valueExpr = (Expression)cell.getExpressions().get(1);
       Expression linkExpr = (Expression)cell.getExpressions().get(2);
       hssfCell.setCellValue((String)valueExpr.evaluate());
       Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);
       link.setAddress((String)linkExpr.evaluate());
       hssfCell.setHyperlink(link);
       cell.setPoiCell(hssfCell);
    }
</code></pre><p>当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###常用的excel操作工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache POI&lt;/li&gt;
&lt;li&gt;jexcelApi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们都提供了完善的API来支持EXCEL的读写。&lt;/p&gt;
&lt;p&gt;###jXLS是什么？&lt;/p&gt;
&lt;p&gt;jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。&lt;/p&gt;
&lt;p&gt;jXLS的基本功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持Excel 95-2000的所有版本&lt;/li&gt;
&lt;li&gt;生成Excel 2000标准格式&lt;/li&gt;
&lt;li&gt;支持字体、数字、日期操作&lt;/li&gt;
&lt;li&gt;能够修饰单元格属性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持图像和图表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;net.sf.jxls&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;jxls-core&amp;lt;/artifactId&amp;gt;
       &amp;lt;version&amp;gt;1.0.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.shenyanchao.cn/categories/Java/"/>
    
    
      <category term="apache poi" scheme="http://www.shenyanchao.cn/tags/apache-poi/"/>
    
      <category term="excel" scheme="http://www.shenyanchao.cn/tags/excel/"/>
    
      <category term="jXLS" scheme="http://www.shenyanchao.cn/tags/jXLS/"/>
    
      <category term="jxl" scheme="http://www.shenyanchao.cn/tags/jxl/"/>
    
  </entry>
  
  <entry>
    <title>Spring中配置quartz集群</title>
    <link href="http://www.shenyanchao.cn/2014/06/24/2014-06-24-quartz-cluster-with-spring/"/>
    <id>http://www.shenyanchao.cn/2014/06/24/2014-06-24-quartz-cluster-with-spring/</id>
    <published>2014-06-24T07:10:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###为什么使用quartz集群？</p>
<p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。<br>quartz集群在spring中的配置</p>
<p>####1.导入数据库表</p>
<p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>
<p>注意事项：</p>
<p>修改SQL： TYPE=InnoDB –&gt; ENGINE=InnoDB<br><a id="more"></a></p>
<p>####2.项目中加入配置文件quartz.properties</p>
<pre><code>#============================================================================
# Configure Main Scheduler Properties
#============================================================================
org.quartz.scheduler.instanceName = ClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.scheduler.skipUpdateCheck = true

#============================================================================
# Configure ThreadPool
#============================================================================
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.useProperties = false
org.quartz.jobStore.tablePrefix = QRTZ_

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 15000
</code></pre><p>####3.增加applicationContext-quartz.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;
       default-lazy-init=&quot;false&quot;&gt;

    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;

    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${db.driver}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${db.user}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${db.pass}&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Quartz集群Schduler --&gt;
    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;
        &lt;!-- Triggers集成 --&gt;
        &lt;property name=&quot;triggers&quot;&gt;
            &lt;list&gt;
                &lt;ref bean=&quot;testTrigger&quot; /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--  quartz配置文件路径--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz/quartz.properties&quot; /&gt;
        &lt;!-- 启动时延期3秒开始任务 --&gt;
        &lt;property name=&quot;startupDelay&quot; value=&quot;3&quot; /&gt;
        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;
        &lt;!-- Job接受applicationContext的成员变量名 --&gt;
        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;
        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;
        &lt;property name=&quot;jobFactory&quot;&gt;
            &lt;bean class=&quot;com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory&quot;/&gt;
        &lt;/property&gt;
     &lt;/bean&gt;


    &lt;bean id=&quot;testTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;
        &lt;property name=&quot;jobDetail&quot; ref=&quot;testJobDetail&quot; /&gt;
        &lt;property name=&quot;cronExpression&quot; value=&quot;* 0/10 * * * ?&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;
    &lt;bean id=&quot;testJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailBean&quot;&gt;
        &lt;property name=&quot;jobClass&quot; value=&quot;cn.shenyanchao.quartz.TestTask&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;
    &lt;util:map id=&quot;timerJobConfig&quot;&gt;
        &lt;entry key=&quot;nodeName&quot; value=&quot;default&quot; /&gt;
    &lt;/util:map&gt;
&lt;/beans&gt;
</code></pre><p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>
<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>
<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {

        private transient AutowireCapableBeanFactory beanFactory;

        public void setApplicationContext(final ApplicationContext context) {
            beanFactory = context.getAutowireCapableBeanFactory();
        }

        @Override
        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {
            final Object job = super.createJobInstance(bundle);
            beanFactory.autowireBean(job);
            return job;
        }
    }
</code></pre><p>####4. 如何写JOB？</p>
<pre><code>@Component
public class TestTask extends QuartzJobBean {


    @Autowired
    private UserService userService;

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(userService.findByName(&quot;shenyanchao&quot;).getEmail());
    }
}
</code></pre><p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>
<p>####5.quartz在mysql5.6下报错</p>
<pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;OPTION SQL_SELECT_LIMIT=5&apos; at line 1
</code></pre><p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<a href="http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1" target="_blank" rel="external">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###为什么使用quartz集群？&lt;/p&gt;
&lt;p&gt;在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。&lt;br&gt;quartz集群在spring中的配置&lt;/p&gt;
&lt;p&gt;####1.导入数据库表&lt;/p&gt;
&lt;p&gt;以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;修改SQL： TYPE=InnoDB –&amp;gt; ENGINE=InnoDB&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.shenyanchao.cn/categories/Java/"/>
    
    
      <category term="spring" scheme="http://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="quartz" scheme="http://www.shenyanchao.cn/tags/quartz/"/>
    
      <category term="集群" scheme="http://www.shenyanchao.cn/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Velocity学习小结</title>
    <link href="http://www.shenyanchao.cn/2014/03/31/2014-03-31-velocity-study-summary/"/>
    <id>http://www.shenyanchao.cn/2014/03/31/2014-03-31-velocity-study-summary/</id>
    <published>2014-03-31T08:24:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###velocity在spring项目中的使用<br>本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。<br>首先，可以交给Spring来初始化velocityEngine:</p>
<pre><code>&lt;bean id=&quot;velocityEngine&quot; class=&quot;org.springframework.ui.velocity.VelocityEngineFactoryBean&quot;&gt;
    &lt;property name=&quot;configLocation&quot;&gt;
        &lt;value&gt;classpath:velocity.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;resourceLoaderPath&quot;&gt;
        &lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>其中的<code>configLocation</code>指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：   </p>
<pre><code>resource.loader  =  file

file.resource.loader.description =  Velocity  File Resource Loader
file.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader
file.resource.loader.cache =  true
file.resource.loader.modificationCheckInterval =  100

input.encoding = utf-8
output.encoding = utf-8
</code></pre><p>需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：</p>
<ul>
<li>spring增强了file加载的能力，推荐使用<code>resourceLoaderPath</code>来指明路径，而不是交给<code>file.resource.loader.path</code>进行处理。如果使用这个可能会跑NullPointerException；</li>
<li>class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。</li>
</ul>
<p>###关于Velocity使用的坑</p>
<ul>
<li><p>关于减号（-）的问题</p>
<blockquote>
<p>请注意下面的2中写法<br><code>#set($maxIndex=$DOC_COUNT-1)</code>报错<br><code>#set($maxIndex=$DOC_COUNT - 1)</code>正确，区别仅在于-两侧的空格</p>
</blockquote>
</li>
<li><p>关于Range类型的问题</p>
<blockquote>
<p><code>#set($array = [0..$maxIndex])</code> 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样<code>#set($array = [0..$maxIndex+1])</code>也是错误的。</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###velocity在spring项目中的使用&lt;br&gt;本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。&lt;br&gt;首先，可以交给Spring来初始化velocityEngine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;q
    
    </summary>
    
      <category term="velocity" scheme="http://www.shenyanchao.cn/categories/velocity/"/>
    
    
      <category term="velocity" scheme="http://www.shenyanchao.cn/tags/velocity/"/>
    
      <category term="spring" scheme="http://www.shenyanchao.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>又见Java乱码</title>
    <link href="http://www.shenyanchao.cn/2014/03/27/2014-03-27-java-encode-error-again/"/>
    <id>http://www.shenyanchao.cn/2014/03/27/2014-03-27-java-encode-error-again/</id>
    <published>2014-03-27T13:43:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###dom4j解析xml</p>
<p>dom4j提供了一个<code>DocumentHelper</code>来解析xml内容，此处的内容是String类型的。下面是其源码：  </p>
<pre><code>public static Document parseText(String text) throws DocumentException {
    Document result = null;

    SAXReader reader = new SAXReader();
    String encoding = getEncoding(text);

    InputSource source = new InputSource(new StringReader(text));
    source.setEncoding(encoding);

    result = reader.read(source);

    // if the XML parser doesn&apos;t provide a way to retrieve the encoding,
    // specify it manually
    if (result.getXMLEncoding() == null) {
        result.setXMLEncoding(encoding);
    }

    return result;
}

private static String getEncoding(String text) {
    String result = null;

    String xml = text.trim();

    if (xml.startsWith(&quot;&lt;?xml&quot;)) {
        int end = xml.indexOf(&quot;?&gt;&quot;);
        String sub = xml.substring(0, end);
        StringTokenizer tokens = new StringTokenizer(sub, &quot; =\&quot;\&apos;&quot;);

        while (tokens.hasMoreTokens()) {
            String token = tokens.nextToken();

            if (&quot;encoding&quot;.equals(token)) {
                if (tokens.hasMoreTokens()) {
                    result = tokens.nextToken();
                }

                break;
            }
        }
    }

    return result;
}
</code></pre><p>从以上的代码中可以看出，解析过程中是使用XML的头<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>来获取编码信息的。<br><a id="more"></a></p>
<p>###如何读取文件到String</p>
<pre><code>public String loadXmlRule() {
    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;file.xml&quot;);
    String xmlContent = null;
    try {
        xmlContent = IOUtils.toString(inputStream);
    } catch (IOException e) {
        LOG.error(&quot;read xml:{} io error&quot;, e);
    } finally {
        IOUtils.closeQuietly(inputStream);
    }
    return xmlContent;
}
</code></pre><p><a href="http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as" target="_blank" rel="external">getResourceAsStream将文件读为字节流</a>，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。</p>
<pre><code>xmlContent = IOUtils.toString(inputStream);

转换为：

xmlContent = IOUtils.toString(inputStream，&quot;UTF-8);//假设文件是UTF-8
</code></pre><p>由此，一定要慎重使用编码。<strong>永远不要相信默认编码</strong>。</p>
<p>###Jenkins/Hudson中shell command的编码</p>
<p>遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###dom4j解析xml&lt;/p&gt;
&lt;p&gt;dom4j提供了一个&lt;code&gt;DocumentHelper&lt;/code&gt;来解析xml内容，此处的内容是String类型的。下面是其源码：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Document parseText(String text) throws DocumentException {
    Document result = null;

    SAXReader reader = new SAXReader();
    String encoding = getEncoding(text);

    InputSource source = new InputSource(new StringReader(text));
    source.setEncoding(encoding);

    result = reader.read(source);

    // if the XML parser doesn&amp;apos;t provide a way to retrieve the encoding,
    // specify it manually
    if (result.getXMLEncoding() == null) {
        result.setXMLEncoding(encoding);
    }

    return result;
}

private static String getEncoding(String text) {
    String result = null;

    String xml = text.trim();

    if (xml.startsWith(&amp;quot;&amp;lt;?xml&amp;quot;)) {
        int end = xml.indexOf(&amp;quot;?&amp;gt;&amp;quot;);
        String sub = xml.substring(0, end);
        StringTokenizer tokens = new StringTokenizer(sub, &amp;quot; =\&amp;quot;\&amp;apos;&amp;quot;);

        while (tokens.hasMoreTokens()) {
            String token = tokens.nextToken();

            if (&amp;quot;encoding&amp;quot;.equals(token)) {
                if (tokens.hasMoreTokens()) {
                    result = tokens.nextToken();
                }

                break;
            }
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从以上的代码中可以看出，解析过程中是使用XML的头&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/code&gt;来获取编码信息的。&lt;br&gt;
    
    </summary>
    
      <category term="encode" scheme="http://www.shenyanchao.cn/categories/encode/"/>
    
    
      <category term="java" scheme="http://www.shenyanchao.cn/tags/java/"/>
    
      <category term="jenkins" scheme="http://www.shenyanchao.cn/tags/jenkins/"/>
    
      <category term="dom4j" scheme="http://www.shenyanchao.cn/tags/dom4j/"/>
    
      <category term="编码" scheme="http://www.shenyanchao.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JSTL介绍</title>
    <link href="http://www.shenyanchao.cn/2014/03/18/2014-03-18-use-jstl/"/>
    <id>http://www.shenyanchao.cn/2014/03/18/2014-03-18-use-jstl/</id>
    <published>2014-03-18T10:49:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###EL 表达式<br>在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。</p>
<p>Sun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。</p>
<p>Standard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。</p>
<p>Standard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。</p>
<p>本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从<a href="http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：" target="_blank" rel="external">http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：</a></p>
<ul>
<li>核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。</li>
<li>国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。</li>
<li>数据库标签库：可以做访问数据库的工作。</li>
<li>XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。</li>
<li>函数标签库：用来读取已经定义的某个函数。</li>
</ul>
<p>此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。</p>
<p>JSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。</p>
<p>说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。</p>
<a id="more"></a>
<p>####9.2.1JSTL EL 表达式语言简介<br>EL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。</p>
<p>下面的示例就是一个EL表达式，见例9.1。</p>
<p>例9.1：简单EL表达式</p>
<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
 &lt;body&gt; ${sampleValue + 1} &lt;br&gt; &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。   </p>
<p>####9.2.2 EL 表达式的默认变量<br>一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：</p>
<p>1．默认变量pageScope、requestScope、sessionScope、applicationScope<br>      这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：</p>
<p>例9.2：使用sessionScope变量的EL表达式</p>
<pre><code>&lt;%request.getSession().setAttribute(&quot;sampleValue&quot;, new Integer(10));%&gt;
${sessionScope.sampleValue}
</code></pre><p>取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。</p>
<p>2．默认变量param、paramValues<br>      这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：</p>
<p>例9.3：提交请求的页面和接受的页面</p>
<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
 &lt;body&gt;
     &lt;form action=&quot;SampleJsp.jsp&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;10&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;11&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;12&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;sampleSingleValue&quot; value=&quot;SingleValue&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
    &lt;/form&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。</p>
<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
 &lt;body&gt;
    ${paramValues.sampleValue[2]} &lt;br&gt;
    ${param.sampleSingleValue} &lt;br&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。</p>
<p>3．默认变量header、headerValues</p>
<p>这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。</p>
<p>4．默认变量cookie</p>
<p>包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。</p>
<p>5．默认变量initParam</p>
<p>包含所有应用程序初始化参数的集合。</p>
<p>6．默认变量pageContext</p>
<p>等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。<br>11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。</p>
<p>###表达式的操作符<br>EL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。</p>
<p>表9.1 EL表达式的操作符</p>
<table cellspacing="0" cellpadding="0" width="562" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="64"><br>                                <p align="left">操作符</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">功能和作用</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">.</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">访问一个bean属性或者Map entry</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">[]</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">访问一个数组或者链表元素</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">()</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">对子表达式分组，用来改变赋值顺序</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">? :</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">条件语句，比如：条件?ifTrue:ifFalse</p><br>                                <p align="left">如果条件为真，表达式值为前者，反之为后者</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">+</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">数学运算符，加操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">-</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">数学运算符，减操作或者对一个值取反</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">*</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">数学运算符，乘操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">/ 或div</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">数学运算符，除操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">% 或mod</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">数学运算符，模操作(取余)</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">== 或eq</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">!= 或ne</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">&lt; 或lt</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">&gt; 或gt</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">&lt;= 或le</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">&gt;= 或ge</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">&amp;&amp; 或and</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">|| 或or</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">! 或not</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">empty</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign="top" width="64"><br>                                <p align="left">func(args)</p><br>                                </td><br>                                <td width="498"><br>                                <p align="left">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：</p>
<p>例9.4：几组操作符的示例</p>
<pre><code>${pageScope.sampleValue + 12} &lt;br&gt;           //显示12
${(pageScope.sampleValue + 12)/3} &lt;br&gt;     //显示4.0
${(pageScope.sampleValue + 12) /3==4} &lt;br&gt;         //显示true
${(pageScope.sampleValue + 12) /3&gt;=5} &lt;br&gt;         //显示false
&lt;input type=&quot;text&quot; name=&quot;sample1&quot; value=&quot;${pageScope.sampleValue + 10}&quot;&gt; //显示值为10的Text控件
</code></pre><p>可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。</p>
<p>###标签库介绍<br>在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。<br>对应的标识符见表9.2所示：</p>
<p>表9.2 标签库的标识符</p>
<table cellspacing="0" cellpadding="0" width="360" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">标签库</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left">URI</p><br>                                </td><br>                                <td width="50"><br>                                <p align="center">前缀</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">Core</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left"><a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a></p><br>                                </td><br>                                <td width="50"><br>                                <p align="left">c</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">XML processing</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left"><a href="http://java.sun.com/jsp/jstl/xml" target="_blank" rel="external">http://java.sun.com/jsp/jstl/xml</a></p><br>                                </td><br>                                <td width="50"><br>                                <p align="left">x</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">I18N formatting</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left"><a href="http://java.sun.com/jsp/jstl/fmt" target="_blank" rel="external">http://java.sun.com/jsp/jstl/fmt</a></p><br>                                </td><br>                                <td width="50"><br>                                <p align="left">fmt</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">Database access</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left"><a href="http://java.sun.com/jsp/jstl/sql" target="_blank" rel="external">http://java.sun.com/jsp/jstl/sql</a></p><br>                                </td><br>                                <td width="50"><br>                                <p align="left">sql</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="107"><br>                                <p align="left">Functions</p><br>                                </td><br>                                <td width="202"><br>                                <p align="left"><a href="http://java.sun.com/jsp/jstl/functions" target="_blank" rel="external">http://java.sun.com/jsp/jstl/functions</a></p><br>                                </td><br>                                <td width="50"><br>                                <p align="left">fn</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看例9.5，简单使用标签库的示例。</p>
<p>例9.5：简单JSTL标签库示例</p>
<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
 &lt;body&gt;
    &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt; ${i} &lt;br /&gt;&lt;/c:forEach&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>在该示例的JSP页面中声明了将使用Core标签库，它的URI为“<a href="http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中</a><c:foreach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。 </c:foreach></p>
<p>###标签库<br>Core标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：</p>
<ul>
<li>多用途核心标签：<c:out>、<c:set>、<c:remove>、<c:catch>。</c:catch></c:remove></c:set></c:out></li>
<li>条件控制标签：<c:if>、<c:choose>、<c:when>、<c:otherwise>。</c:otherwise></c:when></c:choose></c:if></li>
<li>循环控制标签：<c:foreach>、<c:fortokens>。</c:fortokens></c:foreach></li>
<li>URL相关标签：<c:import>、<c:url>、<c:redirect>、<c:param>。</c:param></c:redirect></c:url></c:import></li>
</ul>
<p>以下是各个标签的用途和属性以及简单示例。</p>
<p>###用于显示的<code>&lt;c:out&gt;</code> 标签<br><code>&lt;c:out&gt;</code>标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：</p>
<p>表9.3　<code>&lt;c:out&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="535" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="79"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="456"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="79"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="456"><br>                                <p align="left">输出到页面的数据，可以是EL表达式或常量（必须）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="79"><br>                                <p align="left">default</p><br>                                </td><br>                                <td width="456"><br>                                <p align="left">当value为null时显示的数据（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="79"><br>                                <p align="left">escapeXml</p><br>                                </td><br>                                <td width="456"><br>                                <p align="left">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>在JSTL1.0的时候，在页面显示数据必须使用<c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。</c:out></p>
<pre><code>&lt;c:out value=&quot;${sessionScope.anyValue}&quot; default=&quot;no value&quot; escapeXml=&quot;false&quot;/&gt;
</code></pre><p>该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。</p>
<p>###<code>&lt;c: &gt;</code> 标签 </p>
<p>####用于赋值的<c:set>标签<br><code>&lt;c:set&gt;</code>标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：</c:set></p>
<p>表9.4　<code>&lt;c:set&gt;</code>标签属性和说明</p>
<table cellpadding="0" width="393" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="311"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">value</p><br>                                </td><br>                                <td><br>                                <p align="left">值的信息，可以是EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">target</p><br>                                </td><br>                                <td><br>                                <p align="left">被赋值的JavaBean实例的名称，若存在该属性则必须<br><br>                                存在property属性（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">property</p><br>                                </td><br>                                <td><br>                                <p align="left">JavaBean实例的变量属性名称（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">var</p><br>                                </td><br>                                <td><br>                                <p align="left">被赋值的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">scope</p><br>                                </td><br>                                <td><br>                                <p align="left">变量的作用范围，若没有指定，默认为page（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>

<p> 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：</p>
<pre><code>&lt;c:set value=&quot;this is andy&quot; var=&quot;oneString&quot;/&gt;
${oneString} &lt;br&gt;
</code></pre><p>该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。</p>
<p>####9.3.3 用于删除的 <code>&lt;c:remove&gt;</code>标签<br><code>&lt;c:remove&gt;</code>标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：</p>
<p>表9.5　<code>&lt;c:remove&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="365" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">需要被删除的变量名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">变量的作用范围，若没有指定，默认为全部查找（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例：</p>
<pre><code>&lt;c:remove var=&quot;sampleValue&quot; scope=&quot;session&quot;/&gt;
${sessionScope.sampleValue} &lt;br&gt;
</code></pre><p>该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。</p>
<p>####9.3.4 用于异常捕获的 <code>&lt;c:catch&gt;</code> 标签<br><code>&lt;c:catch&gt;</code>标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。</p>
<pre><code>&lt;c:catch var=&quot;err&quot;&gt; ${param.sampleSingleValue[9] == 3}&lt;/c:catch&gt;
${err}
</code></pre><p>当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。</p>
<p>####9.3.5 用于判断的 <code>&lt;c:if&gt;</code> 标签<br><code>&lt;c:if&gt;</code>标签用于简单的条件语句。它的属性和描述如表9.6所示：</p>
<p>表9.6　<code>&lt;c:if&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="454" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="60"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="394"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="60"><br>                                <p align="left">test</p><br>                                </td><br>                                <td width="394"><br>                                <p align="left">需要判断的条件</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="60"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="394"><br>                                <p align="left">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="60"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="394"><br>                                <p align="left">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例：</p>
<pre><code>&lt;c:if test=&quot;${paramValues.sampleValue[2] == 12}&quot; var=&quot;visits&quot;&gt;It is 12&lt;/c:if&gt;&lt;br&gt;
${visits} &lt;br&gt;
</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。</p>
<p>####9.3.6 用于复杂判断的 <code>&lt;c:choose&gt; 、 &lt;c:when&gt; 、 &lt;c:otherwise&gt;</code> 标签<br>这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。</p>
<p><code>&lt;c:choose&gt;</code>标签没有属性，可以被认为是父标签，<code>&lt;c:when&gt;、&lt;c:otherwise&gt;</code>将作为其子标签来使用。<br><code>&lt;c:when&gt;</code>标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。<br><code>&lt;c:otherwise&gt;</code>标签没有属性，它等价于“else”语句。</p>
<p>下面看一个复杂条件语句的示例。</p>
<pre><code>&lt;c:choose&gt;
         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 11}&quot;&gt;
                   not 12 not 13,it is 11
         &lt;/c:when&gt;
         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 12}&quot;&gt;
                   not 11 not 13,it is 12
         &lt;/c:when&gt;
         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 13}&quot;&gt;
                   not 11 not 12,it is 13
         &lt;/c:when&gt;
         &lt;c:otherwise&gt;
                   not 11 、12、13
         &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。</p>
<p>####9.3.7 用于循环的 <code>&lt;c:forEach&gt;</code> 标签<br><code>&lt;c:forEach&gt;</code>为循环控制标签。它的属性和描述如表9.7所示：</p>
<p>表9.7　<code>&lt;c:forEach&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="511" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">items</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">进行循环的集合（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">begin</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">end</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">step</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="59"><br>                                <p align="left">varStatus</p><br>                                </td><br>                                <td width="452"><br>                                <p align="left">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个集合循环的示例。</p>
<p>&lt;%ArrayList arrayList = new ArrayList();<br>                   arrayList.add(“aa”);<br>                   arrayList.add(“bb”);<br>                   arrayList.add(“cc”);<br>%&gt;<br>&lt;%request.getSession().setAttribute(“arrayList”, arrayList);%&gt;</p>
<p><c:foreach items="${sessionScope.arrayList}" var="arrayListI"><br>         ${arrayListI}<br></c:foreach></p>
<p>该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。</p>
<pre><code>&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt;
      ${i}&lt;br /&gt;
&lt;/c:forEach&gt;
</code></pre><p>该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。</p>
<p>####9.3.8 用于分隔字符的 <code>&lt;c:forTokens&gt;</code> 标签<br><code>&lt;c:forTokens&gt;</code>标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：</p>
<p>表9.8　<code>&lt;c:forTokens&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="268" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">items</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">进行分隔的EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">delims</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">分隔符</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">begin</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">end</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">step</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">做循环的对象变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="76"><br>                                <p align="left">varStatus</p><br>                                </td><br>                                <td width="192"><br>                                <p align="left">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<pre><code>&lt;c:forTokens items=&quot;aa,bb,cc,dd&quot; begin=&quot;0&quot; end=&quot;2&quot; step=&quot;2&quot; delims=&quot;,&quot; var=&quot;aValue&quot;&gt;
         ${aValue}
&lt;/c:forTokens&gt;
</code></pre><p>需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa</p>
<p>###<code>&lt;x: &gt;</code> 标签</p>
<p>####9.3.9 用于包含页面的<code>&lt;c:import&gt;</code><br><code>&lt;c:import&gt;</code>标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：</p>
<p>表9.9　<code>&lt;c:import&gt;</code>标签属性和说明</p>
<table cellpadding="0" width="360" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="73"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="271"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">rl</p><br>                                </td><br>                                <td><br>                                <p align="left">需要导入页面的URL</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">context</p><br>                                </td><br>                                <td><br>                                <p align="left">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">charEncoding</p><br>                                </td><br>                                <td><br>                                <p align="left">导入页面的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">var</p><br>                                </td><br>                                <td><br>                                <p align="left">可以定义导入文本的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">scope</p><br>                                </td><br>                                <td><br>                                <p align="left">导入文本的变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align="left">varReader</p><br>                                </td><br>                                <td><br>                                <p align="left">接受文本的java.io.Reader类变量名（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p> 下面看一个示例。</p>
<pre><code>&lt;c:import url=&quot;/MyHtml.html&quot; var=&quot;thisPage&quot; /&gt;
&lt;c:import url=&quot;/MyHtml.html&quot; context=”/sample2” var=&quot;thisPage&quot;/&gt;
&lt;c:import url=&quot;www.sample.com/MyHtml.html&quot; var=&quot;thisPage&quot;/&gt;
</code></pre><p>该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。</p>
<p>####9.3.10 用于得到URL地址的<code>&lt;c:url&gt;</code>标签<br><code>&lt;c:url&gt;</code> 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：</p>
<p>表9.10 <code>&lt;c:url&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="459" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">页面的URL地址</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">context</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">charEncoding</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">URL的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">存储URL的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="81"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="378"><br>                                <p align="left">变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例：</p>
<pre><code>&lt;c:url value=&quot;/MyHtml.html&quot; var=&quot;urlPage&quot; /&gt;
&lt;a href=&quot;${urlPage}&quot;&gt;link&lt;/a&gt;
</code></pre><p>得到了一个 URL 后，以 EL 表达式放入<code>&lt;a&gt;</code> 标签的 href 属性，达到链接的目的。</p>
<p>####9.3.11 用于页面重定向的<code>&lt;c:redirect&gt;</code>标签<br><code>&lt;c:redirect&gt;</code> 用于页面的重定向，该标签的作用相当于 <code>response.setRedirect</code> 方法的工作。它包含 url 和 context 两个属性，属性含义和 <code>&lt;c:url&gt;</code> 标签相同。下面看一个示例。</p>
<pre><code>&lt;c:redirect url=&quot;/MyHtml.html&quot;/&gt;
</code></pre><p>该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 <code>&lt;c:if&gt;</code> 等标签一起使用。</p>
<p>####9.3.12 用于包含传递参数的<code>&lt;c:param&gt;</code>标签<br> <code>&lt;c:param&gt;</code> 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：</p>
<p>表9.11　<code>&lt;c:param&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="190" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="58"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="132"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="58"><br>                                <p align="left">name</p><br>                                </td><br>                                <td width="132"><br>                                <p align="left">传递的参数名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="58"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="132"><br>                                <p align="left">传递的参数值（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面是一个示例：</p>
<pre><code>&lt;c:redirect url=&quot;/MyHtml.jsp&quot;&gt;
&lt;c:param name=&quot;userName&quot; value=”RW” /&gt;
&lt;/c:redirect&gt;
</code></pre><p>该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。</p>
<p>###9.4 JSTL XML processing标签库<br>在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：</p>
<ul>
<li>XML核心标签：<code>&lt;x:parse&gt;、&lt;x:out&gt;、&lt;x:set&gt;</code>。</li>
<li>XML流控制标签：<code>&lt;x:if&gt;、&lt;x:choose&gt;、&lt;x:when&gt;、&lt;x:otherwise&gt;、&lt;x:forEach&gt;</code>。</li>
<li>XML转换标签：<code>&lt;x:transform&gt;、&lt;x:param&gt;</code>。</li>
</ul>
<p>由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。</p>
<p>####9.4.1 用于解析XML文件的<code>&lt;x:parse&gt;</code>标签<br><code>&lt;x:parse&gt;</code> 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：</p>
<p>表9.12　<code>&lt;x:parse&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" width="537" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">doc</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">varDom</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">scopeDom</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">org.w3c.dom.Document的接口类型变量作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">systemId</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="67"><br>                                <p align="left">filter</p><br>                                </td><br>                                <td width="470"><br>                                <p align="left">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。</p>
<p><code>&lt;x:parse&gt;</code>标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。</p>
<p>首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xml-body&gt;
         &lt;name&gt;RW&lt;/name&gt;
         &lt;passWord&gt;123456&lt;/passWord&gt;
         &lt;age&gt;28&lt;/age&gt;
         &lt;books&gt;
                   &lt;book&gt;book1&lt;/book&gt;
                   &lt;book&gt;book2&lt;/book&gt;
                   &lt;book&gt;book3&lt;/book&gt;
         &lt;/books&gt;
&lt;/xml-body&gt;
</code></pre><p>标签库的工作：</p>
<pre><code>&lt;c:import var=&quot;xmlFile&quot; url=&quot;http://localhost:8080/booksamplejstl/SampleXml.xml&quot;/&gt;
&lt;x:parse var=&quot;xmlFileValue&quot; doc=&quot;${xmlFile}&quot;/&gt;
</code></pre><p>###<code>&lt;fmt: &gt;</code> 标签 </p>
<p>看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：</p>
<ul>
<li>国际化核心标签：<code>&lt;fmt:setLocale&gt;、&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;、&lt;fmt:message&gt;、&lt;fmt:param&gt;、&lt;fmt:requestEncoding&gt;</code>。</li>
<li>格式化标签：<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;、&lt;fmt:formatNumber&gt;、&lt;fmt:parseNumber&gt;、&lt;fmt:formatDate&gt;、&lt;fmt:parseDate&gt;</code>。</li>
</ul>
<p>下面只选择其中常见的一些标签和属性进行介绍。</p>
<p>####9.5.1 用于设置本地化环境的<code>&lt;fmt:setLocale&gt;</code>标签<br>    <code>&lt;fmt:setLocale&gt;</code>标签用于设置Locale环境。它的属性和描述如表9.17所示：</p>
<p>表9.17　<code>&lt;fmt:setLocale&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="49"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="336"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="49"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="336"><br>                                <p align="left">Locale环境的指定，可以是java.util.Locale或String类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="49"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="336"><br>                                <p align="left">Locale环境变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>

<p>下面看一个示例：</p>
<pre><code>&lt;fmt:setLocale value=&quot;zh_TW&quot;/&gt;
</code></pre><p>表示设置本地环境为繁体中文。      </p>
<p>####9.5.2 用于资源文件绑定的<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签</p>
<p>这两组标签用于资源配置文件的绑定，唯一不同的是<code>&lt;fmt:bundle&gt;</code>标签将资源配置文件绑定于它标签体中的显示，<code>&lt;fmt:setBundle&gt;</code>标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。</p>
<p>根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：</p>
<p>表9.18　<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="69"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="421"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="69"><br>                                <p align="left">basename</p><br>                                </td><br>                                <td width="421"><br>                                <p align="left">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="69"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="421"><br>                                <p align="left">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="69"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="421"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例</p>
<pre><code>&lt;fmt:setLocale value=&quot;zh_CN&quot;/&gt;
&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;
</code></pre><p>该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。</p>
<p>####9.5.3  用于显示资源配置文件信息的<code>&lt;fmt:message&gt;</code>标签<br>用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：</p>
<p>表9.19　<code>&lt;fmt:message&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="55"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="513"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="55"><br>                                <p align="left">key</p><br>                                </td><br>                                <td width="513"><br>                                <p align="left">资源配置文件的&ldquo;键&rdquo;指定</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="55"><br>                                <p align="left">bundle</p><br>                                </td><br>                                <td width="513"><br>                                <p align="left">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="55"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="513"><br>                                <p align="left">将显示信息保存为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="55"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="513"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例：</p>
<pre><code>&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;
&lt;fmt:bundle basename=&quot;applicationAllMessage&quot;&gt;
         &lt;fmt:message key=&quot;userName&quot; /&gt;
         &lt;p&gt;
         &lt;fmt:message key=&quot;passWord&quot; bundle=&quot;${applicationBundle}&quot; /&gt;
&lt;/fmt:bundle&gt;
</code></pre><p>该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用<code>&lt;fmt:setBundle&gt;</code>标签被赋于了变量“ applicationBundle ”，而作为<code>&lt;fmt:bundle&gt;</code>标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。</p>
<p>第一个<code>&lt;fmt:message&gt;</code>标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。<br>第二个<code>&lt;fmt:message&gt;</code>标签虽然被定义在<code>&lt;fmt:bundle&gt;</code>标签体内，但是它使用了bundle属性，因此将指定之前由<code>&lt;fmt:setBundle&gt;</code>标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。</p>
<h4 id="9-5-4-用于参数传递的-lt-fmt-param-gt-标签"><a href="#9-5-4-用于参数传递的-lt-fmt-param-gt-标签" class="headerlink" title="9.5.4  用于参数传递的&lt;fmt:param&gt;标签"></a>9.5.4  用于参数传递的<code>&lt;fmt:param&gt;</code>标签</h4><p><code>&lt;fmt:param&gt;</code>标签应该位于<code>&lt;fmt:message&gt;</code>标签内，将为该消息标签提供参数值。它只有一个属性value。<br><code>&lt;fmt:param&gt;</code>标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。</p>
<p>####9.5.6  用于为请求设置字符编码的<code>&lt;fmt:requestEncoding&gt;</code>标签<br><code>&lt;fmt:requestEncoding&gt;</code>标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。</p>
<p>####9.5.7  用于设定时区的<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签<br>这两组标签都用于设定一个时区。唯一不同的是<code>&lt;fmt:timeZone&gt;</code>标签将使得在其标签体内的工作可以使用该时区设置，<code>&lt;fmt:setBundle&gt;</code>标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：</p>
<p>表9.20　<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">时区的设置</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="53"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="312"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<h4 id="9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签"><a href="#9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签" class="headerlink" title="9.5.8  用于格式化数字的&lt;fmt:formatNumber&gt;标签"></a>9.5.8  用于格式化数字的<code>&lt;fmt:formatNumber&gt;</code>标签</h4><p><code>&lt;fmt: formatNumber &gt;</code> 标签用于格式化数字。它的属性和描述如表9.21所示：</p>
<p>表9.21　<code>&lt;fmt:formatNumber&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">type</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">pattern</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">maxIntegerDigits</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">指定格式化结果的最大值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">minIntegerDigits</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">指定格式化结果的最小值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">maxFractionDigits</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">指定格式化结果的最大值，带小数</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="104"><br>                                <p align="left">minFractionDigits</p><br>                                </td><br>                                <td width="384"><br>                                <p align="left">指定格式化结果的最小值，带小数</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p><code>&lt;fmt:formatNumber&gt;</code>标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。</p>
<p>下面看一个示例。</p>
<pre><code>&lt;fmt:formatNumber value=&quot;1000.888&quot; type=&quot;currency&quot; var=&quot;money&quot;/&gt;
</code></pre><p>该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。</p>
<h4 id="9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签"><a href="#9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签" class="headerlink" title="9.5.9  用于解析数字的&lt;fmt:parseNumber&gt;标签"></a>9.5.9  用于解析数字的<code>&lt;fmt:parseNumber&gt;</code>标签</h4><p><code>&lt;fmt:parseNumber&gt;</code>标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。<code>&lt;fmt:parseNumber&gt;</code>标签看起来和<code>&lt;fmt:formatNumber&gt;</code>标签的作用正好相反。它的属性和描述如表9.22所示：</p>
<p>表9.22　<code>&lt;fmt:parseNumber&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">type</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">pattern</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">结果保存变量，类型为java.lang.Number</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">parseLocale</p><br>                                </td><br>                                <td width="463"><br>                                <p align="left">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<pre><code>&lt;fmt:parseNumber value=&quot;15%&quot; type=&quot;percent&quot; var=&quot;num&quot;/&gt;
</code></pre><p>解析之后的结果为“ 0.15 ”。</p>
<p>####9.5.10  用于格式化日期的<code>&lt;fmt:formatDate&gt;</code>标签<br><code>&lt;fmt:formatDate&gt;</code>标签用于格式化日期。它的属性和描述如表9.23所示：</p>
<p>表9.23　<code>&lt;fmt:formatDate&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">type</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">pattern</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p align="left">timeZone</p><br>                                </td><br>                                <td width="343"><br>                                <p align="left">指定格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p><code>&lt;fmt:formatDate&gt;</code>标签与<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签的关系密切。若没有指定 timeZone属性，也可以通过<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签设定的时区来格式化最后的结果。</p>
<h4 id="9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签"><a href="#9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签" class="headerlink" title="9.5.11  用于解析日期的&lt;fmt:parseDate&gt;标签"></a>9.5.11  用于解析日期的<code>&lt;fmt:parseDate&gt;</code>标签</h4><p><code>&lt;fmt:parseDate&gt;</code>标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。<code>&lt;fmt:parseDate&gt;</code>标签看起来和<code>&lt;fmt:formatDate&gt;</code>标签的作用正好相反。它的属性和描述如表9.24所示：</p>
<p>表9.24　<code>&lt;fmt:parseDate&gt;</code>标签属性和说明</p>
<table cellspacing="0" cellpadding="0" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">属性</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">value</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">type</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">pattern</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">var</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">结果保存变量，类型为java.lang.Date</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">scope</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">parseLocale</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="72"><br>                                <p align="left">timeZone</p><br>                                </td><br>                                <td width="451"><br>                                <p align="left">指定解析格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p><code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此<code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。</p>
<p> <code>&lt;sql:&gt;</code>标签 </p>
<p>###9.6  Database access 标签库</p>
<p>Database access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。</p>
<p>对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。</p>
<p>Database access标签库有以下6组标签来进行工作：<code>&lt;sql:setDataSource&gt;、&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:transaction&gt;、&lt;sql:setDataSource&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;</code>。</p>
<p>####9.6.1 用于设置数据源的 <code>&lt;sql:setDataSource&gt;</code> 标签<br><code>&lt;sql:setDataSource&gt;</code>标签用于设置数据源，下面看一个示例：</p>
<pre><code>&lt;sql:setDataSource
         var=&quot;dataSrc&quot;
         url=&quot;jdbc:postgresql://localhost:5432/myDB&quot;
         driver=&quot;org.postgresql.Driver&quot;
         user=&quot;admin&quot;
         password=&quot;1111&quot;/&gt;
</code></pre><p>该示例定义一个数据源并保存在“ dataSrc ”变量内。</p>
<p>####9.6.2 用于查询的 <code>&lt;sql:query&gt;</code>标签</p>
<p><code>&lt;sql:query&gt;</code>标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：</p>
<pre><code>&lt;sql:query var=&quot;queryResults&quot; dataSource=&quot;${dataSrc}&quot;&gt;
      select * from table1
&lt;/sql:query&gt;
</code></pre><p>该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用<code>&lt;c:forEach&gt;</code>循环来进行。下面看一个示例。</p>
<pre><code>&lt;c:forEach var=&quot;row&quot; items=&quot;${queryResults.rows}&quot;&gt;
      &lt;tr&gt;
               &lt;td&gt;${row.userName}&lt;/td&gt;
                &lt;td&gt;${row.passWord}&lt;/td&gt;
      &lt;/tr&gt;
&lt;/c:forEach&gt;
</code></pre><p>“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。</p>
<p>####9.6.3 用于更新的 <code>&lt;sql:update&gt;</code> 标签<br><code>&lt;sql:update&gt;</code>标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和<code>&lt;sql:query&gt;</code>标签没有什么不同。</p>
<p>####9.6.4 用于事务处理的<code>&lt;sql:transaction&gt;</code>标签<br><code>&lt;sql:transaction&gt;</code>标签用于数据库的事务处理，在该标签体内可以使用<code>&lt;sql:update&gt;</code>标签和<code>&lt;sql:query&gt;</code>标签，而<code>&lt;sql:transaction&gt;</code>标签的事务管理将作用于它们之上。<br><code>&lt;sql:transaction&gt;</code>标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。</p>
<p>####9.6.5 用于事务处理的<code>&lt;sql:param&gt; 、 &lt;sql:dateParam&gt;</code> 标签<br>这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。<code>&lt;sql:param&gt;</code>标签传递除java.util.Date类型以外的所有相融参数，<code>&lt;sql:dateParam&gt;</code>标签则指定必须传递java.util.Date类型的参数。</p>
<p>###<code>&lt;fn:&gt;</code> 标签 </p>
<p>###9.7 Functions 标签库<br>       称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。</p>
<pre><code>长度函数：fn:length
字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim
</code></pre><p>以下是各个函数的用途和属性以及简单示例。</p>
<p>####9.7.1 长度函数 fn:length 函数<br>       长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。</p>
<p>fn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。</p>
<pre><code>&lt;%ArrayList arrayList1 = new ArrayList();
                            arrayList1.add(&quot;aa&quot;);
                            arrayList1.add(&quot;bb&quot;);
                            arrayList1.add(&quot;cc&quot;);

%&gt;
&lt;%request.getSession().setAttribute(&quot;arrayList1&quot;, arrayList1);%&gt;
${fn:length(sessionScope.arrayList1)}
</code></pre><p>假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。</p>
<p>####9.7.2 判断函数 fn:contains 函数<br>       fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。</p>
<pre><code>${fn:contains(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;
${fn:contains(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;
</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>
<p>####9.7.3 fn:containsIgnoreCase函数<br>      fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。</p>
<pre><code>${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;
${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;
</code></pre><p>前者和后者都会返回“ true ”。</p>
<p>####9.7.4 词头判断函数 fn:startsWith 函数<br>       fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。</p>
<pre><code>${fn:startsWith (&quot;ABC&quot;, &quot;ab&quot;)}&lt;br&gt;
${fn:startsWith (&quot;ABC&quot;, &quot;AB&quot;)}&lt;br&gt;
</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>
<p>####9.7.5 词尾判断函数 fn:endsWith 函数<br>       fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。</p>
<pre><code>${fn:endsWith(&quot;ABC&quot;, &quot;bc&quot;)}&lt;br&gt;
${fn:endsWith(&quot;ABC&quot;, &quot;BC&quot;)}&lt;br&gt;
</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>
<p>####9.7.6 字符实体转换函数 fn:escapeXml 函数<br>fn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。</p>
<p>####9.7.8 字符匹配函数 fn:indexOf 函数<br>       fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。</p>
<pre><code>${fn:indexOf(&quot;ABCD&quot;,&quot;aBC&quot;)}&lt;br&gt;
${fn:indexOf(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;
</code></pre><p>前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。</p>
<p>####9.7.9 分隔符函数 fn:join 函数<br>       fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：</p>
<p>表9.25　fn:join函数</p>
<table cellspacing="0" cellpadding="0" width="350" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="65"><br>                                <p>参数</p><br>                                </td><br>                                <td width="216"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>array</p><br>                                </td><br>                                <td width="216"><br>                                <p>字符串数组。其类型必须为String[]类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>separator</p><br>                                </td><br>                                <td width="216"><br>                                <p>分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width="216"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<pre><code>&lt;% String[] stringArray = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; %&gt;
&lt;%request.getSession().setAttribute(&quot;stringArray&quot;, stringArray);%&gt;
${fn:join(sessionScope.stringArray,&quot;;&quot;)}&lt;br&gt;
</code></pre><p>定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。</p>
<p>####9.7.10 替换函数 fn:replace 函数<br>       fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：</p>
<p>表9.26　fn:replace函数</p>
<table cellspacing="0" cellpadding="0" width="353" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="105"><br>                                <p>参数</p><br>                                </td><br>                                <td width="249"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p>inputString</p><br>                                </td><br>                                <td width="249"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p>beforeSubstring</p><br>                                </td><br>                                <td width="249"><br>                                <p>指定被替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p>afterSubstring</p><br>                                </td><br>                                <td width="249"><br>                                <p>指定替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="105"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width="249"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<p>${fn:replace(“ABC”,”A”,”B”)}<br></p>
<p>将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。</p>
<p>####9.7.11 分隔符转换数组函数 fn:split 函数<br>fn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：</p>
<p>表9.27　fn:split函数</p>
<table cellspacing="0" cellpadding="0" width="281" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="65"><br>                                <p>参数</p><br>                                </td><br>                                <td width="216"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>string</p><br>                                </td><br>                                <td width="216"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>delimiters</p><br>                                </td><br>                                <td width="216"><br>                                <p>指定分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="65"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width="216"><br>                                <p>返回一个String[]类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<p>${fn:split(“A,B,C”,”,”)}<br></p>
<p>将“ A,B,C ”字符串转换为数组{A,B,C}。</p>
<p>####9.7.12 字符串截取函数 fn:substring 函数<br>fn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：</p>
<p>表9.28　fn:substring函数</p>
<table cellspacing="0" cellpadding="0" width="353" border="1"><br>                        <tbody><br>                            <tr><br>                                <td width="68"><br>                                <p>参数</p><br>                                </td><br>                                <td width="285"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="68"><br>                                <p>string</p><br>                                </td><br>                                <td width="285"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="68"><br>                                <p>beginIndex</p><br>                                </td><br>                                <td width="285"><br>                                <p>指定起始下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="68"><br>                                <p>endIndex</p><br>                                </td><br>                                <td width="285"><br>                                <p>指定结束下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width="68"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width="285"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>


<p>下面看一个示例。</p>
<p>${fn:substring(“ABC”,”1”,”2”)}<br></p>
<p>截取结果为“ B ”。</p>
<p>####9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数<br>fn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。</p>
<pre><code>${fn:substringBefore(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;
</code></pre><p>截取的结果为“ A ”。</p>
<p>####9.7.15 小写转换函数 fn:toLowerCase 函数<br>fn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。</p>
<pre><code>${fn:toLowerCase(&quot;ABCD&quot;)}&lt;br&gt;
</code></pre><p>转换的结果为“ abcd ”。</p>
<p>####9.7.16大写转换函数 fn:toUpperCase 函数<br>fn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>
<pre><code>${fn:toUpperCase(&quot;abcd&quot;)}&lt;br&gt;
</code></pre><p>转换的结果为“ ABCD ”。</p>
<p>####9.7.17空格删除函数 fn:trim 函数<br>fn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>
<pre><code>${fn:trim(&quot;AB C &quot;)}D&lt;br&gt;
</code></pre><p>转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。</p>
<p>参考文档<a href="http://www.javawind.net/help/html/jstl_el.htm" target="_blank" rel="external">http://www.javawind.net/help/html/jstl_el.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###EL 表达式&lt;br&gt;在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。&lt;/p&gt;
&lt;p&gt;Sun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。&lt;/p&gt;
&lt;p&gt;Standard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。&lt;/p&gt;
&lt;p&gt;Standard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。&lt;/p&gt;
&lt;p&gt;本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从&lt;a href=&quot;http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：&quot;&gt;http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。&lt;/li&gt;
&lt;li&gt;国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。&lt;/li&gt;
&lt;li&gt;数据库标签库：可以做访问数据库的工作。&lt;/li&gt;
&lt;li&gt;XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。&lt;/li&gt;
&lt;li&gt;函数标签库：用来读取已经定义的某个函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。&lt;/p&gt;
&lt;p&gt;JSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。&lt;/p&gt;
&lt;p&gt;说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.shenyanchao.cn/categories/java/"/>
    
    
      <category term="jstl" scheme="http://www.shenyanchao.cn/tags/jstl/"/>
    
      <category term="el" scheme="http://www.shenyanchao.cn/tags/el/"/>
    
  </entry>
  
  <entry>
    <title>ut-maven-plugin</title>
    <link href="http://www.shenyanchao.cn/2013/12/14/2013-12-14-ut-maven-plugin/"/>
    <id>http://www.shenyanchao.cn/2013/12/14/2013-12-14-ut-maven-plugin/</id>
    <published>2013-12-14T13:31:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###ut-maven-plugin简介</p>
<p>这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。<br>《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。</p>
<p>也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。<br><a id="more"></a></p>
<p>###实现原理<br>如何解析源码，这是首先需要解决的问题。在计算机科学中，有<strong>抽象语法树(Abstract Syntax Tree)</strong>这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。 </p>
<p>Eclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。</p>
<p><img src="/images/blog/2013/eclipse-outline.png" alt=""></p>
<p>同时,Eclipse也提供的有抽象语法树视图，即ASTView。</p>
<p><img src="/images/blog/2013/eclipse-ast-view.png" alt=""></p>
<p>本插件选用<a href="https://code.google.com/p/javaparser/" target="_blank" rel="external">JavaParser</a>来分析源码，提取并生成测试代码。  </p>
<p>###如何使用这个工具？<br>这个插件一个被我放到了<a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22" target="_blank" rel="external">Maven Central</a>上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。<br>比如：  </p>
<pre><code>&lt;plugin&gt;
&lt;groupId&gt;cn.shenyanchao.ut&lt;/groupId&gt;
&lt;artifactId&gt;ut-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;0.2.9&lt;/version&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;source2test&lt;/id&gt;
        &lt;phase&gt;process-test-sources&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;source2test&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
</code></pre><p>###解决了什么问题？<br>以<a href="https://github.com/spring-projects/spring-petclinic" target="_blank" rel="external">spring-petclinic</a>中的代码为例。</p>
<p>下面的Service代码：  </p>
<pre><code>package org.springframework.samples.petclinic.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.model.PetType;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;

@Service
public class ClinicServiceImpl implements ClinicService {

    @Autowired
    private PetRepository petRepository;
    //省略
    ......

    @Override
    @Transactional(readOnly = true)
    public Pet findPetById(int id) throws DataAccessException {
        return petRepository.findById(id);
    }
    //省略
    ......

}
</code></pre><p>那么，我们自己手工写的单元测试代码有可能是这样的：   </p>
<pre><code>package org.springframework.samples.petclinic.service.test;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.samples.petclinic.service.ClinicServiceImpl;

import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

public class ClinicServiceImplTest {

    @InjectMocks
    private ClinicServiceImpl clinicService = new ClinicServiceImpl();

    @Mock
    private PetRepository petRepository;

    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void findPetByIdTest() {
        when(petRepository.findById(anyInt())).thenReturn(new Pet());
        Pet pet = clinicService.findPetById(1);
        Assert.assertNotNull(pet);
    }
</code></pre><p>如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：  </p>
<pre><code>when(petRepository.findById(anyInt())).thenReturn(new Pet());
Pet pet = clinicService.findPetById(1);
</code></pre><p>因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。   </p>
<p>当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###ut-maven-plugin简介&lt;/p&gt;
&lt;p&gt;这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。&lt;br&gt;《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。&lt;/p&gt;
&lt;p&gt;也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。&lt;br&gt;
    
    </summary>
    
      <category term="测试" scheme="http://www.shenyanchao.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="ast" scheme="http://www.shenyanchao.cn/tags/ast/"/>
    
      <category term="ut-maven-plugin" scheme="http://www.shenyanchao.cn/tags/ut-maven-plugin/"/>
    
      <category term="javaparser" scheme="http://www.shenyanchao.cn/tags/javaparser/"/>
    
  </entry>
  
  <entry>
    <title>《程序员修炼之道》读书笔记</title>
    <link href="http://www.shenyanchao.cn/2013/12/04/2013-12-04-the-pragmatic-programmer-reading-notes/"/>
    <id>http://www.shenyanchao.cn/2013/12/04/2013-12-04-the-pragmatic-programmer-reading-notes/</id>
    <published>2013-12-04T07:45:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。</p>
<p>###关于心态</p>
<p>####石头汤与煮青蛙</p>
<blockquote>
<p>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  </p>
<p>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   </p>
<p>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好…….” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。<br>几分钟后，村民们又问：“就这些了吗？”    </p>
<p>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    </p>
<p>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    </p>
<p>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   </p>
</blockquote>
<a id="more"></a>
<p>在石头汤的故事里有两层寓意。  </p>
<p>士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。</p>
<p>另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。   </p>
<p>我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。    </p>
<p>再来看两个案例。   </p>
<blockquote>
<p>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。    </p>
<p>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！   </p>
</blockquote>
<p>锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。     </p>
<p>当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。   </p>
<p>作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。   </p>
<p>###关于工具</p>
<p>###文本编辑器<br>文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：</p>
<ul>
<li>可配置</li>
<li>可扩展</li>
<li>可编程   </li>
</ul>
<p>一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。<br>知道了这些应该怎么做？   </p>
<table border="1px"><br><tr><br><th>如果你现在这样…</th><th>那么考虑…</th><br></tr><br><tr><br><td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td><br></tr><br><tr><br><td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td><br></tr><br></table>

<p><strong>推荐工具：</strong>Emacs,vi,CRiSP,Brief以及其他的跨平台软件。<br>珍惜生命，远离office哦。</p>
<p>####源码控制<br>源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。</p>
<p>把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。   </p>
<p>###关于编码<br>注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。</p>
<p>适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。   </p>
<ul>
<li>不要试图在重构的同时增加功能</li>
<li>在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。</li>
</ul>
<p>重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。&lt;/p&gt;
&lt;p&gt;###关于心态&lt;/p&gt;
&lt;p&gt;####石头汤与煮青蛙&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  &lt;/p&gt;
&lt;p&gt;士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   &lt;/p&gt;
&lt;p&gt;“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好…….” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。&lt;br&gt;几分钟后，村民们又问：“就这些了吗？”    &lt;/p&gt;
&lt;p&gt;“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    &lt;/p&gt;
&lt;p&gt;接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    &lt;/p&gt;
&lt;p&gt;最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="http://www.shenyanchao.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="读书笔记" scheme="http://www.shenyanchao.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSH原理</title>
    <link href="http://www.shenyanchao.cn/2013/11/26/2013-11-26-the-principle-of-ssh/"/>
    <id>http://www.shenyanchao.cn/2013/11/26/2013-11-26-the-principle-of-ssh/</id>
    <published>2013-11-26T08:04:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>###一、什么是SSH？<br>简单说，SSH是一种网络协议，用于计算机之间的加密登录。   </p>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   </p>
<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   </p>
<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。<br><a id="more"></a></p>
<p>###二、最基本的用法<br>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。   </p>
<pre><code>$ ssh user@host
</code></pre><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。   </p>
<pre><code>$ ssh host
</code></pre><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。    </p>
<p>　　$ ssh -p 2222 user@host </p>
<p>上面这条命令表示，ssh直接连接远程主机的2222端口。     </p>
<p>###三、中间人攻击<br>SSH之所以能够保证安全，原因在于它采用了公钥加密。   </p>
<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。    </p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。<br>SSH协议是如何应对的呢？    </p>
<p>###四、口令登录<br>如果你是第一次登录对方主机，系统会出现下面的提示：   </p>
<pre><code>$ ssh user@host
The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.
RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.
Are you sure you want to continue connecting (yes/no)?
</code></pre><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。     </p>
<pre><code>Are you sure you want to continue connecting (yes/no)? yes
</code></pre><p>系统会出现一句提示，表示host主机已经得到认可。     </p>
<pre><code>Warning: Permanently added &apos;host,12.18.429.21&apos; (RSA) to the list of known hosts.
</code></pre><p>然后，会要求输入密码。    </p>
<pre><code>Password: (enter password)
</code></pre><p>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。    </p>
<p>###五、公钥登录<br>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： </p>
<pre><code>$ ssh-keygen
</code></pre><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。    </p>
<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：  </p>
<pre><code>$ ssh-copy-id user@host
</code></pre><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。      </p>
<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
</code></pre><p>然后，重启远程主机的ssh服务。    </p>
<pre><code>// ubuntu系统
service ssh restart
// debian系统
/etc/init.d/ssh restart
</code></pre><p>###六、authorized_keys文件</p>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。   </p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：   </p>
<pre><code>$ ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub     
</code></pre><p>这条命令由多个语句组成，依次分解开来看：<br>（1）<code>$ ssh user@host</code>，表示登录远程主机；<br>（2）单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程shell上执行的命令：<br>（3）<code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;<br>（4）<code>cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###一、什么是SSH？&lt;br&gt;简单说，SSH是一种网络协议，用于计算机之间的加密登录。   &lt;/p&gt;
&lt;p&gt;如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   &lt;/p&gt;
&lt;p&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   &lt;/p&gt;
&lt;p&gt;需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.shenyanchao.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.shenyanchao.cn/tags/linux/"/>
    
      <category term="ssh" scheme="http://www.shenyanchao.cn/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目集成CheckStyle,PMD,FindBugs进行静态代码扫描</title>
    <link href="http://www.shenyanchao.cn/2013/11/20/2013-11-20-maven-project-integrate-checkstyle-pmd-findbugs/"/>
    <id>http://www.shenyanchao.cn/2013/11/20/2013-11-20-maven-project-integrate-checkstyle-pmd-findbugs/</id>
    <published>2013-11-20T11:22:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在pom.xml里添加以下maven插件配置：   </p>
<pre><code>    &lt;!-- 静态代码检查 --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.11&lt;/version&gt;
    &lt;configuration&gt;
        &lt;configLocation&gt;checkstyle.xml&lt;/configLocation&gt;
        &lt;includeResources&gt;false&lt;/includeResources&gt;
        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;
        &lt;violationSeverity&gt;info&lt;/violationSeverity&gt;
        &lt;maxAllowedViolations&gt;0&lt;/maxAllowedViolations&gt;
        &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;
        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
        &lt;includes&gt;
            **\/package\/**.java,**\/otherpackage\/**.java
        &lt;/includes&gt;
    &lt;/configuration&gt;
&lt;!--     &lt;executions&gt;
         &lt;execution&gt;
             &lt;goals&gt;
                 &lt;goal&gt;check&lt;/goal&gt;
             &lt;/goals&gt;
             &lt;phase&gt;validate&lt;/phase&gt;
         &lt;/execution&gt;
     &lt;/executions&gt;--&gt;
&lt;/plugin&gt;

&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.7.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;failurePriority&gt;5&lt;/failurePriority&gt;
        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;
        &lt;targetJdk&gt;${jdk.version}&lt;/targetJdk&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;
        &lt;rulesets&gt;
            &lt;ruleset&gt;pmd.xml&lt;/ruleset&gt;
        &lt;/rulesets&gt;
        &lt;includes&gt;
            &lt;include&gt;**\/package\/**.java&lt;/include&gt;
            &lt;include&gt;**\/otherpackage\/**.java&lt;/include&gt;
        &lt;/includes&gt;
    &lt;/configuration&gt;
  &lt;!--   &lt;executions&gt;
         &lt;execution&gt;
             &lt;phase&gt;package&lt;/phase&gt;
             &lt;goals&gt;
                 &lt;goal&gt;check&lt;/goal&gt;
             &lt;/goals&gt;
         &lt;/execution&gt;
     &lt;/executions&gt;--&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.5.2&lt;/version&gt;
    &lt;configuration&gt;
        &lt;onlyAnalyze&gt;
            cn.shenyanchao.package.*,
            cn.shenyanchao.otherpackage.*,
        &lt;/onlyAnalyze&gt;
        &lt;includeFilterFile&gt;findbugs.xml&lt;/includeFilterFile&gt;
        &lt;failOnError&gt;true&lt;/failOnError&gt;
        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;
    &lt;/configuration&gt;
 &lt;!--   &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;check&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;--&gt;
&lt;/plugin&gt;
</code></pre><p>这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。<br><a id="more"></a>  </p>
<p>#####那么能否指定只扫描特定的包或者文件呢？<br>上面checkstyle用的是：  </p>
<pre><code>&lt;includes&gt;
    **\/package\/**.java,**\/otherpackage\/**.java
&lt;/includes&gt;
</code></pre><p>pmd是：    </p>
<pre><code>&lt;includes&gt;
    &lt;include&gt;**\/package\/**.java&lt;/include&gt;
    &lt;include&gt;**\/otherpackage\/**.java&lt;/include&gt;
&lt;/includes&gt;
</code></pre><p>findbugs则使用的是：</p>
<pre><code>&lt;onlyAnalyze&gt;
    cn.shenyanchao.package.*,
    cn.shenyanchao.otherpackage.*,
&lt;/onlyAnalyze&gt;
</code></pre><p>#####如何在编译期间或打包期间执行检查？</p>
<p>如上所示的注释掉部分，添加就可以了：</p>
<pre><code>&lt;executions&gt;
     &lt;execution&gt;
         &lt;phase&gt;package&lt;/phase&gt;
         &lt;goals&gt;
             &lt;goal&gt;check&lt;/goal&gt;
         &lt;/goals&gt;
     &lt;/execution&gt;
 &lt;/executions&gt;
</code></pre><p>这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pom.xml里添加以下maven插件配置：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;!-- 静态代码检查 --&amp;gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.11&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;configLocation&amp;gt;checkstyle.xml&amp;lt;/configLocation&amp;gt;
        &amp;lt;includeResources&amp;gt;false&amp;lt;/includeResources&amp;gt;
        &amp;lt;failOnViolation&amp;gt;true&amp;lt;/failOnViolation&amp;gt;
        &amp;lt;violationSeverity&amp;gt;info&amp;lt;/violationSeverity&amp;gt;
        &amp;lt;maxAllowedViolations&amp;gt;0&amp;lt;/maxAllowedViolations&amp;gt;
        &amp;lt;consoleOutput&amp;gt;true&amp;lt;/consoleOutput&amp;gt;
        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
        &amp;lt;includes&amp;gt;
            **\/package\/**.java,**\/otherpackage\/**.java
        &amp;lt;/includes&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;!--     &amp;lt;executions&amp;gt;
         &amp;lt;execution&amp;gt;
             &amp;lt;goals&amp;gt;
                 &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
             &amp;lt;/goals&amp;gt;
             &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
         &amp;lt;/execution&amp;gt;
     &amp;lt;/executions&amp;gt;--&amp;gt;
&amp;lt;/plugin&amp;gt;

&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-pmd-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.7.1&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;failurePriority&amp;gt;5&amp;lt;/failurePriority&amp;gt;
        &amp;lt;failOnViolation&amp;gt;true&amp;lt;/failOnViolation&amp;gt;
        &amp;lt;targetJdk&amp;gt;${jdk.version}&amp;lt;/targetJdk&amp;gt;
        &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
        &amp;lt;outputEncoding&amp;gt;UTF-8&amp;lt;/outputEncoding&amp;gt;
        &amp;lt;rulesets&amp;gt;
            &amp;lt;ruleset&amp;gt;pmd.xml&amp;lt;/ruleset&amp;gt;
        &amp;lt;/rulesets&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**\/package\/**.java&amp;lt;/include&amp;gt;
            &amp;lt;include&amp;gt;**\/otherpackage\/**.java&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/configuration&amp;gt;
  &amp;lt;!--   &amp;lt;executions&amp;gt;
         &amp;lt;execution&amp;gt;
             &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
             &amp;lt;goals&amp;gt;
                 &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
             &amp;lt;/goals&amp;gt;
         &amp;lt;/execution&amp;gt;
     &amp;lt;/executions&amp;gt;--&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;findbugs-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;onlyAnalyze&amp;gt;
            cn.shenyanchao.package.*,
            cn.shenyanchao.otherpackage.*,
        &amp;lt;/onlyAnalyze&amp;gt;
        &amp;lt;includeFilterFile&amp;gt;findbugs.xml&amp;lt;/includeFilterFile&amp;gt;
        &amp;lt;failOnError&amp;gt;true&amp;lt;/failOnError&amp;gt;
        &amp;lt;outputEncoding&amp;gt;UTF-8&amp;lt;/outputEncoding&amp;gt;
    &amp;lt;/configuration&amp;gt;
 &amp;lt;!--   &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;--&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。&lt;br&gt;
    
    </summary>
    
      <category term="maven" scheme="http://www.shenyanchao.cn/categories/maven/"/>
    
    
      <category term="pmd" scheme="http://www.shenyanchao.cn/tags/pmd/"/>
    
      <category term="maven" scheme="http://www.shenyanchao.cn/tags/maven/"/>
    
      <category term="checkstyle" scheme="http://www.shenyanchao.cn/tags/checkstyle/"/>
    
      <category term="findbugs" scheme="http://www.shenyanchao.cn/tags/findbugs/"/>
    
      <category term="静态代码扫描" scheme="http://www.shenyanchao.cn/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Maven如何打包本地依赖包</title>
    <link href="http://www.shenyanchao.cn/2013/11/20/2013-11-20-how-package-system-dependency-lib-in-maven/"/>
    <id>http://www.shenyanchao.cn/2013/11/20/2013-11-20-how-package-system-dependency-lib-in-maven/</id>
    <published>2013-11-20T11:04:00.000Z</published>
    <updated>2016-08-14T08:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>####Maven如何依赖本地包？<br>有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.wltea.ik-analyzer&lt;/groupId&gt;
    &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt;
    &lt;version&gt;3.2.8&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/lib/ik-analyzer-3.2.8.jar&lt;/systemPath&gt;
&lt;/dependency&gt;
</code></pre><p>这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。</p>
<p>####如何将本地包打到war包内？<br>打war包，一般直接执行<code>mvn clean package</code>即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。</p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
    &lt;configuration&gt;
        &lt;warName&gt;${project.artifactId}&lt;/warName&gt;
        &lt;webResources&gt;
            &lt;resource&gt;
                &lt;directory&gt;lib/&lt;/directory&gt;
                &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.jar&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/webResources&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####Maven如何依赖本地包？&lt;br&gt;有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.wltea.ik-analyzer&amp;lt;/
    
    </summary>
    
      <category term="maven" scheme="http://www.shenyanchao.cn/categories/maven/"/>
    
    
      <category term="maven" scheme="http://www.shenyanchao.cn/tags/maven/"/>
    
      <category term="package" scheme="http://www.shenyanchao.cn/tags/package/"/>
    
      <category term="war" scheme="http://www.shenyanchao.cn/tags/war/"/>
    
  </entry>
  
</feed>
