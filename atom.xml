<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-07-04T18:58:10+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《重构与模式》读书笔记]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes/"/>
    <updated>2013-06-28T13:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/28/refactoring-to-patterns-reading-notes</id>
    <content type="html"><![CDATA[<p>GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。</p>

<h3>写作缘由</h3>

<ul>
<li>过度设计：代码存在设计过度的情况</li>
<li>模式万灵丹：认为设计模式的万能的</li>
<li>设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”</li>
<li>测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”</li>
<li>重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构</li>
<li>演进式设计：将模式放到重构的背景中进行领会</li>
</ul>


<h3>什么是重构</h3>

<p>定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。 <br/>
重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。</p>

<p>重构的动机：</p>

<ul>
<li>使新代码的增加更容易</li>
<li>改善既有代码的设计</li>
<li>对代码理解更透彻</li>
<li>提高编程的趣味性</li>
</ul>


<!--more-->


<h3>什么是模式</h3>

<p>GoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。 <br/>
应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。</p>

<h3>代码坏味</h3>

<ul>
<li><p>1.重复代码（Duplicated Code）</p>

<blockquote><p>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；</p></blockquote></li>
<li><p>2.过长函数（Long Method）：</p>

<blockquote><p>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；</p></blockquote></li>
<li><p>3.条件逻辑太复杂（Conditional Complexity）：</p>

<blockquote><p>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;</p></blockquote></li>
<li><p>4.基本类型偏执（Primitive Obsession）:</p>

<blockquote><p>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。</p></blockquote></li>
<li><p>5.不恰当的暴露（Indecent Exposure）：</p>

<blockquote><p>用Factory封装类；</p></blockquote></li>
<li><p>6.解决方案蔓延（Solution Sprawl）：</p>

<blockquote><p>将创建知识搬移到Factory；</p></blockquote></li>
<li><p>7.异曲同工的类（Alternative Classes With Different Interfaces）：</p>

<blockquote><p>通过Adapter统一接口；</p></blockquote></li>
<li><p>8.冗赘类（Lazy Class）：</p>

<blockquote><p>内联Singeton；</p></blockquote></li>
<li>9.过大的类（Large Class）：

<blockquote><p>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；</p></blockquote></li>
<li>10.分支语句（Switch Statement）：

<blockquote><p>用Command替换条件调度程序；将聚集操作搬移到Visitor；</p></blockquote></li>
<li>11.组合爆炸（Combinatorial Explosion）：

<blockquote><p>用Interpreter替换隐式语言；</p></blockquote></li>
<li>12.怪异解决方案（Oddball Solution）：

<blockquote><p>通过Adapter统一接口；</p></blockquote></li>
</ul>


<h3>创建</h3>

<h4>用Creation Method替换构造函数</h4>

<p>如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。 <br/>
优缺点：<br/>
+比构造函数能够更好的表达所创建的实例的种类。 <br/>
+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。 <br/>
+更容易发现无用的创建代码。 <br/>
-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。</p>

<h4>将创建知识搬移到Factory</h4>

<p>当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。  <br/>
优缺点： <br/>
+合并创建逻辑和实例化/配置选项。 <br/>
+将客户代码与创建逻辑解耦。  <br/>
-如果可以直接实例化，会使设计复杂化。</p>

<h4>用Factory封装类</h4>

<p>如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。 <br/>
优缺点： <br/>
+通过意图导向的CreationMethod简化了不同种类实例的创建。  <br/>
+通过隐藏不需要公开的类减少了包结构的“概念重量”  <br/>
+帮助严格执行“面向接口编程，而不是面向实现”这一格言。  <br/>
-当需要创建新种类的实例时，必须新建/更新Creation Method。<br/>
-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。</p>

<h4>用Factory Method引入多态创建</h4>

<p>一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。 <br/>
优缺点： <br/>
+减少因创建自定义对象而产生的重复代码  <br/>
+有效的表达了对象创建发生的位置，以及如何重写对象的创建。 <br/>
+强制Factory Method使用的类必须实现统一的类型。 <br/>
-可能会向Factory Method的一些实现者传递不必要的参数。</p>

<h4>用Builder封装Composite</h4>

<p>构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。 <br/>
优缺点： <br/>
+简化了构造Composite的客户代码。 <br/>
+减少了创建Composite的重复和易出错的本性。<br/>
+在客户代码和Composite之间实现了松耦合。 <br/>
-接口可能不会很清楚的表达其意图。</p>

<h4>内联Singleton</h4>

<p>绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。 <br/>
优缺点： <br/>
+使对象的协作变得更明显和明确。 <br/>
+保护了单一的实例，且不要要特殊的代码。 <br/>
-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。</p>

<h3>简化</h3>

<h4>组合方法</h4>

<p>一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。 <br/>
优缺点：  <br/>
+清晰的描述了一个方法所实现的功能以及如何实现。 <br/>
+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。 <br/>
-可能会产生过多的小方法。 <br/>
-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。</p>

<h4>用Strategy替换条件逻辑</h4>

<p>当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。  <br/>
优缺点： <br/>
+通过减少或去除条件逻辑使算法变得清晰易懂。 <br/>
+通过把算法的变体搬移到类层次中简化了类。 <br/>
+允许在运行时用一种算法替换另一种算法。 <br/>
-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。 <br/>
-增加了算法如何获取或接受上下文类的数据的复杂度。</p>

<h4>将装饰功能搬移到Decorator</h4>

<p>如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。 <br/>
优缺点： <br/>
+把装饰功能从类中搬移去除，从而简化了类。 <br/>
+有效地把类的核心职责和装饰功能区分开来。 <br/>
+可以去除几个相关类中重复的装饰逻辑。 <br/>
-改变了被装饰对象的对象类型。 <br/>
-会使代码变得更难理解和调适。 <br/>
-当Decorator组合产生负面影响的时候，会增加设计的复杂度。</p>

<h4>用State替换状态改变条件语句</h4>

<p>如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。 <br/>
优缺点： <br/>
+减少或去除状态改变条件逻辑。<br/>
+简化了复杂的状态改变逻辑。 <br/>
+提供了观察状态改变逻辑的很好的鸟瞰图。<br/>
-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。</p>

<h4>用Composite替换隐含树</h4>

<p>有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。 <br/>
优缺点： <br/>
+封装重复的指令，如格式化、添加或删除结点。 <br/>
+提供了处理相似逻辑增长的一般性方法。 <br/>
+简化了客户代码的构造职责。  <br/>
-当构造隐式树更简单的时候，会增加设计的复杂度。</p>

<h4>用Command替换条件调度程序</h4>

<p>许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。  <br/>
优缺点： <br/>
+提供了用统一方法执行不同行为的简单机制。 <br/>
+允许在运行时改变所处理的请求，以及如何处理请求。 <br/>
+仅仅需要很少的代码实现。 <br/>
-当条件调度程序已经足够的时候，会增加设计的复杂度。</p>

<h3>泛化</h3>

<h4>形成Template Method</h4>

<p>借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。  <br/>
优点与缺点： <br/>
+通过把不变行为搬移到超类，去除子类中的重复代码  <br/>
+简化并有效地表达了一个通用算法的步骤。 <br/>
+允许子类很容易的定制一个算法  <br/>
-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。</p>

<h4>提取Composite</h4>

<p>在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。  <br/>
优缺点： <br/>
+去除重复的类存储逻辑和类处理逻辑。  <br/>
+能够有效的表达类处理逻辑的可继承性。</p>

<h4>用Composite替换一/多之分</h4>

<p>这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题： <br/>
如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。  <br/>
使用Composite扩展出And，Or等条件，简化客户端的处理。  <br/>
优缺点： <br/>
+去除与处理一个或多个对象相关联的重复代码。 <br/>
+提供了处理一个或多个对象的同一方法。 <br/>
+支持处理多个对象的更丰富的方法。（如OR表达式） <br/>
-可能会在Composite的构造过程中要求类型安全的运行时检查。</p>

<h4>用Observer替换硬编码的通知</h4>

<p>拒绝使用硬编码的通知，考虑使用Observer模式。 <br/>
优缺点： <br/>
+使主题及其观察者访问松散耦合 <br/>
+支持一个或多个观察者  <br/>
-当硬编码的通知已经足够的时候，会增加设计复杂度  <br/>
-当出现串联通知的时候，会增加代码的复杂度      <br/>
-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。</p>

<h4>通过Adapter统一接口</h4>

<p>全部满足以下条件，考虑使用Adapter:</p>

<ul>
<li>2个类所做的事情相同或者相似，但是具有不同的接口。</li>
<li>如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。</li>
<li>无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。</li>
</ul>


<p>比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。 <br/>
优缺点： <br/>
+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。 <br/>
+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。  <br/>
+统一了客户代码与不同的类的交互方式。  <br/>
-当类的接口可以改变的时候，会增加设计的复杂度。</p>

<h4>提取Adapter</h4>

<p>当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。  <br/>
优缺点：<br/>
+隔离了不同版本的组件，类库或API之间的不同之处。 <br/>
+使类只负责适配代码的一个版本。  <br/>
+避免频繁地修改代码   <br/>
-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。</p>

<h4>用Interpreter替换隐式语言</h4>

<p>在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。  <br/>
优缺点： <br/>
+比隐式语言更好的支持语言元素的组合。 <br/>
+不需要新的代码来支持语言元素的新组合。<br/>
+允许行为的运行时配置。
-会产生定义语法和修改客户代码的开销。 <br/>
-如果语言很复杂，则需要很多的编程工作。 <br/>
-如果语言本身就很简单，则会增加设计的复杂度。</p>

<h3>保护</h3>

<h4>用类替换类型代码</h4>

<p>字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。  <br/>
优缺点：  <br/>
+更好的避免非法赋值和比较。  <br/>
-比使用不安全类型要求更多的代码。</p>

<h4>用Singleton限制实例化</h4>

<p>有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。 <br/>
优缺点：  <br/>
+改进性能。  <br/>
-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。 <br/>
-当对象含有不能共享的状态的时候，本重构就无效了。</p>

<h4>引入Null Object</h4>

<p>代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。  <br/>
优缺点：   <br/>
+不需要重复的null逻辑就可以避免null错误。 <br/>
+通过最小化null测试简化了代码。  <br/>
-当系统不太需要null测试的时候，会增加设计的复杂度。 <br/>
-如果程序员不知道Null Object的存在，就会产生多余的null测试。 <br/>
-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。</p>

<h3>聚集操作</h3>

<h4>将聚集操作搬移到Collecting Parameter</h4>

<p>有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。  <br/>
优缺点：   <br/>
+帮助我们把很大的方法转换成更小的，更简单的多个方法。  <br/>
-使结果代码运行得更快。</p>

<h4>将聚集操作搬移到Visitor</h4>

<p>如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。   <br/>
优缺点：  <br/>
+调节多个算法，使其适用于不同的对象结构。 <br/>
+访问相同或不同继承结构中的类。 <br/>
+调用不同类上的类型特定方法，无需类型转换。  <br/>
-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。  <br/>
-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。  <br/>
-可能会破坏被访问类的封装性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DbUnit使用入门]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit/"/>
    <updated>2013-06-27T15:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit</id>
    <content type="html"><![CDATA[<p><a href="http://www.dbunit.org/">DbUnit</a>是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。</p>

<h3>DbUnit原理</h3>

<p>DbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。 <br/>
DbUnit包括三个核心部分:</p>

<ul>
<li>IDatabaseConnection ：描述DbUnit数据库连接接口；</li>
<li>IDataSet：数据集操作接口；</li>
<li>DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；</li>
</ul>


<!--more-->


<p>值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。</p>

<p>DatabaseOperation有以下的可选项：</p>

<ul>
<li>NONE：不执行任何操作，是getTearDownOperation的默认返回值。</li>
<li>UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。</li>
<li>INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。
REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。</li>
<li>DELETE：删除数据库中与数据集对应的记录。</li>
<li>DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。</li>
<li>TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。</li>
<li>CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。</li>
</ul>


<h3>开始使用DbUnit</h3>

<h4>DataSet数据集准备</h4>

<p>DataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以<a href="http://www.dbunit.org/components.html#FlatXmlDataSet">手工编写</a>。另外也可以从数据库读取，DbUnit提供了相关的API：</p>

<pre><code>    QueryDataSet dataSet = new QueryDataSet(getConnection());
    dataSet.addTable("user", "select * from user ");
    FlatXmlDataSet.write(dataSet, new FileOutputStream("data.xml"));
</code></pre>

<h4>继承DBTestCase来实现测试用例</h4>

<p>最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：</p>

<ul>
<li>JdbcBasedDBTestCase</li>
<li>DataSourceBasedDBTestCase</li>
<li>JndiBasedDBTestCase</li>
</ul>


<p>下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。</p>

<pre><code>public class SampleTest extends DBTestCase
{
    public SampleTest(String name)
    {
        super( name );
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, "org.h2.Driver");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, "jdbc:h2:~/dbunitdemo");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, "sa");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, "");

    protected IDataSet getDataSet() throws Exception
    {
        return new FlatXmlDataSetBuilder().build(new FileInputStream("dataset.xml"));
    }
}
</code></pre>

<p>那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。</p>

<pre><code>protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {
    return new JdbcDatabaseTester("org.h2.Driver", "jdbc:h2:~/dbunitdemo", "sa", "");
}
</code></pre>

<h4>定制测试执行前后的操作</h4>

<p>默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。</p>

<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception
{
    return DatabaseOperation.REFRESH;
}

protected DatabaseOperation getTearDownOperation() throws Exception
{
    return DatabaseOperation.NONE;
}
</code></pre>

<h4>DatabaseConfig设置</h4>

<p>有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。</p>

<pre><code>protected void setUpDatabaseConfig(DatabaseConfig config) {
        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));
        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);
}
</code></pre>

<p>比如，我在使用H2Database时，老是报一个这样的warn:</p>

<pre><code>WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory 'class org.dbunit.dataset.datatype.DefaultDataTypeFactory' might cause problems with the current database 'H2' (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.
</code></pre>

<p>那么，如何让这个WARN消失呢？加上这个配置：</p>

<pre><code>config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());
</code></pre>

<h4>Database数据验证</h4>

<p>DbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。</p>

<pre><code>public class Assertion
{
    public static void assertEquals(ITable expected, ITable actual)
    public static void assertEquals(IDataSet expected, IDataSet actual)
}
</code></pre>

<p>下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。</p>

<pre><code>    // Fetch database data after executing your code
    IDataSet databaseDataSet = getConnection().createDataSet();
    ITable actualTable = databaseDataSet.getTable("TABLE_NAME");

    // Load expected data from an XML dataset
    IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File("expectedDataSet.xml"));
    ITable expectedTable = expectedDataSet.getTable("TABLE_NAME");

    // Assert actual database table match expected table
    Assertion.assertEquals(expectedTable, actualTable);
</code></pre>

<h3>DbUnit的运行步骤</h3>

<p>由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：</p>

<pre><code>protected void setUp() throws Exception
{
    logger.debug("setUp() - start");

    super.setUp();
    final IDatabaseTester databaseTester = getDatabaseTester();
    assertNotNull( "DatabaseTester is not set", databaseTester );
    databaseTester.setSetUpOperation( getSetUpOperation() );
    databaseTester.setDataSet( getDataSet() );
    databaseTester.setOperationListener(getOperationListener());
    databaseTester.onSetup();
}

protected void tearDown() throws Exception
{
    logger.debug("tearDown() - start");

    try {
        final IDatabaseTester databaseTester = getDatabaseTester();
        assertNotNull( "DatabaseTester is not set", databaseTester );
        databaseTester.setTearDownOperation( getTearDownOperation() );
        databaseTester.setDataSet( getDataSet() );
        databaseTester.setOperationListener(getOperationListener());
        databaseTester.onTearDown();
    } finally {
        tester = null;
        super.tearDown();
    }
}
</code></pre>

<p>这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。</p>

<p>总结：</p>

<ul>
<li>1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。</li>
<li>2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。</li>
<li>3.运行测试。</li>
<li>4.测试运行完毕后，不执行任何操作。</li>
</ul>


<h3>使用什么数据库？</h3>

<p>由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。  <br/>
这里推荐一个数据库<a href="http://www.h2database.com/html/main.html">H2Database</a>，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：</p>

<table style="width: 470px;" border="1"><tr>
<th></th>
<th>H2</th>
<th><a href="http://db.apache.org/derby">Derby</a></th>
<th><a href="http://hsqldb.org">HSQLDB</a></th>
<th><a href="http://mysql.com">MySQL</a></th>
<th><a href="http://www.postgresql.org">PostgreSQL</a></th>
</tr><tr>
<td>Pure Java</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Memory Mode</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Encrypted Database</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>ODBC Driver</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Fulltext Search</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Multi Version Concurrency</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Footprint (jar/dll size)</td>
<td>~1 MB</td>
<td>~2 MB</td>
<td>~1 MB</td>
<td>~4 MB</td>
<td>~6 MB</td>
</tr>
</table>


<p>之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。  <br/>
有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个<a href="http://mojo.codehaus.org/sql-maven-plugin/">sql-maven-plugin</a>。它可以方便的执行数据库SQL脚本来创建数据库。</p>

<pre><code>            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;sql-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.5&lt;/version&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
                        &lt;artifactId&gt;h2&lt;/artifactId&gt;
                        &lt;version&gt;1.3.172&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;configuration&gt;
                    &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
                    &lt;url&gt;jdbc:h2:~/dbunitdemo&lt;/url&gt;
                    &lt;username&gt;sa&lt;/username&gt;
                    &lt;password&gt;&lt;/password&gt;
                    &lt;srcFiles&gt;
                        &lt;srcFile&gt;${project.basedir}/src/main/sql/dbunitdemo.sql&lt;/srcFile&gt;
                    &lt;/srcFiles&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;create-db&lt;/id&gt;
                        &lt;phase&gt;process-test-resources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;execute&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>

<p>这里，创建了一个H2Database。直接执行<code>mvn sql:execute</code>用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行<code>mvn test</code>就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief/"/>
    <updated>2013-06-21T21:29:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief</id>
    <content type="html"><![CDATA[<p>Mockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。</p>

<p>项目地址:<a href="https://code.google.com/p/mockito/">https://code.google.com/p/mockito/</a></p>

<h2>powermock 简介</h2>

<p>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。</p>

<p>项目地址:<a href="https://code.google.com/p/powermock/">https://code.google.com/p/powermock/</a></p>

<!--more-->


<h2>Mock 和Stub</h2>

<h3>Mock</h3>

<p>所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。</p>

<h3>Stub</h3>

<p>Stub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。</p>

<h3>Stub 与 Mock 的区别</h3>

<p>Stub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。</p>

<h2>Mockito 的使用</h2>

<h3>Maven</h3>

<p>通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mockito&lt;/groupId&gt;
&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
&lt;version&gt;1.9.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>在程序中可以<code>import org.mockito.Mockito</code>，然后调用它的static方法。</p>

<h3>Maven 程序</h3>

<h4>1.模拟对象</h4>

<p>创建 Mock 对象的语法为 mock(class or interface)。</p>

<h4>2.设置对象调用的预期返回值</h4>

<p>通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。</p>

<h4>3.验证被测试类方法</h4>

<p>Mock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。</p>

<h3>Demo</h3>

<h2>Mock 对象的创建</h2>

<pre><code>mock(Class&lt;T&gt; classToMock);
mock(Class&lt;T&gt; classToMock, String name)
mock(Class&lt;T&gt; classToMock, Answer defaultAnswer)
mock(Class&lt;T&gt; classToMock, MockSettings mockSettings)
mock(Class&lt;T&gt; classToMock, ReturnValues returnValues)
</code></pre>

<p>可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。</p>

<h2>Mock对象的期望行为和返回值设定</h2>

<p>假设我们创建了LinkedList类的mock对象：</p>

<pre><code>LinkedList mockedList = mock(LinkedList.class);
</code></pre>

<h3>对方法进行设定返回值和异常</h3>

<h4>对包含返回值的方法的设定</h4>

<pre><code>when(mockedList.get(0)).thenReturn("first");
when(mockedList.get(1)).thenThrow(new RuntimeException());   
</code></pre>

<p>Mockito支持迭代风格的返回值设定</p>

<pre><code>when(mockedList.get(anyInt()).thenReturn("first").thenThrow(new RuntimeException());
when(mockedList.get(anyInt()).thenReturn("first","second");
</code></pre>

<p>Stubbing的另一种风格</p>

<pre><code>doReturn("Hello").when(mockedList).get(0);
doReturn("Hello").doReturn("world").when(mockedList).get(anyInt());
</code></pre>

<p>抛出异常</p>

<pre><code>doThrow(new RuntimeException()).when(mockedList).get(0);
</code></pre>

<h4>对void方法进行方法预期设定</h4>

<pre><code>doNothing().when(mockedClass).SomeVoidMethod();
doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<p>迭代风格</p>

<pre><code>doNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<h2>参数匹配器</h2>

<p>在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。</p>

<pre><code>//stubbing using anyInt() argument matcher
when(mockedList.get(anyInt())).thenReturn("element");

//following prints "element"
System.out.println(mockedList.get(999));

//you can also verify using argument matcher
verify(mockedList).get(anyInt());   
</code></pre>

<p>需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(&#8220;third argument&#8221;)，直接修改为“third argument”会报错。</p>

<pre><code>verify(mockedClass).someMethod(anyObject(), anyString(), eq("third argument"));
</code></pre>

<h2>Mock对象行为的验证</h2>

<p>Mock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。</p>

<h3>调用次数验证</h3>

<pre><code>public static &lt;T&gt; T verify(T mock).someMethod()
public static &lt;T&gt; T verify(T mock, VerificationMode mode).someMethod()

Parameters:
    mock - to be verified
    mode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() 
Returns:
    mock object itself
</code></pre>

<h3>调用顺序验证</h3>

<pre><code>public static InOrder inOrder(java.lang.Object... mocks)
</code></pre>

<p>创建mock对象</p>

<pre><code>// Multiple mocks that must be used in a particular order
List firstMock = mock(List.class);
List secondMock = mock(List.class);
</code></pre>

<p>调用mock对象的方法</p>

<pre><code>//using mocks
firstMock.add("was called first");
secondMock.add("was called second");
</code></pre>

<p>创建InOrder对象</p>

<pre><code>//create inOrder object passing any mocks that need to be verified in order
InOrder inOrder = inOrder(firstMock, secondMock);
</code></pre>

<p>验证方法调用</p>

<pre><code>//following will make sure that firstMock was called before secondMock
inOrder.verify(firstMock).add("was called first");
inOrder.verify(secondMock).add("was called second");
</code></pre>

<h2><code>RETURN_SMART_NULLS和RETURN_DEEP_STUBS</code></h2>

<p><code>RETURN_SMART_NULLS</code> 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， <code>mock(class,answer)</code>。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空&#8221;&#8220;, int 会返回 0,List 会返回 null。</p>

<p>mock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。</p>

<h2>注解</h2>

<p>Mockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks</p>

<h3>Annotation 的初始化</h3>

<p>初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。</p>

<pre><code>public class ArticleManagerTest {

    @Mock private ArticleCalculator calculator;
    @Mock private ArticleDatabase database;
    @Mock private UserProvider userProvider;

    @Before public void setup() {
        MockitoAnnotations.initMocks(testClass);
    }
}
</code></pre>

<p>使用Mockito提供的Junit Runner可以省略上述步骤。</p>

<pre><code>@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {
    @Mock private List list;

    @Test public void shouldDoSomething() {
        list.add(100);
    }
}
</code></pre>

<h2>powermock 的使用</h2>

<h3>Maven配置</h3>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h2>PowerMock 在单元测试中的应用</h2>

<h3>模拟 Static 方法</h3>

<p>在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：</p>

<pre><code>@RunWith(PowerMockRunner.class)   
</code></pre>

<p>然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：</p>

<pre><code>@PrepareForTest( { YourClassWithEgStaticMethod.class })   
</code></pre>

<p>然后就可以开始写测试代码：</p>

<pre><code>1，首先，需要有一个含有 static 方法的代码 , 如
public class IdGenerator { 
    ... 
    public static long generateNewId() { 
        ... 
    } 
    ... 
 } 
2，然后，在被测代码中，引用了以上方法
public class ClassUnderTest { 
    ... 
    public void methodToTest() { 
    .. 
    final long id = IdGenerator.generateNewId(); 
    .. 
    } 
    ... 
} 

3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值
来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：

 @RunWith(PowerMockRunner.class) 
 @PrepareForTest(IdGenerator.class) 
 public class MyTestClass { 
    @Test 
    public void demoStaticMethodMocking() throws Exception { 
        PowerMockito.mockStatic(IdGenerator.class);  
        when(IdGenerator.generateNewId()).thenReturn(2L); 

        new ClassUnderTest().methodToTest(); 

        verifyStatic(); 
        IdGenerator.generateNewId(); 
    } 
 }
</code></pre>

<h3>模拟构造函数</h3>

<p>有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：</p>

<pre><code>public class DirectoryStructure { 
    public boolean create(String directoryPath) { 
        File directory = new File(directoryPath); 

        if (directory.exists()) { 
            throw new IllegalArgumentException(
            "\"" + directoryPath + "\" already exists."); 
        } 

        return directory.mkdirs(); 
    } 
 }    
</code></pre>

<p>为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(DirectoryStructure.class) 
 public class DirectoryStructureTest { 
    @Test 
    public void createDirectoryStructureWhenPathDoesntExist() 
    throws Exception { 
        final String directoryPath = "mocked path"; 

        File directoryMock = mock(File.class); 

        //File的初始化函数的mock
        whenNew(File.class).withArguments(directoryPath)
            .thenReturn(directoryMock); 

        // Standard expectations 
        when(directoryMock.exists()).thenReturn(false); 
        when(directoryMock.mkdirs()).thenReturn(true); 

        assertTrue(new NewFileExample()
            .createDirectoryStructure(directoryPath)); 

        // Optionally verify that a new File was "created". 
        verifyNew(File.class).withArguments(directoryPath); 
    } 
 } 
</code></pre>

<p>使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。</p>

<h3>模拟私有以及 Final 方法</h3>

<p>为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。</p>

<p>在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。</p>

<p>局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。</p>

<p>这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。
参考如下所示的被测代码：</p>

<pre><code> public final class PrivatePartialMockingExample { 
    public String methodToTest() { 
        return methodToMock("input"); 
    } 

    private String methodToMock(String input) { 
        return "REAL VALUE = " + input; 
    } 
 } 
</code></pre>

<p>为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(PrivatePartialMockingExample.class) 
 public class PrivatePartialMockingExampleTest { 
    @Test 
    public void demoPrivateMethodMocking() throws Exception { 
        final String expected = "TEST VALUE"; 
        final String nameOfMethodToMock = "methodToMock"; 
        final String input = "input"; 

        PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); 

        /* 
         * Setup the expectation to the private method using the method name 
         */ 
        when(underTest, nameOfMethodToMock, input).thenReturn(expected); 

        assertEquals(expected, underTest.methodToTest()); 

        // Optionally verify that the private method was actually called 
        verifyPrivate(underTest).invoke(nameOfMethodToMock, input); 
    } 
 } 
</code></pre>

<p>可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。</p>

<p>参考文献:<a href="http://www.ibm.com/developerworks/cn/java/j-lo-powermock/">http://www.ibm.com/developerworks/cn/java/j-lo-powermock/</a></p>

<hr />

<p>Thanks to：lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Github发布jar包到Maven Central]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/19/publishing-from-github-to-maven-central/"/>
    <updated>2013-06-19T19:50:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/19/publishing-from-github-to-maven-central</id>
    <content type="html"><![CDATA[<p>除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。</p>

<p>下面介绍下如何做：</p>

<h3>准备工作</h3>

<p>1.添加source code management信息到pom.xml:</p>

<pre><code>&lt;scm&gt;
    &lt;connection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/connection&gt;
    &lt;developerConnection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/developerConnection&gt;
    &lt;url&gt;git@github.com:blueshen/ut-maven-plugin.git&lt;/url&gt;
&lt;/scm&gt;
</code></pre>

<p>2.创建GPG的密钥对并发布公钥。参看<a href="https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven">Sonatype documentation</a>的具体步骤.推荐使用Linux,Mac来发布。</p>

<blockquote><p><code>gpg --gen-key</code> 创建key  <br/>
<code>gpg --list-keys</code> 查看所有的key <br/>
<code>gpg --send-keys --keyserver pool.sks-keyservers.net yourkey</code>   发布你的key到服务器上</p></blockquote>

<p>3.确保你的工程POM符合<a href="https://docs.sonatype.org/display/Repository/Central+Sync+Requirements">要求</a><br/>
4.创建一个<a href="https://issues.sonatype.org/">Sonatype JIRA</a>账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。</p>

<!--more-->


<h3>使用Maven来发布到Sonatype Nexus repository</h3>

<h4>pom.xml配置有2种方法：</h4>

<p>1.添加maven-release-plugin到pom.xml:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;configuration&gt;
        &lt;arguments&gt;-Dgpg.passphrase=${gpg.passphrase}&lt;/arguments&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>添加Sonatype repositories:</p>

<pre><code>&lt;distributionManagement&gt;
    &lt;snapshotRepository&gt;
        &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;
        &lt;name&gt;Sonatype Nexus snapshot repository&lt;/name&gt;
        &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;
    &lt;/snapshotRepository&gt;
    &lt;repository&gt;
        &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;
        &lt;name&gt;Sonatype Nexus release repository&lt;/name&gt;
        &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/distributionManagement&gt;
</code></pre>

<p>设置artifact signing:</p>

<pre><code>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;release-sign-artifacts&lt;/id&gt;
        &lt;activation&gt;
            &lt;property&gt;
                &lt;name&gt;performRelease&lt;/name&gt;
                &lt;value&gt;true&lt;/value&gt;
            &lt;/property&gt;
        &lt;/activation&gt;
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;
                    &lt;version&gt;1.4&lt;/version&gt;
                    &lt;configuration&gt;
                        &lt;passphrase&gt;${gpg.passphrase}&lt;/passphrase&gt;
                    &lt;/configuration&gt;
                    &lt;executions&gt;
                        &lt;execution&gt;
                            &lt;id&gt;sign-artifacts&lt;/id&gt;
                            &lt;phase&gt;verify&lt;/phase&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;sign&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre>

<p>2.直接添加sonatype parent到POM.XML（推荐）</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.sonatype.oss&lt;/groupId&gt;
    &lt;artifactId&gt;oss-parent&lt;/artifactId&gt;
    &lt;version&gt;7&lt;/version&gt;
&lt;/parent&gt;
</code></pre>

<h4>maven settings.xml配置</h4>

<p>编辑或者创建~/.m2/settings.xml并包含验证信息:</p>

<pre><code>&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                      http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;
            &lt;username&gt;myusername&lt;/username&gt;
            &lt;password&gt;mypassword&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;
            &lt;username&gt;myusername&lt;/username&gt;
            &lt;password&gt;mypassword&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;

    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;id&gt;sign&lt;/id&gt;
            &lt;activation&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;/activation&gt;
            &lt;properties&gt;
                &lt;gpg.passphrase&gt;mypassphrase&lt;/gpg.passphrase&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
&lt;/settings&gt;
</code></pre>

<p>Maven有一个<a href="http://maven.apache.org/guides/mini/guide-encryption.html">避免使用明文的方法</a>,但我还没试用过。</p>

<h3>准备一个release版本</h3>

<p>为了准备一个release版本, 执行:</p>

<pre><code>$ mvn release:clean    
$ mvn release:prepare
</code></pre>

<p><a href="http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html">参考这个</a>.这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.</p>

<p>如果你要撤销release,可以使用<code>git reset --hard HEAD~2</code>进行<a href="http://stackoverflow.com/a/6866485/150884">回退</a>,使用<code>git tag -d ut-maven-plugin-0.1</code><a href="http://nathanhoad.net/how-to-delete-a-remote-git-tag">删除Tag</a>,然后使用<code>git push origin :refs/tags/ut-maven-plugin-0.1</code>提交.</p>

<h3>发布到Sonatype</h3>

<p>1.如果一切OK，你就可以使用<a href="http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html">mvn release:perform</a>来发布工程到Sonatype。<br/>
2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。 <br/>
3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些<a href="https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt">很好的指引</a>. 你可以使用<a href="http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html">Maven repository management plugin</a>来自动化这些步骤,尽管我自己还没有试过。   <br/>
4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。</p>

<p>参考文档<a href="http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html">http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Eclipse AST来解析Java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/19/use-eclipse-ast-to-parser-java/"/>
    <updated>2013-06-19T14:46:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/19/use-eclipse-ast-to-parser-java</id>
    <content type="html"><![CDATA[<p>Eclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。
另外，Eclipse有一个<a href="http://www.eclipse.org/jdt/ui/astview/">AST View</a>插件，使用这个能更加的清楚的看到解析后的效果。</p>

<p><img src="http://www.shenyanchao.cn/images/blog/eclipse-ast-view.png" alt="Eclipse AST View" /></p>

<!--more-->


<h4>依赖的jar包</h4>

<ul>
<li>org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar</li>
<li>org.eclipse.core.jobs_3.5.101.v20120113-1953.jar</li>
<li>org.eclipse.core.resources_3.7.101.v20120125-1505.jar</li>
<li>org.eclipse.core.runtime_3.7.0.v20110110.jar</li>
<li>org.eclipse.equinox.common_3.6.0.v20110523.jar</li>
<li>org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar</li>
<li>org.eclipse.jdt.core_3.7.3.v20120119-1537.jar</li>
<li>org.eclipse.osgi_3.7.2.v20120110-1415.jar</li>
</ul>


<p>这些包都可以在eclipse的plugin目录找到。可能版本有所区别。 <br/>
如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。</p>

<pre><code>          &lt;dependency&gt;
                &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;
                &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;
                &lt;version&gt;3.8.0.v_C03&lt;/version&gt;
            &lt;/dependency&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;
                 &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;
                 &lt;version&gt;3.6.0.v20100505&lt;/version&gt;
             &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;
                &lt;artifactId&gt;org.eclipse.core.resources&lt;/artifactId&gt;
                &lt;version&gt;3.6.0.v20100526-0737&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>

<h4>如何解析Java</h4>

<pre><code>package cn.shenyanchao.ast;

import org.apache.commons.io.FileUtils;
import org.eclipse.jdt.core.dom.*;

import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 *
 * @author shenyanchao
 *         Date:  6/13/13
 *         Time:  11:52 AM
 */
public class AstAnalyzer {
    public static void main(String[] args) throws IOException {

        String javaSource = FileUtils.readFileToString(new File("/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java"));

        ASTParser parser = ASTParser.newParser(AST.JLS3);
        parser.setSource(javaSource.toCharArray());

        // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)
        CompilationUnit result = (CompilationUnit) parser.createAST(null);

        result.imports();
        result.getPackage();
        result.getCommentList();
        System.out.println(result.getCommentList().toString());

        TypeDeclaration type = (TypeDeclaration) result.types().get(0);
        System.out.println("---------Type---------");
        System.out.println(type.toString());

        MethodDeclaration method = type.getMethods()[0];
        method.parameters();
        method.isConstructor();

        System.out.println("---------Method---------");
        System.out.println(method.toString());
        method.getName();
        method.getModifiers();
        Type returnType = method.getReturnType2();
        System.out.println("returnType = " + returnType.toString());


        Block methodBody = method.getBody();
        List&lt;Statement&gt; statementList = methodBody.statements();

        System.out.println(statementList.toString());

        statementList.get(0);

        ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);
        Assignment expression = (Assignment) ifs.getExpression();
        Expression exp = expression.getRightHandSide();

        System.out.println(result.toString());
    }
}
</code></pre>

<h4>如何创建Java</h4>

<pre><code>package cn.shenyanchao.ast;

import org.eclipse.jdt.core.dom.*;

/**
 * Created with IntelliJ IDEA.
 *
 * @author shenyanchao
 *         Date:  6/13/13
 *         Time:  11:27 AM
 */
public class AstHelloWorld {


    public static void main(String[] args) {
        AST ast = AST.newAST(AST.JLS3);
        CompilationUnit compilationUnit = ast.newCompilationUnit();

        // 创建类
        TypeDeclaration programClass = ast.newTypeDeclaration();
        programClass.setName(ast.newSimpleName("HelloWorld"));
        programClass.modifiers().add(
                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        compilationUnit.types().add(programClass);

        // 创建包
        PackageDeclaration packageDeclaration = ast.newPackageDeclaration();
        packageDeclaration.setName(ast.newName("cn.shenyanchao.hello"));
        compilationUnit.setPackage(packageDeclaration);

        MethodDeclaration main = ast.newMethodDeclaration();
        main.setName(ast.newSimpleName("main"));
        main.modifiers().add(
                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
        main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
        main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
        programClass.bodyDeclarations().add(main);
        Block mainBlock = ast.newBlock();
        main.setBody(mainBlock);

        // 给main方法定义String[]参数
        SingleVariableDeclaration mainParameter = ast
                .newSingleVariableDeclaration();
        mainParameter.setName(ast.newSimpleName("arg"));
        mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast
                .newName("String"))));
        main.parameters().add(mainParameter);

        MethodInvocation println = ast.newMethodInvocation();
        println.setName(ast.newSimpleName("println"));

        //生成String类型的常量
        StringLiteral s = ast.newStringLiteral();
        s.setLiteralValue("Hello World");
        println.arguments().add(s);

        println.setExpression(ast.newName("System.out"));

        mainBlock.statements().add(ast.newExpressionStatement(println));

        System.out.println(compilationUnit.toString());
    }
}
</code></pre>

<p>具体的使用手册，参见<a href="http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/">http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[write my maven plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/13/write-my-maven-plugin/"/>
    <updated>2013-06-13T20:35:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/13/write-my-maven-plugin</id>
    <content type="html"><![CDATA[<p>mvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin</p>

<p><a href="http://maven.apache.org/guides/plugin/guide-java-plugin-development.html">http://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse AST抽象语法树API]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/"/>
    <updated>2013-06-07T20:29:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast</id>
    <content type="html"><![CDATA[<h3>Eclipse AST</h3>

<p>Eclipse AST 是 Eclipse JDT 的一个重要组成部分,定义在包 org.eclipse.jdt.core.dom 中,用来表示 Java 语言中的所有语法结构。 <br/>
Eclipse AST 采用工厂方法模式和访问者模式   (见 2.7节)来设计和实现,这样可以减轻用户深入了解其内部结构的压力,并且方便用户利用它们构建并处理 AST。你可以打开 Eclipse 帮助页面,通过鼠标依次点击窗口左边的目录“JDT Plug-in Developer Guide”Æ“Reference”Æ“API Reference” Æ“org.eclipse.jdt.core.dom”,即可打开这个包的详细说明。本节将对这个包中重要的类作简要说明,为简便起见,这里省去这些类的包名,即org.eclipse.jdt.core.dom。  <br/>
在 Eclipse AST 中,与本书的课程设计相关的类主要有以下三部分:</p>

<ul>
<li>ASTNode 类及其派生类:用于描述各种 AST 节点的类,每个 AST 节点表示一个Java 源程序中的一个语法结构,例如,一个名字、类型、表达式、语句或声明等。</li>
<li>AST 类:创建 AST 节点的工厂类,类中包含许多创建各类 AST 节点的工厂方法,用户可以利用这些方法来构建 AST。</li>
<li>ASTVisitor 类:
AST 的访问者抽象类,类中声明了一组访问各类 AST 节点的 visit( )方法、endVisit( )方法和 preVisit( )方法。</li>
</ul>


<!--more-->


<h4>AST 节点类</h4>

<p>在 Eclipse AST 中,Java 源程序中的每个语法结构对应为一个 AST 节点,所有的 AST节点按其在语法上的关系连接形成一棵 AST 树。类 ASTNode 是 AST 树中各类节点的抽象基类,其余的 AST 节点类都由它派生。在 ASTNode 类中声明有各个具体的 AST 节点类所对应的类型标识,如 ASTNode.COMPILATION_UNIT 代表 Compilation_Unit 节点类,这类节点用来表示一个 Java 源程序文件。  <br/>
为便于自顶向下(从父节点到子节点)或者自底向上(从子节点到父节点)访问 AST树,AST 节点含有指向其父节点的 parent 域以及若干关联的子节点域。在 AST 节点类中,以属性(property)来统一处理子节点以及用户自定义的节点属性,属性的访问方法有:</p>

<pre><code>void setProperty(String propertyName, Object data) // 设置指定属性的值
Object getProperty(String propertyName) // 取得指定属性的值
Map properties( )// 返回节点的所有属性表,这个表是不可修改的
</code></pre>

<p>在每个具体的 AST 节点类中,以类常量形式声明该类节点所拥有的基本属性(即基本的子节点)类别,并定义了存放属性值的域以及设置和访问属性的方法。例如,在一个 Java源程序文件中,有可选的 package 声明、0 个或多个 import 声明以及至少 1 个类型声明(可以是类声明或接口声明),从而在表示 Java 源程序文件(称为编译单元)的 AST 节点类CompilationUnit 中就声明有 final 类变量 PACKAGE_PROPERTY、IMPORTS_PROPERTY 和TYPES_PROPERTY,分别表示 package 属性、imports 属性和 types 属性,同时还定义有如下的访问方法:</p>

<pre><code>List imports( )
// 该节点的所有 import 声明,按在程序中的出现次序排列List types( )
// 该节点的所有顶层类型声明,按在程序中的出现次序排列
void setPackage(PackageDeclaration pkgDecl) // 设置该节点的 package 声明
PackageDeclaration getPackage( )
// 取得该节点的 package 声明
</code></pre>

<p>其中,类型相同的子节点组成的序列以 java.util.List 接口类来表示,这个接口类包含 add、get、set、remove 等方法用于访问和修改序列。在实际构造和访问 AST 树时,需要注意统一所使用的 List 接口类的实现类,例如,可以统一使用类 java.util.LinkedList 或者统一使用类java.util.ArrayList 来表示序列。 <br/>
在 AST 节点类中,只提供获取父节点的方法,即</p>

<pre><code>ASTNode getParent( )
</code></pre>

<p>而没有提供设置父节点的方法,这是因为对节点的 parent 域的设置是伴随着将该节点设置为其他节点的子节点而自动进行的。一个新创建的 AST 节点是没有设置其父节点的。当节点A 通过形如 setCHILD 方法,如 A.setPackage(B)方法,或者通过序列的 add 或 set 方法,如A.types( ).add(B)方法,将节点 B 设为自己的孩子时,B 节点的 parent 域将自动设置为对 A节点的引用;对于那些因上述操作导致不再是 A 节点的子节点来说,其 parent 域将被自动设置为 null。</p>

<p>每个 AST 节点及其子节点只能归属于一棵 AST 树。如果将一棵 AST 树中的某个 AST节点添加到另一棵 AST 树中,则必须复制这个节点及其所有的子孙节点,以保证这些节点只属于一棵 AST 树。此外,AST 树中不能含有环,如果某些操作会导致 AST 有环,则这些操作将失败。 <br/>
为支持对源程序的分析和类型检查等,每个 AST 节点还含有一组位标志(用一个 int用来传播与该节点有关的附加信息,这些位标志可以通过节点的以下方法来存取:</p>

<pre><code>void setFlags(int flags)
int getFlags( )
</code></pre>

<p>此外,Eclipse AST 还支持访问者模式,每个 AST 节点都含有方法:</p>

<pre><code>void accept(ASTVisitor visitor)
</code></pre>

<p>用于统一表示对当前节点访问时所要执行的任务,这个任务由参数 visitor 来给定。你可以进一步了解 ASTVisitor 类以及访问者模式(见 2.7.2 节)来了解对 AST 树的访问。</p>

<h4>AST 类</h4>

<p>org.eclipse.jdt.core.dom.AST 是 AST 节点的工厂类,即它提供一系列形如</p>

<pre><code>TYPE newTYPE( )
</code></pre>

<p>的工厂方法,用来创建名为 TYPE 的 Eclipse AST 节点类的实例,新创建的节点并没有设置父节点。例如,方法</p>

<pre><code>CompilationUnit newCompilationUnit( )
</code></pre>

<p>用来创建由这个 AST 所拥有的一个编译单元节点。  <br/>
要使用这些方法,首先需要创建 AST 类的实例:</p>

<pre><code>AST ast = AST.newAST(AST.JLS3);
</code></pre>

<p>其中,参数 AST.JLS3 指示所生成的 ast 包含处理 JLS3(Java 语言规范第 3 版)的 AST API。
JLS3 是 Java 语言所有早期版本的超集,JLS3 API 可以用来处理直到 Java SE 6(即 JDK1.6)
的 Java 程序。</p>

<h4>ASTVisitor 类</h4>

<p>org.eclipse.jdt.core.dom.ASTVisitor 是 AST 树的访问者类,它提供一套方法来实现对给定节点的访问。
这套方法中有两组是与具体的 AST 节点类 T 相关的,即 visit 方法和 endVisit方法,有两个是与具体的 AST 节点类无关的,即 preVisit 方法和 postVisit 方法。这些方法都通过参数接收一个 AST 节点 node,然后对这个节点进行访问以执行一些操作。</p>

<ul>
<li>public boolean visit(T node) 如果返回 true,则接着访问 node 的子节点;如果返回false,则不再访问 node 的子节点。ASTVisitor 类提供的各个 visit 方法的缺省实现是:什么也不做,直接返回 true。子类可以根据需要重新实现这些方法中的部分或全部。
-public void endVisit(T node) 这类方法在节点 node 的子节点已经被访问或者是在visit(node)返回为 false 之后被调用ASTVisitor 类提供的各个 endVisit 方法的缺省实现是什么也不做。子类可以根据需要重新实现这些方法中的部分或全部。</li>
<li>public void preVisit(ASTNode node)</li>
<li>public void postVisit(ASTNode node) 这个方法在 endVisit(node)之后被调用。
这个方法在 visit(node)之前被调用。 <br/>
ASTVisitor 类提供的 preVisit 方法和 postVisit 方法的缺省实现是什么也不做。子类可以根据需要来重新实现它们。</li>
</ul>


<p>在 Eclipse AST 中,结合 AST 节点的 accept( )方法和 ASTVisitor 实例,假设待访问的AST 树的根节点为 root,
则调用 root.accept( )就可以启动对这棵 AST 树的遍历。遍历是以深度优先搜索为基础的,你可以进一步查看 Eclipse JDT 的源代码来确认这一点,你也可以从<a href="http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html">http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html</a> 上查看相关的源代码。为帮
助大家理解对 AST 树的遍历过程,这里简要给出 accept 方法的实现。  <br/>
所有的 AST 节点都执行在 ASTNode 类中定义的 accept 方法:</p>

<pre><code>public final void accept(ASTVisitor visitor) {
if (visitor == null) { throw new IllegalArgumentException(); }
visitor.preVisit(this);
// 执行与节点类型无关的 preVisit 方法
accept0(visitor); // 调用 accept0,执行与节点类型相关的 visit/endVisit 方法
visitor.postVisit(this); // 执行与节点类型无关的 postVisit 方法
}
</code></pre>

<p>ASTNode 类中的 accept0 方法是一个抽象的方法:</p>

<pre><code>abstract void accept0(ASTVisitor visitor);
</code></pre>

<p>每个具体的 AST 节点类中都必须实现 accept0 方法,实现该方法的通用模板如下:</p>

<pre><code>boolean visitChildren = visitor.visit(this);
if (visitChildren) {
// 调用 visit( )访问本节点
// 如果 visit( )返回 true,则访问子节点acceptChild(visitor, getProperty1()); // 访问非序列型属性
acceptChildren(visitor, rawListProperty); // 访问序列型属性
acceptChild(visitor, getProperty2());
}
visitor.endVisit(this);// 调用 endVisit( )执行一些节点访问后的操作
</code></pre>

<p>从上面的模板可以看出,如果节点包含多个属性,如 CompilationUnit 节点中有 imports属性和 types 属性等,则按这些属性在源程序中的先后次序来依次访问;如果一个属性为序列型,如 CompilationUnit 节点中的 types 属性,则调用 acceptChildren 方法来依次访问序列中的各个子节点;如果一个属性是非序列的,则调用 acceptChild 方法来访问。acceptChild和 acceptChildren 这两个方法的实现都与 AST 节点的具体类型无关,故放在 ASTNode 类中:</p>

<pre><code>final void acceptChild(ASTVisitor visitor, ASTNode child) {
if (child == null) { return; }
child.accept(visitor);
}
final void acceptChildren(ASTVisitor visitor, ASTNode.NodeList children) {
NodeList.Cursor cursor = children.newCursor();
try {
while (cursor.hasNext()) {
ASTNode child = (ASTNode) cursor.next();
child.accept(visitor);
}
} finally {
children.releaseCursor(cursor);
}
}
</code></pre>

<p>基于上述的实现机制,当你需要对 AST 树实现特定的访问功能时,你只需要结合实际需求设计和实现 ASTVisitor 类的子类就可以了。例如,在本章的课程设计中,你需要实现ASTVisitor 类的派生类 InterpVisitor,在其中重写(override)与需要解释执行的语法结构相对应的 visit( )方法。</p>

<h4>SimpleMiniJOOL 语言涉及的 AST 节点类</h4>

<p>虽然 Eclipse AST 有为数众多的 AST 节点类,但是为表示 SimpleMiniJOOL 语言只会用到其中的一小部分,下面简要描述 SimpleMiniJOOL 语言所涉及到的 AST 节点类,重点介绍在使用这些类时所关注的成员。</p>

<h5>整体结构</h5>

<p>1、CompilationUnit 类(编译单元)  <br/>
它用来表示一个 Java 源程序文件,本书中用来表示一个 MiniJOOL 语言或其子语言程序的全部,是所对应的 AST 树的根节点。虽然这类节点有 package 声明、import 声明列表和类型声明列表等基本属性,但是在表示 SimpleMiniJOOL 程序时就只有一个类声明子节点。 <br/>
<strong>主要成员</strong></p>

<pre><code>List types( )// 返回该编译单元的顶层类型声明所对应的节点序列
</code></pre>

<p>2、TypeDeclaration 类(类型声明) <br/>
它用于表示 Java 语言中的类声明或接口声明,本书中用来表示 MiniJOOL 语言或其子语言中的类声明。在 SimpleMiniJOOL 程序中,仅有一个名为 Program 的类声明。  <br/>
<strong>主要成员</strong></p>

<pre><code>MethodDeclaration[] getMethods( )
// 返回类声明的方法声明序列
以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:
FieldDeclaration[] getFields( ) // 返回类声明的域声明序列
Type getSuperclassType( ) // 返回该类声明的超类类型或 null
void setSuperclassType(Type superclassType)
// 设置或清除超类
</code></pre>

<p>3、MethodDeclaration 类(方法声明)   <br/>
它用于表示 Java 语言中的方法声明或者是构造器声明(注意:在 Java 语言规范中,并不是将构造器看成是一个方法。因为后者视为是类中的成员,可以被子类继承;而前者不能被子类继承)。这类节点的基本属性包括:方法或构造器名、方法或构造器的体、返回类型、形参列表等。在一个 SimpleMiniJOOL 程序里的唯一的类中,只有一个名为 main 的无参方法,这个方法声明表示为一个 MethodDeclaration 实例。  <br/>
<strong>主要成员</strong></p>

<pre><code>Block getBody( ) // 返回该方法声明的方法体,如果没有体则为 null
void setBody(Block body) // 设置或清除该方法声明的方法体
SimpleName getName( ) // 返回所声明的方法名
void setName(SimpleName methodName)
Type getReturnType2( )
// 设置方法名
// 返回所声明的方法的返回类型
void setReturnType2(Type type)
// 设置返回类型
</code></pre>

<p>以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:</p>

<pre><code>List parameters( ) // 返回所声明的方法的参数声明序列
boolean isConstructor( ) // 返回该声明是否是在声明构造器
void setConstructor(boolean isConstructor)
// 设置是否是在声明构造器
</code></pre>

<h5>语句</h5>

<p>Statement 类是所有 Eclipse AST 中语句节点类的基类,由它派生出许多具体的语句节点类。在表示 SimpleMiniJOOL 程序时,只涉及到 Block、ExpressionStatement、IfStatement、WhileStatement、EmptyStatement、BreakStatement、ContinueStatement、ReturnStatement 等语句节点类。   <br/>
1、Block 类(语句块)  <br/>
它表示用花括号括起来的语句序列,可以用来表示一个方法体。其基本属性是语句序列。   <br/>
<strong>主要成员</strong></p>

<pre><code>List statements( )
// 返回该语句块中的语句序列
</code></pre>

<p>2、ExpressionStatement 类(表达式语句)  <br/>
它表示由表达式形成的合法语句,包括表达式这一基本属性。在 SimpleMiniJOOL 语言中,可以用这个类来表示 print/read 语句或赋值表达式语句。 <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getExpression( ) // 返回该语句中的表达式
void setExpression(Expression expression) // 设置该语句中的表达式
</code></pre>

<p>3、IfStatement(if 语句)  <br/>
它表示 if 或 if-else 语句,节点中包括 if 语句的表达式、then 分支以及可选的 else 分支
这些基本属性。  <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getExpression( ) // 返回 if 语句的表达式
void setExpression(Expression expression) // 设置 if 语句的表达式
Statement getThenStatement( ) // 返回 if 语句的 then 分支
void setThenStatement(Statement statement) // 设置 then 分支
Statement getElseStatement( ) // 返回 if 语句的 else 分支
void setElseStatement(Statement statement) // 设置 else 分支
</code></pre>

<p>4、WhileStatement 类(while 语句)  <br/>
它表示 while 语句,节点中包括 while 语句的表达式和体这些基本属性。  <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getExpression( ) // 返回 while 语句的表达式
void setExpression(Expression expression) // 设置 while 语句的表达式
Statement getBody( ) // 返回 while 语句的体
void setBody(Statement statement) // 设置 while 语句的体
</code></pre>

<p>5、EmptyStatement 类(空语句) <br/>
它表示由分号组成的语句。 <br/>
6、BreakStatement 类和 ContinueStatement 类 <br/>
这两个类分别表示 break 语句和 continue 语句。在 Java 语言中,这两个语句是允许带有标号的,即形如“break label; ”或“continue label;”,因此提供 getLabel( )和 setLabel( )成员来访问标号。但是,在 MiniJOOL 语言或其子语言中,不支持标号。   <br/>
7、ReturnStatement 类  <br/>
它表示 return 语句。SimpleMiniJOOL 语言中的 return 语句是不允许含有表达式的,但是 MiniJOOL 语言和 SkipOOMiniJOOL 语言中的 return 语句允许含有表达式以支持返回值。故以下成员在表示 MiniJOOL 语言和 SkipOOMiniJOOL 语言时才会用到:  <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getExpression( ) // 返回 return 语句的表达式
void setExpression(Expression expression) // 设置 return 语句的表达式
</code></pre>

<h5>表达式</h5>

<p>Expression 类是所有 Eclipse AST 中表达式节点类的基类,由它派生出许多类。在表示SimpleMiniJOOL 程 序 时 , 只 涉 及 到 MethodInvocation 、 Assignment 、 InfixExpression 、PrefixExpression、ParenthesizedExpression、NumberLiteral、Name 这些表达式节点类。  <br/>
1、MethodInvocation 类(方法调用) <br/>
它用来表示 Java 程序中的方法调用。MiniJOOL 语言中的方法调用形如:</p>

<pre><code>[ Expression . ] Identifier ( [ Expression { , Expression } ] )
</code></pre>

<p>开头的“Expression .”是限制被调用方法的受限表达式,可以是类名、实例表达式或者没有。在 SkipOOMiniJOOL 语言中,方法调用不存在受限表达式。虽然 SimpleMiniJOOL 语言中没有方法调用,但是程序中的“print/read( &lt;参数>)”用方法调用节点来表示。  <br/>
<strong>主要成员</strong></p>

<pre><code>// 返回所调用的方法名
SimpleName getName( )
void setName(SimpleName methodName) // 设置方法名
List arguments( )
// 返回方法调用表达式中的实参表达式序列
</code></pre>

<p>以下成员在表示 MiniJOOL 程序时才会用到:</p>

<pre><code>Expression getExpression( ) // 返回方法调用的受限表达式
void setExpression(Expression expression) // 设置方法调用的受限表达式
</code></pre>

<p>2、Assignment 类(赋值表达式)  <br/>
它用于表示赋值表达式,包含运算符、左部和右部等基本属性。赋值运算符是在内部类Assignment.Operator 中义。MiniJOOL 语言或其子语言中支持的赋值运算符包括 =、+=、-=、*=、/=、%=。 <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getLeftHandSide( )
// 返回赋值表达式的左部
void setLeftHandSide(Expression expr)
getRightHandSide( )
// 设 置 赋 值 表 达 式 的 左 部 Expression
// 返回赋值表达式的右部
void setRightHandSide(Expression expr)
// 设置赋值表达式的右部
Assignment.Operator getOperator( ) // 返回赋值表达式的运算符
void setOperator(Assignment.Operator op) // 设置赋值表达式的运算符
</code></pre>

<p><strong>赋值运算符</strong>
在内部类 Assignment.Operator 中,定义有许多类型为 static Assignment.Operator 的赋值运算符,其中与 MiniJOOL 语言及其子语言有关的有:</p>

<pre><code>ASSIGN:表示 =,可以用 Assignment.Operator.ASSIGN 来访问,以下类似
PLUS_ASSIGN:表示+=
MINUS_ASSIGN:表示 -=
TIMES_ASSIGN:表示 *=
DIVIDE_ASSIGN:表示 /=
REMAINDER_ASSIGN:表示 %=
</code></pre>

<p>3、InfixExpression 类(中缀表达式)  <br/>
它用于表示中缀表达式,包含运算符、左操作数和右操作数等基本属性。运算符是在内部类 InfixExpression.Operator 中定义。MiniJOOL 语言或其子语言中支持的中缀运算符包括包括+、-、*、/、%、==、!=、&lt;、&lt;=、>、>=、&amp;&amp;、||等。 <br/>
<strong>主要成员</strong></p>

<pre><code>// 返回中缀表达式的左操作数
Expression getLeftOperand( )
void setLeftOperand(Expression expr) // 设置左操作数
Expression getRightOperand( ) // 返回中缀表达式的右操作数
void setRightOperand(Expression expr) // 设置右操作数
InfixExpression.Operator getOperator( ) // 返回中缀表达式的运算符
void setOperator(InfixExpression.Operator op) // 设置运算符
</code></pre>

<p><strong>中缀运算符</strong>
本书涉及内部类 InfixExpression.Operator 中定义的以下 static InfixExpression.Operator 类型的实例:</p>

<pre><code>+ PLUS
% REMAINDER
&lt; LESS
&amp;&amp;
-
MINUS
==
&gt; GREATER
CONDITIONAL_AND
*
TIMES
/ DIVIDE
EQUALS != NOT_EQUALS
&lt;= &gt;=
||
LESS_EQUALS
GREATER_EQUALS
CONDITIONAL_OR
</code></pre>

<p>4、PrefixExpression 类(前缀表达式)  <br/>
它用于表示前缀表达式,包含运算符、操作数等基本属性。运算符是在内部类PrefixExpression.Operator 中定义。在 SimpleMiniJOOL 中,包括-、+、!等前缀运算符。 <br/>
<strong>主要成员</strong></p>

<pre><code>Expression getOperand( )
// 返回前缀表达式的操作数
void setOperand(Expression expr)
// 设置操作数
PrefixExpression.Operator getOperator( ) // 返回前缀表达式的运算符
void setOperator(PrefixExpression.Operator op) // 设置运算符
</code></pre>

<p><strong>前缀运算符</strong>
本书涉及内部类 PrefixExpression.Operator 中定义的以下 static PrefixExpression.Operator类型的实例:</p>

<pre><code>+PLUS
- MINUS
! NOT
</code></pre>

<p>5、ParenthesizedExpression 类(带括号的表达式)
<strong>主要成员</strong></p>

<pre><code>Expression getExpression( )
// 返回括号内的表达式
void setExpression(Expression expression) // 设置括号内的表达式
</code></pre>

<p>6、NumberLiteral 类(整数)  <br/>
<strong>主要成员</strong></p>

<pre><code>String getToken( )
// 返回对应的整数串
void setToken(String token) // 设置整数串
</code></pre>

<p>7、Name 类  <br/>
它用于表示一个名字,由它派生出 QualifiedName 和 SimpleName 两个类,前者表示一个形如 a.b 的受限名,后者表示一个简单名。在 SimpleMiniJOOL 程序中只会出现简单名。 <br/>
<strong>SimpleName 的主要成员</strong></p>

<pre><code>String getIdentifier( ) // 返回标识符
void setIdentifier(String expression) // 设置标识符
boolean isDeclaration( ) // 该标识符是否定义过
</code></pre>

<p><strong>QualifiedName 的主要成员</strong></p>

<pre><code>SimpleName getName( ) // 返回受限名中的名字部分
void setName(SimpleName name ) // 设置受限名中的名字部分
Name getQualifier( ) // 返回受限名中的受限部分
void setQualifier(Name qualifier) // 设置受限名中的受限部分
</code></pre>

<h4>Eclipse AST 使用示例</h4>

<p>在这一节中,我们将演示如何利用 Eclipse AST 手工构建如下的 SimpleMiniJOOL 程序的 AST 中间表示。</p>

<pre><code>class Program {
static void main() {
i = 10;
}
}
</code></pre>

<p>首先,你需要通过 Eclipse AST 工厂类中的方法 newAST()建立一个 AST 实例:</p>

<pre><code>AST ast = AST.newAST(JLS3);
</code></pre>

<p>利用这个 AST 实例,就可以按如下的方法创建各种 AST 节点,并构建完整的抽象语法树。然后,利用 Eclipse AST 工厂类中的各种创建方法按如下步骤创建所需要的 AST 节点:  <br/>
1) 整个 SimpleMiniJOOL 程序构成一个 CompilationUnit:</p>

<pre><code>CompilationUnit cu = ast.newCompilationUnit();
</code></pre>

<p>2) 在 CompilationUnit 实例中包含一个 TypeDeclaration,表示程序中的类 Program:</p>

<pre><code>TypeDeclaration type = ast.newTypeDeclaration( );
type.setName(ast.newSimpleName(“Program”));
// 定义类的名字
</code></pre>

<p>3) 在这个 TypeDeclaration 实例中添加类 Program 中的方法 main():</p>

<pre><code>MethodDeclaration method = ast.newMethodDeclaration( );
method.setName(ast.newSimpleName(“main”));
type.bodyDeclarations().add(method);
// 设置方法 main()的 modifier 为 static
method.modifiers().add(
ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
// 设置方法 main()的返回类型为 void
method.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
</code></pre>

<p>4) 构造 main 函数的函数体 mainBody</p>

<pre><code>Block mainBody = ast.newBlock();
method.setBody(mainBody);
</code></pre>

<p>5) 向方法 main 函数体 mainBody 中添加语句</p>

<pre><code>// 构建赋值表达式
Assignment assign = ast.newAssignment();
// 设置赋值表达式的左值为 i
assign.setLeftHandSide(ast.newSimpleName("i"));
// 设置赋值表达式的赋值算符为=
assign.setOperator(Assignment.Operator.ASSIGN);
// 设置赋值表达式的右值为数字 10
assign.setRightHandSide(ast.newNumberLiteral("10"));
// 由赋值表达式构建语句,并把这个语句加入方法 Main()的函数体
ExpressionStatement statement = ast.newExpressionStatement(assign);
mainBody.statements().add(statement);
</code></pre>

<p>至此,用 Eclipse AST 表示的 SimpleMiniJOOL 程序的抽象语法树就构建完毕了。 <br/>
在 lab1/src/edu/ustc/cs/compile/interpreter/TestCase.java 中的 createSampleAST( )方法给出了构建一个简单 SimpleMiniJOOL 程序对应的 AST 的完整示例。 <br/>
需要再次强调的是,使用 Eclipse AST 构建的抽象语法树在拓扑结构上必须是无环的。无论是手工构建 AST 还是自动构建 AST,你都需要小心的检查自己的代码,避免违反这个原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TestNG深入理解]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/05/deep-in-testng/"/>
    <updated>2013-06-05T20:10:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/05/deep-in-testng</id>
    <content type="html"><![CDATA[<h3>TestNG annotaion:</h3>

<ul>
<li>@DataProvider</li>
<li>@ExpectedExceptions</li>
<li>@Factory</li>
<li>@Test</li>
<li>@Parameters</li>
</ul>


<hr />

<pre><code>&lt;suite name="ParametersTest"&gt;
　　&lt;test name="Regression1"&gt;
　　　　&lt;classes&gt;
　　　　　　&lt;class name="com.example.ParameterSample" /&gt;
　　　　　　&lt;class name="com.example.ParameterTest"&gt;
　　　　　　　　&lt;mtehods&gt;
　　　　　　　　　　&lt;include name="database.*" /&gt;
　　　　　　　　　　&lt;exclude name="inProgress" /&gt;
　　　　　　　　&lt;/methods&gt;
　　　　　　&lt;/class&gt;
　　　　&lt;/classes&gt;
　　&lt;/test&gt;    
　　&lt;test name="Parameters"&gt;
　　　　&lt;packages&gt;
　　　　　　&lt;package name="test.parameters.Parameter*" /&gt;
　　　　&lt;/packages&gt;
　　&lt;/test&gt;   
&lt;/suite&gt;    
</code></pre>

<p>一个suite(套件) 由一个或多个测试组成。 <br/>
一个test(测试) 由一个或多个类组成  <br/>
一个class(类) 由一个或多个方法组成。</p>

<p>@BeforeSuite/@AfterSuite 在某个测试套件开始之前/在某个套件所有测试方法执行之后  <br/>
@BeforeTest/@AfterTest 在某个测试开始之前/在某个测试所有测试方法执行之后   <br/>
@BeforeClass/@AfterClass 在某个测试类开始之前/在某个类的所有测试方法执行之后   <br/>
@BeforeMethod/@AfterMethod 在某个测试方法之前/在某个测试方法执行之后 <br/>
@BeforeGroup/@AfterGroup 在某个组的所有测试方法之前/在某个组的所有测试方法执行之后</p>

<!--more-->


<h4>1、分组</h4>

<pre><code>@Test(groups = {"fast", "unit", "database"})
public void rowShouldBeInserted() {}

java org.testng.TestNG -groups fast com.example.MyTest
</code></pre>

<p>测试的一个目标就是确保代码按照预期的方式工作。这种测试要么在用户层面上进行，要么在编程层面上进行。这两种类型的测试分别是通过功能测试和单元测试来实现的。</p>

<p>针对失败而测试</p>

<p>Java提供了两种不同类型的异常：从java.lang.RuntimeException派生的运行时刻异常和从java.lang.Exception派生的被检查的异常。</p>

<p>抛出被检查的异常的经验法则：调用者可以为这个异常做什么吗？如果答案是肯定的，那么可能应该是用被检查的异常，否则，最好是选择运行时刻异常。</p>

<pre><code>@Test(expectedExceptions = {ReservationException.class, FlightCanceledException.class})
public void shouldThrowIfPlaneIsFull() 
{
　　Plane plane = createPlane();
　　plane.bookAllSeats();
　　plane.bookPlane(createValidItinerary(), null);
}
</code></pre>

<p>属性expectedExceptions是一组类，包含了这个测试方法中预期会抛出的异常列表。如果没有抛出异常，或抛出的异常不再该属性的类表中，那么TestNG就会认为这个测试方法失败了。</p>

<p>单一职责：</p>

<pre><code>public class BookingTest
{
　　private Plane plane;

　　@BeforeMethod
　　public void init() { plane = createPlane(); }

　　@Test(expectedException = PlaneFullException.class)
　　public void shouldThrowIfPlaneIsFull()
　　{
　　　　plane.bookAllseats();
　　　　plane.bookPlane(createValidItinerary(), null);
　　}

　　@Test(expectedException = FlightCanceledException.class)
　　public void shouldThrowIfFlightIsCanceled()
　　{
　　　　cancelFlight(/* ... */);
　　　　plane.bookPlane(createValidItinerary(), null);
　　}
}
</code></pre>

<p>testng-failed.xml</p>

<p>当您执行包涵失败的测试套件时，TestNG会在输出目录(默认是test-output/)下自动生成一个名为testng-failded.xml的问他件。这个XML文件包含了原来的testng.xml中失败的方法所构成的子集。</p>

<pre><code>java org.testng.TestNG test.xml
java org.testng.TestNG test-output/testng-failed.xml
</code></pre>

<h4>2、工厂</h4>

<p>TestNG让您可以选择自己将测试类实例化。这是通过@Factory annotation来实现的，他必须放在返回一个对象数组方法的顶部。所有这些对象都必须是包含TestNG annotation的类的实例。如果有@Factory annotation，那么这个循环会继续下去，知道TestNG拿到的都是没有@Factory annotation实例，或者@Factory方法都已被调用过的实例。</p>

<pre><code>public class ExpectedAttributes
{
　　private Image image;
　　private int width;
　　private height;
　　private String path;
　　
　　@Test
　　public void testWidth() {}

　　@Test
　　public void testHeight() {}

　　public PictureTest(String path, int width, int height, int depth) throws IOException
　　{
　　　　File f = new File(path);
　　　　this.path = path;
　　　　this.image = ImageIO.read(f);
　　　　this.width = width;
　　　　this.height = height;
　　}

　　private static String[] findImageFileNames() {}

　　@Factory
　　public static Object[] create() throws IOException
　　{
　　　　List result = new ArrayList();

　　　　String[] paths = findImageFileNames();

　　　　for (String path : paths) {
　　　　　　ExpectedAttributes ea = findAttributes(path);
　　　　　　result.add(new PictureTest(path, ea.width, ea.height, ea.depth));
　　　　}

　　　　return result.toArray();
　　}

　　public class ExpectedAttributes 
　　{
　　　　public int width;
　　　　public int height;
　　　　public int depth;
　　}

　　private static ExpectedAttributes findExpectedAttributes(String path)
　　{
　　　　// ...... 
　　}
}
</code></pre>

<p>可以安全的在同一个类包含@Factory和@Test annotation，因为TestNG确保@Factory方法只被调用一次。</p>

<p>org.testng.ITest接口</p>

<pre><code>public interface ITest 
{
public String getTestName(); 
}
</code></pre>

<p>当TestNG遇到实现了这个接口的测试类时，他会在生成各种报告中包含getTestName()方法返回的信息。</p>

<pre><code>public class PictureTest implements ITest
{
　　public String getTestName() 
　　{
　　　　return "[Picture: " + name + "]";
　　} 
}
</code></pre>

<p>数据驱动测试</p>

<p>测试需要针对许多具有类似结构的数据来执行。  <br/>
实际的测试逻辑是一样的，仅仅发生改变的是数据。 <br/>
数据可以被一组不同的人修改。</p>

<p>参数测试方法  <br/>
测试逻辑可以非常简单或不易改变，而提供給他的数据肯定会随着时间增长。</p>

<p>TestNG可以通过两种方式向测试方法传递参数：</p>

<ul>
<li>利用testng.xml</li>
<li>利用DataProviders</li>
</ul>


<p>1、利用testng.xml传递参数</p>

<pre><code>&lt;suite name="Parameters"&gt;
　　&lt;parameter name="xml-file" value="accounts.xml" /&gt;
　　&lt;parameter name="hostname" value="arkonis.example.com" /&gt;

　　&lt;test name="ParameterTest"&gt;
　　　　&lt;parameter name="hostname" value="terra.example.com" /&gt;
　　　　...
　　&lt;/test&gt;
　　...
&lt;/suite&gt;
</code></pre>

<p>在测试方法中指定参数</p>

<pre><code>@Test(parameters = {"xml-file"})
public void validateFile(String xmlFile)
{
　　// xmlFile has the value "accounts.xml"
}
</code></pre>

<p>如果犯下以下错误之一，TestNG将抛出一个异常：</p>

<ul>
<li>在testng.xml中指定了一个参数，但不能转换为对应方法参数的类型。</li>
<li>声明了一个@Parameters annotation，但引用的参数名称在testng.xml中没有声明。</li>
</ul>


<p>2.利用@DataProvider传递参数</p>

<p>如果需要向测试方法传递的参数不是基本的Java类型，或者如果需要的值智能在运行时刻创建，那么我们应该考虑使用@DataProvider annotation。</p>

<p>数据提供者是用@Dataprovider标注的方法。这个annotation只有一个字符串属性：他的名称，如果没有提供名称，数据提供者的名称就默认采用方法的名称。</p>

<p>数据提供者同时实现两个目的：</p>

<p>向测试方法传递任意数目的参数 <br/>
根据需要，允许利用不同的参数集合对他的测试方法进行多次调用。</p>

<pre><code>@Test(dataProvider = "range-provider")
public void testIsBetWeen(int n, int lower, int upper, boolean expected)
{
　　println("Received " + n + " " + lower + "-" + upper + " expected: " + expected);
　　assert.assertEquals(expected, isBetween(n, lower, upper));
}

@DataProvider(name = "range-provider")
public Object[][] rangeData()
{
　　int lower = 5;
　　int upper = 10;

　　return new Object[][] {
　　　　{ lower-1, lower, upper, false},
　　　　{ lower, lower, upper, true},
　　　　{ lower+1, lower, upper, true},
　　　　{ upper, lower, upper, true},
　　　　{ upper+1, lower, upper, false},
　　};
}
</code></pre>

<p>由于数据提供者是测试类中的一个方法，他可以属于一个超类，然后被一些测试方法复用。我们也可以有几个数据提供者，只要他们定义在测试类或者他的一个子类上。当我们像在合适的地方记录数据源，并在几个测试方法中复用他时，这种方法是很方边的。</p>

<p>针对数据提供者的参数   <br/>
数据提供者本身可以接受两个类型的参数：Method和ITestContext</p>

<pre><code>@DataProvider
public void craete() { ... }

@DataProvider
public void create(Method method) { ... }

@DataProvider
public void create(ITestContext context) { ... }

@DataProvider
public void create(Method method, ITestContext context) { ... }
</code></pre>

<p>Method参数   <br/>
如果数据提供者的第一个参数是java.lang.reflect.Method，TestNG传递这个将调用的测试方法。如果您希望数据提供者根据不同的测试方法返回不同的数据，那么这种做法就非常有用。</p>

<pre><code>@DataProvider
public Object[][] provideNumbers(Method method)
{
　　String methodName = method.getName();

　　if (methodName.equals("tow")) {
　　　　return new Object[][] { new Object[] {2} };
　　}
　　if (methodName.equals("three")) {
　　　　return new Object[][] { new Object[] {3} };
　　}
}

@Test(dataProvider = "provideNumbers")
public void two(int param)
{
　　System.out.println("Two received: " + param); 
}

@Test(dataProvider = "provideNumbers")
public void three(int param)
{
　　System.out.println("Three received: " + param);
}
</code></pre>

<p>使用同一个数据提供者的地方：</p>

<p>数据提供者代码相当复杂，应该保存在一个地方，这样维护起来更方便。  <br/>
我们要传入数据的那些测试方法具有许多参数，其中只有少数参数是不一样的。  <br/>
我们引入了某个方法的特殊情况。</p>

<p>ITestContext参数  <br/>
如果一个数据提供者在方法签名中声名了一个ITestContext类型的参数，TestNG就会将当前的测试上下文设置给它，这使得数据提供者能够知道当前测试执行的运行时刻参数。</p>

<pre><code>@DataProvider
public Object[][] randomIntegers(ITestContext context)
{
　　String[] groups = context.getIncludeGroups();

　　int size = 2;
　　for (String group : groups) {
　　　　if (group.equals("functional-test")) {
　　　　　　size = 10; 
　　　　　　break;
　　　　}
　　}

　　Object[][] result = new Object[size][];
　　Random r = new Random();
　　for (int i = 0; i &lt; size; i++) {
　　　　result[i] = new Object[] { new Integer(r.nextInt()) };
　　}

　　return result;
}

@Test(dataProvider = "randomIntegers", groups = {"unit-test", "functional-test"})
public void random(Integer n)
{
　　// ......
} 
</code></pre>

<p>ITestContext对象中的数据是运行时刻的信息，不是静态的信息：这个测试方法即属于unit-test组，也属于functional-test组，但在运行时刻，我们决定只执行functional-test组，这个值由ITestContext#getIncludeGroups方法返回。</p>

<p>延迟数据提供者</p>

<p>为了实现这种方法，TestNG允许我们从数据提供者返回一个Iterator，而不是一个二维对象数组。</p>

<p>这种方法与数组不同之处在于，当TestNG需要从数据提供者取得下一组参数时，他会调用Iterator的next方法，这样就有机会在最后一刻实例化相应的对象，即刚好在需要这些参数的测试方法被调用之前。</p>

<pre><code>@DataProvider(name = "generate-accounts-lazy")
public Iterator generateAccountsLazy
{
　　return new AccountIterator();
}

@Test(dataProvider = "generate-accounts-lazy")
public void testAccount(Account a)
{
　　System.out.println("Testing account " + a);
}

class AccountIterator implements Iterator
{
　　private static final int MAX = 4;
　　private int index = 0;

　　public boolean hasNext()
　　{
　　　　return index &lt; MAX;
　　}

　　public Object next()
　　{
　　　　return new Object[] { new Account(index++); } 
　　}

　　public void remove()
　　{
　　　　throw new UnsupportedOperationException(); 
　　}
}
</code></pre>

<p>如果传递的参数是简单类型的常数，利用testng.xml的方法是很好的。档我们需要更多灵活性，并知道参数的数目和值将随时间增加时，我们可能应该选择@DataProvider。</p>

<p>提供数据  <br/>
数据的位置可能是：硬编码在Java源码中、再文本文件中、在属性文件中、在Excel表格中、在数据库中、在网络中&#8230;。</p>

<p>数据提供者还是工厂   <br/>
数据提供者向测试方法传递参数，而工厂像构造方法传递参数。</p>

<p>不如不能确定使用哪种方法，那么就看看测试方法所使用的参数。是否有几个测试方法需要接收同样的参数？如果是这样，您可能最好是将这些参数保存在一个字段中，然后在几个方法中复用这个字段，这就意味着最好是选择工厂。反之，如果所有的测试方法都需要传入不同的参数，那么数据提供者可能是最好的选择。</p>

<p>异步测试  <br/>
异步代码通常出现在下列领域：</p>

<ul>
<li>基于消息的框架，其中发送者和接收者是解耦合的。(JMS)</li>
<li>由java.util.concurrent提供的异步机制(FutureTask)</li>
<li>由SWT或Swing这样的工具集开发的图形用户界面，其中代码与主要的图形部分运行在不同的线程中。</li>
</ul>


<p>测试异步代码比测试同步代码的问题更多：</p>

<ul>
<li>无法确定异步调用何时质性。</li>
<li>无法确定异步调用是否会完成。</li>
</ul>


<p>当调用异步时有三种可能的结果：</p>

<ul>
<li>调用完成并成功。</li>
<li>调用完成并失败。</li>
<li>调用没有完成。
基本上，异步编程遵循着一种非常简单的模式：在发出一个请求时指定一个对象或一个函数，当收到响应时系统会调用回调。</li>
</ul>


<p>测试异步代码也同样遵循下面的模式：</p>

<p>发出异步调用，他会立即返回。如果可能，制定一个回调对象。</p>

<p>如果有回调方法：</p>

<p>等待结果，在接到结果是设置布尔变量，反应结果是否是您的预期。</p>

<p>在测试方法中，监视那个布尔变量，等到他被设置或过了一段时间。</p>

<p>如果没有回调方法：</p>

<p>在测试方法中，定期检查预期的值。如果过了一段时间还没有检查到预期值，就失败并退出。</p>

<p>不指定回调方法</p>

<pre><code>private volatile boolean success = false;

@BeforeClass
public void sendMessage()
{
　　// send the message;
　　// Successful completion should eventually set success to true;
}

@Test(timeOut = 10000)
public void waitForAnswer()
{
　　while (!success) {
　　　　Thead.sleep(1000);
　　}
}
</code></pre>

<p>在这个测试中，消息是作为测试初始化的一部分，利用@BeforeClass发出的，这保证了这段代码在测试方法调用之前执行并且只执行一次。在初始化后TestNG将调用waitForAswer测试方法，他将进行不完全忙等。</p>

<p>有回调方法：</p>

<pre><code>@Test(groups = “send”)
public void sendMessage()
{
　　// send the message
}

@Test(timeOut = 10000, dependsOnGroups = {“send”})
public void waitForAnswer()
{
　　while (!success) {
　　　　Thread.sleep(1000);
　　}
}
</code></pre>

<p>现在sendMessage()是一个@Test方法，他将包含在最终的报告中，如果发送消息失败，TestNG将跳过waitForAnswer测试方法，并把他表示为SKIP。</p>

<pre><code>@Test(timeOut = 10000, invocationCount=100, successPercentage = 98)
public void waitForAnswer ……
</code></pre>

<p>TestNG调用该方法100次，如果98%的调用成功，就认为总体测试通过。</p>

<p>测试多线程代码   <br/>
并发测试</p>

<pre><code>private Singleton singleton;

@Test(invocationCount = 100, threadPoolSize = 10)
public void testSingleton()
{
　　Thread.yield();
　　Singleton p = Singleton.getInstance();
}

public static Singleton getInstance()
{
　　if (instance == null) {
　　　　Thread.yield();
　　　　Assert.assertNull(instance);
　　　　instance = new Singleton();
　　}
　　return instance;
}
</code></pre>

<p>@invocationCount相当简单，在不考虑并发时也可以使用：他决定了TestNG调用一个测试方法的次数。</p>

<p>@threadPoolSize要求TestNG分配一定数量的线程，并使用这些线程来调用这个测试方法，当一个测试完成之后，执行他的线程将归还给线程池，然后可以用于下一次调用。</p>

<p>并发执行</p>

<pre><code>&lt;suite name=”TestNG JDK 1.5” verbose=“1” parallel=“methods” thread-count = “2”&gt;......&lt;/suite&gt;
</code></pre>

<p>thread-count属性指定了线程数目，TestNG将使用这些线程来执行这个测试套件中的所有测试方法，parallel属性告诉TestNG您在执行这些测试时希望采用的并行模式。</p>

<p>parallel=”methods” 在这种模式下，每个测试方法将在他自己的一个线程中执行。</p>

<p>parallel=”test” 在这种模式下，在某个<test>标签内的所有测试方法将在他们自己的一个线程中执行。</p>

<p>在tests模式中，TestNG保证每个<test>将在他自己的线程中执行。如果希望测试不安全的代码，这一点是非常重要的。在method模式中，所有限制都被取消，无法预测哪些方法将在同一个线程中执行，哪些方法将在不同的测试中执行。</p>

<p>为可模拟性设计  <br/>
为了能够成功地使用模拟模拟对象或桩，重要得失要确保代码的设计能让使用模拟对象或桩变得简单而直接。 <br/>
这种设计最重要的方面就是正确的确定组件之间的交互，从而确定组件的交互接口。</p>

<p>如果我们有2个组件A和B，A需要用到B，那么应该通过B的接口来完成，而不是通过B的具体实现。</p>

<p>Singleton查找</p>

<pre><code>public void doWork1()
{
　　C c = C.getInstance();
　　c.doSomething();
}
</code></pre>

<p>对于某个对象智能由一个实例，这在项目生命周期的后期产生阻碍效果。</p>

<p>JNDI定位服务</p>

<pre><code>public void doWork2()
{
　　C c = (C) new InitialContext().lockup("C");
　　c.Something();
}
</code></pre>

<p>不能够向A提供一个受控制的B的实例。只有一个全局实例，A只能取得这个实例。</p>

<p>依赖注入</p>

<pre><code>private C c;

public void setC(C c)
{
　　this.c = c; 
}
</code></pre>

<p>从外部通知A应该使用哪个B的实例。这让我们能够根据实际情况灵活地决定向A提供B的哪个实例。</p>

<p>EasyMock</p>

<pre><code>import static org.easymock.EasyMock.*;

public class EasyMockUserManagerTest
{
　　@Test
　　public void createUser()
　　{
　　　　UserManager manager = new UserManagerImpl();
　　　　UserDao dao = createMock(UserDao.class);
　　　　Mailer mailer = createMock(Mailer.class);

　　　　manager.setDao(dao);
　　　　manager.setMailer(mailer);

　　　　expect(dao.saveUser("tester")).andReturn(true);
　　　　expect(mailer.sendMail(eq("tester"), (String) notNull(), (String) notNull())).addReturn(true);

　　　　replay(dao, mailer);

　　　　manager.createUser("tester");
　　　　verify(mailer, dao);
　　}
}
</code></pre>

<p>1创建模拟对象  <br/>
这是通过createMock方法完成的，传入希望模拟的类作为参数。</p>

<p>2纪录预期行为  <br/>
只要在模拟对象上调用我们预期会被调用的方法，就能纪录预期的行为。当用到某些具体的参数时，只要将这些参数传入就可以了。</p>

<p>3调用主要被测对象  <br/>
在主要的被测对象上调用一个方法或一组方法，预期这次调用将倒置被测对象调用模拟对象的那些预期的方法。</p>

<p>4验证预期行为 <br/>
最后调用verify，检查所有的模拟对象。</p>

<p>JMock  <br/>
jMock是一个模拟库，她让我们通过编成的方式来之行约束条件。</p>

<p>选择正确的策略</p>

<p>缺少接口   <br/>
有时候，我们面对的是庞大臃肿的遗留系统，没有向期望的那样有很好的设计。  <br/>
大多数模拟库现在都允许替换类，而不仅是接口。这些库会在运行时刻生成一个新类，通过字节码操作来实现指定的契约。</p>

<p>复杂的类  <br/>
如果我们得到了一些类，他们拥有20多个方法，与许多其他组件交互，而且随着是间的推移变得越来越复杂。  <br/>
这种情况下，使用动态的模拟对象库效果会比较好，因为他们能够定义单个方法的行为，而不是考虑所有的方法。</p>

<p>契约纪录  <br/>
使用模拟对象让我们记录更多的契约信息，而不止是方法签名。我们可以随时验证器乐的。</p>

<p>测试目标  <br/>
根据经验法则，如果希望测试组件之间交互，模拟对象可能优于桩对象。模拟库能够以一种准确的方式来指定交互。而桩该作为被测试组件使用的那些次要的组件。在这种情况下，测试的目标是测试被测试组件本身，而不是他与其他组件之间的交互。</p>

<p>模拟易犯的错误  <br/>
依赖模拟对象会导至许多问题，所以重要的是要知道使用模拟对象不利的一面：</p>

<ul>
<li>模拟外部API行</li>
<li>虚假的安全感</li>
<li>维护开销</li>
<li>继承与复杂性</li>
</ul>


<p>依赖的测试 <br/>
层叠失败：一个测试的失败导致一组测试的失败。</p>

<p>依赖的代码
只要测时方法依赖于其他测试方法，就很难以隔离的方式执行这些测试方法。  <br/>
彼此依赖的测试方法通常会出现这样的情况，因为他们共享了一些状态，而在测试之间共享状态是不好的。</p>

<p>利用TestNG进行依赖的测试   <br/>
TestNG通过@Test annotation的两个属性(dependsOnGroups和dependsOnMethods)赖支持依赖的测试。</p>

<pre><code>@Test
public void launchServer() {}

@Test(dependsOnMethods = "launchServer")
public void deploy() {}

@Test(dependsOnMethods = "deploy")
public void test1() {}

@Test(dependsOnMethods = "deploy")
public void test2() {}
</code></pre>

<p>dependsOnMethods的问题:  <br/>
通过字符串来执行方法名称，如果将来对他进行重构，代码就有可能失效。方法名称违反了&#8221;不要重复自己&#8221;的原则，方法名称即在Java方法中用到，也在字符串中使用，另外，等我们不断添加新的测试方法时，这个测试用例伸缩性也不好。</p>

<pre><code>@Test(groups = "init")
public void launchServer() {}

@Test(dependsOnGroups = "init", groups = "deploy-apps")
public void deploy() {}

@Test(dependsOnGroups = "init", groups = "deploy-apps")
public void deployAuthenticationServer() {}

@Test(dependsOnGroups = "deploy-apps")
public void test1() {}

@Test(dependsOnGroups = "deploy-apps")
public void test2() {}
</code></pre>

<p>利用组来指定依赖关系可以解决我们遇到的所有问题：</p>

<ul>
<li>不在遇到重构问题，可以任意秀该方法的名称。</li>
<li>不再违反DRY原则。</li>
<li>当新方法须要加入到依赖关系中时，只要将他放到适当的组中，并确保他依赖于正确的组。</li>
</ul>


<p>依赖的测试和线程 <br/>
当打算并行执行测试时，要记住，线程池中的一个或多个线程将用于依次执行每个方法。所以，如果打算在不同的线程中执行一些测试，过渡的使用依赖的测试将影像执行性能。</p>

<p>配置方法的失败  <br/>
依赖测试方法和配置方法之间唯一的不同就是，测试方法隐式的依赖于配置方法。</p>

<p>虽然dependsOnMethods可以处理简单的测试或之由一个测试方法依赖于另一个测试方法的情况，但是在大多数情况下，您都应该使用dependsOnGroups，这种方式的伸缩性好，面对将来的重构也更为健壮。</p>

<p>既然我们提供了准去的依赖信息，那么TestNG就能够按照于骑的顺序来执行测试。</p>

<p>测试隔离并没有因此而受到影响。</p>

<p>如果出现层叠式的错误，依赖测试可以加快测试执行速读。</p>

<p>继承和annotation范围</p>

<pre><code>public class CreditCardTest
{
　　@Test(groups = "web.credit-card")
　　public void test1() {}

　　@Test(groups = "web.credit-card")
　　public void test2() {}
}
</code></pre>

<p>他违反了&#8221;不要重复自己&#8221;的原则   <br/>
他为将来添加测试方法的开发者带来了负担。</p>

<pre><code>@Target({METHOD, TYPE, CONSTRUCTOR})
public @interface Test{}


@Test(groups = "web.credit-card")
public class CreditCardTest
{
　　public void test1() {}
　　public void test2() {}
}
</code></pre>

<p>annotation继承</p>

<pre><code>@Test(groups = "web.credit-card")
class BaseWebTest {}

public class WebTest extends BaseWebTest 
{
　　public test1() {}
　　public test2() {}
}
</code></pre>

<p>所有扩展自BaseWebTest的类都会看到，他们所有的工有方法都自动成为web.credit-card组的成员。  <br/>
WebTest变成了一个普通的传统Java对象(POJO),不带任何annotation。</p>

<p>集成易犯的错误  <br/>
由于TestNG的测试方法必须是公有的，在基类中声明的方法会自动在子类中可见，所以他们永远也不需要作为测试类显式的列出(不要将测试基类列在testng.xml文件中)</p>

<p>测试分组
分组解决了上面提到的局限性，实际上，他们进一步提升了TesgNG的一个设计目标：在静态模型(测试代码)和动态模型(执行哪些测试)之间实现清晰的分离。</p>

<p>语法
@Test annotation和配置annotation(@BeforeClass, @AfterClass, @BeforeMethod&#8230;)都可以属于分组</p>

<pre><code>@Test(groups = {"group1"})
@Test(groups = {"group1", "group2"})
@Test(groups = "group1")

@Test(groups = "group2")
public class B
{
　　@Test
　　public test1() {}

　　@Test(groups = "group3")
　　public test2() {}
}
</code></pre>

<p>test1属于group2组，test2同时属于group2组和group3组</p>

<p>分组与运行时刻</p>

<pre><code>&lt;suite name="Simple suite"&gt;
　　&lt;test name="GroupTest"&gt;
　　　　&lt;groups&gt;
　　　　　　&lt;run&gt;
　　　　　　　　&lt;include name="group1" /&gt;
　　　　　　&lt;/run&gt;
　　　　&lt;/groups&gt;
　　　　&lt;classes&gt;
　　　　　　&lt;class name="com.example.A" /&gt;
　　　　&lt;/classes&gt;
　　&lt;/test&gt;
&lt;/suite&gt;
</code></pre>

<p>这个testng.xml告诉TestNG执行com.example.A类中所有属于group1组的测试方法。</p>

<pre><code>&lt;include name="database" /&gt;
&lt;exclude name="gui" /&gt;
</code></pre>

<p>如果某个方法即属于包含的组，又属于排除的组，那么排除的组优先。   <br/>
如果既没有include，也没有exclude，那么TestNG将忽略组，执行所有的测试方法。</p>

<p>另一个功能就是可以在testng.xml中利用正则表达式来指定组。</p>

<pre><code>&lt;groups&gt;
　　&lt;define name="all-web"&gt;
　　　　&lt;include name="jsp" /&gt;
　　　　&lt;include name="servlet" /&gt;
　　&lt;/define&gt;
　　&lt;run&gt;
　　　　&lt;include name="all-web"&gt;
　　&lt;/run&gt;
&lt;/groups&gt;
</code></pre>

<p>在设计组的层次关系时，能够在testng.xml中定义新组带来灵活性：  <br/>
可以在代码中使用粒度非常小的分组，然后在运行时刻将这些小分组合并成大分组。</p>

<p>执行分组  <br/>
利用命令行执行</p>

<pre><code>java org.testng.TestNG -groups jsp -groups servlet -excludegroups broken com.example.MytestClass
</code></pre>

<p>利用ant</p>

<pre><code>&lt;testng groups="jsp, servlet" excludegroups="broken"&gt;
　　&lt;classfileset&gt;
　　　　&lt;include name="com/example/MyTestClass.class" /&gt;
　　&lt;/classfileset&gt;
&lt;/testng&gt;
</code></pre>

<p>利用Maven</p>

<pre><code>&lt;dependencies&gt;
　　&lt;dependency&gt;
　　　　&lt;groupId&gt;org.testng&lt;/groupId&gt;
　　　　&lt;artifactId&gt;testng&lt;/artifactId&gt;
　　　　&lt;version&gt;5.10&lt;/version&gt;
　　　　&lt;classifier&gt;jdk15&lt;/classifier&gt;
　　&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
　　&lt;plugins&gt;
　　　　&lt;plugin&gt;
　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
　　　　　　&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
　　　　　　&lt;version&gt;2.5&lt;/version&gt;

　　　　　　&lt;configuration&gt;
　　　　　　　　&lt;suiteXmlFiles&gt;
　　　　　　　　　　&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;
　　　　　　　　&lt;suiteXmlFiles&gt;
　　　　　　&lt;/configuration&gt;
　　　　&lt;/plugin&gt;
　　&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>利用Java API</p>

<pre><code>TestNG tng = new TestNG();
tng.setGroups("jsp, servlet");
tng.setExcludeGroups("broken")
</code></pre>

<p>排除失败的测试  <br/>
创建一个特书的组如broken</p>

<pre><code>@Test(groups = { "web", "broken"})
</code></pre>

<p>然后在运行时刻排除这个组。</p>

<pre><code>&lt;exclude name="broken" /&gt;
</code></pre>

<p>组分类</p>

<p>测试类型:单元测试、继承测试  <br/>
测试规模:小规模、大规模  <br/>
功能描述:数据库、界面  <br/>
测试速度:慢测试、快测试  <br/>
过程描述:冒烟测试、发布测试</p>

<p>让开发者能够指定方法的分组，主要的好处在于开发者因此能够很容易找出他们需要执行哪些测试。(如刚刚修改了数据库代码，可能只需要执行fast和database组测试)</p>

<p>组命名</p>

<pre><code>@Test(groups = {"os.linux.debian"})
@Test(groups = {"database.table.ACCOUNTS"})
@Test(groups = {"database.ejb3.connection"})
</code></pre>

<p>TestNG能够利用正则表达式来之定要执行的组，如果与这项功能配合使用，这种命名方式就很有用了。</p>

<pre><code>&lt;groups&gt;
　　&lt;run&gt;
　　　　&lt;include name="database.*" /&gt;
　　&lt;/run&gt;
&lt;/groups&gt;
</code></pre>

<p>代码覆盖率   <br/>
类的覆盖率：类覆盖描熟了项目中多少类已被测试套件访问。　 <br/>
方法覆盖率：方法覆盖率是被访问的方法的百分比。 <br/>
语句覆盖率：语句覆盖率追踪单条源代码语句的调用。 <br/>
语句块覆盖率：语句快覆盖率将语句块作为基本的覆盖律单元。 <br/>
分支覆盖率：分支覆盖率也被称为判断覆盖率。指标计算哪些代码分支被执行。</p>

<p>覆盖律工具  <br/>
Clover、EMMA和Cobertura</p>

<p>成功使用覆盖率的建议 <br/>
覆盖率报告的信息何音的解读不同 <br/>
覆盖率很难 <br/>
百分比没有意义 <br/>
为覆盖率而设计是错误得 <br/>
有一点好过没有 <br/>
覆盖律工具不会测试不存在的代码 <br/>
覆盖率的历史讲述了自己的故事</p>

<p>企业级测试   <br/>
单元测试：单元测试对系统中的一个单元进行独立的测试。</p>

<p>功能测试：功能测试关注一项功能。通常涉及不同组件之间的交互。</p>

<p>继承测试：继承测试是一种端到端的测试，他会执行整个应用栈，包括所有的外部依赖关系或系统。</p>

<p>一个具体的例子  <br/>
系统中有一个相当典型的组件，他接收一条JMS消息，其中包含一段有效的XML文本。这段XML文本相当长，描述了一笔财务交易。这个组件的工作是读出这条消息，解析XML，根据消息的内容条填充一些数据库的表，然后调用一个存储过程来处理这些表。</p>

<p>测试内容</p>

<p>我们将创建一个成功测试。希望确保，如果收到一条有效的XML消息，我们会正确地处理他，并更新正确的数据表，然后存储过程的调用也成功。   <br/>
我们将摹拟不同的场景。希望能够为测试替工不同的XML文本，这样就能够很容易地不断添加测试粒子数据。   <br/>
我们提供明确的失败测试。失败的行为将被记录和测试，这样当组件内部出现失败时，他的状态就可以与测，并且很容易记录下来。</p>

<p>非测试内容</p>

<p>我们不测试JMS provider的功能。假定他是一个完全兼容的实现，已经正确的进行了配置，将成功地提交我们期望的消息。
我们不执行捕捉所有错误得测试。失败测试应该针对明确的、可重现的失败场景。
我们不测试API。例如，JDBC去冬的行为不是测试的主题。确保所有的测试都贯注业务功能，要避免对Java语言的语义进行测试。</p>

<p>测试成功场景  <br/>
对于JMS API的接口  <br/>
利用模拟对象(或桩)对象，创建TextMessage实现，用一个简单的POJO来表现，带有消息内容和其他属性的设置方法。
重构该组件，解除业务功能与JMS API的耦合。</p>

<pre><code>public void onMessage(Message message)
{
    TextMEssage tm = (TextMessage) message;
    processDocument(tm.getText());
}

public void processDocument(String xml)
{
    // code previously in onMessage that updates DB
}

@Test
public void componentUpdateDatabase() throws Exception {}
</code></pre>

<p>构件测试数据</p>

<pre><code>@Test(dataProvider = "")
public void componentUpdateDatabase() throws Exception  {}

@DataProvider(name = "component-data-files")
public Iterator&lt;Object[]&gt; loadXML() throws Exception {}
</code></pre>

<p>我们的测试现在接受一个参数，不再需要自己考虑测试数据的来源，也不需要考虑如何加载测试数据。他要做的只是指定数据提供者。加载XML的实际工作现在代理给了一段独立的加载程序。</p>

<pre><code>@DataProvider(name = "component-data-files")
public Iterator&lt;Object[]&gt; loadXML() throws Exception
{
    File[] f = new File("filepath").listFiles();
    final Iterator&lt;File&gt; files = Arrays.asList(f).iterator();

    return new Iterator&lt;Object[]&gt;() {
        public boolean hasNext()
        {
            return files.hasNext();   
        }

        public Object[] next()
        {
            return new Object[] { IOUtils.readFile(files.next()) };
        }

        public void remove()
        {
            throw new UnsupportedOperationException(); 
        }
    };
}
</code></pre>

<p>当然，可以从数据提供者返回一个Object[]的数组，但是，这种方法意味着我们必需将所有的文件的数据都一次性加载到内存中，因为数组必须事先填充。</p>

<p>测试准备问题</p>

<p>幂等的测试是指，这个测试执行一次和执行多次的结果是一样的。如果某个东西是幂等的，那么说明他在多次调用时状态不会改变。</p>

<p>不仅需要测试是幂等的，而且测试的次序应该无关紧要。所以除了需要是是幂等的之外，测试不应该在状态或数据方面影像其他测试。</p>

<p>对于一些写操作，成功执行之后很容易会对再次执行产生影响，下面方法有助于我们对付这个问题：</p>

<p>嵌入式数据</p>

<pre><code>有一些基于Java的数据库引擎，在设计时专门考虑了嵌入式支持。这些数据库可以在测试过程中临时创建并进行初始化。他们开销很小，通常性能不错。   
不足之处在于，它们与应用程序实际执行的环境差别非常大。通常在数据库特征上存在巨大的诧异。   
</code></pre>

<p>在测试准备时初始化数据</p>

<pre><code>测试数据库总加载一定数量的已知测试数据。其中包含希望操作的所有数据，以及组件所依赖的所有外部引用。   
不足之处在于，很难维护一个健壮的数据集，使他对测试有足够的意义。   
</code></pre>

<p>事务回滚</p>

<pre><code>另一种方法就是利用Java API来防止数据写入到持久数据存储中。总的方法是开是一个事务，执行所有的写操作，验证一切正常，然后让事务回滚。    
不足之处在于，如果没有复杂的嵌套事务准备，就不能测试参与事务的代码或开始自己的事务的代码。   
</code></pre>

<p>选择正确的策略</p>

<pre><code>private WrappedConnection wrappedConnection;    

@BeforeMethod   
public void connection() throws SQLException
{
    connection = DatabaseHelper.getConnection();
    connection.setAutoCommit(false);
    wrappedConnection = new WrappedConnection(connection);
    wrappedConnection.setSuppressCommit(true);
}

@AfterMethod
public void rollback() throws SQLException
{
    wrappedConnection.rollback(); 
}

public class WrappedConnection implements Connection
{
    private Connection connection;
    private boolean suppressClose;
    private boolean suppressCommit;

    public WrappedConnection(Connection connection)
    {
        this.connection = connection;    
    }

    public void commit() throws SQLException
    {
        if (!suppressCommit)    
            connection.commit();
    }

    // ......
}
</code></pre>

<p>错误处理</p>

<pre><code>@Test(dataProvider = "component-data-files")
public void componentupdateDatabase(String xml) throws Exception
{
    Component component = new Component();
    try {
        component.processDocument(xml);
    }
    catch (InvalidTradeException e) {
        return;
    }
    // rest of test code
}
</code></pre>

<p>这种方法在于，他们没能让我们区分失败是否是预期的。相反，我们应该能够区分预期的成功和预期的失败。这个测时目前在两种情况下会通过：要么遇到好的数据时会通过，要么遇到坏数据时会通过。在每种情况下，我们都不能确定会发生些什么。</p>

<p>一个测试不应该在两种或两种以上的情况下都通过。如果测试验证了不同的失败情况，这没问题，但如果测试在好数据和坏数据的情况下都通过，那就会导致一些微妙的错误，这类错误难以被发现。(因此我们定义了另一个目录和数据提供者来处理失败的情况)</p>

<pre><code>@Test(dataProvider = "component-invalid-data-files", expectedException = InvalidTradeException.class)
public void componentInvalidInput(String xml) throws Exception
{
    Component component = new Component();
    component.processDocument(xml);
    // rest of test code
}
</code></pre>

<p>逐渐出现的单元测试  <br/>
单元测试不一定是在其它测试之前编写的，他们可以是功能测试驱动的。特别是对于大型项目或原有的代码来说，一开始就编写有用的单元测试可能很困难，因为在不了解全局的情况下，单元测试可能太琐碎或不太重要。相反，单元测试可以从有意义的继承测试中推导出来，因为调试开发功能测试和集成测试的过程揭示他们所需的单元测试。</p>

<p>对于例子来说我们需要将XML验证与数据库处理放到各自独立的方法中。这样就能对他们进行测试</p>

<pre><code>public void processDocument(String xml) throws InvalidDocumentException
{
    Document doc = XMLHelper.parseDocument(xml);
    validateDocument(doc);
    // ......
}

public void validateDocument(Document doc) throws InvalidDocumentException
{
    // perform constraint checks that can't be captured by XML
}
</code></pre>

<p>这测重构的结果是我们得到了一个简单的单元测试。</p>

<p>不论测试编写的次序如何，功能测试和单元测试都是互不的。功能测试是更为水平化的测试，涉及许多不同的组件，执行代码的很多部分。相反，单元测试是更为垂直化的测试，他关注范围狭窄的主题，比功能测试要彻底得多。</p>

<p>竞争消费者模式  <br/>
消费者的执行是并发的，所以我们必须在测试中进行某种程度的模拟，生产环境中的真实情况。在我们这样作了之后，也希望验证结果。不论哪个消费者先开始，也不论哪个消费者先结束，都没有关系。我们希望确定对于给定数量的消费者，我们将得道一组已知的结果，可以进行验证。</p>

<pre><code>private final List&lt;Object[]&gt; data = Collections.synchronizedList(new ArrayList&lt;Object[]&gt;());

@BeforeClass
public void populateData()
{
    data.add(new Object[] {"value1", "prop1"});
    data.add(new Object[] {"value2", "prop2"});
    data.add(new Object[] {"value3", "prop3"});
}

@Test(threadPoolSize = 3, invocationCount = 3, dataProvider = "concurrent-processor")
public void runConcurrentProcessors(String value, String someProp)
{    
    MessageProcessor processor = new MessageProcessor();
    processor.process(value, someProp);
}

@Test(dependsOnMethods = "runConcurrentProcessors")
public void verifyConcurrentProcessors()
{
    // load data from db
    // verify that we have 3 results
    // verify that each of the 3 result matches our 3 input
}

@DataProvider(name = "concurrent-processor")
public Object[][] getProcessorData()
{
    return new Object[][] {data.remove(data.size() - 1)};
}
</code></pre>

<p>我们的测试被分成两个，一个负责执行消费者，另一个负责验证结果。原因是runConcurrentProcessors会被调用多次，而我们只需要在所有方法调用完成之后，对结果验证一次。为了表示这种次序，我们利用了dependsOnMethods这个annotation属性。</p>

<p>当TestNG发现一个数据提供者时，他将针对数据提供者返回的每一条数据调用一次测试。类似的，当我们指定调用次数时，TestNG会按照指定的次数调用测试。因此，如果我们返回数据提供者中准备好的3条数据，那么每个线程都会执行3次测试。</p>

<p>因此解决方案是使用一个栈结构，每次调用数据提供者时，返回一条数据，并将这条数据从列表中清除。数据提供者将被调用3次，每次都将为数据返回不一样的数据。</p>

<p>原则：将数据的考虑和功能的考虑分开来是很关键的。  <br/>
在这个例子中，消费者需要的数据应该和实际的测试没有依赖关系。这种方法意味着，随着我们对数据的需求不断变化，变得更为复杂，测试本身却不需要被修改。</p>

<p>一个具体的例子 <br/>
我们希望测试一个登录servlet。这个servlet接受一个请求，检查用户名和口令，如果他们有效，就在会话中加入一个标记。表明用户已登录。</p>

<p>这个例子展示了重构在测试方面起到的重要辅助作用，说明了即使对于看上去很麻烦、需要一很复杂地方是进行交互的API，页可以通过抽象去掉依赖关系。这种抽象意味着 在测试过程中，我们可以利用更简单的对象，这些对象更容易构造，因此也更容易测试。</p>

<p>增加可测试性的一个副作用就是改进了设计。为提高可测试性而进行重构，可以帮助我们以一种实际的、代码中的方式来确定职责和考虑，而这种效果通过画设计图是很难达到的。</p>

<p>Java EE测试  <br/>
容器内测试与容器外测试的对比</p>

<p>容器内测试  <br/>
优点：</p>

<pre><code>完全符合运行时环境   
</code></pre>

<p>缺点：</p>

<pre><code>启动消耗大    
难以部署新的测试    
难以自动化    
夸平台测试的复杂性增加    
</code></pre>

<p>容器外测试  <br/>
优点：</p>

<pre><code>提供了相对较快的启动    
可以完全控制环境    
可以自动化    
容易测试    
</code></pre>

<p>缺点：</p>

<pre><code>没有符合运行时环境   
测试所用的实现可能与运行时的实现来自不同的提供商。   
</code></pre>

<p>容器内测试  <br/>
测试步骤：</p>

<p>创建一个测试环境的实例。 <br/>
确定测试。 <br/>
在测试框架中注册测试。 <br/>
注册一个监听者来接收搜测试结果。</p>

<p>创建测试环境</p>

<pre><code>TestNG tester = new TestNG();
tester.setDeafultSuiteName("container-tests");
</code></pre>

<p>确定测试  <br/>
假定所有的测试类都在WEB-INF/classes目录下，我们可以递归地读入这个目录，找到其中所有的类文件。</p>

<pre><code>public static Class[] scan(ServletContext context)
{
    String root = context.getReadPath();
    ClassScanner scanner = new ClassScanner(new File(root));
    scanner.setClassLoader(ClassScanner.class.getClassLoader());
    final File testDir = new File(root, "com/foo/tests");
    scanner.setFilter(new FileFilter() {
        public boolean accept(File pathname) {
            return pathname.getPath().startsWith(testDir.getPath());
        }    
    });
    Class[] classes = scanner.getClasses();
    return classes;
}
</code></pre>

<p>context是一个ServletContext实例，他是通过调用servlet或JSP页面得到的。</p>

<p>注册测试  <br/>
注册测试类的动作告诉了TestNG他要查看的一组类，TestNG将在这组类中查找需要执行哪些测试。他将检查每个指定的类，确定他是否包涵测试方法或配置方法。当所有类都检查过后，TestNG内部会生成一个依赖关系图，以决定照到的这些测试的执行次序。</p>

<pre><code>tester.setTestClasses(classes);
</code></pre>

<p>注册结果监听者</p>

<p>TestNG自代了3个默认的报告类：</p>

<p>SuiteHTMLRepoter 默认报告类，他在一个目录下输出交叉引用HTML文件，让您能看到某个具体测试的结果。</p>

<p>FailedReporter: 这个报高生成一个TestNG执行配置，该配置包含了所有前一次运行时失败的测试。他也是默认运行的。</p>

<p>EmailableReporter: 这个报告类生成一个报告文件，可以很容易地通过电子邮件发送，显示测试的结果。</p>

<p>默认情况下，EmailableReporter在磁盘上生成一个文件。</p>

<pre><code>public class SinglePageReporter extends EmailableReporter
{
    private Writer writer;

    public SinglePageReporter()
    {
        this.writer = writer;
    }

    protected PrintWriter createWriter(String out)
    {
        return new PrintWriter(writer);
    }
}
</code></pre>

<p>调用TestNG的JSP页面</p>

<pre><code>&lt;%@ page import="org.testng.*, java.io.*" %&gt;
&lt;%
    TestNG tester = new TestNG();
    tester.setDefaultSuiteName("container-tests");

    String root = application.getRealPath("/WEB-INF/classes");
    ClassScanner scanner = new ClassScanner(new File(root));
    scanner.setLoader(getClass().getClassLoader());
    scanner.setFilter(new FileFilter() {
        public boolean accept(File pathname) {
            return pathname.getPath().indexOf(Test) &gt; -1;
        }
    });

    Class[] classes = scanner.getClasses();
    tester.setTestClasses(classes);

    IReporter reporter = new SinglePageReporter(out);
    tester.addListener(reporter);

    tester.run();
%&gt;
</code></pre>

<p>Java命名和目录接(JNDI)  <br/>
JNDI是一个在全局目录中查找资源的API。可以把他看成是一个很大的树型结构，我们在其中按照名称查找某个节点。</p>

<pre><code>new InitialContext().lockup("someObject");     
</code></pre>

<p>上面创建一个InitialContext对象，如果在执行容器内执行，会利用供应商提供的API实现，来查找容器内部命名目录结构。创建了上下文之后，我们在其中查找对象，列出他的内容，或遍历这棵树。所有这些都是通过JNDI API来完成的。InitialContext的构造方法由一个重载的版本，接受一个Hashtable对象作为参数，其中包含不同的环境变量值，决定了上下文应该如何创建。</p>

<pre><code>Hashtable env = new Hashtable();
env.put(Context.INITIAL_CONTEXT_FACTORY, "");
env.put(Context.PROVIDER_URL, "smqp://localhost:4001");
Object topic = new InitialContext(env).lookup("myTopic");
</code></pre>

<p>避免JNDI  <br/>
组件依赖关系要么通过服务定位(通常是JNDI)来实现，要么通过注入来实现。如果您可以选择，就采用注入的方式，因为这样测试的开销最小，并且这种方式带来了更大的灵活性。</p>

<p>Java消息服务(JMS)</p>

<pre><code>private Session session;
private Destination destination;

@BeforeClass(groups = "jms")
public void setupJMS() throws NamingException, JMSException
{
    Hashtable env = new Hashtable();
    // populate environmet for out specific provider
    InitialContext context = new InitialContext(env);

    ConnectionFactory factory = (ConnectionFactory) context.lookup("QueueConnectionFactory");
    Connection connection = factory.createConnection();
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    destination = (Detination) context.lookup("TestQueue@router1");
}


@Test(groups = "jms")
public void sendMessage() throws JMSException
{
    TextMessage msg = session.createTextMessage();
    msg.setText("hello!");
    msg.setStringProperty("test", "test1");
    session.createProducer(destination).send(msg);
}

@Test(groups = "jms", dependsOnMethods = "sendMessage", timeOut = 1000)
public void receiveMessage() throws JMSException
{
    MessageConsumer consumer = session.createConsumer(destination, "test", "test1");
    TextMessage msg = (TextMessage) consumer.receive();
    assert "hello!".equals(msg.getText());
}
</code></pre>

<p>在测试中使用ActiveMQ</p>

<pre><code>@BeforeClass(groups = "jms")
public void setupActiveMQ() throws Exception
{
    BrokerService broker = new BrokerService();
    broker.setPersistent(false);
    broker.setUseJmx(false);
    broker.start();

    URI uri = broker.gettVmCnnectionURI();
    ConnectionFactory factory = new ActiveMQConnectionFactory(uri);
    Connection connection = factory.createConnection();
    connection.start();

    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    destination = session.createQueue("TestQueue@router1");
}
</code></pre>

<p>处理状态   <br/>
在JMS的例子中，当我们拥有多个测试时，会引发一个有趣的问题。因为测试是由一对方法组成的，所以让我们假定同一个类中还有另一对发送/接收测试。</p>

<p>一种方法是将发送和接受者放在一个测试中，并在每个测试方法之前初始化消息代理。请注意两点都要做到，因为让消息代里在一对测试方法之前初始化是比较麻烦的。</p>

<p>另一种方法是使用消息分捡器。JMS消息分捡器让我们能够过滤接收到的消息，这样可以只接收与分捡器匹配的消息。</p>

<p>Spring <br/>
Spring的测试包功能</p>

<p>TestNG通过自己的一组针对Spring的类来解决这些问题，这些类作为扩展提供。org.testng.spring.test包中包含了所有Spring在其测试包中提供的类，这些类已修改过，可以用在基于TestNG的测试中。</p>

<p>AbstractSpringContextTests <br/>
这是所有Spring测试的基类。他的主要职责是提供上下文的管理。这个类包含一个静态map，其中包含所有注册的Spring上下文。</p>

<p>AbstractSingleSpringContextTests  <br/>
这个类扩展了AbstractSpringContextTests，提供了装入一个ApplicationContext对象的钩子。他的子类应该实现getConfigLocation(String[] paths)方法。这个方法返回一个字符串数组，指出了Spring配置文件的位置，通常是从classpath加载的。</p>

<pre><code>import org.testng.annotation.Test;
import org.testng.spring.test.AbstractSingleSpringContextTests;

public class SpringContextTests extends AbstractSingleSpringContextTests
{
    protected String[] getConfigLocations()
    {
        return new String[] {"/spring.xml"};    
    }

    @Test
    public void beanDefined()
    {
        assert applicationContext.getBean("myBean") != null;
    }
}
</code></pre>

<p>Spring的配置方法被声明在名为Spring-init的TestNG分组中。我们不必依赖于单个的onSetUp或ontearDown方法，可以根据需要声明任意多个@BeforeMethod/@AfterMethod配置方法，只要指定他们依赖于spring-init，就可以确保他们在Spring执行完准备工作之后得到调用。</p>

<p>AbstractDependencyInjectionSpringContextTests <br/>
这个类提供的最有趣的功能就是向测试注入依赖。测试依赖关系可以表现为设值方法或成员字断。测试也可以指定Spring应该对他们的树性执行哪种类型的自动编织。</p>

<pre><code>public class SpringInjectionTests extends AbstractDependncyInjectionSpringContextTests
{
    private PersonManager manager;

    protected String[] getConfigLocation()
    {
        return new String[] {"/spring.xml"};     
    }

    public void setManager(PersonManager manager)
    {
        this.manager = manager; 
    }

    @Test
    public void verifyManager()
    {
        assert manager != null;    
    }
}
</code></pre>

<p>这个类有一个事务管理器属性。因为他派生自支持注入的类，配置文件中必需指定一个PlatforTransactionManager，以便注入。</p>

<pre><code>public class StrpingTranscationTests extends AbstractTransactionalSpringContextTests
{
    private PersonManager manager;

    public void setManager(PersonManager manager)
    {
        this.manager = manager
    }

    protected String[] getConfigLocation()
    {
        return new String[] {"/spring.xml"};
    }

    @Test
    public void savePerson()
    {
        Person p = new Person();
        manager.savePerson(p);

        assert p.getId() != null;
        // setComplete();
    }
}
</code></pre>

<p>我们没有在测试中指定任何事务行为，超类自动处理了事务方面的问题，让每个测试在他自己的事务中执行，这个十五将在该测试完成之后回滚。</p>

<p>增加的调用setComplete通知超类在测试执行之后应该提交这个事务，而不是回滚。调用这个方法由一个有趣的副作用：这个类中所有后续测试都会提交事务，而不是依赖于默认行为。</p>

<p>答案在于JUnit和TestNG之间的一个微妙区别。Spring测试假定采用了JUnit的语义。每个测试类对每个测试方法都会重新实例化。因此，所有的测试都假定每个测试开始时，测试时里的状态都会复原，但TestNG不是这样的。</p>

<p>AbstractTransactionalDataSouceSpringContextTests  <br/>
这个类添加了一些JDBC相关的便利方法。</p>

<p>AbstractAnnotationAwareTransactionalTests  <br/>
这个类支持超类提供的所有功能之外，这个类允许我们在测试方法上指定Spring特有的事务annotation，而不是通过编程的方式来指定事务行为。</p>

<p>Guice <br/>
第2章中的例子，对于每个接口，我们都有两个实现。一个是实际的产品实现，他会与一些外部的依赖关系进行交互，如UserDAO对象会与数据库交互，Mailer对象会与SMTP邮件服务器交互。我们还有桩对象实现。</p>

<pre><code>@Test
public void verifyCreateUser()
{
    UserManager manager = new UserManagerImpl();
    MailerStub mailer = new MailerStub();

    manager.setMailer(mailer);
    manager.setDao(new UserDAOStub());

    manager.createUser("tester");
    assert mailer.getMails().size() == 1;
}
</code></pre>

<p>Guice注入测试</p>

<pre><code>@Inject private UserManager manager;
@Inject private MailerStub mailer;

@Test
public void verifyCreateUser()
{
    manager.createUser("tester");    
    assert mailer.getMails().size() == 1;
}
</code></pre>

<p>Spring注入测试</p>

<pre><code>private UserManager manager;
private MailerStub mailer;

public void verifyCreateUser()
{
    manager.createUser("tester");
    assert mailer.getMails().size() == 1;
}

public void setManager(UserManager manager)
{
    this.manager = manager;
}

public void setMailer(MailerStub mailer)
{
    this.mailer = mailer;    
}
</code></pre>

<p>对象工厂</p>

<p>杂谈 <br/>
关注和提供异常  <br/>
一层遇到了一个没有预料到的错误，不知道如何处理。所以这一层就快乐地向上一层抛出一个异常，希望这个可怜的异常最终会遇到知道怎么作的人。</p>

<p>吞掉抛出异常</p>

<pre><code>try {
    callBackend();
}
catch (SQLException ex) {
    throw new BackendException("Error in backed");
}
</code></pre>

<p>这种方法问题在于，实际上我们丢试了真实错误的有意义的信息。当我们最后有机会处理这个异常的时候，我们得到的信息仅仅是某一层中出了问题，但我们不知道是在这一曾本身出了问题，还是更低的层出了问题。</p>

<p>记日志并抛出</p>

<pre><code>try {
    callBackend();
}
catch (SQLException ex) {
    log.error("Error calling backend", ex);
    throw ex;
}
</code></pre>

<p>问题在于调用栈经常发生的情况：信息隐藏。假定一个应用程序有三层或四层，每一层都在日志中记录他处里的异常，查遍8页的调用栈信息并不是最有效地方式。</p>

<p>嵌套抛出</p>

<pre><code>try {
    callBackend();
}
catch (SQLException ex) {
    throw new BackendException("Error in backend", ex);
}
</code></pre>

<p>当这个调用栈显示的时候，没有丝毫暗示表明背后的原因是什么。您必须编写一个帮助方法，从外面的包装中取出背后实际的异常。</p>

<p>我们建议两种解决方案</p>

<p>避免需检察异常。运行时异常很合适这样的情况。 <br/>
包装异常。假如您非常肯定在调用栈打印时，背后的原因会显示出来，那么包装的异常也很好。</p>

<p>有状态测试  <br/>
有两种截然不同的状态分类：不可修改的状态和可修改的状态</p>

<p>不可修改的状态  <br/>
访问共享的不可修改的状态的测试方法，相互之间是独立的。 <br/>
因为这些方法都不能修改他们读到的状态，所以调用顺序可以是任意的，因此他们没有违反测试访法应该彼此肚里的原则。</p>

<p>可修改的状态</p>

<pre><code>public class MyTest extends TestCase
{
    private int count = 0;

    public void test1()
    {
        count++;
        assertEquals(1, count);
    }

    public void test2()
    {
        count++;
        assertEquals(2, count);
    }
}
</code></pre>

<p>JUnit会让这个测试通过，但TestNG不会。 <br/>
只有当您知道测试方法被调用的顺序时，共享可修改的状态才有意义。</p>

<p>安全的共享数 <br/>
安全          不可修改的状态</p>

<p>安全　　　可修改的状态与完全指定的依赖关系</p>

<p>不安全　　可修改的状态与不确定的依赖关系</p>

<p>测试驱动开发的缺点  <br/>
他注重微观设计超过宏观测试</p>

<p>他在实践中难以应用</p>

<p>TDD注重微观设计超过宏观设计</p>

<p>测试驱动开发可以得到更健壮的软件，但他也可能导致不必要的反复和过度重构的趋势，这可能对饮的软件、设计和最后期限产生负面影响。</p>

<p>TDD难以应用</p>

<p>这种方式得到的代码本身并不会优先于传统方法测试的代码。</p>

<p>如何创建测试并不重要，重要的是确实要创建测试</p>

<p>测试私有方法 <br/>
如果他有可能出问题，您就应该测试他。</p>

<p>测试私有方法的比较好的方法是提升方法的可见性，例如，让他变成保护可见，或者包可见。后者更好一些，因为您可以把测试和被测类放在同一个包中，然后您就可以访问他的所有字段。如果这些方法都不可取，我们测试私有方法的方式就是利用反射。</p>

<pre><code>public class LoginController
{
    private String userName;

    private void init()
    {
        this.username = getUserNameFromCookie();
    }
}

@Test
public void verifyInit()
{
    LoginController lc = new LoginController();

    Field f = lc.getClass().getField("username");
    Object valueBefore = f.get(lc);
    Assert.assertNull(valueBefore);

    Method m = lc.getClass().getDeclaredMethod("init", null);
    m.setAccessible(true);
    m.invock(lc);

    Object valueAfter = f.get(lc);
    Assert.assertNotNull(vlaueAfter);
}
</code></pre>

<p>我们利用字符串来描述Java元素。如果您对这些元素进行重命名，这种危险的实践肯定会失效。</p>

<p>我们利用了该类危险的私有信息。我们不仅假定存在一些私有方法和属性，而且也假定这个方法将以某种方式修改一个字段。</p>

<p>测试与封装  <br/>
如果让代码更可测试，不要担心破坏封装。可测试星应该胜过封装。</p>

<p>让一个私有方法(或字段)成为包可见的、保护可见的或公有的。</p>

<p>去掉方法的final限定符。这让测试勒能够扩展这些类，或重写这些方法，模拟或稍微改变他们的实现，从而让系统的其它部分更可测试。</p>

<p>记日志的最佳实践  <br/>
在出错时，输出错误或警告是合理的。但是对於警告的情况，重要的是确定这是不是该做的事情。我们添加的每一条无用的日志信息都会干扰有用的信息，所已精心选择是有意义的。</p>

<p>对于调试需求，记日志是有用的。但是，只要有一个开关能打开或关闭，绝大多数的记日志需求都能够满足了，不需要复杂的解决方案。</p>

<p>参考文档：<a href="http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html">http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:selenium常见问题]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions/"/>
    <updated>2013-05-30T19:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions</id>
    <content type="html"><![CDATA[<h3>selenium常见问题</h3>

<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions">https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions</a></p>

<h4>Q:什么是WebDriver?</h4>

<p>A:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。</p>

<h4>Q:Selenium与<a href="http://sahi.co.in/">Sahi</a>有什么异同？</h4>

<p>A:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。</p>

<h4>Q：什么是Selenium 2.0?</h4>

<p>A:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。</p>

<!--more-->


<h4>Q：如何从原来的selenium api迁移到新的webdriver api?</h4>

<p>A:参见<a href="http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html">http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html</a></p>

<h4>Q:WebDriver支持哪些浏览器？</h4>

<p>A:目前支持<a href="https://code.google.com/p/selenium/wiki/ChromeDriver">ChromeDriver</a>,<a href="https://code.google.com/p/selenium/wiki/InternetExplorerDriver">InternetExplorerDriver</a>,<a href="https://code.google.com/p/selenium/wiki/FirefoxDriver">FirefoxDriver</a>,<a href="https://code.google.com/p/selenium/wiki/OperaDriver">OperaDriver</a>,<a href="https://code.google.com/p/selenium/wiki/HtmlUnitDriver">HtmlUnitDriver</a>。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括<a href="https://code.google.com/p/selenium/wiki/AndroidDriver">AndroidDriver</a>,OperaMobileDriver,IPhoneDriver。</p>

<h4>Q：“developer focused”是什么意思？</h4>

<p>A:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。</p>

<h4>Q:如何直接执行Javascript?</h4>

<p>A:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。  <br/>
我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。</p>

<pre><code>WebDriver driver; // Assigned elsewhere
JavascriptExecutor js =     (JavascriptExecutor) driver;
js.executeScript("return document.title");
</code></pre>

<p>至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。</p>

<h4>Q：为什么我执行Javascript,总是返回NULL？</h4>

<p>A:你需要让你的JS脚本有返回值。所以<code>js.executeScript("document.title");</code>会返回null;而<code>js.executeScript("return document.title");</code>则会返回页面的title。</p>

<h4>Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？</h4>

<p>A:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见<a href="https://code.google.com/p/selenium/wiki/XpathInWebDriver">XpathInWebDriver</a>章节。</p>

<h4>Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？</h4>

<p>A:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：</p>

<pre><code>DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();
capabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);
WebDriver driver = new InternetExplorerDriver(capabilities);    
</code></pre>

<p>正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。</p>

<h4>Q：除了Java，还支持哪些语言？</h4>

<p>A:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。</p>

<h4>Q：如何处理新弹出的浏览器窗口？</h4>

<p>A:WebDriver提供了处理多浏览器窗口的能力。通过使用<code>WebDriver.switchTo().window()</code>可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用<code>"WebDriver.getWindowHandles()</code>获取窗口的名字列表。然后就可以使用<code>switchTo().window()</code>来转向了。</p>

<h4>Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？</h4>

<p>A: 使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html">Alert API</a>可以搞定:</p>

<pre><code>// Get a handle to the open alert, prompt or confirmation
Alert alert = driver.switchTo().alert();
// Get the text of the alert or prompt
alert.getText();  
// And acknowledge the alert (equivalent to clicking "OK")
alert.accept();
</code></pre>

<h4>Q：WebDriver支持文件上传？</h4>

<p>A:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用<code>WebElement#sendKeys("/path/to/file")</code> 就可以正确上传。同时你要保证不要在文件上传元素上进行<code>WebElement#click()</code>操作，否则可能导致浏览器挂起。 <br/>
小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。</p>

<pre><code>((JavascriptExecutor)driver).executeScript("arguments[0].style.visibility = 'visible';      arguments[0].style.height = '1px'; arguments[0].style.width = '1px'; arguments[0].style.opacity = 1", fileUploadElement); 
</code></pre>

<h4>Q：为什么在执行<code>sendKeys</code>后，没有触发onchange事件？</h4>

<p>A:WebDriver是将焦点一直放在调用<code>sendKeys</code>的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的<code>click</code>下其他元素即可。</p>

<h4>Q：能同时运行多个WebDriver的实例？</h4>

<p>A:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。</p>

<h4>Q：我需要使用代理。我该如何配置呢？</h4>

<p>A：代理配置是通过<code>org.openqa.selenium.Proxy</code>类来实现的，类似下面代码所示：</p>

<pre><code>Proxy proxy = new Proxy();
proxy.setProxyAutoconfigUrl("http://youdomain/config");

// We use firefox as an example here.
DesiredCapabilities capabilities = DesiredCapabilities.firefox();
capabilities.setCapability(CapabilityType.PROXY, proxy);

// You could use any webdriver implementation here
WebDriver driver = new FirefoxDriver(capabilities);
</code></pre>

<h4>Q：使用HtmlUnitDriver该如何实现权限验证？</h4>

<p>A:当创建HtmlUnitDriver时，重写<code>modifyWebClient</code>方法即可。例如：</p>

<pre><code>WebDriver driver = new HtmlUnitDriver() {
  protected WebClient modifyWebClient(WebClient client) {
    // This class ships with HtmlUnit itself
    DefaultCredentialsProvider creds = new DefaultCredentialsProvider();

    // Set some example credentials
    creds.addCredentials("username", "password");

    // And now add the provider to the webClient instance
    client.setCredentialsProvider(creds);

    return client;
  }
};
</code></pre>

<h4>Q：WebDriver是线程安全的吗？</h4>

<p>A:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。</p>

<h4>Q：如何向一个可编辑的iframe里输入？</h4>

<p>A:假设那个iframe的name是“foo”:</p>

<pre><code>driver.switchTo().frame("foo");
WebElement editable = driver.switchTo().activeElement();
editable.sendKeys("Your text here");
</code></pre>

<p>有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在<code>sendKeys</code>之前做以下的操作：</p>

<pre><code>((JavascriptExecutor) driver).executeScript("document.body.innerHTML = '&lt;br&gt;'");
</code></pre>

<p>因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。 <br/>
记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。</p>

<pre><code>driver.switchTo().defaultContent();
</code></pre>

<h4>Q：在Linux系统上WebDriver无法启动Firefox，并抛出<code>java.net.SocketException</code>。</h4>

<p>A:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：</p>

<pre><code>Caused by: java.net.SocketException: Invalid argument
        at java.net.PlainSocketImpl.socketBind(Native Method)
        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)
        at java.net.Socket.bind(Socket.java:571)
        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)
        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)
</code></pre>

<p>这可能是因为机器上的IPv6设置导致的。执行下面的脚本：</p>

<pre><code>sudo sysctl net.ipv6.bindv6only=0
</code></pre>

<p>为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑<code>/etc/sysctl.d/bindv6only.conf</code>禁用这个行为。</p>

<h4>Q:WebDriver找不到元素/页面没有完全加载就返回了。</h4>

<p>A:这个问题可以从各种方式显现出来：</p>

<ul>
<li>使用WebDriver.findElement(&#8230;)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。</li>
<li>调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。</li>
<li>click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？</li>
<li>我怎么才能知道一个页面是否已经完全加载了？</li>
</ul>


<p><strong>解析</strong>：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。  <br/>
<strong>解决方案</strong>：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html">WebDriver.manage().timeouts()</a>来实现.</p>

<h4>Q:如何能触发页面上的任意事件？</h4>

<p>A:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。 <br/>
触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。</p>

<h4>Q:为什么不能与隐藏的元素进行交互？</h4>

<p>A:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。
然而，执行JavaScript来直接调用隐藏元素的getText是允许的。</p>

<pre><code>WebElement element = ...;
((JavascriptExecutor) driver).executeScript("return arguments[0].getText();", element);
</code></pre>

<h4>Q:如何启动一个带插件的Firefox？</h4>

<p>A:</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile()
profile.addExtension(....);

WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h4>Q: 要是WebDriver有&#8230;功能，我会更喜欢它。</h4>

<p>A: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。</p>

<h4>Q: 有时Selenium server启动一个新session的时候要花费很长的时间？</h4>

<p>A:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。<br/>
在Windows(XP)系统上，你可以看下<a href="http://bugs.sun.com/view_bug.do?bug_id=6705872">http://bugs.sun.com/view_bug.do?bug_id=6705872</a>,这通常需要从你的临时文件夹清理大量的数据文件。</p>

<h4>Q: 在Selenium WebDriver的API中哪个与TextPresent对等?</h4>

<p>A:</p>

<pre><code>driver.findElement(By.tagName("body")).getText()
</code></pre>

<p>会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。</p>

<h4>Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。</h4>

<p>A:守护Firefox启动的socket lock在设计时，有以下的限制：</p>

<ul>
<li>socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。</li>
<li>启动firefox的某些关键部分必须在机器上独占锁定。</li>
<li>socket lock本身不是瓶颈。启动firefox才是。</li>
</ul>


<p><code>SocketLock</code>是<code>Lock</code>接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。</p>

<h4>Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？</h4>

<p>A: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=&#8221;en_US.UTF-8&#8221;就可以了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:webdriverJs]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js</id>
    <content type="html"><![CDATA[<h1>WebDriverJS</h1>

<p>WebDriver 的 JavaScript 语言绑定。本文包含以下内容：</p>

<ul>
<li>介绍</li>
<li>快速上手

<ul>
<li>在 Node 中运行</li>
<li>在浏览器中运行</li>
</ul>
</li>
<li>设计细节

<ul>
<li>管理异步 API</li>
<li>同服务端通讯</li>
<li>/xdrpc</li>
</ul>
</li>
<li>未来计划</li>
</ul>


<h2>介绍</h2>

<p>WebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。</p>

<p><strong>警告：</strong> WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。</p>

<!--more-->


<h2>快速上手</h2>

<h3>在 Node 中运行</h3>

<p>虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：</p>

<pre><code>$ ./go selenium-server-standalone //javascript/node:webdriver
</code></pre>

<p>当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：</p>

<pre><code>$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
$ node

var webdriver = require('./build/javascript/node/webdriver');

var driver = new webdriver.Builder().
    usingServer('http://localhost:4444/wd/hub').
    withCapabilities({
      'browserName': 'chrome',
      'version': '',
      'platform': 'ANY',
      'javascriptEnabled': true
    }).
    build();

driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click();
driver.getTitle().then(function(title) {
  require('assert').equal('webdriver - Google Search', title);

});

driver.quit();
</code></pre>

<h3>在浏览器中运行</h3>

<p>除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：</p>

<pre><code>$ ./go //javascript/webdriver:webdriver
</code></pre>

<p>为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 <a href="https://code.google.com/p/selenium/wiki/JsonWireProtocol">JsonWireProtocol</a> 和 <a href="https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing">cross-origin resource sharing</a>：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;script&gt;
  var client = new webdriver.http.CorsClient('http://localhost:4444/wd/hub');
  var executor = new webdriver.http.Executor(client);

  // 启动一个新浏览器，这个浏览器可以被这段脚本控制
  var driver = webdriver.WebDriver.createSession(executor, {
    'browserName': 'chrome',
    'version': '',
    'platform': 'ANY',
    'javascriptEnabled': true
  });

  driver.get('http://www.google.com');
  driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
  driver.findElement(webdriver.By.name('btnG')).click();
  driver.getTitle().then(function(title) {
    if (title !== 'webdriver - Google Search') {
      throw new Error(
          'Expected "webdriver - Google Search", but was "' + title + '"');
    }
  });

  driver.quit();
&lt;/script&gt;
</code></pre>

<h4>控制宿主浏览器</h4>

<p>启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。</p>

<pre><code>&lt;!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&amp;wdsid=foo1234 --&gt;
&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;input id="input" type="text"/&gt;
&lt;script&gt;
  // Attaches to the server and session controlling this browser.
  var driver = new webdriver.Builder().build();

  var input = driver.findElement(webdriver.By.tagName('input'));
  input.sendKeys('foo bar baz').then(function() {
    assertEquals('foo bar baz',
        document.getElementById('input').value);
  });
&lt;/script&gt;
</code></pre>

<h5>警告</h5>

<p>在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。</p>

<ul>
<li>webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。</li>
<li><p>webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):</p>

<p>  &lt;!DOCTYPE html>
  <script src="webdriver.js"></script>
  <script></p>

<pre><code>var testWindow = window.open('', 'slave');

var driver = new webdriver.Builder().build();
driver.switchTo().window('slave');
driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click(); 
</code></pre>

<p>  </script></p></li>
</ul>


<h4>调试 Tests</h4>

<p>你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。</p>

<pre><code>$ ./go selenium-server-standalone
$ java -jar \
    -Dwebdriver.server.session.timeout=0 \
    build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
</code></pre>

<p>启动服务后，访问 WebDriver 的控制面板： http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除 sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。</p>

<h5>支持的浏览器</h5>

<ul>
<li>IE 8+</li>
<li>Firefox 4+</li>
<li>Chrome 12+</li>
<li>Opera 12.0a+</li>
<li>Android 4.0+</li>
</ul>


<h2>设计细节</h2>

<h3>管理异步 API</h3>

<p>不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 <a href="http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw">Promise/A</a> 提议，它定义了 promise 是任意对象上的 then 函数属性。</p>

<pre><code>/**
 * Registers listeners for when this instance is resolved.
 *
 * @param {?function(*)} callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {?function(*)=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the failure
 *     reason. While this argument is typically an {@code Error}, any type is
 *     permissible.
 * @return {!Promise} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
Promise.prototype.then = function(callback, opt_errback) {
};
</code></pre>

<p>通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com').then(function() {
  return driver.findElement(webdriver.By.name('q')).then(function(searchBox){
    return searchBox.sendKeys('webdriver').then(function() {
      return driver.findElement(webdriver.By.name('btnG')).then(function(submitButton) {
        return submitButton.click().then(function() {
          return driver.getTitle().then(function(title) {
            assertEquals('webdriver - Google Search', title);
          });
        });
      });
    });
  });
});
</code></pre>

<p>不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。</p>

<p>简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com');

var searchBox = driver.findElement(webdriver.By.name('q'));
searchBox.sendKeys('webdriver');

var submitButton = driver.findElement(webdriver.By.name('btnG'));
submitButton.click();

driver.getTitle().then(function(title) {
  assertEquals('webdriver - Google Search', title);
});
</code></pre>

<h4>On Frames and Callbacks</h4>

<p>就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：</p>

<pre><code>driver.get(MY_APP_URL);
driver.getTitle().then(function(title) {
  if (title === 'Login page') {
    driver.findElement(webdriver.By.id('user')).sendKeys('bugs');
    driver.findElement(webdriver.By.id('pw')).sendKeys('bunny');
    driver.findElement(webdriver.By.id('login')).click();
  }
});
driver.findElement(webdriver.By.id('userPreferences')).click();
</code></pre>

<p>这个测试用例可以使用 WebDriver 的 Java API 重写如下：</p>

<pre><code>driver.get(MY_APP_URL);
if ("Login Page".equals(driver.getTitle())) {
  driver.findElement(By.id("user")).sendKeys("bugs");
  driver.findElement(By.id("pw")).sendKeys("bunny");
  driver.findElement(By.id("login")).click();
}
driver.findElement(By.id("userPreferences")).click();
</code></pre>

<h4>错误处理</h4>

<p>既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。</p>

<p>如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。</p>

<pre><code>// 注册一个事件监听未处理的错误
webdriver.promise.Application.
    getInstance().
    on('uncaughtException', function(e) {
      console.error('There was an uncaught exception: ' + e.message);
    });

driver.switchTo().window('foo').then(null, function(e) {
  // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡
  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {
    throw e;
  }
});
// 如果上面的错误不被抑制的话，这句将永远不会执行
driver.getTitle();
</code></pre>

<h3>同服务端通讯</h3>

<p>当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。</p>

<h4>Cross-Origin Resource Sharing</h4>

<p>如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。</p>

<pre><code>Access-Control-Origin: *
Access-Control-Allow-Methods: DELETE,GET,HEAD,POST
Access-Control-Allow-Headers: Accept,Content-Type
</code></pre>

<p>在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。</p>

<ul>
<li>IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。</li>
<li>WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。</li>
<li>如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。</li>
</ul>


<p>为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。</p>

<h4>/xdrpc</h4>

<p><strong>POST /xdrpc</strong></p>

<p>作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。</p>

<p><strong>参数：</strong></p>

<ul>
<li>method - {string} http 方法</li>
<li>path - {string} 命令路径</li>
<li>data - {Object} JSON 格式的命令参数</li>
</ul>


<p><strong>返回：</strong></p>

<p>{*} 命令执行的结果。</p>

<p>举个例子，考虑以下 /xdrpc 命令：</p>

<pre><code>POST /xdrpc HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 94

{"method":"POST","path":"/session/123/element/0a/element","data":{"using":"id","value":"foo"}}
</code></pre>

<p>服务端将编码这个命令并重新分发：</p>

<pre><code>POST /session/123/element/0a/element HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28

{"using":"id","value":"foo"}
</code></pre>

<p>不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 60

{"status":7,"value":{"message":"Unable to locate element."}}
</code></pre>

<h2>未来计划</h2>

<p>以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）</p>

<ul>
<li>使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。</li>
<li>基于扩展实现一个 SafariDriver。</li>
<li>为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:高级用户交互]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions</id>
    <content type="html"><![CDATA[<h3>AdvancedUserInteractions(高级用户交互)</h3>

<h3>入门</h3>

<p>高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。</p>

<h4>开始（short how to）</h4>

<p>为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：</p>

<pre><code>Actions builder = new Actions(driver);

builder.keyDown(Keys.CONTROL)
.click(someElement)
.click(someOtherElement)
.keyUp(Keys.CONTROL);
</code></pre>

<p>然后，获得操作（Action）:</p>

<pre><code>Action selectMultiple = builder.build();
</code></pre>

<p>最后，执行这个动作：</p>

<pre><code>selectMultiple.perform();   
</code></pre>

<p>这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。</p>

<!--more-->


<p></p>

<h4>键盘交互（Keyboard interactions）</h4>

<p>键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。 <br/>
既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（<code>Keys.TAB</code>）键。<br/>
The new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.</p>

<h4>鼠标交互（Mouse interactions）</h4>

<p>鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。</p>

<h3>支持情况</h3>

<p>这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。</p>

<h3>大纲</h3>

<h4>单个动作</h4>

<p>所有的动作都实现了<code>Action</code>接口，这个接口只有一个方法：<code>perform（）</code>。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。 <br/>
下面是一些动作：</p>

<ul>
<li>ButtonReleaseAction - 释放鼠标左键</li>
<li>ClickAction - 相当于 WebElement.click()</li>
<li>ClickAndHoldAction - 按下鼠标左键并保持</li>
<li>ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。</li>
<li>DoubleClickAction - 双击某个元素</li>
<li>KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）</li>
<li>KeyUpAction - 释放修饰键</li>
<li>MoveMouseAction - 移动鼠标从当前位置到另外的元素.</li>
<li>MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。</li>
<li>SendKeysAction - 相当于 WebElement.sendKey(&#8230;)</li>
</ul>


<p><code>CompositeAction</code>包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用<code>ActionChainsGenerator</code>。</p>

<h4>生成动作链</h4>

<p><code>Actions</code>链生成器实现了创建者模式来新建一个包含一组动作的<code>CompositeAction</code>。使用Actions生成器可以很容易的生成动作并调用<code>build（）</code>方法来获得复杂的操作。</p>

<pre><code>Actions builder = new Actions(driver);

Action dragAndDrop = builder.clickAndHold(someElement)
   .moveToElement(otherElement)
   .release(otherElement)
   .build();

dragAndDrop.perform();
</code></pre>

<p>有一个对<code>Actions</code>进行扩展的计划，给<code>Actions</code>类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展<code>Actions</code>,请往下看。</p>

<h4>扩展Action接口的指导</h4>

<p>Action接口只有一个方法-<code>perform()</code>。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。</p>

<h3>实现细节</h3>

<p>为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：<code>Mouse</code>和<code>Keyboard</code>。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。</p>

<h4>一字警告</h4>

<p><code>Keyboard</code>和<code>Mouse</code>接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。</p>

<h4>Keyboard接口</h4>

<p>Keyboard接口包含3个方法：</p>

<ul>
<li>void sendKeys(CharSequence&#8230; keysToSend) - 与 sendKeys(&#8230;)相似.</li>
<li>void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).</li>
<li>void releaseKey(Keys keyToRelease) - 释放修饰键.</li>
</ul>


<p>至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。</p>

<h4>Mouse接口</h4>

<p><code>Mouse</code>接口包含以下方法（有可能不久之后会有变化）：</p>

<ul>
<li>void click(WebElement onElement) - 同click()方法一样.</li>
<li>void doubleClick(WebElement onElement) - 双击一个元素.</li>
<li>void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持
Action selectMultiple = builder.build();</li>
<li>void mouseUp(WebElement onElement) - 在一个元素上释放左键.</li>
<li>void mouseMove(WebElement toElement) - 从当前位置移动到一个元素</li>
<li>void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标</li>
<li>void contextClick(WebElement onElement) - 在一个元素上做一个右键操作</li>
</ul>


<h4>Native events（原生事件） VS synthetic events（合成事件）</h4>

<p>WebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加<a href="https://code.google.com/p/selenium/wiki/NativeEventsOnLinux">native events on Linux</a>。原生事件无论什么时候总是应该尽可能的使用。</p>

<p>下面的表格展示了浏览器对事件的支持情况。</p>

<table border="1px">
<tr>
<td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td>
</tr>
<tr>
<td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td>
</tr>
<tr>
<td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td>
</tr>
<tr>
<td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td>
</tr>
<tr>
<td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
</table>


<p>*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。</p>

<p>FirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.setEnableNativeEvents(true);
FirefoxDriver driver = new FirefoxDriver(profile);
</code></pre>

<h5>例子</h5>

<p>以下是原生事件与合成事件表现不同的一些例子：</p>

<ul>
<li>使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。</li>
<li>当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。</li>
</ul>


<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/AdvancedUserInteractions">https://code.google.com/p/selenium/wiki/AdvancedUserInteractions</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium WebDriver]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-web-driver/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-web-driver</id>
    <content type="html"><![CDATA[<h1>Selenium WebDriver</h1>

<p>注意：本章内容官方团队正在完善中。</p>

<h2>介绍 WebDriver</h2>

<p>Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。</p>

<h2>同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？</h2>

<p>Selenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。</p>

<p>相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。</p>

<!--more-->


<h2>WebDriver 和 Selenium-Server</h2>

<p>你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。</p>

<p>在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：</p>

<ul>
<li>你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。</li>
<li>你希望连接一台远程的机器来测试一个特定的浏览器。</li>
<li>你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。</li>
</ul>


<h2>设置一个 Selenium-WebDriver 项目</h2>

<p>安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。</p>

<h3>Java</h3>

<p>创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。</p>

<p>首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;MySel20Proj&lt;/groupId&gt;
    &lt;artifactId&gt;MySel20Proj&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
            &lt;version&gt;2.28.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.opera&lt;/groupId&gt;
            &lt;artifactId&gt;operadriver&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.opera&lt;/groupId&gt;
                &lt;artifactId&gt;operadriver&lt;/artifactId&gt;
                &lt;version&gt;1.1&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
                        &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>

<p>确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 <a href="http://seleniumhq.org/download/maven.html">Maven 下载页面</a> 中的最新版本，并修改上述文件中依赖的版本。</p>

<p>命令行进入本目录，运行如下命令：</p>

<pre><code>mvn clean install
</code></pre>

<p>该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。</p>

<p>最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。</p>

<p><a href="http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference">Importing a maven project into IntelliJ IDEA</a></p>

<p><a href="http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference">Importing a maven project into Eclipse</a></p>

<h2>从 Selenium 1.0 迁移</h2>

<p>对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。</p>

<p><a href="http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference">Migrating From Selenium RC to Selenium WebDriver</a></p>

<h2>实例介绍 Selenium-WebDriver API</h2>

<p>WebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。</p>

<p>建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。</p>

<p><strong>注意：</strong> 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。</p>

<p>我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。</p>

<pre><code>package org.openqa.selenium.example;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.WebDriverWait;

public class Selenium2Example  {
    public static void main(String[] args) {
        // 创建了一个 Firefox driver 的实例
        // 注意，其余的代码依赖于接口而非实例
        WebDriver driver = new FirefoxDriver();

        // 使用它访问 Google
        driver.get("http://www.google.com");
        // 同样的事情也可以通过以下代码完成
        // driver.navigate().to("http://www.google.com");

        // 找到搜索输入框
        WebElement element = driver.findElement(By.name("q"));

        // 输入要查找的词
        element.sendKeys("Cheese!");

        // 提交表单
        element.submit();

        // 检查页面标题
        System.out.println("Page title is: " + driver.getTitle());

        // Google 搜索结果由 JavaScript 动态渲染
        // 等待页面加载完毕，超时时间设为10秒
        (new WebDriverWait(driver, 10)).until(new ExpectedCondition&lt;Boolean&gt;() {
            public Boolean apply(WebDriver d) {
                return d.getTitle().toLowerCase().startsWith("cheese!");
            }
        });

        //应该能看到: "cheese! - Google Search"
        System.out.println("Page title is: " + driver.getTitle());

        //关闭浏览器
        driver.quit();
    }
}
</code></pre>

<p>在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。</p>

<h2>Selenium-WebDriver API 和操作</h2>

<h3>获取一个页面</h3>

<p>访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：</p>

<pre><code>driver.get("http://www.google.com");
</code></pre>

<p>包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 <a href="http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference">Explicit and Implicit Waits</a> 等到页面元素可用。</p>

<h3>查找 UI 元素（web 元素）</h3>

<p>WebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。</p>

<p>“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：</p>

<h4>By id</h4>

<p>这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。</p>

<p>HTML:</p>

<pre><code>&lt;div id="coolestWidgetEvah"&gt;...&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement element = driver.findElement(By.id("coolestWidgetEvah"));
</code></pre>

<h4>By Class Name</h4>

<p>&#8220;class&#8221; 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。</p>

<p>HTML:</p>

<pre><code>&lt;div class="cheese"&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class="cheese"&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>List&lt;WebElement&gt; cheeses = driver.findElements(By.className("cheese"));
</code></pre>

<h4>By Tag Name</h4>

<p>根据元素标签名查找。</p>

<p>HTML:</p>

<pre><code>&lt;iframe src="..."&gt;&lt;/iframe&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement frame = driver.findElement(By.tagName("iframe"));
</code></pre>

<h4>By Name</h4>

<p>查找 name 属性匹配的表单元素。</p>

<p>HTML:</p>

<pre><code>&lt;input name="cheese" type="text"/&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.name("cheese"));
</code></pre>

<h4>By Link Text</h4>

<p>查找链接文字匹配的链接元素。</p>

<p>HTML：</p>

<pre><code>&lt;a href="http://www.google.com/search?q=cheese"&gt;cheese&lt;/a&gt;&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.linkText("cheese"));
</code></pre>

<h4>By Partial Link Text</h4>

<p>查找链接文字部分匹配的链接元素。</p>

<p>HTML:</p>

<pre><code>&lt;a href="http://www.google.com/search?q=cheese"&gt;search for cheese&lt;/a&gt;&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.partialLinkText("cheese"));
</code></pre>

<h4>By CSS</h4>

<p>正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 <a href="http://www.w3.org/TR/CSS/#selectors">css 选择器</a>。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。</p>

<p>注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。</p>

<p>HTML:</p>

<pre><code>&lt;div id="food"&gt;&lt;span class="dairy"&gt;milk&lt;/span&gt;&lt;span class="dairy aged"&gt;cheese&lt;/span&gt;&lt;/div&gt;
</code></pre>

<p>Java：</p>

<pre><code>WebElement cheese = driver.findElement(By.cssSelector("#food span.dairy.aged"));
</code></pre>

<h4>By XPATH</h4>

<p>此处略过不译</p>

<h3>用户输入 - 填充表单</h3>

<p>我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：</p>

<pre><code>WebElement select = driver.findElement(By.tagName("select"));
List&lt;WebElement&gt; allOptions = select.findElements(By.tagName("option"));
for (WebElement option : allOptions) {
    System.out.println(String.format("Value is: %s", option.getAttribute("value")));
    option.click();
}
</code></pre>

<p>上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver
有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。</p>

<pre><code>Select select = new Select(driver.findElement(By.tagName("select")));
select.deselectAll();
select.selectByVisibleText("Edam");
</code></pre>

<p>上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。</p>

<p>如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。</p>

<pre><code>driver.findElement(By.id("submit")).click();
</code></pre>

<p>或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。</p>

<pre><code>element.submit();
</code></pre>

<h3>在窗口和帧(frames)之间切换</h3>

<p>有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。</p>

<pre><code>driver.switchTo().window("windowName");
</code></pre>

<p>所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：</p>

<pre><code>&lt;a href="somewhere.html" target="windowName"&gt;Click here to open a new window&lt;/a&gt;
</code></pre>

<p>你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：</p>

<p>   for (String handle : driver.getWindowHandles()) {</p>

<pre><code>    driver.switchTo().window(handle);
}
</code></pre>

<p>你也可以切换到指定帧：</p>

<pre><code>driver.switchTo().frame("frameName");
</code></pre>

<p>你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：</p>

<pre><code>driver.switchTo().frame("frameName.0.child");
</code></pre>

<p>该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 <strong>top</strong> 开始。</p>

<h3>弹出框</h3>

<p>由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：</p>

<pre><code>Alert alert = driver.switchTo().alert();
</code></pre>

<p>该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。</p>

<h3>导航：历史记录和位置</h3>

<p>更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(&#8220;http://www.example.com&#8221;))。正如你所见，WebDriver 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：</p>

<pre><code>driver.navigate().to("http://www.example.com");
</code></pre>

<p>重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。</p>

<p>“navigate” 接口暴露了访问浏览器历史记录的接口：</p>

<pre><code>driver.navigate().forward();
driver.navigate().back();
</code></pre>

<p>需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。</p>

<h3>Cookies</h3>

<p>在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (http://example.com/some404page)。</p>

<pre><code>// 进到正确的域
driver.get("http://www.example.com");

// 设置 cookie，这个cookie 对整个域都有效
Cookie cookie = new Cookie("key", "value");
driver.manage().addCookie(cookie);

// 输出当前 url 所有可用的 cookie
Set&lt;Cookie&gt; allCookies = driver.manage().getCookies();
for (Cookie loadedCookie : allCookies) {
    System.out.println(String.format("%s -&gt; %s", loadedCookie.getName(), loadedCookie.getValue()));
}

// 你可以通过3中方式删除 cookie
// By name
driver.manage().deleteCookieNamed("CookieName");
// By Cookie
driver.manage().deleteCookie(loadedCookie);
// Or all of them
driver.manage().deleteAllCookies();
</code></pre>

<h3>改变 UA</h3>

<p>当使用 Firefox Driver 的时候这很容易：</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.addAdditionalPreference("general.useragent.override", "some UA string");
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h3>拖拽</h3>

<p>以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：</p>

<pre><code>WebElement element = driver.findElement(By.name("source"));
WebElement target = driver.findElement(By.name("target"));

(new Actions(driver)).dragAndDrop(element, target).perform();
</code></pre>

<h2>Driver 特性和权衡</h2>

<h2>Selenium-WebDriver’s Drivers</h2>

<p>WebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：</p>

<h3>HtmlUnit Driver</h3>

<p>这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new HtmlUnitDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>WebDriver 最快速的实现</li>
<li>纯 Java 实现，跨平台</li>
<li>支持 JavaScript</li>
</ul>


<h4>劣势</h4>

<ul>
<li>需要模拟浏览器中 JavaScript 的行为（如下）。</li>
</ul>


<h4>JavaScript in the HtmlUnit Driver</h4>

<p>没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。</p>

<p>当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。</p>

<p>使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。</p>

<h5>启用 JavaScript</h5>

<p>启用 JavaScript 也非常简单：</p>

<pre><code>HtmlUnitDriver driver = new HtmlUnitDriver(true);
</code></pre>

<p>上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。</p>

<h3>Firefox Driver</h3>

<p>我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（<a href="http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55">see the source to see which ones</a>）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new FirefoxDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>在真实的浏览器里运行，且支持 JavaScript</li>
<li>比 IE Driver 快</li>
</ul>


<h4>劣势</h4>

<ul>
<li>比 HtmlUnit Driver 慢</li>
<li>需要修改 Firefox 配置</li>
</ul>


<p>例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：</p>

<pre><code>ProfilesIni allProfiles = new ProfilesIni();
FirefoxProfile profile = allProfiles.getProfile("WebDriver");
profile.setPreferences("foo.bar", 23);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<p>如果配置文件没有注册至 Firefox：</p>

<pre><code>File profileDir = new File("path/to/top/level/of/profile");
FirefoxProfile profile = new FirefoxProfile(profileDir);
profile.addAdditionalPreferences(extraPrefs);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<p>当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.setEnableNativeEvents(true);
WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h4>信息</h4>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/FirefoxDriver">Firefox section in the wiki page</a> 以获得更多新鲜信息。</p>

<h3>Internet Explorer Driver</h3>

<p>这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new InternetExplorerDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>显然它只在 Windows 系统上有效。</li>
<li>相对较慢。</li>
<li>Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。</li>
<li>IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。</li>
<li>IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.</li>
</ul>


<h4>信息</h4>

<p>访问 <a href="http://code.google.com/p/selenium/wiki/InternetExplorerDriver">Internet Explorer section of the wiki page</a> 以获得更多新鲜信息。特别注意配置部分的内容。</p>

<h3>Chrome Driver</h3>

<p>Chrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 以获得更多信息。</p>

<h4>使用</h4>

<pre><code>WebDriver driver = new ChromeDriver();
</code></pre>

<h4>优势</h4>

<ul>
<li>运行在真实的浏览器中，并且支持 JavaScript。</li>
<li>由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>比 HtmlUnit 慢</li>
</ul>


<h4>信息</h4>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 以获得更多最新信息。更多信息可以在 <a href="http://seleniumhq.org/download/">下载页面</a> 找到。</p>

<h4>运行 Chrome Driver</h4>

<p>下载 <a href="http://code.google.com/p/chromium/downloads/list">Chrome Driver</a> 并参考 <a href="http://code.google.com/p/selenium/wiki/ChromeDriver">wiki</a> 上的其他建议。</p>

<h3>Opera Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/OperaDriver">wiki</a></p>

<h3>iPhone Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/IPhoneDriver">wiki</a></p>

<h3>Android Driver</h3>

<p>查看 <a href="http://code.google.com/p/selenium/wiki/AndroidDriver">wiki</a></p>

<h2>可选择的后端：混合 WebDriver 和 RC 技术</h2>

<h3>WebDriver-Backed Selenium-RC</h3>

<p>Java 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。</p>

<p>Selenium-WebDriver 的用法如下：</p>

<pre><code>// 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。
WebDriver driver = new FirefoxDriver();

// 基准 url，selenium 用于解析相对路径。
 String baseUrl = "http://www.google.com";

// 创建一个 Selenium 实现。
Selenium selenium = new WebDriverBackedSelenium(driver, baseUrl);

// 使用 selenium 进行一些操作。
selenium.open("http://www.google.com");
selenium.type("name=q", "cheese");
selenium.click("name=btnG");

// Get the underlying WebDriver implementation back. This will refer to the
// same WebDriver instance as the "driver" variable above.
WebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();

// 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。
// 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。
selenium.stop();
</code></pre>

<h4>优势</h4>

<ul>
<li>允许 WebDriver 和 Selenium API 并存。</li>
<li>提供了简单的机制从 Selenium RC API 迁移至 WebDriver。</li>
<li>不需要运行 Selenium RC server。</li>
</ul>


<h4>劣势</h4>

<ul>
<li>没有实现所有的方法。</li>
<li>一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。</li>
<li>由于底层的实现，有些方法会比较慢。</li>
</ul>


<h3>Backing WebDriver with Selenium</h3>

<p>WebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。</p>

<p>通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：</p>

<pre><code>DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setBrowserName("safari");
CommandExecutor executor = new SeleneseCommandExecutor(new URL("http://localhost:4444/"), new URL("http://www.google.com/"), capabilities);
WebDriver driver = new RemoteWebDriver(executor, capabilities);
</code></pre>

<p>这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。</p>

<h2>运行 Selenium Server 以使用 RemoteDrivers¶</h2>

<p>从 <a href="https://code.google.com/p/selenium/downloads/list">Selenium 下载页面</a> 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 <a href="http://chromedriver.googlecode.com/">google code</a> 下载它。</p>

<p>把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。</p>

<p>从命令行启动服务：</p>

<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar
</code></pre>

<p>如果你希望使用本地事件功能，在命令行添加以下参数：</p>

<pre><code>-Dwebdriver.enable.native.events=1
</code></pre>

<p>查看帮助：</p>

<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar -help
</code></pre>

<p>为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。</p>

<h2>更多资源</h2>

<p>你可以在 <a href="http://code.google.com/p/selenium/wiki/FurtherResources">WebDriver wiki</a> 找到更多有用的资源。</p>

<p>当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：http://groups.google.com/group/selenium-users。</p>

<h2>接下来</h2>

<p>本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium RC]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-rc/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-rc</id>
    <content type="html"><![CDATA[<h1>Selenium 1 (Selenium RC)¶</h1>

<h2>介绍</h2>

<p>正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。</p>

<p>Selenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。</p>

<h2>Selenium RC 如何工作</h2>

<p>首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。</p>

<h3>RC 组件</h3>

<p>Selenium RC 组件是：</p>

<p>Selenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。</p>

<!--more-->


<p>客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。</p>

<p>以下是一个简单的架构图：</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png" alt="架构图" /></p>

<p>上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。</p>

<h3>Selenium 服务端</h3>

<p>Selenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。</p>

<p>RC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。</p>

<p>Server 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。</p>

<h3>客户端库</h3>

<p>客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。</p>

<p>客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。</p>

<p>因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。</p>

<h2>安装</h2>

<p>用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。</p>

<p>一旦你选定了一种编程语言，你仅需要：</p>

<ul>
<li>安装 Selenium RC 服务端。</li>
<li>使用特定于该语言的客户端驱动创建你的项目</li>
</ul>


<h3>安装 Selenium 服务端</h3>

<p>Selenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。</p>

<h3>运行 Selenium 服务</h3>

<p>在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar
</code></pre>

<p>你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。</p>

<p>要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：</p>

<pre><code>java -version
</code></pre>

<p>如果你得到一个版本号（必须>=1.5），那么你已经成功启动 Selenium RC。</p>

<h3>使用 Java 客户端驱动</h3>

<ul>
<li>从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。</li>
<li>提取 selenium-java-<version-number>.jar</li>
<li>打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)</li>
<li>创建一个 java 项目。</li>
<li>将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。</li>
<li>将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。</li>
<li>从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。</li>
<li>从命令行运行 Selenium 服务。</li>
<li>从 Java IDE 或者命令行中执行你的测试。</li>
</ul>


<p>关于更多 Java 测试项目的配置细节，可查看本章附件：<strong>在 Eclipse 中配置 Selenium RC</strong> 和 <strong>在 Intellij 中配置 Selenium RC</strong>。</p>

<h2>将 Selenese 转换成程序</h2>

<p>使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。</p>

<h3>测试脚本范例</h3>

<p>让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：</p>

<table>
    <tbody>
        <tr>
            <td>open</td>
            <td>/</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium rc</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium rc</td>
            <td>&nbsp;</td>
        </tr>
    </tbody>
</table>


<p>注意: 这个例子仅仅在 Google 搜索页面 http://www.google.com 工作。</p>

<h2>Selenese 作为编程代码</h2>

<p>以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。</p>

<pre><code>/** Add JUnit framework to your classpath if not already there
 *  for this example to work
 */
package com.example.tests;

import com.thoughtworks.selenium.*;
import java.util.regex.Pattern;

public class NewTest extends SeleneseTestCase {
    public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
    }
      public void testNew() throws Exception {
          selenium.open("/");
          selenium.type("q", "selenium rc");
          selenium.click("btnG");
          selenium.waitForPageToLoad("30000");
          assertTrue(selenium.isTextPresent("Results * for selenium rc"));
    }
}
</code></pre>

<p>在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。</p>

<h2>编写你的测试代码</h2>

<p>现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：</p>

<ul>
<li>从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。</li>
<li>编写一个 main() 方法来执行创建的代码。</li>
</ul>


<p>你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。</p>

<p>这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。</p>

<h3>Java</h3>

<p>在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。</p>

<p>你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。</p>

<pre><code>selenium = new DefaultSelenium("localhost", 4444, "*iehta", "http://www.google.com/");
</code></pre>

<p>使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。</p>

<pre><code>package com.example.tests;
// 我们指定了这个文件的包

import com.thoughtworks.selenium.*;
// 导入驱动。
// 你将使用它来初始化浏览器并执行一些任务。

import java.util.regex.Pattern;
// 加入正则表达式模块，因为有些我们需要使用它进行校验。
// 如果你的代码不需要它，完全可以移除掉。 

public class NewTest extends SeleneseTestCase {
// 创建 Selenium 测试用例

      public void setUp() throws Exception {
        setUp("http://www.google.com/", "*firefox");
             // 初始化并启动浏览器
      }

      public void testNew() throws Exception {
           selenium.open("/");
           selenium.type("q", "selenium rc");
           selenium.click("btnG");
           selenium.waitForPageToLoad("30000");
           assertTrue(selenium.isTextPresent("Results * for selenium rc"));
           // 以上为真实的测试步骤
     }
}
</code></pre>

<h2>学习使用 API</h2>

<p>Selenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。</p>

<h3>启动浏览器</h3>

<pre><code>setUp("http://www.google.com/", "*firefox");
</code></pre>

<p>每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。</p>

<p>创建浏览器对象所需要的参数如下：</p>

<h4>host</h4>

<p>指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。</p>

<h4>port</h4>

<p>指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。</p>

<h4>browser</h4>

<p>指定你希望运行测试的浏览器。该参数必选。</p>

<h4>url</h4>

<p>AUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。</p>

<p>注意，有些客户端要求调用 start() 方法来启动浏览器。</p>

<h3>运行 命令</h3>

<p>一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 &#8220;Selenium&#8221;），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：</p>

<pre><code>selenium.type(“field-id”,”string to type”)
</code></pre>

<p>此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。</p>

<h2>报告结果</h2>

<p>Selenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。</p>

<h3>测试框架报告工具</h3>

<p>很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。</p>

<p>我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。</p>

<h3>测试报告库</h3>

<p>同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。</p>

<h3>最佳实践是？</h3>

<p>大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。</p>

<h3>测试报告范例</h3>

<p>为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。</p>

<h4>Java 中的测试报告</h4>

<ul>
<li>如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 <a href="http://ant.apache.org/manual/Tasks/junitreport.html">JUnit 报告</a> 。</li>
<li>如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 <a href="http://testng.org/doc/documentation-main.html#test-results">TestNG 报告</a> 。</li>
<li>ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 <a href="http://reportng.uncommons.org/">TestNG</a></li>
<li><p>同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：</p>

<p>  <img src="http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png" alt="TestNG-xslt" /></p>

<p>  了解更多 <a href="">TestNG-xslt</a></p></li>
</ul>


<h5>记录 Selenese 命令</h5>

<p>Logging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 <a href="http://loggingselenium.sourceforge.net/index.html">Logging Selenium</a></p>

<h2>为你的测试加点料</h2>

<p>现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。</p>

<p>当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。</p>

<p>本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。</p>

<h3>迭代</h3>

<p>迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。</p>

<p>使用同之前一样的 <a href="http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example">Google 搜索例子</a>，让我们来检查搜索结果。这个测试将使用 Selenese：</p>

<table>
    <tbody>
        <tr>
            <td>open</td>
            <td>/</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium rc</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium rc</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium ide</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium ide</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>type</td>
            <td>q</td>
            <td>selenium grid</td>
        </tr>
        <tr>
            <td>clickAndWait</td>
            <td>btnG</td>
            <td>&nbsp;</td>
        </tr>
        <tr>
            <td>assertTextPresent</td>
            <td>Results * for selenium grid</td>
            <td>&nbsp;</td>
        </tr>
    </tbody>
</table>


<p>同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。</p>

<h3>In Csharp</h3>

<pre><code>// Collection of String values.
String[] arr = {"ide", "rc", "grid"};

// Execute loop for each String in array 'arr'.
foreach (String s in arr) {
    sel.open("/");
    sel.type("q", "selenium " +s);
    sel.click("btnG");
    sel.waitForPageToLoad("30000");
    assertTrue("Expected text: " +s+ " is missing on page."
    , sel.isTextPresent("Results * for selenium " + s));
}
</code></pre>

<h3>条件语句</h3>

<p>我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：</p>

<pre><code>// Java
selenium.type("q", "selenium " +s);
</code></pre>

<p>如果元素“q”不在页面上将会抛出一个异常：</p>

<pre><code>com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found
</code></pre>

<p>这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。</p>

<p>一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：</p>

<pre><code>// 如果元素可用，则则行类型判定操作
if(selenium.isElementPresent("q")) {
    selenium.type("q", "Selenium rc");
} else {
    System.out.printf("Element: " +q+ " is not available on page.")
}
</code></pre>

<p>这样做的好处是，即使页面上没有这个元素测试也能够继续执行。</p>

<h3>在你的测试中执行 JavaScript</h3>

<p>在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。</p>

<p>考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。</p>

<pre><code>// Java
public static String[] getAllCheckboxIds () {
     String script = "var inputId  = new Array();";// Create array in java script.
            script += "var cnt = 0;"; // Counter for check box ids.
            script += "var inputFields  = new Array();"; // Create array in java script.
            script += "inputFields = window.document.getElementsByTagName('input');"; // Collect input elements.
            script += "for(var i=0; i&lt;inputFields.length; i++) {"; // Loop through the collected elements.
            script += "if(inputFields[i].id !=null " +
                      "&amp;&amp; inputFields[i].id !='undefined' " +
                      "&amp;&amp; inputFields[i].getAttribute('type') == 'checkbox') {"; // If input field is of type check box and input id is not null.
            script += "inputId[cnt]=inputFields[i].id ;" + // Save check box id to inputId array.
                      "cnt++;" + // increment the counter.
                      "}" + // end of if.
                      "}"; // end of for.
            script += "inputId.toString();" ;// Convert array in to string.
     String[] checkboxIds = selenium.getEval(script).split(","); // Split the string.
     return checkboxIds;
 }
</code></pre>

<p>如果要计算页面中的图片数，你可以：</p>

<pre><code>// Java
selenium.getEval("window.document.images.length;");
</code></pre>

<p>记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。</p>

<h2>服务端选项</h2>

<p>当服务启动时，可以使用命令行配置项来改变其默认行为。</p>

<p>回想一下，我们是这样启动服务的：</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar
</code></pre>

<p>你可以使用 -h 来查看所有的配置项：</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -h
</code></pre>

<p>你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。</p>

<h3>代理配置</h3>

<p>如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。</p>

<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password
</code></pre>

<h3>多窗口模式</h3>

<p>如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png" alt="multi-window" /></p>

<p>有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png" alt="multi-window2" /></p>

<p>对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：</p>

<pre><code>-multiwindow
</code></pre>

<p>在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：</p>

<pre><code>-singlewindow
</code></pre>

<h3>指定 Firefox 配置</h3>

<p>Firefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。</p>

<p>首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：</p>

<pre><code>firefox.exe -profilemanager

firefox.exe -P
</code></pre>

<p>使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。</p>

<pre><code>-firefoxProfileTemplate "path to the profile"
</code></pre>

<p><strong>警告</strong></p>

<p>确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。</p>

<p>更多请参考 <a href="http://support.mozilla.com/zh-CN/kb/Managing+profiles">Mozilla’s Knowledge Base</a></p>

<h3>通过 -htmlSuite 配置项在服务端直接运行 Selenese</h3>

<p>通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -htmlSuite "*firefox"
"http://www.google.com" "c:\absolute\path\to\my\HTMLSuite.html"
"c:\absolute\path\to\my\results.html"
</code></pre>

<p>这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。</p>

<p><strong>注意</strong></p>

<p>在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。</p>

<p>这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。</p>

<h3>Selenium 服务日志</h3>

<h4>服务端日志</h4>

<p>当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -log selenium.log
</code></pre>

<p>这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：</p>

<pre><code>20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -
Browser 465828/:top frame1 posted START NEW
</code></pre>

<p>该信息格式为：</p>

<pre><code>TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE
</code></pre>

<h4>浏览器端日志</h4>

<p>在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。</p>

<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -browserSideLog
</code></pre>

<p>为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。</p>

<h3>指定特定浏览器路径</h3>

<p>你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：</p>

<pre><code>*custom &lt;path to browser&gt;
</code></pre>

<h2>Selenium RC 架构</h2>

<p><strong>注意</strong></p>

<p>该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。</p>

<p>为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 <a href="http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy">同源策略</a>。</p>

<h3>同源策略</h3>

<p>Selenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。</p>

<p>为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。</p>

<p>之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。</p>

<p><strong>注意</strong></p>

<p>你可以在维基百科上找到更多关于 <a href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略</a> 和 <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> 的内容</p>

<h3>代理注入</h3>

<p>Selenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。</p>

<ol>
<li>代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。</li>
<li>浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：</li>
</ol>


<p><img src="http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png" alt="proxy" /></p>

<p>当测试开始时，将发生以下事情：</p>

<ol>
<li>客户端驱动将和 Selenium RC 服务端建立一个连接。</li>
<li>Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。</li>
<li>客户端驱动向服务端传递一个 Selenese 命令。</li>
<li>服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。</li>
<li>Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。</li>
<li>浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）</li>
<li>Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）</li>
<li>浏览器接收到这个页面并且渲染到相应的帧或者窗口。</li>
</ol>


<h3>高特权浏览器（Heightened Privileges Browsers）</h3>

<p>这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。</p>

<p>结构图如下：</p>

<p><img src="http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png" alt="Heightened Privileges Browsers" /></p>

<p>此时，将发生以下事情：</p>

<ol>
<li>客户端驱动和 Selenium RC 服务端建立一个连接。</li>
<li>Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。</li>
<li>Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。</li>
<li>Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。</li>
<li>浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。</li>
</ol>


<h2>处理 HTTPS 和安全警告弹出框</h2>

<p>当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。</p>

<p>为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。</p>

<p>当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。</p>

<p>在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 <em>firefox 和 </em>iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 <em>chrome 和 </em>iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。</p>

<p>在版本1中，推荐运行 <em>firefox 和 </em>iexplore 运行模式。然而，我们还提供 <em>iexploreproxy 和 </em>firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。</p>

<p>在 Selenium RC 的早期版本中，<em>chrome 或 </em>iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。</p>

<h3>关于安全证书</h3>

<p>通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。</p>

<p>为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。</p>

<p>另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。</p>

<h2>更多浏览器支持和相关配置</h2>

<p>Selenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”<em>custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 </em>firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。</p>

<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\Program Files\Mozilla Firefox\MyBrowser.exe&amp;2=http://www.google.com
</code></pre>

<h3>使用不同的浏览器配置来运行测试</h3>

<p>通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。</p>

<p>例如，你使用如下自定义配置启动 Firefox：</p>

<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\Program Files\Mozilla Firefox\firefox.exe&amp;2=http://www.google.com
</code></pre>

<p>注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。</p>

<p>注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。</p>

<h2>常见问题</h2>

<p><strong>译者注：</strong>这部分内容不翻译了，请参考原英文文档。</p>

<ul>
<li>Unable to Connect to Server</li>
<li>Unable to Load the Browser</li>
<li>Selenium Cannot Find the AUT</li>
<li>Firefox Refused Shutdown While Preparing a Profile</li>
<li>Versioning Problems</li>
<li>Error message: “(Unsupported major.minor version 49.0)” while starting server</li>
<li>404 error when running the getNewBrowserSession command</li>
<li>Permission Denied Error</li>
<li>Handling Browser Popup Windows</li>
<li>On Linux, why isn’t my Firefox browser session closing?</li>
<li>Firefox *chrome doesn’t work with custom profile</li>
<li>Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?</li>
<li>Problems With Verify Commands</li>
<li>Safari and MultiWindow Mode</li>
<li>Firefox on Linux</li>
<li>IE and Style Attributes</li>
<li>Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser</li>
<li>Where can I Ask Questions that Aren’t Answered Here?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium文档:selenium Grid]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-grid/"/>
    <updated>2013-05-30T19:55:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-selenium-grid</id>
    <content type="html"><![CDATA[<h1>Selenium Grid</h1>

<h2>快速上手</h2>

<p>如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 <a href="http://code.google.com/p/selenium/wiki/Grid2">Selenium Wiki</a> 的相关文章。</p>

<h2>什么是 Selenium-Grid ?</h2>

<p>Selenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。</p>

<!--more-->


<h2>何时需要使用</h2>

<p>通常，以下两种情况你都会需要使用 Selenium-Grid。</p>

<ul>
<li>在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。</li>
<li>减少测试运行时间。</li>
</ul>


<p>Selenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。</p>

<p>Selenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。</p>

<p>另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。</p>

<p>Selenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。</p>

<h2>Selenium-Grid 2.0</h2>

<p>Selenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。</p>

<h2>Selenium-Grid 1.0</h2>

<p>版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 <a href="http://selenium-grid.seleniumhq.org/">Selenium-Grid website</a></p>

<h2>Selenium-Grid 的 Hub 和 Nodes 是如何工作的？</h2>

<p>Grid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。</p>

<p>中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。</p>

<p>我们提供了一些<a href="http://selenium-grid.seleniumhq.org/how_it_works.html">图标</a>来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。</p>

<h2>下载</h2>

<p>下载过程很简单。从 SeleniumHq 站点的<a href="http://docs.seleniumhq.org/download/">下载页面</a>下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。</p>

<p>将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。</p>

<h2>启动 Selenium-Grid</h2>

<p>由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。</p>

<h3>启动中心</h3>

<p>通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub
</code></pre>

<p>我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。</p>

<h3>启动节点</h3>

<p>通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register
</code></pre>

<p>该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。</p>

<p><strong>警告：</strong> 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。</p>

<h2>配置 Selenium-Grid</h2>

<h3>默认配置</h3>

<h3>JSON 配置文件</h3>

<h3>通过命令行选项配置</h3>

<h2>中心配置</h2>

<p>通过指定 <code>-role hub</code> 即以默认设置启动中心：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub
</code></pre>

<p>你将看到以下日志输出：</p>

<pre><code>Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main
INFO: Launching a selenium grid server
2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT
2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}
2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444
</code></pre>

<h3>指定端口</h3>

<p>中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：</p>

<pre><code>10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444
Exception in thread "main" java.net.BindException: Selenium is already running on port 4444. Or some other service is.
</code></pre>

<p>如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。<code>-port</code> 选项用于修改中心的端口：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441
</code></pre>

<p>即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。</p>

<p>你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：</p>

<pre><code>netstat -a
</code></pre>

<p>Unix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。</p>

<h2>节点配置</h2>

<h2>时间参数</h2>

<h2>获取命令行帮助</h2>

<p>Selenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。</p>

<p>Selenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。</p>

<p>如果你仅传递一个 <code>-h</code> 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -h
</code></pre>

<p>上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 <code>-hub</code> 或 <code>-node</code> 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 <code>-h</code> 选项。</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node -h
</code></pre>

<p>对于这个问题，你还可以给 <code>-role node</code> 传递一个垃圾参数：</p>

<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node xx
</code></pre>

<p>你将先看到 “INFO&#8230;” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：</p>

<pre><code>Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main
INFO: Launching a selenium grid node
org.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444
        at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)
        at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)
        at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)
Error building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444
Usage :
  -hubConfig:
        (hub) a JSON file following grid2 format.

 -nodeTimeout:
        (node) &lt;XXXX&gt;  the timeout in seconds before the hub
          automatically ends a test that hasn't had aby activity than XX
          sec.The browser will be released for another test to use.This
          typically takes care of the client crashes.
</code></pre>

<h2>常见错误</h2>

<h3>Unable to acess the jarfile</h3>

<p>Unable to access jarfile selenium-server-standalone-2.21.0.jar</p>

<p>无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium 文档:入门介绍]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-introduction/"/>
    <updated>2013-05-30T19:54:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-doc-introduction</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<h2>用于网站应用的测试自动化</h2>

<p>如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。</p>

<p>测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。</p>

<p>本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。</p>

<p>对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：</p>

<ul>
<li>频繁的回归测试</li>
<li>快速反馈</li>
<li>几乎无限制的测试用例迭代执行</li>
<li>支持敏捷和极限编程</li>
<li>遵循测试用例的文档</li>
<li>自定义缺陷报告</li>
<li>能找出手工测试中没发现的缺陷</li>
</ul>


<!--more-->


<h2>自动化？或不自动化？</h2>

<p>自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？</p>

<p>自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。</p>

<h2>介绍 Selenium</h2>

<p>Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。</p>

<h2>Selenium 项目简史</h2>

<p>Selenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。</p>

<p>Selenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。</p>

<p>在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。</p>

<p>跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：</p>

<blockquote><p>为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。</p></blockquote>

<h2>Selenium 工具集</h2>

<p>Selenium 由多个软件工具组成，每个具备特定的功能。</p>

<h3>Selenium 2 (又叫 Selenium Webdriver)</h3>

<p>Selenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。</p>

<p>正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。</p>

<p>Selenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。</p>

<h3>Selenium 1 (又叫 Selenium RC 或 Remote Control)</h3>

<p>正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.</p>

<p>Seleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。</p>

<h3>Selenium IDE</h3>

<p>Selenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。</p>

<p><strong>注意</strong></p>

<p>虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.</p>

<h3>Selenium-Grid</h3>

<p>Selenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。</p>

<h2>选择合适你的 Selenium 工具</h2>

<p>很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。</p>

<p>但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。</p>

<p>在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。</p>

<p>我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。</p>

<h2>支持的浏览器和平台</h2>

<p>在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。</p>

<h3>Selenium-WebDriver</h3>

<p>Selenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。</p>

<ul>
<li>Google Chrome 12.0.712.0+</li>
<li>Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable</li>
<li>Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7</li>
<li>Opera 11.5+</li>
<li>HtmlUnit 2.9</li>
<li>Android – 2.3+ for phones and tablets (devices &amp; emulators)</li>
<li>iOS 3+ for phones (devices &amp; emulators) and 3.2+ for tablets (devices &amp; emulators)</li>
</ul>


<p><strong>注意：</strong></p>

<p>在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。</p>

<h3>Selenium 1.0 and Selenium-RC</h3>

<p>这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。</p>

<table border="1">
    <tbody>
    <tr>
        <td><strong>Browser</strong></td>
        <td><strong>Selenium IDE</strong></td>
        <td><strong>Selenium 1 (RC)</strong></td>
        <td><strong>Operating Systems</strong></td>
    </tr>
    <tr>
        <td>Firefox 3.x</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Firefox 3</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Firefox 2</td>
        <td>Record and playback tests</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>IE 8</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>IE 7</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>IE 6</td>
        <td>Test execution only via Selenium RC*</td>
        <td>Start browser, run tests</td>
        <td>Windows</td>
    </tr>
    <tr>
        <td>Safari 4</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Safari 3</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Safari 2</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Mac</td>
    </tr>
    <tr>
        <td>Opera 10</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Opera 9</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Opera 8</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Google Chrome</td>
        <td>Test execution only via Selenium RC</td>
        <td>Start browser, run tests</td>
        <td>Windows, Linux, Mac</td>
    </tr>
    <tr>
        <td>Others</td>
        <td>Test execution only via Selenium RC</td>
        <td>Partial support possible**</td>
        <td>As applicable</td>
    </tr>
    </tbody>
</table>


<p>* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。</p>

<p>** Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。</p>

<h2>灵活性和可扩展性</h2>

<p>你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。</p>

<h2>本文档包含哪些内容？</h2>

<p>本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。</p>

<p>剩下的章节将讲述以下内容:</p>

<h3>Selenium IDE</h3>

<p>介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。</p>

<h3>Selenium 2</h3>

<p>解释如何通过 Selenium 2 创建自动化测试项目。</p>

<h3>Selenium 1</h3>

<p>解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。</p>

<h3>测试设计</h3>

<p>这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。</p>

<h3>Selenium-Grid</h3>

<p>这部分内容未完成。</p>

<h3>User extensions</h3>

<p>讲述如何修改、扩展和定制 Selenium。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Maven Archetype来生成项目框架]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/21/use-maven-archetype-to-generate-project-architecture/"/>
    <updated>2013-05-21T16:36:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/21/use-maven-archetype-to-generate-project-architecture</id>
    <content type="html"><![CDATA[<h3>Maven in 5 Minutes</h3>

<p><a href="http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">maven官方文档</a>的入门章节就介绍了如何创建一个maven项目。大致如下：</p>

<pre><code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     
</code></pre>

<p>我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？  <br/>
其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。</p>

<!--more-->


<h3>Maven Archetype Plugin</h3>

<p>我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。  <br/>
Maven Archetype Plugin有4个Goal:</p>

<ul>
<li>archetype:create 已过时，用于从archetype创建maven project</li>
<li>archetype:generate  替代create,并且可以用交互的模式</li>
<li>archetype:create-from-project 依据存在的project 创建archetype</li>
<li>archetype:crawl 查找repo里存在的archetypes并更新目录。</li>
</ul>


<h3>实战演练一把</h3>

<p>假设我们已经有了一个项目名叫seleniumframework-start: <br/>
进入到这个工程的根目录，首先执行：</p>

<pre><code>mvn clean archetype:create-from-project
</code></pre>

<p>这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.baidu.selenium.archetypes&lt;/groupId&gt;
  &lt;artifactId&gt;seleniumframework-start-archetype&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;packaging&gt;maven-archetype&lt;/packaging&gt;

  &lt;name&gt;seleniumframework-start-archetype&lt;/name&gt;

  &lt;build&gt;
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.apache.maven.archetype&lt;/groupId&gt;
        &lt;artifactId&gt;archetype-packaging&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;

    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<p>这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：</p>

<ul>
<li>${groupId}</li>
<li>${artifactId}</li>
<li>${version}</li>
<li>${package}</li>
</ul>


<p>找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的<code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>转为了<code>&lt;?xml version="${version}" encoding="UTF-8"?&gt;^</code>。这并不是我们想要的，<code>${version}</code>是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：</p>

<pre><code>mvn clean install
</code></pre>

<p>这样，这个archetype就安装到了local repository。
如何使用呢？咱们试试。</p>

<pre><code>mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes -DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0
</code></pre>

<p>其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。<br/>
此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《HTTP权威指南》读书笔记1]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes/"/>
    <updated>2013-05-15T16:53:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/15/http-the-definitive-guide-reading-notes</id>
    <content type="html"><![CDATA[<h3>URL语法</h3>

<p>完整的URL是建立在由以下9个部分构成的通用格式上的。</p>

<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;   
</code></pre>

<p>其中各个部分代表：</p>

<ul>
<li>scheme(方案)：使用的哪种协议;默认无</li>
<li>user（用户）：用户名；默认匿名</li>
<li>password(密码)：密码</li>
<li>host(主机)：服务器主机名或点分IP地址</li>
<li>port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80</li>
<li>path(路径)：/分割的资源路径</li>
<li>params(参数)：名/值对，使用；分割。</li>
<li>query（查询）：名=值对，用&amp;分割多个</li>
<li>frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。</li>
</ul>


<!--more-->


<h3>HTTP报文格式</h3>

<h4>1.请求报文（request message）</h4>

<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>GET /images/blog/qunit-pic.png HTTP/1.0
Host: www.shenyanchao.cn
</code></pre>

<h4>2.响应报文（request message）</h4>

<pre><code>&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre>

<p>例如：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: image/png
Content-Length: 18107
</code></pre>

<p>以上报文格式中，各个部分的描述如下：</p>

<ul>
<li>method（方法）：希望服务器对资源执行的动作。如GET，POST等。</li>
<li>request-URL（请求的URL）：要请求的资源。</li>
<li>version（版本）：报文使用的HTTP协议版本。</li>
<li>status-code(状态码)：描述了请求过程中的状态。</li>
<li>reason-phrase（原因短语）：状态码的可读版本。</li>
<li>header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。</li>
<li>entity-body（实体的主题部分）：任意数据组成的数据块。</li>
</ul>


<h3>HTTP方法</h3>

<h4>1.GET</h4>

<p>请求服务器发送某个资源。请求无主体部分。</p>

<h4>2.HEAD</h4>

<p>与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：</p>

<ul>
<li>在不获取资源的情况下了解资源的情况（比如其类型）;</li>
<li>通过查看响应中的状态码，判断某个对象是否存在。</li>
<li>通过查看header，测试资源是否被修改了。</li>
</ul>


<h4>3.PUT</h4>

<p>PUT方法用于向服务器写入文档。请求有主体部分。</p>

<h4>4.POST</h4>

<p>POST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。</p>

<h4>5.TRACE</h4>

<p>客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。</p>

<h4>6.OPTIONS</h4>

<p>OPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。</p>

<h4>7.DELETE</h4>

<p>DELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。</p>

<h3>HTTP连接</h3>

<p>HTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。 <br/>
HTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：</p>

<ul>
<li>客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。</li>
<li>客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。</li>
<li>连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。</li>
<li>服务器回送响应也花费时间。</li>
</ul>


<h4>1.TCP连接握手时延</h4>

<p>由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。</p>

<h4>2.延迟确认</h4>

<p>网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。 <br/>
由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。</p>

<h4>3.TCP慢启动</h4>

<p>TCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。</p>

<h4>4.Nagle算法与TCP_NODELAY</h4>

<p>一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。</p>

<h4>5.TIME_WAIT累积与端口耗尽</h4>

<p>在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。</p>

<h3>HTTP状态码</h3>

<p>+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;+<br/>
|  整体范围   |   已定义范围     |   分类   |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 100～199   | 100～101        | 信息提示 | <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 200～299   | 200～206        | 成功    |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 300~399    | 300~305        | 重定向   |  <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 400～499   | 400～415       |客户端错误| <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+ <br/>
| 500~599    | 500~505        | 服务器错误|   <br/>
+&#8212;&#8212;&#8212;&#8212;+&#8212;&#8212;&#8212;&#8212;&#8212;-+&#8212;&#8212;&#8212;+</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从windows到linux]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/02/my-linux-dream/"/>
    <updated>2013-05-02T16:37:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/02/my-linux-dream</id>
    <content type="html"><![CDATA[<p>从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.</p>

<p>高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.</p>

<p>大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.</p>

<p>研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.</p>

<p>工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.</p>

<p>大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.</p>

<p>个人常用软件推荐:</p>

<ul>
<li>office: wps for linux  or libreoffice</li>
<li>输入法:  sogou for linux</li>
<li>开发IDE: Intellij IDEA or Eclipse</li>
<li>编辑器: sublime,retext</li>
<li>浏览器: chrome,firefox</li>
<li>邮件客户端: thunderbird</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Karma与Jenkins-CI集成]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci/"/>
    <updated>2013-04-01T19:38:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci</id>
    <content type="html"><![CDATA[<p>Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？</p>

<h3>前提条件</h3>

<p>Jenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：</p>

<ul>
<li>Node</li>
<li>Karma</li>
</ul>


<h3>配置Karma.conf.js文件</h3>

<p>必须保证：</p>

<pre><code>singleRun = true;
</code></pre>

<p>只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。  <br/>
在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。</p>

<pre><code>reporters = ['junit'];
junitReporter = {
    outputFile: 'test-results.xml'
};
</code></pre>

<p>那么，Junit格式的测试结果就存到了test-results.xml中。</p>

<p>另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：</p>

<pre><code>reporters = ['coverage'];

preprocessors = {
    'src/*.js': 'coverage'
};

coverageReporter = {
    type : 'cobertura',
    dir : 'coverage/'
};
</code></pre>

<p>这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。</p>

<!--more-->


<h3>一个Jenkins Job</h3>

<p>1.新建一个自由风格（freestyle）的Job即可。 <br/>
2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。 <br/>
3.源码管理部分，填写repository url。  <br/>
4.在构建里，直接填写<code>karma start</code>即可。 <br/>
5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-cobertura.png" alt="karma-jenkins-cobertura" /></p>

<p>6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit.png" alt="karma-jenkins-junit" /></p>

<h3>Jenkins运行结果</h3>

<p>Code Coverage结果： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-codecoverage.png" alt="" /></p>

<p>点击进入后，可以看到具体的覆盖率情况： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-codecoverage-detail.png" alt="" /></p>

<p>JUnit结果： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit-report.png" alt="" /></p>

<p>点进去后可以查看详细信息：<br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-jenkins-junit-report-detail.png" alt="" /></p>

<h3>关于Coverage</h3>

<p>coverageReporter的类型有以下几种：</p>

<ul>
<li>html (default)</li>
<li>lcov (lcov and html)</li>
<li>lcovonly</li>
<li>text (standard output)</li>
<li>text-summary (standard output)</li>
<li>cobertura (xml format supported by Jenkins)</li>
</ul>


<p>Karma是使用<a href="http://gotwarlost.github.com/istanbul/">istanbul</a>来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。 <br/>
以下是lcov类型的Coverage结果：</p>

<p><img src="http://www.shenyanchao.cn/images/blog/karma-lcov-1.png" alt="" /></p>

<p>而下面的结果，则指明了哪行源码被覆盖了。 <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-lcov-2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Karma来驱动mocha测试]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/27/use-karma-to-run-mocha-test/"/>
    <updated>2013-03-27T19:00:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/27/use-karma-to-run-mocha-test</id>
    <content type="html"><![CDATA[<h2>从Testacular到Karma的变化</h2>

<p>2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。<br/>
安装：</p>

<pre><code>npm install -g karma
</code></pre>

<h2>什么时候使用Karma？</h2>

<ul>
<li>在真实浏览器里测试。</li>
<li>在多种浏览器里进行测试（包括桌面、移动）。</li>
<li>在本地开发环境执行测试。</li>
<li>想在持续集成CI内运行测试。</li>
<li>想在每次保存代码时，自动执行测试。</li>
<li>热衷于terminal小黑屏。</li>
<li>不想陷入令人厌烦的测试生活。</li>
<li>想使用Istanbul自动生成coverage报告。</li>
<li>想在源码中使用RequireJS。</li>
</ul>


<h2>Karma不是Testing Framework</h2>

<p>Karma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。</p>

<ul>
<li>Mocha</li>
<li>Jasmine</li>
<li>QUnit</li>
</ul>


<!--more-->


<h2>Karma与Test Framework集成</h2>

<p>Karma对各种Test Framework的支持是以插件的模式进行支持的。<br/>
只需要在karma.conf.js进行以下配置（mocha为例）：</p>

<pre><code>frameworks = ['mocha'];

plugins = [
'karma-mocha'
];
</code></pre>

<p>在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：</p>

<pre><code>npm install karma-mocha
</code></pre>

<p>其他框架依此类推。</p>

<h2>Karma报告</h2>

<p>Karma的报告（reporter）也是以插件模式进行的。</p>

<h4>JUnit Reporter</h4>

<p>首先，要定义reporter类型，在karma.conf.js添加：</p>

<pre><code>reporters = ['junit'];
</code></pre>

<p>如果想更近一步的话，可以配置一下报告的位置。</p>

<pre><code>junitReporter = {
    outputFile: 'junit-report/test-results.xml'
};
</code></pre>

<p>报告配置完了，自然要有依赖啊。执行<code>npm install karma-junit-reporter</code>来安装。然后在加上这个plugin:</p>

<pre><code>plugins = [
    'karma-junit-reporter'
];
</code></pre>

<h4>Coverage Reporter</h4>

<p>同JUnit Reporter一样，首先添加：</p>

<pre><code>reporters = ['coverage'];
</code></pre>

<p>进一步的配置coverage report:</p>

<pre><code>coverageReporter = {
    type : 'cobertura',
    dir : 'coverage/'
};
</code></pre>

<p>其中，type用于指出报告类型；dir用于指出生成报告的存放目录。<br/>
type包括：</p>

<ul>
<li>html (default)</li>
<li>lcov (lcov and html)</li>
<li>lcovonly</li>
<li>text (standard output)</li>
<li>text-summary (standard output)</li>
<li>cobertura (xml format supported by Jenkins)</li>
</ul>


<p>下面，需要安装依赖<code>npm install karma-coverage</code>。并在配置文件内添加：</p>

<pre><code>plugins = [
    'karma-coverage'
];
</code></pre>

<h2>创建一个样例</h2>

<p>1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。</p>

<p>2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。</p>

<p>3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：</p>

<pre><code>// Karma configuration
// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)

// base path, that will be used to resolve files and exclude
basePath = './';

frameworks = ['mocha'];

// list of files / patterns to load in the browser
files = [
    {pattern: 'node_modules/chai/chai.js',include: true},
    'src/*.js',
    'test/*.js'
];


// list of files to exclude
exclude = [
    'karma.conf.js'
];


// use dots reporter, as travis terminal does not support escaping sequences
// possible values: 'dots', 'progress', 'junit', 'teamcity'
// CLI --reporters progress
reporters = ['progress','junit','coverage'];

junitReporter = {
    // will be resolved to basePath (in the same way as files/exclude patterns)
    outputFile: 'junit-report/test-results.xml'
};

preprocessors = {
    'src/*.js': 'coverage'
};

//Code Coverage options. report type available:
//- html (default)
//- lcov (lcov and html)
//- lcovonly
//- text (standard output)
//- text-summary (standard output)
//- cobertura (xml format supported by Jenkins)
coverageReporter = {
    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/
    type : 'cobertura',
    dir : 'coverage/'
};


// web server port
port = 9876;


// cli runner port
runnerPort = 9100;


// enable / disable colors in the output (reporters and logs)
colors = true;


// level of logging
// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG
logLevel = LOG_DEBUG;


// enable / disable watching file and executing tests whenever any file changes
autoWatch = true;


// Start these browsers, currently available:
// - Chrome
// - ChromeCanary
// - Firefox
// - Opera
// - Safari (only Mac)
// - PhantomJS
// - IE (only Windows)
// CLI --browsers Chrome,Firefox,Safari
browsers = ['Chrome'];


// If browser does not capture in given timeout [ms], kill it
captureTimeout = 6000;


// Continuous Integration mode
// if true, it capture browsers, run tests and exit
singleRun = true;


plugins = [
    'karma-mocha',
    'karma-chrome-launcher',
    'karma-firefox-launcher',
    'karma-junit-reporter',
    'karma-coverage'
];
</code></pre>

<p>4.放入相应的代码到src以及test目录里。执行&#8217;karma start&#8217;命令, 浏览器将会被打开，然后执行相应的Test。效果如下图： <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-chrome.png" alt="Karma in Chrome" /></p>

<p>完整样例代码： <br/>
<a href="https://github.com/blueshen/Karma-mocha-example">https://github.com/blueshen/Karma-mocha-example</a></p>

<h2>IntelliJ IDEA集成</h2>

<p>为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。 <br/>
1.安装NodeJS插件： Settings &#8211;> IDE Settings &#8211;> Plugins &#8211;> Browse repositories &#8211;> NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。 <br/>
2.配置Karma Server: 从菜单Run &#8211;> Edit Configurations&#8230; &#8211;>点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：  <br/>
<img src="http://www.shenyanchao.cn/images/blog/karma-node-server.png" alt="karma-node-server" /></p>

<p>其中：  <br/>
Name： 任意，本处为Karma node Server <br/>
Path to Node: node可执行全路径。$NODE_PATH/bin/node   <br/>
Working Directory: 当前项目的跟路径 <br/>
Path to Node App JS File: 此处为karma的可执行全路径。 <br/>
Application Parameters: 要执行的命令，此处为start   <br/>
Environment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。</p>

<p>3.配置Karma run   <br/>
同Karma Server，只是修改Application Parameters为run
<img src="http://www.shenyanchao.cn/images/blog/karma-node-run.png" alt="karma-node-run" /></p>

<p>配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将<code>singleRun=false</code>,也就是说执行完测试之后不退出。只有在CI环境下才用true。</p>

<p>在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将<code>autoWatch=true</code>,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。</p>
]]></content>
  </entry>
  
</feed>
