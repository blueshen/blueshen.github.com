{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1470993686000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1470993686000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1470993686000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1470993686000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1470993686000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1470993686000},{"_id":"source/_posts/2012-09-20-wo-de-di--pian-zhong-wen-bo-ke.markdown","hash":"1e5d75f258327a4296f95de1ac1d43d0dbe924bb","modified":1470994179000},{"_id":"source/_posts/2012-09-21-markdown-syntax.markdown","hash":"5db8daaf1860598aaea1dcb029b56baec9faac70","modified":1470994179000},{"_id":"source/_posts/2012-09-21-markpad-tools.markdown","hash":"e9bfd974888a93edb7fbd17c331a16008f686725","modified":1470994179000},{"_id":"source/_posts/2012-10-11-selenium-stable-1.markdown","hash":"d31ba9f03df3facff425f9454d4451ebc8720d53","modified":1470994179000},{"_id":"source/_posts/2012-09-28-pmd.markdown","hash":"c645c1c5fc865096eee28eab1d25d81c8993bbad","modified":1470994179000},{"_id":"source/_posts/2012-10-11-selenium-stable-2.markdown","hash":"f2b1c440e6fc494155aa9acd34021823f6ccc9e4","modified":1470994179000},{"_id":"source/_posts/2012-10-12-apache-mpm.markdown","hash":"a274f50e09176c0d6af7e715e019b3bd45dc75e8","modified":1470994179000},{"_id":"source/_posts/2012-10-12-selenium-faq-alerts-and-prompts.markdown","hash":"ab541711c4fdd1043e8b57154c3ad482ec99a9d1","modified":1470994179000},{"_id":"source/_posts/2012-10-12-selenium-faq-how-to-use-javascript.markdown","hash":"01d8d899688660cac63f5c3d409e788278e82902","modified":1470994179000},{"_id":"source/_posts/2012-10-12-selenium-multiple-browser-support.markdown","hash":"638ca9a5c794ed804214c22e956f185a2591ce72","modified":1470994179000},{"_id":"source/_posts/2012-10-16-pageobjects-design-pattern.markdown","hash":"afee6d73ae188a895ab66fc75368ad0574483943","modified":1470994179000},{"_id":"source/_posts/2012-10-19-install-maven.markdown","hash":"6c5cb532853a3dc54bcd1c26f33eb4e86d84482b","modified":1470994179000},{"_id":"source/_posts/2012-10-19-java6-jvm-params.markdown","hash":"f967fbf297eb3d81b54642cad2448debe71c1511","modified":1470994179000},{"_id":"source/_posts/2012-10-19-jvm-out-of-memory.markdown","hash":"6003cebdf381557dd16122e3927ab15530721ff1","modified":1470994179000},{"_id":"source/_posts/2012-10-19-maven-life-cycle.markdown","hash":"188e3620a9ba23cb808d2c516d74e77502706d76","modified":1470994179000},{"_id":"source/_posts/2012-10-20-xpath.markdown","hash":"826b6b1e664b1d240c2611c85415ea0a2e6dfda7","modified":1470994179000},{"_id":"source/_posts/2012-10-20-git-command.markdown","hash":"ee4474ea5de5797d124f2ffdbc9a4be14c2f5c9b","modified":1470994179000},{"_id":"source/_posts/2012-10-22-design-pattern-in-jdk-index.markdown","hash":"6508d6eaea0ff79a5f9a68a281431e7cd9b6cedc","modified":1470994179000},{"_id":"source/_posts/2012-10-22-encode-story.markdown","hash":"051d3cb84ddcd41e354c6ce9cdfa8b1ea45fd1b5","modified":1470994179000},{"_id":"source/_posts/2012-10-22-http-header.markdown","hash":"2d631dd43774b3dba764e190fc277a60267e9a23","modified":1470994179000},{"_id":"source/_posts/2012-10-23-bom-in-utf8-text.markdown","hash":"efddcf8eb2fb0454abf345908bc692de1e116f5b","modified":1470994179000},{"_id":"source/_posts/2012-10-22-word-charset.markdown","hash":"af2ddcbb27f78a251df2a28c2558e09e75668d8a","modified":1470994179000},{"_id":"source/_posts/2012-10-23-encode-in-java.markdown","hash":"db2a2fc25e901d73c2ff4f85be91b138a27f5664","modified":1470994179000},{"_id":"source/_posts/2012-10-30-adapter-in-java.markdown","hash":"a2fa2158ac79352b7a73aa819c42d338145bffae","modified":1470994179000},{"_id":"source/_posts/2012-10-30-decorator-in-java.markdown","hash":"99f43243ec7653c47aaeb664f027c3ac45342ab8","modified":1470994179000},{"_id":"source/_posts/2012-10-30-travel-in-yunnan.markdown","hash":"ba944da3f88b2dcc39d31bed61f64d544cbb5bd5","modified":1470994179000},{"_id":"source/_posts/2012-11-02-bridge-in-java.markdown","hash":"75ef73ee244c84397b0c556a6b25e46b534cb81d","modified":1470994179000},{"_id":"source/_posts/2012-11-02-builder-in-java.markdown","hash":"43b86fcb203cc4034bbc668625c362a868820186","modified":1470994179000},{"_id":"source/_posts/2012-11-02-chain-of-responsibility-in-java.markdown","hash":"84aa1edf7b22c23689fb69413ae7b77a3171bfc6","modified":1470994179000},{"_id":"source/_posts/2012-11-02-command-in-java.markdown","hash":"e94f5ad0db9a385b81ed4583fffa5feaf757a08b","modified":1470994179000},{"_id":"source/_posts/2012-11-02-composite-in-java.markdown","hash":"9b1451047da0299cef3c058ba02a3b00fb88cefc","modified":1470994179000},{"_id":"source/_posts/2012-11-02-facade-in-java.markdown","hash":"e184351041cc20adfd911fa56628e567664c0d88","modified":1470994179000},{"_id":"source/_posts/2012-11-02-factory-in-java.markdown","hash":"d85bb5932472123010c07822e106b2cfbf572071","modified":1470994179000},{"_id":"source/_posts/2012-11-02-flyweight-in-java.markdown","hash":"4f622084c94e7c8cec2253e63217ab11e3171fbf","modified":1470994179000},{"_id":"source/_posts/2012-11-02-how-webdriver-works.markdown","hash":"1930b7798622392b4c4e01939ecfa49584336c34","modified":1470994179000},{"_id":"source/_posts/2012-11-02-interpreter-in-java.markdown","hash":"13682c33eaab3684ded9af40d4c03068e98fcd0d","modified":1470994179000},{"_id":"source/_posts/2012-11-02-iterator-in-java.markdown","hash":"cef93c9aa6509d3706b62b19b9b2987b0283c257","modified":1470994179000},{"_id":"source/_posts/2012-11-02-mediator-in-java.markdown","hash":"85e745026ed5b953319e7fa562bf441e5107277a","modified":1470994179000},{"_id":"source/_posts/2012-11-02-memento-in-java.markdown","hash":"f2c4d26e73c0220362287e14a3e1d963151f26b0","modified":1470994179000},{"_id":"source/_posts/2012-11-02-null-object-in-java.markdown","hash":"b2de4ee0cf7bbe1e4d4450a3c37907b2c026da24","modified":1470994179000},{"_id":"source/_posts/2012-11-02-observer-in-java.markdown","hash":"0d7002a3bb1dcd2de19dd4606c699e14d71ae047","modified":1470994179000},{"_id":"source/_posts/2012-11-02-prototype-in-java.markdown","hash":"91a3eaa7f3da70662b1973778a3ee3021e6ad402","modified":1470994179000},{"_id":"source/_posts/2012-11-02-proxy-in-java.markdown","hash":"70b82c5edaf800a36f1b8b96dcace12a04e0ca40","modified":1470994179000},{"_id":"source/_posts/2012-11-02-state-in-java.markdown","hash":"e417ef8786dddb8f079adfe21aaad75065e78bc1","modified":1470994179000},{"_id":"source/_posts/2012-11-02-singleton-in-java.markdown","hash":"a9f9dbc7e3787093973245eea1e3c9bb2b89fce4","modified":1470994179000},{"_id":"source/_posts/2012-11-02-strategy-in-java.markdown","hash":"889a47ed3178bed16164dc1a8c2324a93c8245fb","modified":1470994179000},{"_id":"source/_posts/2012-11-02-template-method-in-java.markdown","hash":"343bbcd6ed850f49819a0a37747a91d106bc4c21","modified":1470994179000},{"_id":"source/_posts/2012-11-02-visitor-in-java.markdown","hash":"7e932b53244d7b941aaec6014fe86ff396c6cd04","modified":1470994179000},{"_id":"source/_posts/2012-12-04-mysqldump.markdown","hash":"112959f20111c6e672b675c3e2b7efced6097178","modified":1470994179000},{"_id":"source/_posts/2012-12-07-jmeter-distribution-step-by-step.markdown","hash":"612f8b91e6581b8343a407917ed6d52e228e0e77","modified":1470994179000},{"_id":"source/_posts/2012-12-31-build-jmeter-from-sources.markdown","hash":"240ae506e561e4367e4a1839fc4bd8c7dcdbc032","modified":1470994179000},{"_id":"source/_posts/2013-01-10-mysql-monitor.markdown","hash":"4a1eedb02810502b9d8c8243126b224cdf9b8866","modified":1470994179000},{"_id":"source/_posts/2013-01-17-most-rated-20-software-in-ubuntu-softcenter.markdown","hash":"8d0d9c70f9dc50ad506dd4d2c402126bbd78812f","modified":1470994179000},{"_id":"source/_posts/2013-01-10-selenium-grid2-config.markdown","hash":"c23d9e405567f849b5a27c84ef6eea3c1faf16e6","modified":1470994179000},{"_id":"source/_posts/2013-01-21-exploratory-software-testing-reading-notes-1.markdown","hash":"206017c15a1662cf083c592da29b37ab230b259a","modified":1470994179000},{"_id":"source/_posts/2013-03-11-node-dot-js-develop-guide-reading-note.markdown","hash":"afc5348a62eec8d1a177e8863fd84f414dd5fca3","modified":1470994179000},{"_id":"source/_posts/2013-03-12-testacular-in-brief.markdown","hash":"c95363666957422d6f2c128f18eaa5e08e91747e","modified":1470994179000},{"_id":"source/_posts/2013-03-18-mocha-in-brief.markdown","hash":"8a8f6c3270dd9919febdf2ee16735f1098488fc8","modified":1470994179000},{"_id":"source/_posts/2013-03-22-jasmine-in-brief.markdown","hash":"0d7a1805b3883379a69eefc364d7d4f80cdf6e2f","modified":1470994179000},{"_id":"source/_posts/2013-03-22-jenkins-plugin-start.markdown","hash":"c495a25a63d8fcc95a40073cf82b1e2cf2015e6a","modified":1470994179000},{"_id":"source/_posts/2013-03-22-jstestdriver-in-brief.markdown","hash":"c34d4dd96f69cbc84af0a2e03c37d5461215b16a","modified":1470994179000},{"_id":"source/_posts/2013-03-22-qunit-in-brief.markdown","hash":"a56dd42b3d2dfc12f77e45d1a36f6f51d072a6b5","modified":1470994179000},{"_id":"source/_posts/2013-03-27-use-karma-to-run-mocha-test.markdown","hash":"0acb3d285b3c8df917874db7054a71ff9cd7aafe","modified":1470994179000},{"_id":"source/_posts/2013-04-01-run-karma-in-jenkins-ci.markdown","hash":"717e5967979dfd5777b89f7cda84a7345d19590f","modified":1470994179000},{"_id":"source/_posts/2013-04-01-run-karma-in-jenkins-ci.markdown~","hash":"0e42845c8f8f04b7a34ef2018a3778f89123ec9d","modified":1470994179000},{"_id":"source/_posts/2013-05-02-my-linux-dream.markdown","hash":"e93f2b277f132244e81b1925ce574b2b060fc140","modified":1470994179000},{"_id":"source/_posts/2013-05-15-http-the-definitive-guide-reading-notes.markdown","hash":"b712ccf9407dbf1580862883ba55021767a14089","modified":1470994179000},{"_id":"source/_posts/2013-05-21-use-maven-archetype-to-generate-project-architecture.markdown","hash":"60b42e25426de232b0a1f02f3b8cad0b771ebb62","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-doc-introduction.markdown","hash":"7e4eef63305f2df43d8df408ecfa6aa52d962370","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-doc-selenium-grid.markdown","hash":"ac6a67ed4bfc89993e3cc34b8266afb60bd54afb","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-doc-selenium-rc.markdown","hash":"be41aaa0b3de6038ac23f83532c6f4e3941da69a","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-wiki-advanced-user-interactions.markdown","hash":"426b658bb20cab8f109d51891ca43164364f01ed","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-doc-selenium-web-driver.markdown","hash":"f2ce427338bb7505076e08e889059d44f983a6b2","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-wiki-frequently-asked-questions.markdown","hash":"06bcfc08c6ff1cb093e362b4c08f27099cbaf8ed","modified":1470994179000},{"_id":"source/_posts/2013-05-30-selenium-wiki-web-driver-js.markdown","hash":"d607fc2711fcc6b3fdea7f642fc39be67c380667","modified":1470994179000},{"_id":"source/_posts/2013-06-13-write-my-maven-plugin.markdown","hash":"80a30b2b72361e01a663f4e9e83c85e36f0f34aa","modified":1470994179000},{"_id":"source/_posts/2013-06-07-eclipse-ast.markdown","hash":"b688f8b4baf6fd68fc31423e617c124fd1e57e8d","modified":1470994179000},{"_id":"source/_posts/2013-06-19-use-eclipse-ast-to-parser-java.markdown","hash":"db5030b82d3d3bbee84d490d92e4fe7b3cb00f1b","modified":1470994179000},{"_id":"source/_posts/2013-06-19-publishing-from-github-to-maven-central.markdown","hash":"929f2fb337c0731ec2a822d7fd2812267dc03934","modified":1470994179000},{"_id":"source/_posts/2013-06-05-deep-in-testng.markdown","hash":"8778aa6b767795c928d1dcee9ee6af28d86b09fc","modified":1470994179000},{"_id":"source/_posts/2013-06-21-mockito-in-brief.markdown","hash":"f495576a07b9334bb33bcad1bcf0a23467387851","modified":1470994179000},{"_id":"source/_posts/2013-06-27-usage-dbunit.markdown","hash":"cd678149b948b5af34dc24900e52abe71ff99276","modified":1470994179000},{"_id":"source/_posts/2013-06-28-refactoring-to-patterns-reading-notes.markdown","hash":"028ef90c263793c999e3907984827f3f2f365987","modified":1470994179000},{"_id":"source/_posts/2013-09-16-git-ssh-connection.markdown","hash":"a3c6be7cccefc27c4b704474749faf66d4fef110","modified":1470994179000},{"_id":"source/_posts/2013-09-04-use-sonar.markdown","hash":"47b42d1ee22942f6059a62aadc1a4d981d702e89","modified":1470994179000},{"_id":"source/_posts/2013-09-24-performance-tuning-in-web-test.markdown","hash":"9cceb9e1bcab1f2fc0aa3c32b8fd4083205b3cae","modified":1470994179000},{"_id":"source/_posts/2013-09-25-custome-checkstyle-rule.markdown","hash":"8ddeb5757e472e11fe8ed57210c4eaecee1650cb","modified":1470994179000},{"_id":"source/_posts/2013-11-20-how-package-system-dependency-lib-in-maven.markdown","hash":"3aa49afa6fdbfd99344588f4d9995aa566935c43","modified":1470994179000},{"_id":"source/_posts/2013-11-20-maven-project-integrate-checkstyle-pmd-findbugs.markdown","hash":"412601e3398a1f46593202e02d78f9bfb4f7f069","modified":1470994179000},{"_id":"source/_posts/2013-11-26-the-principle-of-ssh.markdown","hash":"ad1eb90f2aaf9a0a0b69b5ef68f367bc5f0dcfac","modified":1470994179000},{"_id":"source/_posts/2013-12-04-the-pragmatic-programmer-reading-notes.markdown","hash":"9f7276308b117822338b459b253fb82fab2a758d","modified":1470994179000},{"_id":"source/_posts/2013-12-14-ut-maven-plugin.markdown","hash":"93348f1e2d697546bd6f9ae6148828780703cc16","modified":1470994179000},{"_id":"source/_posts/2014-03-27-java-encode-error-again.markdown","hash":"b194b7c97fdb90e9b0c50127cb0058e575765075","modified":1470994179000},{"_id":"source/_posts/2014-06-24-export-excel-by-jxls.markdown","hash":"8ebcec1ee0b71f267cc571ef5691c87a07e736d8","modified":1470994179000},{"_id":"source/_posts/2014-03-31-velocity-study-summary.markdown","hash":"6e334cd0bc18ba9e19d64b227331dafde26ed34e","modified":1470994179000},{"_id":"source/_posts/2014-06-24-quartz-cluster-with-spring.markdown","hash":"d1816e0235967b7de904b060b0f5ce83afbfaef3","modified":1470994179000},{"_id":"source/_posts/2014-10-22-tie-breaker-in-solr.markdown","hash":"aa207346c46061484842fb243ec76f13e87b36d6","modified":1470994179000},{"_id":"source/_posts/2014-08-27-java-new-feature.markdown","hash":"8218f5b850190f636a280189ca4c3bfdfbc5b28d","modified":1470994179000},{"_id":"source/_posts/2014-11-11-introduce-oryx.markdown","hash":"b1977e46cff98b5c9923720dcde28f7f99669ff0","modified":1470994179000},{"_id":"source/_posts/2014-11-13-encode-convert-in-linux.markdown","hash":"c0cdf5a560db1eac788fd760c7158a3ba7141983","modified":1470994179000},{"_id":"source/_posts/2014-11-14-use-mahout-to-classify-sogou-corpus.markdown","hash":"cdae43a3d371e06688b7edcaefca5830e6198d0b","modified":1470994179000},{"_id":"source/_posts/2014-11-13-install-hadoop.markdown","hash":"2db736959096f1f1f724adec7e40fa500cd10aa1","modified":1470994179000},{"_id":"source/_posts/2014-11-25-better-synonym-handling-in-solr.markdown","hash":"593d0ed4d13d4db4e5aabfab318216cd86e871ab","modified":1470994179000},{"_id":"source/_posts/2015-03-26-c3p0-config.markdown","hash":"f2276ee184c8b7765c5d09c4ea3c9037c1bd7f8c","modified":1470994179000},{"_id":"source/_posts/2015-11-03-restful-springmvc.markdown","hash":"dc6d1a4bd569f491c5186e63b8ca6b12d470f588","modified":1470994179000},{"_id":"source/_posts/2015-11-04-about-interface-define.md","hash":"48be14bceb1e7d76008d466adae6c4b140089376","modified":1470994179000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1470993686000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1470993686000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1470993686000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1470993686000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1470993686000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1470993686000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1470993686000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1470993686000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1470993686000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1470993686000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1470993686000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1470993686000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1470993686000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1470993686000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1470993686000},{"_id":"source/_posts/2014-03-18-use-jstl.markdown","hash":"356cfed47e833a659f82f57a2d31841fb648ee43","modified":1470994179000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1470993686000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1470993686000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1470993686000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1470993686000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1470993686000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1470993686000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1470993686000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1470993686000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1470993686000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1470993686000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1470993687000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1470993687000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1470993687000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1470993687000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1470993687000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1470993686000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1470993687000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1470993687000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1470993687000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1470993686000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1470993687000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1470993686000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1470993687000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1470993687000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1470993687000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1470993687000}],"Category":[{"name":"个人","_id":"cirrmop110003v8fyfen7fg01"},{"name":"markdown","_id":"cirrmop190008v8fy43ecng2d"},{"name":"selenium","_id":"cirrmop1l000hv8fyd73cizc3"},{"name":"maven","_id":"cirrmop1p000mv8fynzehl4mb"},{"name":"apache","_id":"cirrmop1z0012v8fyckvri337"},{"name":"JVM","_id":"cirrmop2i001pv8fys33xgs51"},{"name":"git","_id":"cirrmop2u001zv8fyxpeq13kr"},{"name":"设计模式","_id":"cirrmop2y0025v8fymbkyh5u0"},{"name":"encode","_id":"cirrmop35002dv8fytoin2l73"},{"name":"HTTP","_id":"cirrmop3f002kv8fyigd6lmb0"},{"name":"encode Java","_id":"cirrmop3o002zv8fy4t1fi8si"},{"name":"mysql","_id":"cirrmop4r0047v8fy994mgc0n"},{"name":"jmeter","_id":"cirrmop4x004hv8fy9rs6xu2e"},{"name":"ubuntu","_id":"cirrmop54004vv8fycsh13pus"},{"name":"测试","_id":"cirrmop560051v8fyhs6q5ewk"},{"name":"javascript","_id":"cirrmop5b005av8fyzh2ipftr"},{"name":"nodejs","_id":"cirrmop5g005kv8fynlvhlgzs"},{"name":"jenkins","_id":"cirrmop5x0066v8fyxc4d3nk2"},{"name":"linux","_id":"cirrmop6g0078v8fyssv6ymcr"},{"name":"selenium官方文档","_id":"cirrmop6k007fv8fy76gkmx6p"},{"name":"selenium-wiki","_id":"cirrmop6y0087v8fyx9b0652b"},{"name":"java","_id":"cirrmop74008mv8fyf4c3r092"},{"name":"testng","_id":"cirrmop7g0096v8fyb5klrpbg"},{"name":"ut","_id":"cirrmop7k009ev8fykjmjp6m9"},{"name":"调优","_id":"cirrmop7p009pv8fydcrgjtpz"},{"name":"checkstyle","_id":"cirrmop7q009sv8fyzfierybl"},{"name":"开发","_id":"cirrmop7q009wv8fyvw18ey90"},{"name":"Java","_id":"cirrmop7r00a1v8fy60d48h3t"},{"name":"velocity","_id":"cirrmop7s00a5v8fy6sn292hq"},{"name":"solr","_id":"cirrmop7t00acv8fy6fihxmgp"},{"name":"oryx","_id":"cirrmop7t00ahv8fyvphwk8t6"},{"name":"mahout","_id":"cirrmop7u00amv8fyayrl12cm"},{"name":"hadoop","_id":"cirrmop7w00auv8fygjuge77w"},{"name":"c3p0","_id":"cirrmop7y00ayv8fyjb2vvp8m"},{"name":"spring","_id":"cirrmop7y00b2v8fym0hr5110"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"我的第一篇中文博客","date":"2012-09-20T08:57:00.000Z","comments":1,"keywords":"关键字","description":"测试octopress是否成功了","_content":"#吐槽\n这个OCTOPRESS真是难搞啊，最主要是_config.xml里面的格式校验也太严格了</center>\n#正文\n在这里写一些内容。\n链接<http://www.baidu.com>\n***\n代码段\n\t\tSystem.out.println(\"ok!\")\n\n---\n<iframe height=498 width=510 frameborder=0 src=\"http://player.youku.com/embed/XODk1Mzg1NTY=\" allowfullscreen></iframe>\n---","source":"_posts/2012-09-20-wo-de-di--pian-zhong-wen-bo-ke.markdown","raw":"---\nlayout: post\ntitle: \"我的第一篇中文博客\"\ndate: 2012-09-20 16:57\ncomments: true\ncategories: 个人\ntags: [ octopress, github, config.xml, 中文 ]\nkeywords: 关键字\ndescription: 测试octopress是否成功了\n---\n#吐槽\n这个OCTOPRESS真是难搞啊，最主要是_config.xml里面的格式校验也太严格了</center>\n#正文\n在这里写一些内容。\n链接<http://www.baidu.com>\n***\n代码段\n\t\tSystem.out.println(\"ok!\")\n\n---\n<iframe height=498 width=510 frameborder=0 src=\"http://player.youku.com/embed/XODk1Mzg1NTY=\" allowfullscreen></iframe>\n---","slug":"2012-09-20-wo-de-di--pian-zhong-wen-bo-ke","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop0q0000v8fy2eqmv8ua","content":"<p>#吐槽<br>这个OCTOPRESS真是难搞啊，最主要是_config.xml里面的格式校验也太严格了</p>\n<p>#正文<br>在这里写一些内容。<br>链接<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"external\">http://www.baidu.com</a></p>\n<hr>\n<p>代码段<br>        System.out.println(“ok!”)</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><iframe height=\"498\" width=\"510\" frameborder=\"0\" src=\"http://player.youku.com/embed/XODk1Mzg1NTY=\" allowfullscreen></iframe></h2>","excerpt":"","more":"<p>#吐槽<br>这个OCTOPRESS真是难搞啊，最主要是_config.xml里面的格式校验也太严格了</center></p>\n<p>#正文<br>在这里写一些内容。<br>链接<a href=\"http://www.baidu.com\">http://www.baidu.com</a></p>\n<hr>\n<p>代码段<br>        System.out.println(“ok!”)</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><iframe height=498 width=510 frameborder=0 src=\"http://player.youku.com/embed/XODk1Mzg1NTY=\" allowfullscreen></iframe></h2>"},{"layout":"post","title":"markdown Syntax","date":"2012-09-21T05:37:00.000Z","comments":1,"_content":"\n>用起来很爽   \n语法具体可以参考：[markdown Syntax](http://wowubuntu.com/markdown/)  \n\t\n---\n","source":"_posts/2012-09-21-markdown-syntax.markdown","raw":"---\nlayout: post\ntitle: \"markdown Syntax\"\ndate: 2012-09-21 13:37\ncomments: true\ncategories: markdown\ntags: [ markdown, syntax, octopress ]\n---\n\n>用起来很爽   \n语法具体可以参考：[markdown Syntax](http://wowubuntu.com/markdown/)  \n\t\n---\n","slug":"2012-09-21-markdown-syntax","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop0v0001v8fym4ihcy5f","content":"<blockquote>\n<p>用起来很爽<br>语法具体可以参考：<a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"external\">markdown Syntax</a>  </p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<blockquote>\n<p>用起来很爽<br>语法具体可以参考：<a href=\"http://wowubuntu.com/markdown/\">markdown Syntax</a>  </p>\n</blockquote>\n<hr>\n"},{"layout":"post","title":"markdown 工具","date":"2012-09-21T10:37:00.000Z","comments":1,"_content":"---\n这个工具不错！可以很好的用来快速的对博客进行排版。  \n编辑器推荐: [MarkDownPad](http://markdownpad.com/)\n\n@[Blues小站](http://www.shenyanchao.cn \"shenyanchao\")就是使用这种工具进行排版的\n\n---\n\n","source":"_posts/2012-09-21-markpad-tools.markdown","raw":"---\nlayout: post\ntitle: \"markdown 工具\"\ndate: 2012-09-21 18:37\ncomments: true\ncategories: markdown\ntags: [ MarkDownPad ]\n---\n---\n这个工具不错！可以很好的用来快速的对博客进行排版。  \n编辑器推荐: [MarkDownPad](http://markdownpad.com/)\n\n@[Blues小站](http://www.shenyanchao.cn \"shenyanchao\")就是使用这种工具进行排版的\n\n---\n\n","slug":"2012-09-21-markpad-tools","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop120004v8fy0439sibq","content":"<hr>\n<p>这个工具不错！可以很好的用来快速的对博客进行排版。<br>编辑器推荐: <a href=\"http://markdownpad.com/\" target=\"_blank\" rel=\"external\">MarkDownPad</a></p>\n<p>@<a href=\"http://www.shenyanchao.cn\" title=\"shenyanchao\">Blues小站</a>就是使用这种工具进行排版的</p>\n<hr>\n","excerpt":"","more":"<hr>\n<p>这个工具不错！可以很好的用来快速的对博客进行排版。<br>编辑器推荐: <a href=\"http://markdownpad.com/\">MarkDownPad</a></p>\n<p>@<a href=\"http://www.shenyanchao.cn\" title=\"shenyanchao\">Blues小站</a>就是使用这种工具进行排版的</p>\n<hr>\n"},{"layout":"post","title":"提高selenium自动化的稳定性1-点击空白区域","date":"2012-10-11T06:12:00.000Z","comments":1,"_content":"在写selenium自动化的过程中，经常会遇到这样的问题：   \n>1.在同一个页面内做操作，比如点击某个按钮后，弹出一个框，再点击另外一个按钮，又弹出一个框   \n>2.此时如果第一个click操作后，第二个click再点击时，由于前一个弹出的框仍旧在前端显示，就会出错   \n>3.在实际人工操作中，点击出第一个框后，点击一下空白区域，在点击出现第二个框。因此，可以考虑一个点击空白区域的方法\n\n##实现方法如下    \n```java   \n    /**\n\t * 点击空白区域：坐标（0，0）\n\t */\n\tpublic static void clickBlankArea(WebDriver driver) {\n\t\tActions actions = new Actions(driver);\n\t\tactions.moveByOffset(0, 0).click().build().perform();\n\t}\n```\n让driver先移动到一个空白位置（此处设为(0,0)坐标点），做一下点击操作即可\n","source":"_posts/2012-10-11-selenium-stable-1.markdown","raw":"---\nlayout: post\ntitle: \"提高selenium自动化的稳定性1-点击空白区域\"\ndate: 2012-10-11 14:12\ncomments: true\ncategories: selenium\ntags: [ webdriver, selenium , stable  ]\n---\n在写selenium自动化的过程中，经常会遇到这样的问题：   \n>1.在同一个页面内做操作，比如点击某个按钮后，弹出一个框，再点击另外一个按钮，又弹出一个框   \n>2.此时如果第一个click操作后，第二个click再点击时，由于前一个弹出的框仍旧在前端显示，就会出错   \n>3.在实际人工操作中，点击出第一个框后，点击一下空白区域，在点击出现第二个框。因此，可以考虑一个点击空白区域的方法\n\n##实现方法如下    \n```java   \n    /**\n\t * 点击空白区域：坐标（0，0）\n\t */\n\tpublic static void clickBlankArea(WebDriver driver) {\n\t\tActions actions = new Actions(driver);\n\t\tactions.moveByOffset(0, 0).click().build().perform();\n\t}\n```\n让driver先移动到一个空白位置（此处设为(0,0)坐标点），做一下点击操作即可\n","slug":"2012-10-11-selenium-stable-1","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop140005v8fy8srg0wy9","content":"<p>在写selenium自动化的过程中，经常会遇到这样的问题：   </p>\n<blockquote>\n<p>1.在同一个页面内做操作，比如点击某个按钮后，弹出一个框，再点击另外一个按钮，又弹出一个框<br>2.此时如果第一个click操作后，第二个click再点击时，由于前一个弹出的框仍旧在前端显示，就会出错<br>3.在实际人工操作中，点击出第一个框后，点击一下空白区域，在点击出现第二个框。因此，可以考虑一个点击空白区域的方法</p>\n</blockquote>\n<p>##实现方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\"> * 点击空白区域：坐标（0，0）</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clickBlankArea</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">\tActions actions = <span class=\"keyword\">new</span> Actions(driver);</div><div class=\"line\">\tactions.moveByOffset(<span class=\"number\">0</span>, <span class=\"number\">0</span>).click().build().perform();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让driver先移动到一个空白位置（此处设为(0,0)坐标点），做一下点击操作即可</p>\n","excerpt":"","more":"<p>在写selenium自动化的过程中，经常会遇到这样的问题：   </p>\n<blockquote>\n<p>1.在同一个页面内做操作，比如点击某个按钮后，弹出一个框，再点击另外一个按钮，又弹出一个框<br>2.此时如果第一个click操作后，第二个click再点击时，由于前一个弹出的框仍旧在前端显示，就会出错<br>3.在实际人工操作中，点击出第一个框后，点击一下空白区域，在点击出现第二个框。因此，可以考虑一个点击空白区域的方法</p>\n</blockquote>\n<p>##实现方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\"> * 点击空白区域：坐标（0，0）</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clickBlankArea</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">\tActions actions = <span class=\"keyword\">new</span> Actions(driver);</div><div class=\"line\">\tactions.moveByOffset(<span class=\"number\">0</span>, <span class=\"number\">0</span>).click().build().perform();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让driver先移动到一个空白位置（此处设为(0,0)坐标点），做一下点击操作即可</p>\n"},{"layout":"post","title":"PMD静态代码检查","date":"2012-10-11T03:20:00.000Z","comments":1,"_content":"\n##一 maven插件：maven-pmd-plugin##\n>pom.xml添加如下内容：\n\n``` xml\n\t\t<plugin>\n\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t<artifactId>maven-pmd-plugin</artifactId>\n\t\t\t\t<version>2.7.1</version>\n\t\t\t\t<executions>\n\t\t\t\t\t<execution>\n\t\t\t\t\t\t<phase>package</phase>\n\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t<goal>check</goal>\n\t\t\t\t\t\t</goals>\n\t\t\t\t\t</execution>\n\t\t\t\t</executions>\n\t\t\t\t<configuration>\n\t\t\t\t\t<failurePriority>2</failurePriority>\n\t\t\t\t\t<targetJdk>1.6</targetJdk>\n\t\t\t\t\t<rulesets>\n\t\t\t\t\t\t<ruleset>/pmd-rulesets.xml</ruleset>\n\t\t\t\t\t</rulesets>\n\t\t\t\t</configuration>\n\t\t\t</plugin>\n```\n>failurePriority用于指定在什么错误级别会failure，级别0~5不等。0为最高，5为最低。此处设为2,意为0、1、2级别的错误都会导致报错。级别可以根据项目的要求进行配置   \n<!--more-->\n>其中**pmd-rulesets.xml**是规则文件,由pmd制定的一些规则，这些规则可以在pmd-*.jar里找到。 **pmd-rulesets.xml**类似于以下：\n\n```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\t<ruleset xmlns=\"http://pmd.sf.net/ruleset/1.0.0\" name=\"pmd-rulsets\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://pmd.sf.net/ruleset_xml_schema.xsd\" xsi:schemaLocation=\"http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd\">\n  \t \t<description>PMD Plugin preferences rule set</description>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/LooseCoupling\"/>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/CloneMethodMustImplementCloneable\"/>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/SignatureDeclareThrowsException\"/>\n  \t\t<rule ref=\"rulesets/braces.xml/IfStmtsMustUseBraces\"/>\n   \t\t<rule ref=\"rulesets/braces.xml/WhileLoopsMustUseBraces\"/>\n\t</ruleset>\n```\t\n \n###如何使用###\n``` sh\n\tmvn pmd:pmd\n\tmvn pmd:check   \n```\n---\n##二 pmd在eclipse中的使用\n>1.安装\n>>Help -> Install New Software -> Add...  \n>>设置update site:<http://pmd.sourceforge.net/eclipse>  \n>>一路next安装成功即可\n  \t  \n>2.eclipse中的设置\n>>Window -> Prefrences -> PMD -> Rules Configuration  \n>>在其中可以设置相关Rules，这里面的Rules对应maven-pmd-plugins中的pmd-rulesets.xml，可以根据自己的需求进行定制\n\n>3.eclipse中的使用\n>>右键选中project -> PMD -> Check Code with PMD  \n>>执行结束后，会打开PMD视图，会依据不同的Priority级别显示不同的颜色。其中红色标注的X是级别为错误级别的。\n\n  \n\n---","source":"_posts/2012-09-28-pmd.markdown","raw":"---\nlayout: post\ntitle: \"PMD静态代码检查\"\ndate: 2012-10-11 11:20\ncomments: true\ncategories: maven\ntags: [ pmd, maven, eclipse ]\n---\n\n##一 maven插件：maven-pmd-plugin##\n>pom.xml添加如下内容：\n\n``` xml\n\t\t<plugin>\n\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t<artifactId>maven-pmd-plugin</artifactId>\n\t\t\t\t<version>2.7.1</version>\n\t\t\t\t<executions>\n\t\t\t\t\t<execution>\n\t\t\t\t\t\t<phase>package</phase>\n\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t<goal>check</goal>\n\t\t\t\t\t\t</goals>\n\t\t\t\t\t</execution>\n\t\t\t\t</executions>\n\t\t\t\t<configuration>\n\t\t\t\t\t<failurePriority>2</failurePriority>\n\t\t\t\t\t<targetJdk>1.6</targetJdk>\n\t\t\t\t\t<rulesets>\n\t\t\t\t\t\t<ruleset>/pmd-rulesets.xml</ruleset>\n\t\t\t\t\t</rulesets>\n\t\t\t\t</configuration>\n\t\t\t</plugin>\n```\n>failurePriority用于指定在什么错误级别会failure，级别0~5不等。0为最高，5为最低。此处设为2,意为0、1、2级别的错误都会导致报错。级别可以根据项目的要求进行配置   \n<!--more-->\n>其中**pmd-rulesets.xml**是规则文件,由pmd制定的一些规则，这些规则可以在pmd-*.jar里找到。 **pmd-rulesets.xml**类似于以下：\n\n```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\t<ruleset xmlns=\"http://pmd.sf.net/ruleset/1.0.0\" name=\"pmd-rulsets\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://pmd.sf.net/ruleset_xml_schema.xsd\" xsi:schemaLocation=\"http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd\">\n  \t \t<description>PMD Plugin preferences rule set</description>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/LooseCoupling\"/>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/CloneMethodMustImplementCloneable\"/>\n   \t\t<rule ref=\"rulesets/typeresolution.xml/SignatureDeclareThrowsException\"/>\n  \t\t<rule ref=\"rulesets/braces.xml/IfStmtsMustUseBraces\"/>\n   \t\t<rule ref=\"rulesets/braces.xml/WhileLoopsMustUseBraces\"/>\n\t</ruleset>\n```\t\n \n###如何使用###\n``` sh\n\tmvn pmd:pmd\n\tmvn pmd:check   \n```\n---\n##二 pmd在eclipse中的使用\n>1.安装\n>>Help -> Install New Software -> Add...  \n>>设置update site:<http://pmd.sourceforge.net/eclipse>  \n>>一路next安装成功即可\n  \t  \n>2.eclipse中的设置\n>>Window -> Prefrences -> PMD -> Rules Configuration  \n>>在其中可以设置相关Rules，这里面的Rules对应maven-pmd-plugins中的pmd-rulesets.xml，可以根据自己的需求进行定制\n\n>3.eclipse中的使用\n>>右键选中project -> PMD -> Check Code with PMD  \n>>执行结束后，会打开PMD视图，会依据不同的Priority级别显示不同的颜色。其中红色标注的X是级别为错误级别的。\n\n  \n\n---","slug":"2012-09-28-pmd","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop180007v8fyhehnrqkk","content":"<p>##一 maven插件：maven-pmd-plugin##</p>\n<blockquote>\n<p>pom.xml添加如下内容：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-pmd-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>check<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">failurePriority</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">failurePriority</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">targetJdk</span>&gt;</span>1.6<span class=\"tag\">&lt;/<span class=\"name\">targetJdk</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">rulesets</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ruleset</span>&gt;</span>/pmd-rulesets.xml<span class=\"tag\">&lt;/<span class=\"name\">ruleset</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">rulesets</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>failurePriority用于指定在什么错误级别会failure，级别0~5不等。0为最高，5为最低。此处设为2,意为0、1、2级别的错误都会导致报错。级别可以根据项目的要求进行配置<br><a id=\"more\"></a><br>其中<strong>pmd-rulesets.xml</strong>是规则文件,由pmd制定的一些规则，这些规则可以在pmd-<em>.jar里找到。 <em>*pmd-rulesets.xml</em></em>类似于以下：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ruleset</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset/1.0.0\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"pmd-rulsets\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset_xml_schema.xsd\"</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd\"</span>&gt;</span></div><div class=\"line\">  \t \t<span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>PMD Plugin preferences rule set<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/LooseCoupling\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/CloneMethodMustImplementCloneable\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/SignatureDeclareThrowsException\"</span>/&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/braces.xml/IfStmtsMustUseBraces\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/braces.xml/WhileLoopsMustUseBraces\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ruleset</span>&gt;</span></div><div class=\"line\">```\t</div><div class=\"line\"> </div><div class=\"line\">###如何使用###</div><div class=\"line\">``` sh</div><div class=\"line\">\tmvn pmd:pmd</div><div class=\"line\">\tmvn pmd:check</div></pre></td></tr></table></figure>\n<hr>\n<p>##二 pmd在eclipse中的使用</p>\n<blockquote>\n<p>1.安装</p>\n<blockquote>\n<p>Help -&gt; Install New Software -&gt; Add…<br>设置update site:<a href=\"http://pmd.sourceforge.net/eclipse\" target=\"_blank\" rel=\"external\">http://pmd.sourceforge.net/eclipse</a><br>一路next安装成功即可</p>\n</blockquote>\n<p>2.eclipse中的设置</p>\n<blockquote>\n<p>Window -&gt; Prefrences -&gt; PMD -&gt; Rules Configuration<br>在其中可以设置相关Rules，这里面的Rules对应maven-pmd-plugins中的pmd-rulesets.xml，可以根据自己的需求进行定制</p>\n</blockquote>\n<p>3.eclipse中的使用</p>\n<blockquote>\n<p>右键选中project -&gt; PMD -&gt; Check Code with PMD<br>执行结束后，会打开PMD视图，会依据不同的Priority级别显示不同的颜色。其中红色标注的X是级别为错误级别的。</p>\n</blockquote>\n</blockquote>\n<hr>\n","excerpt":"<p>##一 maven插件：maven-pmd-plugin##</p>\n<blockquote>\n<p>pom.xml添加如下内容：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-pmd-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>check<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">failurePriority</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">failurePriority</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">targetJdk</span>&gt;</span>1.6<span class=\"tag\">&lt;/<span class=\"name\">targetJdk</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">rulesets</span>&gt;</span></div><div class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">ruleset</span>&gt;</span>/pmd-rulesets.xml<span class=\"tag\">&lt;/<span class=\"name\">ruleset</span>&gt;</span></div><div class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">rulesets</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>failurePriority用于指定在什么错误级别会failure，级别0~5不等。0为最高，5为最低。此处设为2,意为0、1、2级别的错误都会导致报错。级别可以根据项目的要求进行配置<br>","more":"<br>其中<strong>pmd-rulesets.xml</strong>是规则文件,由pmd制定的一些规则，这些规则可以在pmd-<em>.jar里找到。 <em>*pmd-rulesets.xml</em></em>类似于以下：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ruleset</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset/1.0.0\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"pmd-rulsets\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset_xml_schema.xsd\"</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd\"</span>&gt;</span></div><div class=\"line\">  \t \t<span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>PMD Plugin preferences rule set<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/LooseCoupling\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/CloneMethodMustImplementCloneable\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/typeresolution.xml/SignatureDeclareThrowsException\"</span>/&gt;</span></div><div class=\"line\">  \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/braces.xml/IfStmtsMustUseBraces\"</span>/&gt;</span></div><div class=\"line\">   \t\t<span class=\"tag\">&lt;<span class=\"name\">rule</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"rulesets/braces.xml/WhileLoopsMustUseBraces\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">ruleset</span>&gt;</span></div><div class=\"line\">```\t</div><div class=\"line\"> </div><div class=\"line\">###如何使用###</div><div class=\"line\">``` sh</div><div class=\"line\">\tmvn pmd:pmd</div><div class=\"line\">\tmvn pmd:check</div></pre></td></tr></table></figure>\n<hr>\n<p>##二 pmd在eclipse中的使用</p>\n<blockquote>\n<p>1.安装</p>\n<blockquote>\n<p>Help -&gt; Install New Software -&gt; Add…<br>设置update site:<a href=\"http://pmd.sourceforge.net/eclipse\">http://pmd.sourceforge.net/eclipse</a><br>一路next安装成功即可</p>\n</blockquote>\n<p>2.eclipse中的设置</p>\n<blockquote>\n<p>Window -&gt; Prefrences -&gt; PMD -&gt; Rules Configuration<br>在其中可以设置相关Rules，这里面的Rules对应maven-pmd-plugins中的pmd-rulesets.xml，可以根据自己的需求进行定制</p>\n</blockquote>\n<p>3.eclipse中的使用</p>\n<blockquote>\n<p>右键选中project -&gt; PMD -&gt; Check Code with PMD<br>执行结束后，会打开PMD视图，会依据不同的Priority级别显示不同的颜色。其中红色标注的X是级别为错误级别的。</p>\n</blockquote>\n</blockquote>\n<hr>"},{"layout":"post","title":"提高selenium自动化的稳定性2-等待","date":"2012-10-11T06:32:00.000Z","comments":1,"_content":"##很多页面元素都是ajax动态生成的，这就要求进行适当的等待##\n##如何进行等待呢？##\n###1.直接sleep###\n```java\n\tpublic static void sleep(int seconds) {\n\t\ttry {\n\t\t\tTimeUnit.SECONDS.sleep(seconds);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n```\n这种方法，用于直接的让thread进行等待指定的seconds。  \n<!--more-->\n###2.使用selenium webdriver提供的等待方法\n```java\ndriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n```\n这种方法是webdriver提供的一种隐式等待。  \n隐式等待是指当要查找元素（`driver.findElement()`），而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。   \n比如使用：`driver.findElement(By.id(\"element\"));`来查找id=\"element\"的元素。如果没有设置隐式等待，那么执行到这一步的时候就会直接报错`NoSuchElementException`。而设置后，则会在10秒内不断就查询元素是否存在，如果存在则返回。超过10秒仍没找到，才报错。\n###3.使用WebDriver提供的`Wait<T>`接口\n```java\n\tFluentWait<T> implements Wait<T>  \n\n\tWait<WebDriver> wait = new FluentWait<WebDriver>(driver)\n       .withTimeout(30, SECONDS)\n       .pollingEvery(5, SECONDS)\n       .ignoring(NoSuchElementException.class);\n\n   \tWebElement element = wait.until(new Function<WebDriver, WebElement>() {\n     public WebElement apply(WebDriver driver) {\n       return driver.findElement(By.id(\"element\"));\n     }\n   \t});\n\telement.click();//something to do\n```\n此方法用于等待一个元素在页面上出现，超时时间为30S，每隔5S去请求一次，并且忽略掉until中抛出的`NoSuchElementException`。   \nFluentWait的源码中这样写到:    \n\n```java\n\tprivate Duration timeout = FIVE_HUNDRED_MILLIS;  \n\tprivate Duration interval = FIVE_HUNDRED_MILLIS; \n```  \n因此，如果不设置`withTimeout`、`pollingEvery`则相当于等待了500ms,并且请求了一次，要使用`FluentWait`应该依据实际需要进行设置。那有没有更好的方法呢，有的，请往下看。 \n\n```java \n\n\tWebDriverWait extends FluentWait<WebDriver>\n\t\n\tWait<WebDriver> waiter = new WebDriverWait(driver, 10);\n\tWebElement element = waiter.until(new Function<WebDriver, WebElement>() {\n\t\t\tpublic WebElement apply(WebDriver driver) {\n\t\t\t\treturn driver.findElement(By.id(\"element\"));\n\t\t\t}\n\t\t\t\n\t\t});\n\telement.click();//something to do\n```\n`WebDriverWait`是继承于`FluentWait`的，并且实现了对功能进行了增强。从源码看出`WebDriverWait`的构造函数进行了如下的设置：   \n\n```java\n\twithTimeout(timeOutInSeconds, TimeUnit.SECONDS);\n    pollingEvery(sleepTimeOut, TimeUnit.MILLISECONDS);\n    ignoring(NotFoundException.class);\n```\n设置了超时时间、每次请求的间隔为`sleepTimeOut`（默认500ms）、忽略了`NotFoundException`。因此直接使用`WebDriverWait`更加的省事。\n###总结###\nWebDriver提供了很多等待机制来增加selenium自动化的稳定性，只要合理利用是可以达到理想的效果的。   \n无疑第一种方法sleep是最不可取的，是万不得已才用的一份方法，因为元素的加载与网络速度等客观因素直接相关。这个sleep的值是很难取的，值小了不行，值大了会造成case的运行速度缓慢。   \n第二种方法是从全局的角度来解决元素查找问题的，在解决通用性的问题上有一定的优势，可以考虑使用。   \n第三种方法是最好的，也是**推荐**的一种等待方式，很好的解决了动态元素的查找问题。   \n\n---","source":"_posts/2012-10-11-selenium-stable-2.markdown","raw":"---\nlayout: post\ntitle: \"提高selenium自动化的稳定性2-等待\"\ndate: 2012-10-11 14:32\ncomments: true\ncategories: selenium\ntags: [ webdriver , selenium , stable, wait  ]\n---\n##很多页面元素都是ajax动态生成的，这就要求进行适当的等待##\n##如何进行等待呢？##\n###1.直接sleep###\n```java\n\tpublic static void sleep(int seconds) {\n\t\ttry {\n\t\t\tTimeUnit.SECONDS.sleep(seconds);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n```\n这种方法，用于直接的让thread进行等待指定的seconds。  \n<!--more-->\n###2.使用selenium webdriver提供的等待方法\n```java\ndriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n```\n这种方法是webdriver提供的一种隐式等待。  \n隐式等待是指当要查找元素（`driver.findElement()`），而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。   \n比如使用：`driver.findElement(By.id(\"element\"));`来查找id=\"element\"的元素。如果没有设置隐式等待，那么执行到这一步的时候就会直接报错`NoSuchElementException`。而设置后，则会在10秒内不断就查询元素是否存在，如果存在则返回。超过10秒仍没找到，才报错。\n###3.使用WebDriver提供的`Wait<T>`接口\n```java\n\tFluentWait<T> implements Wait<T>  \n\n\tWait<WebDriver> wait = new FluentWait<WebDriver>(driver)\n       .withTimeout(30, SECONDS)\n       .pollingEvery(5, SECONDS)\n       .ignoring(NoSuchElementException.class);\n\n   \tWebElement element = wait.until(new Function<WebDriver, WebElement>() {\n     public WebElement apply(WebDriver driver) {\n       return driver.findElement(By.id(\"element\"));\n     }\n   \t});\n\telement.click();//something to do\n```\n此方法用于等待一个元素在页面上出现，超时时间为30S，每隔5S去请求一次，并且忽略掉until中抛出的`NoSuchElementException`。   \nFluentWait的源码中这样写到:    \n\n```java\n\tprivate Duration timeout = FIVE_HUNDRED_MILLIS;  \n\tprivate Duration interval = FIVE_HUNDRED_MILLIS; \n```  \n因此，如果不设置`withTimeout`、`pollingEvery`则相当于等待了500ms,并且请求了一次，要使用`FluentWait`应该依据实际需要进行设置。那有没有更好的方法呢，有的，请往下看。 \n\n```java \n\n\tWebDriverWait extends FluentWait<WebDriver>\n\t\n\tWait<WebDriver> waiter = new WebDriverWait(driver, 10);\n\tWebElement element = waiter.until(new Function<WebDriver, WebElement>() {\n\t\t\tpublic WebElement apply(WebDriver driver) {\n\t\t\t\treturn driver.findElement(By.id(\"element\"));\n\t\t\t}\n\t\t\t\n\t\t});\n\telement.click();//something to do\n```\n`WebDriverWait`是继承于`FluentWait`的，并且实现了对功能进行了增强。从源码看出`WebDriverWait`的构造函数进行了如下的设置：   \n\n```java\n\twithTimeout(timeOutInSeconds, TimeUnit.SECONDS);\n    pollingEvery(sleepTimeOut, TimeUnit.MILLISECONDS);\n    ignoring(NotFoundException.class);\n```\n设置了超时时间、每次请求的间隔为`sleepTimeOut`（默认500ms）、忽略了`NotFoundException`。因此直接使用`WebDriverWait`更加的省事。\n###总结###\nWebDriver提供了很多等待机制来增加selenium自动化的稳定性，只要合理利用是可以达到理想的效果的。   \n无疑第一种方法sleep是最不可取的，是万不得已才用的一份方法，因为元素的加载与网络速度等客观因素直接相关。这个sleep的值是很难取的，值小了不行，值大了会造成case的运行速度缓慢。   \n第二种方法是从全局的角度来解决元素查找问题的，在解决通用性的问题上有一定的优势，可以考虑使用。   \n第三种方法是最好的，也是**推荐**的一种等待方式，很好的解决了动态元素的查找问题。   \n\n---","slug":"2012-10-11-selenium-stable-2","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1a0009v8fyj45inxb6","content":"<p>##很多页面元素都是ajax动态生成的，这就要求进行适当的等待##</p>\n<p>##如何进行等待呢？##</p>\n<p>###1.直接sleep###<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">(<span class=\"keyword\">int</span> seconds)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tTimeUnit.SECONDS.sleep(seconds);</div><div class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\te.printStackTrace();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方法，用于直接的让thread进行等待指定的seconds。<br><a id=\"more\"></a></p>\n<p>###2.使用selenium webdriver提供的等待方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.manage().timeouts().implicitlyWait(<span class=\"number\">10</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>\n<p>这种方法是webdriver提供的一种隐式等待。<br>隐式等待是指当要查找元素（<code>driver.findElement()</code>），而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。<br>比如使用：<code>driver.findElement(By.id(&quot;element&quot;));</code>来查找id=”element”的元素。如果没有设置隐式等待，那么执行到这一步的时候就会直接报错<code>NoSuchElementException</code>。而设置后，则会在10秒内不断就查询元素是否存在，如果存在则返回。超过10秒仍没找到，才报错。</p>\n<p>###3.使用WebDriver提供的<code>Wait&lt;T&gt;</code>接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">FluentWait&lt;T&gt; implements Wait&lt;T&gt;  </div><div class=\"line\"></div><div class=\"line\">Wait&lt;WebDriver&gt; wait = <span class=\"keyword\">new</span> FluentWait&lt;WebDriver&gt;(driver)</div><div class=\"line\">      .withTimeout(<span class=\"number\">30</span>, SECONDS)</div><div class=\"line\">      .pollingEvery(<span class=\"number\">5</span>, SECONDS)</div><div class=\"line\">      .ignoring(NoSuchElementException.class);</div><div class=\"line\"></div><div class=\"line\">  \tWebElement element = wait.until(<span class=\"keyword\">new</span> Function&lt;WebDriver, WebElement&gt;() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebElement <span class=\"title\">apply</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> driver.findElement(By.id(<span class=\"string\">\"element\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t&#125;);</div><div class=\"line\">element.click();<span class=\"comment\">//something to do</span></div></pre></td></tr></table></figure></p>\n<p>此方法用于等待一个元素在页面上出现，超时时间为30S，每隔5S去请求一次，并且忽略掉until中抛出的<code>NoSuchElementException</code>。<br>FluentWait的源码中这样写到:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"keyword\">private</span> Duration timeout = FIVE_HUNDRED_MILLIS;  </div><div class=\"line\">\t<span class=\"keyword\">private</span> Duration interval = FIVE_HUNDRED_MILLIS; </div><div class=\"line\">```  </div><div class=\"line\">因此，如果不设置`withTimeout`、`pollingEvery`则相当于等待了<span class=\"number\">500</span>ms,并且请求了一次，要使用`FluentWait`应该依据实际需要进行设置。那有没有更好的方法呢，有的，请往下看。 </div><div class=\"line\"></div><div class=\"line\">```java </div><div class=\"line\"></div><div class=\"line\">\tWebDriverWait extends FluentWait&lt;WebDriver&gt;</div><div class=\"line\">\t</div><div class=\"line\">\tWait&lt;WebDriver&gt; waiter = <span class=\"keyword\">new</span> WebDriverWait(driver, <span class=\"number\">10</span>);</div><div class=\"line\">\tWebElement element = waiter.until(<span class=\"keyword\">new</span> Function&lt;WebDriver, WebElement&gt;() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> WebElement <span class=\"title\">apply</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> driver.findElement(By.id(<span class=\"string\">\"element\"</span>));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\telement.click();<span class=\"comment\">//something to do</span></div></pre></td></tr></table></figure>\n<p><code>WebDriverWait</code>是继承于<code>FluentWait</code>的，并且实现了对功能进行了增强。从源码看出<code>WebDriverWait</code>的构造函数进行了如下的设置：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">withTimeout(timeOutInSeconds, TimeUnit.SECONDS);</div><div class=\"line\">   pollingEvery(sleepTimeOut, TimeUnit.MILLISECONDS);</div><div class=\"line\">   ignoring(NotFoundException.class);</div></pre></td></tr></table></figure>\n<p>设置了超时时间、每次请求的间隔为<code>sleepTimeOut</code>（默认500ms）、忽略了<code>NotFoundException</code>。因此直接使用<code>WebDriverWait</code>更加的省事。</p>\n<p>###总结###<br>WebDriver提供了很多等待机制来增加selenium自动化的稳定性，只要合理利用是可以达到理想的效果的。<br>无疑第一种方法sleep是最不可取的，是万不得已才用的一份方法，因为元素的加载与网络速度等客观因素直接相关。这个sleep的值是很难取的，值小了不行，值大了会造成case的运行速度缓慢。<br>第二种方法是从全局的角度来解决元素查找问题的，在解决通用性的问题上有一定的优势，可以考虑使用。<br>第三种方法是最好的，也是<strong>推荐</strong>的一种等待方式，很好的解决了动态元素的查找问题。   </p>\n<hr>\n","excerpt":"<p>##很多页面元素都是ajax动态生成的，这就要求进行适当的等待##</p>\n<p>##如何进行等待呢？##</p>\n<p>###1.直接sleep###<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">(<span class=\"keyword\">int</span> seconds)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tTimeUnit.SECONDS.sleep(seconds);</div><div class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\te.printStackTrace();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种方法，用于直接的让thread进行等待指定的seconds。<br>","more":"</p>\n<p>###2.使用selenium webdriver提供的等待方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">driver.manage().timeouts().implicitlyWait(<span class=\"number\">10</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>\n<p>这种方法是webdriver提供的一种隐式等待。<br>隐式等待是指当要查找元素（<code>driver.findElement()</code>），而这个元素没有马上出现时，告诉WebDriver查询Dom一定时间。默认值是0,但是设置之后，这个时间将在WebDriver对象实例整个生命周期都起作用。<br>比如使用：<code>driver.findElement(By.id(&quot;element&quot;));</code>来查找id=”element”的元素。如果没有设置隐式等待，那么执行到这一步的时候就会直接报错<code>NoSuchElementException</code>。而设置后，则会在10秒内不断就查询元素是否存在，如果存在则返回。超过10秒仍没找到，才报错。</p>\n<p>###3.使用WebDriver提供的<code>Wait&lt;T&gt;</code>接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">FluentWait&lt;T&gt; implements Wait&lt;T&gt;  </div><div class=\"line\"></div><div class=\"line\">Wait&lt;WebDriver&gt; wait = <span class=\"keyword\">new</span> FluentWait&lt;WebDriver&gt;(driver)</div><div class=\"line\">      .withTimeout(<span class=\"number\">30</span>, SECONDS)</div><div class=\"line\">      .pollingEvery(<span class=\"number\">5</span>, SECONDS)</div><div class=\"line\">      .ignoring(NoSuchElementException.class);</div><div class=\"line\"></div><div class=\"line\">  \tWebElement element = wait.until(<span class=\"keyword\">new</span> Function&lt;WebDriver, WebElement&gt;() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebElement <span class=\"title\">apply</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> driver.findElement(By.id(<span class=\"string\">\"element\"</span>));</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t&#125;);</div><div class=\"line\">element.click();<span class=\"comment\">//something to do</span></div></pre></td></tr></table></figure></p>\n<p>此方法用于等待一个元素在页面上出现，超时时间为30S，每隔5S去请求一次，并且忽略掉until中抛出的<code>NoSuchElementException</code>。<br>FluentWait的源码中这样写到:    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"keyword\">private</span> Duration timeout = FIVE_HUNDRED_MILLIS;  </div><div class=\"line\">\t<span class=\"keyword\">private</span> Duration interval = FIVE_HUNDRED_MILLIS; </div><div class=\"line\">```  </div><div class=\"line\">因此，如果不设置`withTimeout`、`pollingEvery`则相当于等待了<span class=\"number\">500</span>ms,并且请求了一次，要使用`FluentWait`应该依据实际需要进行设置。那有没有更好的方法呢，有的，请往下看。 </div><div class=\"line\"></div><div class=\"line\">```java </div><div class=\"line\"></div><div class=\"line\">\tWebDriverWait extends FluentWait&lt;WebDriver&gt;</div><div class=\"line\">\t</div><div class=\"line\">\tWait&lt;WebDriver&gt; waiter = <span class=\"keyword\">new</span> WebDriverWait(driver, <span class=\"number\">10</span>);</div><div class=\"line\">\tWebElement element = waiter.until(<span class=\"keyword\">new</span> Function&lt;WebDriver, WebElement&gt;() &#123;</div><div class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> WebElement <span class=\"title\">apply</span><span class=\"params\">(WebDriver driver)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> driver.findElement(By.id(<span class=\"string\">\"element\"</span>));</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\telement.click();<span class=\"comment\">//something to do</span></div></pre></td></tr></table></figure>\n<p><code>WebDriverWait</code>是继承于<code>FluentWait</code>的，并且实现了对功能进行了增强。从源码看出<code>WebDriverWait</code>的构造函数进行了如下的设置：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">withTimeout(timeOutInSeconds, TimeUnit.SECONDS);</div><div class=\"line\">   pollingEvery(sleepTimeOut, TimeUnit.MILLISECONDS);</div><div class=\"line\">   ignoring(NotFoundException.class);</div></pre></td></tr></table></figure>\n<p>设置了超时时间、每次请求的间隔为<code>sleepTimeOut</code>（默认500ms）、忽略了<code>NotFoundException</code>。因此直接使用<code>WebDriverWait</code>更加的省事。</p>\n<p>###总结###<br>WebDriver提供了很多等待机制来增加selenium自动化的稳定性，只要合理利用是可以达到理想的效果的。<br>无疑第一种方法sleep是最不可取的，是万不得已才用的一份方法，因为元素的加载与网络速度等客观因素直接相关。这个sleep的值是很难取的，值小了不行，值大了会造成case的运行速度缓慢。<br>第二种方法是从全局的角度来解决元素查找问题的，在解决通用性的问题上有一定的优势，可以考虑使用。<br>第三种方法是最好的，也是<strong>推荐</strong>的一种等待方式，很好的解决了动态元素的查找问题。   </p>\n<hr>"},{"layout":"post","title":"apache mpm介绍","date":"2012-10-12T04:45:00.000Z","comments":1,"_content":"##什么是MPM？ \n\nMPM（Multi -Processing Modules，多路处理模块）是Apache2.x中影响性能的最核心特性。 \n\n是Apache 2.x才支持的一个可插入的并发模型，在编译的时候，我们只可以选择一个并发模型。 \n\n配置文件：/usr/local/apache2/conf/extra/httpd-mpm.conf \n\n如果apache是默认安装的可能配置在httpd.conf文件中。根据实际情况查找配置。 \n\n使用格式： \n进入apache的目录，对apache进行如下编译： \n\nLinux代码   \n\n```sh\n./configure --help|grep mpm  \n```\n<!--more-->\n\n显示内容如下： \n\nLinux代码   \n\n```sh\n\t--with-mpm=MPM  \n\tChoose the process model for Apache to use.  \n\tMPM={beos|worker|prefork|mpmt_os2| perchild|leader|threadpool} \n``` \n\n* 1、beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM。 \n\n* 2、perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程，这在运行多个需要CGI的虚拟主机时特别有用，会比1.3版中的SuExec 机制做得更好。 \n\n* 3、leader和threadpool都是基于worker的变体，还处于实验性阶段，某些情况下并不会按照预期设想的那样工作，所以 Apache官方也并不推荐使用。 \n\n* 4、prefork如果不用“–with-mpm ”显式指定某种MPM，prefork就是LInux/Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的，这也使其成为最稳定的MPM之一。  \nprefork的工作原理是，控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个，直到满足MinSpareServers设置的值为止。这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。 \n\n* 5、worker相对于prefork,worker是2.x版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理,所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器.但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.x的发展趋势。    \nworker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild 线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 \n\n##如何判断当前的服务器使用那种MPM 模块? \n若使用prefork，在make编译和make install安装后，使用“httpd -l”来确定当前使用的MPM， \n如下示:    \n\n```sh\n\t[aaron@webslave1 extra]$ /usr/local/apache2/bin/httpd -l \n\tCompiled in modules: \n\tcore.c \n\t...... \n\tprefork.c \n\t...... \n```\n应该会看到prefork.c（如果看到worker.c说明使用的是worker MPM，依此类推）。再查看缺省生成的httpd.conf配置文件，里面包含如下配置段： \n\nLinux代码     \n\n``` xml\n\t<IfModule prefork.c>  \n\tStartServers 5  \n\tMinSpareServers 5  \n\tMaxSpareServers 10  最大的空闲进程数 \n\tMaxClients 150  Apache可以同时处理的请求(最重要)--即为常说的并发连接数!! \n\tMaxRequestsPerChild 0  每个子进程可处理的请求数 \n\t</IfModule>  \n```\n\nMaxSpareServers设置了最大的空闲进程数，如果空闲进程数大于这个值，Apache会自动kill掉一些多余进程。这个值不要设得过大，但如果设的值比MinSpareServers小，Apache会自动把其调整为MinSpareServers+1。如果站点负载较大，可考虑同时加大MinSpareServers和MaxSpareServers。 \n\nMaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处： \n\n可防止意外的内存泄漏； \n在服务器负载下降的时侯会自动减少子进程数。 \n\n因此，可根据服务器的负载来调整这个值。笔者认为10000左右比较合适。 \n\nMaxClients是这些指令中最为重要的一个，设定的是Apache可以同时处理的请求，是对Apache性能影响最大的参数。  \n其缺省值150是远远不够的，如果请求总数已达到这个值（可通过ps -ef|grep http|wc -l来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。系统管理员可以根据硬件配置和负载情况来动态调整这个值。  \n虽然理论上这个值越大，可以处理的请求就越多，但Apache默认的限制不能大于256。如果把这个值设为大于256，那么Apache将无法起动。事实上，256对于负载稍重的站点也是不够的。在Apache 1.3中，这是个硬限制。如果要加大这个值，必须在“configure”前手工修改的源代码树下的src/include/httpd.h中查找256，就会发现“#define HARD_SERVER_LIMIT 256”这行。把256改为要增大的值（如4000），然后重新编译Apache即可。在Apache 2.0中新加入了ServerLimit指令，使得无须重编译Apache就可以加大MaxClients。下面是笔者的prefork配置段： \n\nLinux代码 \n    \n```xml\n\t<IfModule prefork.c>  \n\tStartServers 10  \n\tMinSpareServers 10  \n\tMaxSpareServers 15  \n\tServerLimit 20000  \n\tMaxClients 1000  \n\tMaxRequestsPerChild 10000  \n\t</IfModule>  \n```\n\n　上述配置中，ServerLimit的最大值是20000，对于大多数站点已经足够。如果一定要再加大这个数值，对位于源代码目录下 \n/httpd-2.2.15/server/mpm/prefork/prefork.c中以下两行做相应修改即可：  \nLinux代码    \n\n```sh\n\t#define DEFAULT_SERVER_LIMIT 256  \n\t#define MAX_SERVER_LIMIT 20000  \n```\nworker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 \n\nMinSpareThreads和MaxSpareThreads的最大缺省值分别是75和250。这两个参数对Apache的性能影响并不大，可以按照实际情况相应调节。 \nThreadsPerChild是worker MPM中与性能相关最密切的指令。ThreadsPerChild的最大缺省值是64，如果负载较大，64也是不够的。这时要显式使用ThreadLimit指令，它的最大缺省值是20000。上述两个值位于源码树server/mpm/worker/worker.c中的以下两行： \n\nLinux代码    \n\n```sh\n\t#define DEFAULT_THREAD_LIMIT 64  \n\t#define MAX_THREAD_LIMIT 20000  \n```\n这两行对应着ThreadsPerChild和ThreadLimit的限制数。最好在configure之前就把64改成所希望的值。注意，不要把这两个值设得太高，超过系统的处理能力，从而因Apache不起动使系统很不稳定。 \nWorker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的，应该大于等于MaxClients。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时也需要显式声明ServerLimit（最大值是20000）。这两个值位于源码树server/mpm/worker/worker.c中的以下两行： \n\nLinux代码     \n\n```sh\n\t#define DEFAULT_SERVER_LIMIT 16  \n\t#define MAX_SERVER_LIMIT 20000  \n```\n需要注意的是，如果显式声明了ServerLimit，那么它乘以ThreadsPerChild的值必须大于等于MaxClients，而且MaxClients必须是ThreadsPerChild的整数倍，否则Apache将会自动调节到一个相应值（可能是个非期望值）。下面是笔者的worker配置段： \n\nLinux代码  \n   \n```xml\n\t<IfModule worker.c>  \n\tStartServers 3  \n\tMaxClients 2000  \n\tServerLimit 25  \n\tMinSpareThreads 50  \n\tMaxSpareThreads 200  \n\tThreadLimit 200  \n\tThreadsPerChild 100  \n\tMaxRequestsPerChild 0  \n\t</IfModule>  \n```\n硬性公式：  \n\n         ThreadLimit >= ThreadsPerChild\n         MaxClients <= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数\n         MaxSpareThreads >= MinSpareThreads+ThreadsPerChild\nServerLimit默认是16,最大20000;ThreadLimit默认是64,最大20000。  \n通过上面的叙述，可以了解到Apache 2.0中prefork和worker这两个重要MPM的工作原理，并可根据实际情况来配置Apache相关的核心参数，以获得最大的性能和稳定性。","source":"_posts/2012-10-12-apache-mpm.markdown","raw":"---\nlayout: post\ntitle: \"apache mpm介绍\"\ndate: 2012-10-12 12:45\ncomments: true\ncategories: apache\ntags: [ apache, mpm, worker, perfork  ]\n---\n##什么是MPM？ \n\nMPM（Multi -Processing Modules，多路处理模块）是Apache2.x中影响性能的最核心特性。 \n\n是Apache 2.x才支持的一个可插入的并发模型，在编译的时候，我们只可以选择一个并发模型。 \n\n配置文件：/usr/local/apache2/conf/extra/httpd-mpm.conf \n\n如果apache是默认安装的可能配置在httpd.conf文件中。根据实际情况查找配置。 \n\n使用格式： \n进入apache的目录，对apache进行如下编译： \n\nLinux代码   \n\n```sh\n./configure --help|grep mpm  \n```\n<!--more-->\n\n显示内容如下： \n\nLinux代码   \n\n```sh\n\t--with-mpm=MPM  \n\tChoose the process model for Apache to use.  \n\tMPM={beos|worker|prefork|mpmt_os2| perchild|leader|threadpool} \n``` \n\n* 1、beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM。 \n\n* 2、perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程，这在运行多个需要CGI的虚拟主机时特别有用，会比1.3版中的SuExec 机制做得更好。 \n\n* 3、leader和threadpool都是基于worker的变体，还处于实验性阶段，某些情况下并不会按照预期设想的那样工作，所以 Apache官方也并不推荐使用。 \n\n* 4、prefork如果不用“–with-mpm ”显式指定某种MPM，prefork就是LInux/Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的，这也使其成为最稳定的MPM之一。  \nprefork的工作原理是，控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个，直到满足MinSpareServers设置的值为止。这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。 \n\n* 5、worker相对于prefork,worker是2.x版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理,所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器.但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.x的发展趋势。    \nworker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild 线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 \n\n##如何判断当前的服务器使用那种MPM 模块? \n若使用prefork，在make编译和make install安装后，使用“httpd -l”来确定当前使用的MPM， \n如下示:    \n\n```sh\n\t[aaron@webslave1 extra]$ /usr/local/apache2/bin/httpd -l \n\tCompiled in modules: \n\tcore.c \n\t...... \n\tprefork.c \n\t...... \n```\n应该会看到prefork.c（如果看到worker.c说明使用的是worker MPM，依此类推）。再查看缺省生成的httpd.conf配置文件，里面包含如下配置段： \n\nLinux代码     \n\n``` xml\n\t<IfModule prefork.c>  \n\tStartServers 5  \n\tMinSpareServers 5  \n\tMaxSpareServers 10  最大的空闲进程数 \n\tMaxClients 150  Apache可以同时处理的请求(最重要)--即为常说的并发连接数!! \n\tMaxRequestsPerChild 0  每个子进程可处理的请求数 \n\t</IfModule>  \n```\n\nMaxSpareServers设置了最大的空闲进程数，如果空闲进程数大于这个值，Apache会自动kill掉一些多余进程。这个值不要设得过大，但如果设的值比MinSpareServers小，Apache会自动把其调整为MinSpareServers+1。如果站点负载较大，可考虑同时加大MinSpareServers和MaxSpareServers。 \n\nMaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处： \n\n可防止意外的内存泄漏； \n在服务器负载下降的时侯会自动减少子进程数。 \n\n因此，可根据服务器的负载来调整这个值。笔者认为10000左右比较合适。 \n\nMaxClients是这些指令中最为重要的一个，设定的是Apache可以同时处理的请求，是对Apache性能影响最大的参数。  \n其缺省值150是远远不够的，如果请求总数已达到这个值（可通过ps -ef|grep http|wc -l来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。系统管理员可以根据硬件配置和负载情况来动态调整这个值。  \n虽然理论上这个值越大，可以处理的请求就越多，但Apache默认的限制不能大于256。如果把这个值设为大于256，那么Apache将无法起动。事实上，256对于负载稍重的站点也是不够的。在Apache 1.3中，这是个硬限制。如果要加大这个值，必须在“configure”前手工修改的源代码树下的src/include/httpd.h中查找256，就会发现“#define HARD_SERVER_LIMIT 256”这行。把256改为要增大的值（如4000），然后重新编译Apache即可。在Apache 2.0中新加入了ServerLimit指令，使得无须重编译Apache就可以加大MaxClients。下面是笔者的prefork配置段： \n\nLinux代码 \n    \n```xml\n\t<IfModule prefork.c>  \n\tStartServers 10  \n\tMinSpareServers 10  \n\tMaxSpareServers 15  \n\tServerLimit 20000  \n\tMaxClients 1000  \n\tMaxRequestsPerChild 10000  \n\t</IfModule>  \n```\n\n　上述配置中，ServerLimit的最大值是20000，对于大多数站点已经足够。如果一定要再加大这个数值，对位于源代码目录下 \n/httpd-2.2.15/server/mpm/prefork/prefork.c中以下两行做相应修改即可：  \nLinux代码    \n\n```sh\n\t#define DEFAULT_SERVER_LIMIT 256  \n\t#define MAX_SERVER_LIMIT 20000  \n```\nworker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 \n\nMinSpareThreads和MaxSpareThreads的最大缺省值分别是75和250。这两个参数对Apache的性能影响并不大，可以按照实际情况相应调节。 \nThreadsPerChild是worker MPM中与性能相关最密切的指令。ThreadsPerChild的最大缺省值是64，如果负载较大，64也是不够的。这时要显式使用ThreadLimit指令，它的最大缺省值是20000。上述两个值位于源码树server/mpm/worker/worker.c中的以下两行： \n\nLinux代码    \n\n```sh\n\t#define DEFAULT_THREAD_LIMIT 64  \n\t#define MAX_THREAD_LIMIT 20000  \n```\n这两行对应着ThreadsPerChild和ThreadLimit的限制数。最好在configure之前就把64改成所希望的值。注意，不要把这两个值设得太高，超过系统的处理能力，从而因Apache不起动使系统很不稳定。 \nWorker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的，应该大于等于MaxClients。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时也需要显式声明ServerLimit（最大值是20000）。这两个值位于源码树server/mpm/worker/worker.c中的以下两行： \n\nLinux代码     \n\n```sh\n\t#define DEFAULT_SERVER_LIMIT 16  \n\t#define MAX_SERVER_LIMIT 20000  \n```\n需要注意的是，如果显式声明了ServerLimit，那么它乘以ThreadsPerChild的值必须大于等于MaxClients，而且MaxClients必须是ThreadsPerChild的整数倍，否则Apache将会自动调节到一个相应值（可能是个非期望值）。下面是笔者的worker配置段： \n\nLinux代码  \n   \n```xml\n\t<IfModule worker.c>  \n\tStartServers 3  \n\tMaxClients 2000  \n\tServerLimit 25  \n\tMinSpareThreads 50  \n\tMaxSpareThreads 200  \n\tThreadLimit 200  \n\tThreadsPerChild 100  \n\tMaxRequestsPerChild 0  \n\t</IfModule>  \n```\n硬性公式：  \n\n         ThreadLimit >= ThreadsPerChild\n         MaxClients <= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数\n         MaxSpareThreads >= MinSpareThreads+ThreadsPerChild\nServerLimit默认是16,最大20000;ThreadLimit默认是64,最大20000。  \n通过上面的叙述，可以了解到Apache 2.0中prefork和worker这两个重要MPM的工作原理，并可根据实际情况来配置Apache相关的核心参数，以获得最大的性能和稳定性。","slug":"2012-10-12-apache-mpm","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1d000bv8fy49e7yv2x","content":"<p>##什么是MPM？ </p>\n<p>MPM（Multi -Processing Modules，多路处理模块）是Apache2.x中影响性能的最核心特性。 </p>\n<p>是Apache 2.x才支持的一个可插入的并发模型，在编译的时候，我们只可以选择一个并发模型。 </p>\n<p>配置文件：/usr/local/apache2/conf/extra/httpd-mpm.conf </p>\n<p>如果apache是默认安装的可能配置在httpd.conf文件中。根据实际情况查找配置。 </p>\n<p>使用格式：<br>进入apache的目录，对apache进行如下编译： </p>\n<p>Linux代码   </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./configure --help|grep mpm</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>显示内容如下： </p>\n<p>Linux代码   </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t--with-mpm=MPM  </div><div class=\"line\">\tChoose the process model <span class=\"keyword\">for</span> Apache to use.  </div><div class=\"line\">\tMPM=&#123;beos|worker|prefork|mpmt_os2| perchild|leader|threadpool&#125; </div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">* 1、beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM。 </div><div class=\"line\"></div><div class=\"line\">* 2、perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程，这在运行多个需要CGI的虚拟主机时特别有用，会比1.3版中的SuExec 机制做得更好。 </div><div class=\"line\"></div><div class=\"line\">* 3、leader和threadpool都是基于worker的变体，还处于实验性阶段，某些情况下并不会按照预期设想的那样工作，所以 Apache官方也并不推荐使用。 </div><div class=\"line\"></div><div class=\"line\">* 4、prefork如果不用“–with-mpm ”显式指定某种MPM，prefork就是LInux/Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的，这也使其成为最稳定的MPM之一。  </div><div class=\"line\">prefork的工作原理是，控制进程在最初建立“StartServers”个子进程后,为了满足M<span class=\"keyword\">in</span>SpareServers设置的需要创建一个进程,等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个，直到满足M<span class=\"keyword\">in</span>SpareServers设置的值为止。这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。 </div><div class=\"line\"></div><div class=\"line\">* 5、worker相对于prefork,worker是2.x版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理,所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器.但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.x的发展趋势。    </div><div class=\"line\">worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild 线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，M<span class=\"keyword\">in</span>SpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">##如何判断当前的服务器使用那种MPM 模块? </span></div><div class=\"line\">若使用prefork，在make编译和make install安装后，使用“httpd <span class=\"_\">-l</span>”来确定当前使用的MPM， </div><div class=\"line\">如下示:    </div><div class=\"line\"></div><div class=\"line\">```sh</div><div class=\"line\">\t[aaron@webslave1 extra]$ /usr/<span class=\"built_in\">local</span>/apache2/bin/httpd <span class=\"_\">-l</span> </div><div class=\"line\">\tCompiled <span class=\"keyword\">in</span> modules: </div><div class=\"line\">\tcore.c </div><div class=\"line\">\t...... </div><div class=\"line\">\tprefork.c </div><div class=\"line\">\t......</div></pre></td></tr></table></figure>\n<p>应该会看到prefork.c（如果看到worker.c说明使用的是worker MPM，依此类推）。再查看缺省生成的httpd.conf配置文件，里面包含如下配置段： </p>\n<p>Linux代码     </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">prefork.c</span>&gt;</span>  </div><div class=\"line\">StartServers 5  </div><div class=\"line\">MinSpareServers 5  </div><div class=\"line\">MaxSpareServers 10  最大的空闲进程数 </div><div class=\"line\">MaxClients 150  Apache可以同时处理的请求(最重要)--即为常说的并发连接数!! </div><div class=\"line\">MaxRequestsPerChild 0  每个子进程可处理的请求数 </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>MaxSpareServers设置了最大的空闲进程数，如果空闲进程数大于这个值，Apache会自动kill掉一些多余进程。这个值不要设得过大，但如果设的值比MinSpareServers小，Apache会自动把其调整为MinSpareServers+1。如果站点负载较大，可考虑同时加大MinSpareServers和MaxSpareServers。 </p>\n<p>MaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处： </p>\n<p>可防止意外的内存泄漏；<br>在服务器负载下降的时侯会自动减少子进程数。 </p>\n<p>因此，可根据服务器的负载来调整这个值。笔者认为10000左右比较合适。 </p>\n<p>MaxClients是这些指令中最为重要的一个，设定的是Apache可以同时处理的请求，是对Apache性能影响最大的参数。<br>其缺省值150是远远不够的，如果请求总数已达到这个值（可通过ps -ef|grep http|wc -l来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。系统管理员可以根据硬件配置和负载情况来动态调整这个值。<br>虽然理论上这个值越大，可以处理的请求就越多，但Apache默认的限制不能大于256。如果把这个值设为大于256，那么Apache将无法起动。事实上，256对于负载稍重的站点也是不够的。在Apache 1.3中，这是个硬限制。如果要加大这个值，必须在“configure”前手工修改的源代码树下的src/include/httpd.h中查找256，就会发现“#define HARD_SERVER_LIMIT 256”这行。把256改为要增大的值（如4000），然后重新编译Apache即可。在Apache 2.0中新加入了ServerLimit指令，使得无须重编译Apache就可以加大MaxClients。下面是笔者的prefork配置段： </p>\n<p>Linux代码 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">prefork.c</span>&gt;</span>  </div><div class=\"line\">StartServers 10  </div><div class=\"line\">MinSpareServers 10  </div><div class=\"line\">MaxSpareServers 15  </div><div class=\"line\">ServerLimit 20000  </div><div class=\"line\">MaxClients 1000  </div><div class=\"line\">MaxRequestsPerChild 10000  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　上述配置中，ServerLimit的最大值是20000，对于大多数站点已经足够。如果一定要再加大这个数值，对位于源代码目录下<br>/httpd-2.2.15/server/mpm/prefork/prefork.c中以下两行做相应修改即可：<br>Linux代码    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_SERVER_LIMIT 256  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_SERVER_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 </p>\n<p>MinSpareThreads和MaxSpareThreads的最大缺省值分别是75和250。这两个参数对Apache的性能影响并不大，可以按照实际情况相应调节。<br>ThreadsPerChild是worker MPM中与性能相关最密切的指令。ThreadsPerChild的最大缺省值是64，如果负载较大，64也是不够的。这时要显式使用ThreadLimit指令，它的最大缺省值是20000。上述两个值位于源码树server/mpm/worker/worker.c中的以下两行： </p>\n<p>Linux代码    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_THREAD_LIMIT 64  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_THREAD_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>这两行对应着ThreadsPerChild和ThreadLimit的限制数。最好在configure之前就把64改成所希望的值。注意，不要把这两个值设得太高，超过系统的处理能力，从而因Apache不起动使系统很不稳定。<br>Worker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的，应该大于等于MaxClients。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时也需要显式声明ServerLimit（最大值是20000）。这两个值位于源码树server/mpm/worker/worker.c中的以下两行： </p>\n<p>Linux代码     </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_SERVER_LIMIT 16  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_SERVER_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>需要注意的是，如果显式声明了ServerLimit，那么它乘以ThreadsPerChild的值必须大于等于MaxClients，而且MaxClients必须是ThreadsPerChild的整数倍，否则Apache将会自动调节到一个相应值（可能是个非期望值）。下面是笔者的worker配置段： </p>\n<p>Linux代码  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">worker.c</span>&gt;</span>  </div><div class=\"line\">StartServers 3  </div><div class=\"line\">MaxClients 2000  </div><div class=\"line\">ServerLimit 25  </div><div class=\"line\">MinSpareThreads 50  </div><div class=\"line\">MaxSpareThreads 200  </div><div class=\"line\">ThreadLimit 200  </div><div class=\"line\">ThreadsPerChild 100  </div><div class=\"line\">MaxRequestsPerChild 0  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>硬性公式：  </p>\n<pre><code>ThreadLimit &gt;= ThreadsPerChild\nMaxClients &lt;= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数\nMaxSpareThreads &gt;= MinSpareThreads+ThreadsPerChild\n</code></pre><p>ServerLimit默认是16,最大20000;ThreadLimit默认是64,最大20000。<br>通过上面的叙述，可以了解到Apache 2.0中prefork和worker这两个重要MPM的工作原理，并可根据实际情况来配置Apache相关的核心参数，以获得最大的性能和稳定性。</p>\n","excerpt":"<p>##什么是MPM？ </p>\n<p>MPM（Multi -Processing Modules，多路处理模块）是Apache2.x中影响性能的最核心特性。 </p>\n<p>是Apache 2.x才支持的一个可插入的并发模型，在编译的时候，我们只可以选择一个并发模型。 </p>\n<p>配置文件：/usr/local/apache2/conf/extra/httpd-mpm.conf </p>\n<p>如果apache是默认安装的可能配置在httpd.conf文件中。根据实际情况查找配置。 </p>\n<p>使用格式：<br>进入apache的目录，对apache进行如下编译： </p>\n<p>Linux代码   </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./configure --help|grep mpm</div></pre></td></tr></table></figure>","more":"<p>显示内容如下： </p>\n<p>Linux代码   </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t--with-mpm=MPM  </div><div class=\"line\">\tChoose the process model <span class=\"keyword\">for</span> Apache to use.  </div><div class=\"line\">\tMPM=&#123;beos|worker|prefork|mpmt_os2| perchild|leader|threadpool&#125; </div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">* 1、beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM。 </div><div class=\"line\"></div><div class=\"line\">* 2、perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程，这在运行多个需要CGI的虚拟主机时特别有用，会比1.3版中的SuExec 机制做得更好。 </div><div class=\"line\"></div><div class=\"line\">* 3、leader和threadpool都是基于worker的变体，还处于实验性阶段，某些情况下并不会按照预期设想的那样工作，所以 Apache官方也并不推荐使用。 </div><div class=\"line\"></div><div class=\"line\">* 4、prefork如果不用“–with-mpm ”显式指定某种MPM，prefork就是LInux/Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程，2.0版使用它是为了与1.3版保持兼容性；另一方面，prefork用单独的子进程来处理不同的请求，进程之间是彼此独立的，这也使其成为最稳定的MPM之一。  </div><div class=\"line\">prefork的工作原理是，控制进程在最初建立“StartServers”个子进程后,为了满足M<span class=\"keyword\">in</span>SpareServers设置的需要创建一个进程,等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个，直到满足M<span class=\"keyword\">in</span>SpareServers设置的值为止。这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。 </div><div class=\"line\"></div><div class=\"line\">* 5、worker相对于prefork,worker是2.x版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理,所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器.但是，worker也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.x的发展趋势。    </div><div class=\"line\">worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild 线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，M<span class=\"keyword\">in</span>SpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">##如何判断当前的服务器使用那种MPM 模块? </span></div><div class=\"line\">若使用prefork，在make编译和make install安装后，使用“httpd <span class=\"_\">-l</span>”来确定当前使用的MPM， </div><div class=\"line\">如下示:    </div><div class=\"line\"></div><div class=\"line\">```sh</div><div class=\"line\">\t[aaron@webslave1 extra]$ /usr/<span class=\"built_in\">local</span>/apache2/bin/httpd <span class=\"_\">-l</span> </div><div class=\"line\">\tCompiled <span class=\"keyword\">in</span> modules: </div><div class=\"line\">\tcore.c </div><div class=\"line\">\t...... </div><div class=\"line\">\tprefork.c </div><div class=\"line\">\t......</div></pre></td></tr></table></figure>\n<p>应该会看到prefork.c（如果看到worker.c说明使用的是worker MPM，依此类推）。再查看缺省生成的httpd.conf配置文件，里面包含如下配置段： </p>\n<p>Linux代码     </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">prefork.c</span>&gt;</span>  </div><div class=\"line\">StartServers 5  </div><div class=\"line\">MinSpareServers 5  </div><div class=\"line\">MaxSpareServers 10  最大的空闲进程数 </div><div class=\"line\">MaxClients 150  Apache可以同时处理的请求(最重要)--即为常说的并发连接数!! </div><div class=\"line\">MaxRequestsPerChild 0  每个子进程可处理的请求数 </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>MaxSpareServers设置了最大的空闲进程数，如果空闲进程数大于这个值，Apache会自动kill掉一些多余进程。这个值不要设得过大，但如果设的值比MinSpareServers小，Apache会自动把其调整为MinSpareServers+1。如果站点负载较大，可考虑同时加大MinSpareServers和MaxSpareServers。 </p>\n<p>MaxRequestsPerChild设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxRequestsPerChild”个请求后将自动销毁。0意味着无限，即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求，但如果设成非零值也有两点重要的好处： </p>\n<p>可防止意外的内存泄漏；<br>在服务器负载下降的时侯会自动减少子进程数。 </p>\n<p>因此，可根据服务器的负载来调整这个值。笔者认为10000左右比较合适。 </p>\n<p>MaxClients是这些指令中最为重要的一个，设定的是Apache可以同时处理的请求，是对Apache性能影响最大的参数。<br>其缺省值150是远远不够的，如果请求总数已达到这个值（可通过ps -ef|grep http|wc -l来确认），那么后面的请求就要排队，直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。系统管理员可以根据硬件配置和负载情况来动态调整这个值。<br>虽然理论上这个值越大，可以处理的请求就越多，但Apache默认的限制不能大于256。如果把这个值设为大于256，那么Apache将无法起动。事实上，256对于负载稍重的站点也是不够的。在Apache 1.3中，这是个硬限制。如果要加大这个值，必须在“configure”前手工修改的源代码树下的src/include/httpd.h中查找256，就会发现“#define HARD_SERVER_LIMIT 256”这行。把256改为要增大的值（如4000），然后重新编译Apache即可。在Apache 2.0中新加入了ServerLimit指令，使得无须重编译Apache就可以加大MaxClients。下面是笔者的prefork配置段： </p>\n<p>Linux代码 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">prefork.c</span>&gt;</span>  </div><div class=\"line\">StartServers 10  </div><div class=\"line\">MinSpareServers 10  </div><div class=\"line\">MaxSpareServers 15  </div><div class=\"line\">ServerLimit 20000  </div><div class=\"line\">MaxClients 1000  </div><div class=\"line\">MaxRequestsPerChild 10000  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　上述配置中，ServerLimit的最大值是20000，对于大多数站点已经足够。如果一定要再加大这个数值，对位于源代码目录下<br>/httpd-2.2.15/server/mpm/prefork/prefork.c中以下两行做相应修改即可：<br>Linux代码    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_SERVER_LIMIT 256  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_SERVER_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置了所有子进程中的线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。 </p>\n<p>MinSpareThreads和MaxSpareThreads的最大缺省值分别是75和250。这两个参数对Apache的性能影响并不大，可以按照实际情况相应调节。<br>ThreadsPerChild是worker MPM中与性能相关最密切的指令。ThreadsPerChild的最大缺省值是64，如果负载较大，64也是不够的。这时要显式使用ThreadLimit指令，它的最大缺省值是20000。上述两个值位于源码树server/mpm/worker/worker.c中的以下两行： </p>\n<p>Linux代码    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_THREAD_LIMIT 64  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_THREAD_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>这两行对应着ThreadsPerChild和ThreadLimit的限制数。最好在configure之前就把64改成所希望的值。注意，不要把这两个值设得太高，超过系统的处理能力，从而因Apache不起动使系统很不稳定。<br>Worker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的，应该大于等于MaxClients。如果负载很大，现有的子进程数不能满足时，控制进程会派生新的子进程。默认最大的子进程总数是16，加大时也需要显式声明ServerLimit（最大值是20000）。这两个值位于源码树server/mpm/worker/worker.c中的以下两行： </p>\n<p>Linux代码     </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#define DEFAULT_SERVER_LIMIT 16  </span></div><div class=\"line\"><span class=\"comment\">#define MAX_SERVER_LIMIT 20000</span></div></pre></td></tr></table></figure>\n<p>需要注意的是，如果显式声明了ServerLimit，那么它乘以ThreadsPerChild的值必须大于等于MaxClients，而且MaxClients必须是ThreadsPerChild的整数倍，否则Apache将会自动调节到一个相应值（可能是个非期望值）。下面是笔者的worker配置段： </p>\n<p>Linux代码  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">worker.c</span>&gt;</span>  </div><div class=\"line\">StartServers 3  </div><div class=\"line\">MaxClients 2000  </div><div class=\"line\">ServerLimit 25  </div><div class=\"line\">MinSpareThreads 50  </div><div class=\"line\">MaxSpareThreads 200  </div><div class=\"line\">ThreadLimit 200  </div><div class=\"line\">ThreadsPerChild 100  </div><div class=\"line\">MaxRequestsPerChild 0  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>硬性公式：  </p>\n<pre><code>ThreadLimit &gt;= ThreadsPerChild\nMaxClients &lt;= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数\nMaxSpareThreads &gt;= MinSpareThreads+ThreadsPerChild\n</code></pre><p>ServerLimit默认是16,最大20000;ThreadLimit默认是64,最大20000。<br>通过上面的叙述，可以了解到Apache 2.0中prefork和worker这两个重要MPM的工作原理，并可根据实际情况来配置Apache相关的核心参数，以获得最大的性能和稳定性。</p>"},{"layout":"post","title":"selenium FAQ:如何处理JavaScript弹出的alert、prompt窗口","date":"2012-10-12T06:39:00.000Z","comments":1,"_content":"##经常会碰到，页面操作后，出现一个alert窗口或者prompt确认窗口的情况，这时需要获得窗口的提示信息以及点击确定或取消的情况。\n\t// Get a handle to the open alert, prompt or confirmation\n\tAlert alert = driver.switchTo().alert();\n\t// Get the text of the alert or prompt\n\talert.getText();  \n\t// And acknowledge the alert (equivalent to clicking \"OK\")\n\talert.accept();\n这是通用的处理方法。但是如果弹出的窗口不是`alert()`或者`prompt()`弹出来的则不适用。请注意。","source":"_posts/2012-10-12-selenium-faq-alerts-and-prompts.markdown","raw":"---\nlayout: post\ntitle: \"selenium FAQ:如何处理JavaScript弹出的alert、prompt窗口\"\ndate: 2012-10-12 14:39\ncomments: true\ncategories: selenium\ntags: [ webdriver , selenium , alert , FAQ ]\n---\n##经常会碰到，页面操作后，出现一个alert窗口或者prompt确认窗口的情况，这时需要获得窗口的提示信息以及点击确定或取消的情况。\n\t// Get a handle to the open alert, prompt or confirmation\n\tAlert alert = driver.switchTo().alert();\n\t// Get the text of the alert or prompt\n\talert.getText();  \n\t// And acknowledge the alert (equivalent to clicking \"OK\")\n\talert.accept();\n这是通用的处理方法。但是如果弹出的窗口不是`alert()`或者`prompt()`弹出来的则不适用。请注意。","slug":"2012-10-12-selenium-faq-alerts-and-prompts","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1i000ev8fy0vwvvldj","content":"<p>##经常会碰到，页面操作后，出现一个alert窗口或者prompt确认窗口的情况，这时需要获得窗口的提示信息以及点击确定或取消的情况。<br>    // Get a handle to the open alert, prompt or confirmation<br>    Alert alert = driver.switchTo().alert();<br>    // Get the text of the alert or prompt<br>    alert.getText();<br>    // And acknowledge the alert (equivalent to clicking “OK”)<br>    alert.accept();<br>这是通用的处理方法。但是如果弹出的窗口不是<code>alert()</code>或者<code>prompt()</code>弹出来的则不适用。请注意。</p>\n","excerpt":"","more":"<p>##经常会碰到，页面操作后，出现一个alert窗口或者prompt确认窗口的情况，这时需要获得窗口的提示信息以及点击确定或取消的情况。<br>    // Get a handle to the open alert, prompt or confirmation<br>    Alert alert = driver.switchTo().alert();<br>    // Get the text of the alert or prompt<br>    alert.getText();<br>    // And acknowledge the alert (equivalent to clicking “OK”)<br>    alert.accept();<br>这是通用的处理方法。但是如果弹出的窗口不是<code>alert()</code>或者<code>prompt()</code>弹出来的则不适用。请注意。</p>\n"},{"layout":"post","title":"selenium FAQ:怎么样调用Javascript？","date":"2012-10-12T06:30:00.000Z","comments":1,"_content":"##selenium自动化开发中，难免需要用到直接调用javascript，怎么用呢？\n\tWebDriver driver; // Assigned elsewhere\n\tJavascriptExecutor js = (JavascriptExecutor) driver;\n\tjs.executeScript(\"return document.title\");\n直接将driver强制转化为JavascriptExecutor,然后执行javascript即可。\n","source":"_posts/2012-10-12-selenium-faq-how-to-use-javascript.markdown","raw":"---\nlayout: post\ntitle: \"selenium FAQ:怎么样调用Javascript？\"\ndate: 2012-10-12 14:30\ncomments: true\ncategories: selenium\ntags: [ webdriver, selenium, JavaScript ]\n---\n##selenium自动化开发中，难免需要用到直接调用javascript，怎么用呢？\n\tWebDriver driver; // Assigned elsewhere\n\tJavascriptExecutor js = (JavascriptExecutor) driver;\n\tjs.executeScript(\"return document.title\");\n直接将driver强制转化为JavascriptExecutor,然后执行javascript即可。\n","slug":"2012-10-12-selenium-faq-how-to-use-javascript","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1k000fv8fy0ybvkfo6","content":"<p>##selenium自动化开发中，难免需要用到直接调用javascript，怎么用呢？<br>    WebDriver driver; // Assigned elsewhere<br>    JavascriptExecutor js = (JavascriptExecutor) driver;<br>    js.executeScript(“return document.title”);<br>直接将driver强制转化为JavascriptExecutor,然后执行javascript即可。</p>\n","excerpt":"","more":"<p>##selenium自动化开发中，难免需要用到直接调用javascript，怎么用呢？<br>    WebDriver driver; // Assigned elsewhere<br>    JavascriptExecutor js = (JavascriptExecutor) driver;<br>    js.executeScript(“return document.title”);<br>直接将driver强制转化为JavascriptExecutor,然后执行javascript即可。</p>\n"},{"layout":"post","title":"Selenium WebDriver的多浏览器支持","date":"2012-10-12T06:56:00.000Z","comments":1,"_content":"##Selenium WebDriver支持哪儿些浏览器？\n按照官方文档的说法，现阶段有以下的drivers: \n>* ChromeDriver  \n>* InternetExplorerDriver   \n>* FirefoxDriver   \n>* OperaDriver   \n>* HtmlUnitDriver   \n>* AndroidDriver(mobile testing)  \n>* OperaMobileDriver(mobile testing)  \n>* IPhoneDriver(mobile testing)   \n<!--more-->   \n\n##为什么selenium自动化case在一个浏览器运行的很好，换为另外一个浏览器则不行？   \n###一个Driver可以打开浏览器，另外一个Driver却不行？   \nWebDriver是通过调用native浏览器来操作的，浏览器之间的差异注定会出现一些问题。下面以InternetExplorer,Firefox,Chrome为例进行说明：  \n####InternetExplorer：  \n> 1.它分不同的版本，版本之间差异很大。InternetExplorerDriver支持IE6、7、8、9。操作系统支持XP、Vista、Windows 7。   \n>2.InternetExplorerDriver同时支持32/64bit的浏览器，这个取决于你用的是什么版本的[IEDriverServer.exe](http://code.google.com/p/selenium/downloads/list)。   \n>3.要求条件如下：\n>>* [IEDriverServer](http://code.google.com/p/selenium/downloads/list)在系统环境的PATH内（selenium2.26.0+版本推荐方式）。或者设置`webdriver.ie.driver`系统属性。   \n\t `System.setProperty(\"webdriver.ie.driver\", \"D:\\\\IEDriverServer.exe\");`  \n\t` WebDriver driver = new InternetExplorerDriver();`\n>>* 在windows vista、windows7操作系统中，如果使用IE7+的浏览器，应该保证浏览器的**保护模式**都处于**同一状态**[开启或者关闭]。如果不一致，那么报错信息类似于`Caused by: org.openqa.selenium.WebDriverException: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones. (WARNING: The server did not provide any stacktrace information)`   \n不会设置吗？   \n操作如下：打开浏览器->Internet选项 ->安全->启用保护模式。保证Internet、本地Intranet、受信任的站点、受限制的站点4个zone保护模式一致就OK   \n>>* 为了确保能获得正确的坐标点，要把浏览器的缩放设为100%。   \n设置方法：打开浏览器->页面->缩放(Z)->100%   \n\n参考<http://code.google.com/p/selenium/wiki/InternetExplorerDriver>\n\n#### Firefox:  \n>1.Firefox不像InternetExplorer一样，用户可以自定义安装路径。因此使用时，需要制定firefox.exe的安装路径。  \n怎么指定?\n>>+ java code: `System.setProperty()`   \n>>+ 命令行：`-DpropertyName='value'`   \n\n\n>2.系统变量的值为：`webdriver.firefox.bin`，以及其他的key值，详见参考页面。webdriver.firefox.bin用来指定Firefox的安装路径。如不设置，默认从%PROGRAMFILES%\\Mozilla Firefox\\firefox.exe加载。**个人强烈建议，即使安装在默认路径也进行指定**。   \n>3.Java代码如下：  \n\tSystem.setProperty(\"webdriver.firefox.bin\", \"C://Mozila/firefox.exe\"); \t\n    WebDriver driver = new FirefoxDriver();  \n>其中firefox的安装路径，按情况自行替换。\n\n参考<http://code.google.com/p/selenium/wiki/FirefoxDriver>   \n####Chrome:   \nchrome要求条件如下：\n>1.Chrome应当安装在默认路径下（如果是从官方下载的，安装后直接都是默认路径）。\n><table border=”1px\">\n<tbody>\n<tr><td>OS</td><td>默认位置</td></tr>\n<tr><td>Linux</td><td>/usr/bin/google-chrome</td></tr>\n<tr><td>Mac</td><td>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome</td></tr>\n<tr><td>Windwos XP</td><td>%HOMEPATH%\\Local Settings\\Application Data\\Google\\Chrome\\Application\\chrome.exe</td></tr>\n<tr><td>Windwos Vista</td><td>C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe</td></tr>\n</tbody>\n</table>    \n>2.需要下载相应版本的[chromedriver](http://code.google.com/p/chromedriver/downloads/list)，用来架起chrome浏览器与webdriver之间的桥梁。   \n>3.与FirefoxDriver差不多，需要设置chromedriver的路径。key值为：webdriver.chrome.driver.   \n>4.Java代码如下：   \n\tSystem.setProperty(\"webdriver.chrome.driver\", \"C://drivers/chromedriver.exe\"); \t\n    WebDriver driver = new ChromeDriver();    \n需要注意的是，chrome浏览器会自动更新，而[chromedriver](http://code.google.com/p/chromedriver/downloads/list)也是不断更新的。如果chrome版本太新，而chromedriver没有相应的更换，会造成只是打开chrome浏览器，而不进行任何操作的问题。另外，ChromeDriver只适用于chrome 12.0.712.0+,如果需要使用更老的版本，见参考页面的详细描述。   \n \n参考<http://code.google.com/p/selenium/wiki/ChromeDriver>   \n\n###在一个浏览器里，元素可以找到或者可以操作，而在另外一个浏览器内则不行，为什么？\n不同浏览器之间解析DOM以及响应事件的机制不同，难免会有一些不兼容性。解决方法：\n>1.元素定位，通常是由于DOM解析不同造成的，可以使用不同的findElement方法进行实验，如id,class,xpath等。这个没有统一的结论，大多数情况下id是最靠谱的。**推荐！**   \n>2.事件的响应，这个如果存在问题，一般比较难解决。通常是由于浏览器之间的差异造成的。可以通过使用selenium更高的版本，或者更换浏览器的版本来解决。或者想一下，有没有其他的方式，换个事件来绕过去，总有办法的。如果实在解决不了，那也只能暂时是这样了。","source":"_posts/2012-10-12-selenium-multiple-browser-support.markdown","raw":"---\nlayout: post\ntitle: \"Selenium WebDriver的多浏览器支持\"\ndate: 2012-10-12 14:56\ncomments: true\ncategories: selenium\ntags: [ webdriver, selenium, Firefox, Chrome, Driver ]\n---\n##Selenium WebDriver支持哪儿些浏览器？\n按照官方文档的说法，现阶段有以下的drivers: \n>* ChromeDriver  \n>* InternetExplorerDriver   \n>* FirefoxDriver   \n>* OperaDriver   \n>* HtmlUnitDriver   \n>* AndroidDriver(mobile testing)  \n>* OperaMobileDriver(mobile testing)  \n>* IPhoneDriver(mobile testing)   \n<!--more-->   \n\n##为什么selenium自动化case在一个浏览器运行的很好，换为另外一个浏览器则不行？   \n###一个Driver可以打开浏览器，另外一个Driver却不行？   \nWebDriver是通过调用native浏览器来操作的，浏览器之间的差异注定会出现一些问题。下面以InternetExplorer,Firefox,Chrome为例进行说明：  \n####InternetExplorer：  \n> 1.它分不同的版本，版本之间差异很大。InternetExplorerDriver支持IE6、7、8、9。操作系统支持XP、Vista、Windows 7。   \n>2.InternetExplorerDriver同时支持32/64bit的浏览器，这个取决于你用的是什么版本的[IEDriverServer.exe](http://code.google.com/p/selenium/downloads/list)。   \n>3.要求条件如下：\n>>* [IEDriverServer](http://code.google.com/p/selenium/downloads/list)在系统环境的PATH内（selenium2.26.0+版本推荐方式）。或者设置`webdriver.ie.driver`系统属性。   \n\t `System.setProperty(\"webdriver.ie.driver\", \"D:\\\\IEDriverServer.exe\");`  \n\t` WebDriver driver = new InternetExplorerDriver();`\n>>* 在windows vista、windows7操作系统中，如果使用IE7+的浏览器，应该保证浏览器的**保护模式**都处于**同一状态**[开启或者关闭]。如果不一致，那么报错信息类似于`Caused by: org.openqa.selenium.WebDriverException: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones. (WARNING: The server did not provide any stacktrace information)`   \n不会设置吗？   \n操作如下：打开浏览器->Internet选项 ->安全->启用保护模式。保证Internet、本地Intranet、受信任的站点、受限制的站点4个zone保护模式一致就OK   \n>>* 为了确保能获得正确的坐标点，要把浏览器的缩放设为100%。   \n设置方法：打开浏览器->页面->缩放(Z)->100%   \n\n参考<http://code.google.com/p/selenium/wiki/InternetExplorerDriver>\n\n#### Firefox:  \n>1.Firefox不像InternetExplorer一样，用户可以自定义安装路径。因此使用时，需要制定firefox.exe的安装路径。  \n怎么指定?\n>>+ java code: `System.setProperty()`   \n>>+ 命令行：`-DpropertyName='value'`   \n\n\n>2.系统变量的值为：`webdriver.firefox.bin`，以及其他的key值，详见参考页面。webdriver.firefox.bin用来指定Firefox的安装路径。如不设置，默认从%PROGRAMFILES%\\Mozilla Firefox\\firefox.exe加载。**个人强烈建议，即使安装在默认路径也进行指定**。   \n>3.Java代码如下：  \n\tSystem.setProperty(\"webdriver.firefox.bin\", \"C://Mozila/firefox.exe\"); \t\n    WebDriver driver = new FirefoxDriver();  \n>其中firefox的安装路径，按情况自行替换。\n\n参考<http://code.google.com/p/selenium/wiki/FirefoxDriver>   \n####Chrome:   \nchrome要求条件如下：\n>1.Chrome应当安装在默认路径下（如果是从官方下载的，安装后直接都是默认路径）。\n><table border=”1px\">\n<tbody>\n<tr><td>OS</td><td>默认位置</td></tr>\n<tr><td>Linux</td><td>/usr/bin/google-chrome</td></tr>\n<tr><td>Mac</td><td>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome</td></tr>\n<tr><td>Windwos XP</td><td>%HOMEPATH%\\Local Settings\\Application Data\\Google\\Chrome\\Application\\chrome.exe</td></tr>\n<tr><td>Windwos Vista</td><td>C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe</td></tr>\n</tbody>\n</table>    \n>2.需要下载相应版本的[chromedriver](http://code.google.com/p/chromedriver/downloads/list)，用来架起chrome浏览器与webdriver之间的桥梁。   \n>3.与FirefoxDriver差不多，需要设置chromedriver的路径。key值为：webdriver.chrome.driver.   \n>4.Java代码如下：   \n\tSystem.setProperty(\"webdriver.chrome.driver\", \"C://drivers/chromedriver.exe\"); \t\n    WebDriver driver = new ChromeDriver();    \n需要注意的是，chrome浏览器会自动更新，而[chromedriver](http://code.google.com/p/chromedriver/downloads/list)也是不断更新的。如果chrome版本太新，而chromedriver没有相应的更换，会造成只是打开chrome浏览器，而不进行任何操作的问题。另外，ChromeDriver只适用于chrome 12.0.712.0+,如果需要使用更老的版本，见参考页面的详细描述。   \n \n参考<http://code.google.com/p/selenium/wiki/ChromeDriver>   \n\n###在一个浏览器里，元素可以找到或者可以操作，而在另外一个浏览器内则不行，为什么？\n不同浏览器之间解析DOM以及响应事件的机制不同，难免会有一些不兼容性。解决方法：\n>1.元素定位，通常是由于DOM解析不同造成的，可以使用不同的findElement方法进行实验，如id,class,xpath等。这个没有统一的结论，大多数情况下id是最靠谱的。**推荐！**   \n>2.事件的响应，这个如果存在问题，一般比较难解决。通常是由于浏览器之间的差异造成的。可以通过使用selenium更高的版本，或者更换浏览器的版本来解决。或者想一下，有没有其他的方式，换个事件来绕过去，总有办法的。如果实在解决不了，那也只能暂时是这样了。","slug":"2012-10-12-selenium-multiple-browser-support","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1m000jv8fy90cp8cvm","content":"<p>##Selenium WebDriver支持哪儿些浏览器？<br>按照官方文档的说法，现阶段有以下的drivers: </p>\n<blockquote>\n<ul>\n<li>ChromeDriver  </li>\n<li>InternetExplorerDriver   </li>\n<li>FirefoxDriver   </li>\n<li>OperaDriver   </li>\n<li>HtmlUnitDriver   </li>\n<li>AndroidDriver(mobile testing)  </li>\n<li>OperaMobileDriver(mobile testing)  </li>\n<li>IPhoneDriver(mobile testing)   <a id=\"more\"></a>   \n</li>\n</ul>\n</blockquote>\n<p>##为什么selenium自动化case在一个浏览器运行的很好，换为另外一个浏览器则不行？   </p>\n<p>###一个Driver可以打开浏览器，另外一个Driver却不行？<br>WebDriver是通过调用native浏览器来操作的，浏览器之间的差异注定会出现一些问题。下面以InternetExplorer,Firefox,Chrome为例进行说明：  </p>\n<p>####InternetExplorer：  </p>\n<blockquote>\n<p>1.它分不同的版本，版本之间差异很大。InternetExplorerDriver支持IE6、7、8、9。操作系统支持XP、Vista、Windows 7。<br>2.InternetExplorerDriver同时支持32/64bit的浏览器，这个取决于你用的是什么版本的<a href=\"http://code.google.com/p/selenium/downloads/list\" target=\"_blank\" rel=\"external\">IEDriverServer.exe</a>。<br>3.要求条件如下：</p>\n<blockquote>\n<ul>\n<li><a href=\"http://code.google.com/p/selenium/downloads/list\" target=\"_blank\" rel=\"external\">IEDriverServer</a>在系统环境的PATH内（selenium2.26.0+版本推荐方式）。或者设置<code>webdriver.ie.driver</code>系统属性。<br>   <code>System.setProperty(&quot;webdriver.ie.driver&quot;, &quot;D:\\\\IEDriverServer.exe&quot;);</code><br>  <code>WebDriver driver = new InternetExplorerDriver();</code></li>\n<li>在windows vista、windows7操作系统中，如果使用IE7+的浏览器，应该保证浏览器的<strong>保护模式</strong>都处于<strong>同一状态</strong>[开启或者关闭]。如果不一致，那么报错信息类似于<code>Caused by: org.openqa.selenium.WebDriverException: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones. (WARNING: The server did not provide any stacktrace information)</code><br>不会设置吗？<br>操作如下：打开浏览器-&gt;Internet选项 -&gt;安全-&gt;启用保护模式。保证Internet、本地Intranet、受信任的站点、受限制的站点4个zone保护模式一致就OK   </li>\n<li>为了确保能获得正确的坐标点，要把浏览器的缩放设为100%。<br>设置方法：打开浏览器-&gt;页面-&gt;缩放(Z)-&gt;100%   </li>\n</ul>\n</blockquote>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/InternetExplorerDriver\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/wiki/InternetExplorerDriver</a></p>\n<h4 id=\"Firefox\"><a href=\"#Firefox\" class=\"headerlink\" title=\"Firefox:\"></a>Firefox:</h4><blockquote>\n<p>1.Firefox不像InternetExplorer一样，用户可以自定义安装路径。因此使用时，需要制定firefox.exe的安装路径。<br>怎么指定?</p>\n<blockquote>\n<ul>\n<li>java code: <code>System.setProperty()</code>   </li>\n<li>命令行：<code>-DpropertyName=&#39;value&#39;</code>   </li>\n</ul>\n</blockquote>\n<p>2.系统变量的值为：<code>webdriver.firefox.bin</code>，以及其他的key值，详见参考页面。webdriver.firefox.bin用来指定Firefox的安装路径。如不设置，默认从%PROGRAMFILES%\\Mozilla Firefox\\firefox.exe加载。<strong>个人强烈建议，即使安装在默认路径也进行指定</strong>。<br>3.Java代码如下：<br>    System.setProperty(“webdriver.firefox.bin”, “C://Mozila/firefox.exe”);<br>    WebDriver driver = new FirefoxDriver();<br>其中firefox的安装路径，按情况自行替换。</p>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/FirefoxDriver\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/wiki/FirefoxDriver</a>   </p>\n<p>####Chrome:<br>chrome要求条件如下：</p>\n<blockquote>\n<p>1.Chrome应当安装在默认路径下（如果是从官方下载的，安装后直接都是默认路径）。</p>\n<p>&lt;table border=”1px”&gt;</p>\n<p><tbody></tbody></p>\n<p><tr><td>OS</td><td>默认位置</td></tr></p>\n<p><tr><td>Linux</td><td>/usr/bin/google-chrome</td></tr></p>\n<p><tr><td>Mac</td><td>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome</td></tr></p>\n<p><tr><td>Windwos XP</td><td>%HOMEPATH%\\Local Settings\\Application Data\\Google\\Chrome\\Application\\chrome.exe</td></tr></p>\n<p><tr><td>Windwos Vista</td><td>C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe</td></tr><br><br><br>2.需要下载相应版本的<a href=\"http://code.google.com/p/chromedriver/downloads/list\" target=\"_blank\" rel=\"external\">chromedriver</a>，用来架起chrome浏览器与webdriver之间的桥梁。<br>3.与FirefoxDriver差不多，需要设置chromedriver的路径。key值为：webdriver.chrome.driver.<br>4.Java代码如下：<br>    System.setProperty(“webdriver.chrome.driver”, “C://drivers/chromedriver.exe”);<br>    WebDriver driver = new ChromeDriver();<br>需要注意的是，chrome浏览器会自动更新，而<a href=\"http://code.google.com/p/chromedriver/downloads/list\" target=\"_blank\" rel=\"external\">chromedriver</a>也是不断更新的。如果chrome版本太新，而chromedriver没有相应的更换，会造成只是打开chrome浏览器，而不进行任何操作的问题。另外，ChromeDriver只适用于chrome 12.0.712.0+,如果需要使用更老的版本，见参考页面的详细描述。   </p>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/wiki/ChromeDriver</a>   </p>\n<p>###在一个浏览器里，元素可以找到或者可以操作，而在另外一个浏览器内则不行，为什么？<br>不同浏览器之间解析DOM以及响应事件的机制不同，难免会有一些不兼容性。解决方法：</p>\n<blockquote>\n<p>1.元素定位，通常是由于DOM解析不同造成的，可以使用不同的findElement方法进行实验，如id,class,xpath等。这个没有统一的结论，大多数情况下id是最靠谱的。<strong>推荐！</strong><br>2.事件的响应，这个如果存在问题，一般比较难解决。通常是由于浏览器之间的差异造成的。可以通过使用selenium更高的版本，或者更换浏览器的版本来解决。或者想一下，有没有其他的方式，换个事件来绕过去，总有办法的。如果实在解决不了，那也只能暂时是这样了。</p>\n</blockquote>\n","excerpt":"<p>##Selenium WebDriver支持哪儿些浏览器？<br>按照官方文档的说法，现阶段有以下的drivers: </p>\n<blockquote>\n<ul>\n<li>ChromeDriver  </li>\n<li>InternetExplorerDriver   </li>\n<li>FirefoxDriver   </li>\n<li>OperaDriver   </li>\n<li>HtmlUnitDriver   </li>\n<li>AndroidDriver(mobile testing)  </li>\n<li>OperaMobileDriver(mobile testing)  </li>\n<li>IPhoneDriver(mobile testing)","more":"</li>\n</ul>\n</blockquote>\n<p>##为什么selenium自动化case在一个浏览器运行的很好，换为另外一个浏览器则不行？   </p>\n<p>###一个Driver可以打开浏览器，另外一个Driver却不行？<br>WebDriver是通过调用native浏览器来操作的，浏览器之间的差异注定会出现一些问题。下面以InternetExplorer,Firefox,Chrome为例进行说明：  </p>\n<p>####InternetExplorer：  </p>\n<blockquote>\n<p>1.它分不同的版本，版本之间差异很大。InternetExplorerDriver支持IE6、7、8、9。操作系统支持XP、Vista、Windows 7。<br>2.InternetExplorerDriver同时支持32/64bit的浏览器，这个取决于你用的是什么版本的<a href=\"http://code.google.com/p/selenium/downloads/list\">IEDriverServer.exe</a>。<br>3.要求条件如下：</p>\n<blockquote>\n<ul>\n<li><a href=\"http://code.google.com/p/selenium/downloads/list\">IEDriverServer</a>在系统环境的PATH内（selenium2.26.0+版本推荐方式）。或者设置<code>webdriver.ie.driver</code>系统属性。<br>   <code>System.setProperty(&quot;webdriver.ie.driver&quot;, &quot;D:\\\\IEDriverServer.exe&quot;);</code><br>  <code>WebDriver driver = new InternetExplorerDriver();</code></li>\n<li>在windows vista、windows7操作系统中，如果使用IE7+的浏览器，应该保证浏览器的<strong>保护模式</strong>都处于<strong>同一状态</strong>[开启或者关闭]。如果不一致，那么报错信息类似于<code>Caused by: org.openqa.selenium.WebDriverException: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones. (WARNING: The server did not provide any stacktrace information)</code><br>不会设置吗？<br>操作如下：打开浏览器-&gt;Internet选项 -&gt;安全-&gt;启用保护模式。保证Internet、本地Intranet、受信任的站点、受限制的站点4个zone保护模式一致就OK   </li>\n<li>为了确保能获得正确的坐标点，要把浏览器的缩放设为100%。<br>设置方法：打开浏览器-&gt;页面-&gt;缩放(Z)-&gt;100%   </li>\n</ul>\n</blockquote>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/InternetExplorerDriver\">http://code.google.com/p/selenium/wiki/InternetExplorerDriver</a></p>\n<h4 id=\"Firefox\"><a href=\"#Firefox\" class=\"headerlink\" title=\"Firefox:\"></a>Firefox:</h4><blockquote>\n<p>1.Firefox不像InternetExplorer一样，用户可以自定义安装路径。因此使用时，需要制定firefox.exe的安装路径。<br>怎么指定?</p>\n<blockquote>\n<ul>\n<li>java code: <code>System.setProperty()</code>   </li>\n<li>命令行：<code>-DpropertyName=&#39;value&#39;</code>   </li>\n</ul>\n</blockquote>\n<p>2.系统变量的值为：<code>webdriver.firefox.bin</code>，以及其他的key值，详见参考页面。webdriver.firefox.bin用来指定Firefox的安装路径。如不设置，默认从%PROGRAMFILES%\\Mozilla Firefox\\firefox.exe加载。<strong>个人强烈建议，即使安装在默认路径也进行指定</strong>。<br>3.Java代码如下：<br>    System.setProperty(“webdriver.firefox.bin”, “C://Mozila/firefox.exe”);<br>    WebDriver driver = new FirefoxDriver();<br>其中firefox的安装路径，按情况自行替换。</p>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/FirefoxDriver\">http://code.google.com/p/selenium/wiki/FirefoxDriver</a>   </p>\n<p>####Chrome:<br>chrome要求条件如下：</p>\n<blockquote>\n<p>1.Chrome应当安装在默认路径下（如果是从官方下载的，安装后直接都是默认路径）。</p>\n<p>&lt;table border=”1px”&gt;</p>\n<p><tbody></p>\n<p><tr><td>OS</td><td>默认位置</td></tr></p>\n<p><tr><td>Linux</td><td>/usr/bin/google-chrome</td></tr></p>\n<p><tr><td>Mac</td><td>/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome</td></tr></p>\n<p><tr><td>Windwos XP</td><td>%HOMEPATH%\\Local Settings\\Application Data\\Google\\Chrome\\Application\\chrome.exe</td></tr></p>\n<p><tr><td>Windwos Vista</td><td>C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe</td></tr><br></tbody><br></table><br>2.需要下载相应版本的<a href=\"http://code.google.com/p/chromedriver/downloads/list\">chromedriver</a>，用来架起chrome浏览器与webdriver之间的桥梁。<br>3.与FirefoxDriver差不多，需要设置chromedriver的路径。key值为：webdriver.chrome.driver.<br>4.Java代码如下：<br>    System.setProperty(“webdriver.chrome.driver”, “C://drivers/chromedriver.exe”);<br>    WebDriver driver = new ChromeDriver();<br>需要注意的是，chrome浏览器会自动更新，而<a href=\"http://code.google.com/p/chromedriver/downloads/list\">chromedriver</a>也是不断更新的。如果chrome版本太新，而chromedriver没有相应的更换，会造成只是打开chrome浏览器，而不进行任何操作的问题。另外，ChromeDriver只适用于chrome 12.0.712.0+,如果需要使用更老的版本，见参考页面的详细描述。   </p>\n</blockquote>\n<p>参考<a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\">http://code.google.com/p/selenium/wiki/ChromeDriver</a>   </p>\n<p>###在一个浏览器里，元素可以找到或者可以操作，而在另外一个浏览器内则不行，为什么？<br>不同浏览器之间解析DOM以及响应事件的机制不同，难免会有一些不兼容性。解决方法：</p>\n<blockquote>\n<p>1.元素定位，通常是由于DOM解析不同造成的，可以使用不同的findElement方法进行实验，如id,class,xpath等。这个没有统一的结论，大多数情况下id是最靠谱的。<strong>推荐！</strong><br>2.事件的响应，这个如果存在问题，一般比较难解决。通常是由于浏览器之间的差异造成的。可以通过使用selenium更高的版本，或者更换浏览器的版本来解决。或者想一下，有没有其他的方式，换个事件来绕过去，总有办法的。如果实在解决不了，那也只能暂时是这样了。</p>\n</blockquote>"},{"layout":"post","title":"PageObjects 设计模式","date":"2012-10-16T08:40:00.000Z","comments":1,"_content":"##什么是Page Objects(翻译为：页面对象？)...##\n简单的说，Page Objects是指UI界面上用于与用户进行交互的对象。它可以指整个页面，也可以指Page上的某个区域。Page Objects是你的test code的交互对象，是对实际UI的一种抽象模型化。通过Page Objects可以减少重复代码的编写，例如，很多页面都有同样的header，footer，navigator等部分，如果对这些进行抽象，只写一次就可以在其他地方通用了。  \n\n**注意PageObjects与Page Objects是不一样的**，PageObjects用于特指采用Page Objects进行封装的一种设计模式（Design Pattern）,而不仅仅是多一个空格的区别。哈。\n##如何实现PageObjects设计模式？##\n一般情况下，对于一个Page Objects对象，它有两个方面的特征：  \n \n* 自身元素(WebElement)  \n* 实现功能 (Services)  \n<!--more-->  \n\n自身元素很好理解，就是实实在在的页面元素。而Page Object通常也都是实现一定的功能的。就Test的开发人员来说，更关心的是Page Objects它们实现了什么交互功能，而不是其内部的实现，因此，这里的功能与开发人员理解的功能是**不一样的**。   \n\n以用户登录为例：在登录界面，点击登录后要么成功，转向首页。要么失败，出现提示出错信息。   \n相信这是一个很容易理解的场景吧！  \nJava Code可能类似如下：   \n\n```java\n\tpublic class LoginPage {\n\t\t//用户名录入框\n\t\tprivate WebElement usernameBox;\n\t\t//密码录入框\n\t\tprivate WebElement passwordBox;\n\t\t//提交按钮\n\t\tprivate WebElement submitButton;\n\n    \tpublic HomePage loginAs(String username, String password) {\n\t\t\tusernameBox.sendKeys(username);\n\t\t\tpasswordBox.sendKeys(password);\n\t\t\tsubmitButton.submit();\n        \treturn new HomePage(...)\n    \t}\n    \n    \tpublic LoginPage loginAsExpectingError(String username, String password) {\n       \t\t //  出错的username,password 仍留在LoginPage\n   \t\t }\n    \n    \tpublic String getErrorMessage() {\n        // 获取错误信息\n    \t}\n\t}  \n``` \n从上面可以看出，同时封装了元素以及功能。此处样例，元素是没有初始化的。可以通过类似于`driver.findElement()`的函数来直接进行初始化，另外WebDriver提供了一个PageFactory用于对PageObjects设计模式进行支持，下面将会讲到。  \n通过上面的这段代码，也展现出了一个重要的问题，那就是assertion不应该在Page Objects内部，而应该由tests进行处理。Page Objects只是返回需要验证的信息即可。\n\n##总结##\n* public方法代表Page提供的功能\n* 尽量不要暴露Page的内部细节\n* 不要assertion\n* 方法可以返回其他Page Objects\n* Page Objects不用代表整个页面，可以是任意一个部分\n* 一样的操作，不同的结果应该分开（正确登录，错误登录）   \n\n##样例##\n```java\t\n\tpublic class LoginPage {\n\t\tprivate final WebDriver driver;\n\t\t// 用户名录入框\n\t\tprivate WebElement usernameBox;\n\t\t// 密码录入框\n\t\tprivate WebElement passwordBox;\n\t\t// 提交按钮\n\t\tprivate WebElement submitButton;\n\n\t\tpublic LoginPage(WebDriver driver) {\n\t\t\tthis.driver = driver;\n\t\t\tif (!\"Login\".equals(driver.getTitle())) {\n\t\t\t\tthrow new IllegalStateException(\"This is not the login page\");\n\t\t\t}\n\t\t\tthis.usernameBox = driver.findElement(By.id(\"username\"));\n\t\t\tthis.passwordBox = driver.findElement(By.id(\"passwd\"));\n\t\t\tthis.submitButton = driver.findElement(By.id(\"login\"));\n\t\t}\n\n\t\tpublic HomePage loginAs(String username, String password) {\n\t\t\tusernameBox.sendKeys(username);\n\t\t\tpasswordBox.sendKeys(password);\n\t\t\tsubmitButton.submit();\n\t\t\treturn new HomePage(driver);\n\t\t}\n\t}\n```\n##PageFactory##\n从上面的样例中，有没有发现每个元素都要进行`driver.findElement()`这样的操作，写起来好累啊，一堆重复性的代码。有没有更好的，更优雅的处理方法呢？**`org.openqa.selenium.support.PageFactory`**就是用来负责处理这个的，真Happy!   \n下面以[百度搜索](http://www.baidu.com)作为样例场景，搜索一个关键字\n\n\t\n```java\n\timport org.openqa.selenium.WebDriver;\n\timport org.openqa.selenium.WebElement;\n\timport org.openqa.selenium.htmlunit.HtmlUnitDriver;\n\timport org.openqa.selenium.support.PageFactory;\n\timport org.slf4j.Logger;\n\timport org.slf4j.LoggerFactory;\n\n\t/**\n \t* @author shenyanchao\n \t* \n\t */\n\tpublic class BaiduSearchPage {\n\t\tpublic static final Logger LOG = LoggerFactory\n\t\t\t.getLogger(BaiduSearchPage.class);\n\t\tprivate WebElement wd;\n\n\t\tpublic void searchFor(String keyword) {\n\t\t\twd.sendKeys(keyword);\n\t\t\twd.submit();\n\t\t}\n\n\t\tpublic static void main(String[] args) {\n\t\t\tWebDriver driver = new HtmlUnitDriver();\n\t\t\tdriver.get(\"http://www.baidu.com\");\n\t\t\tBaiduSearchPage baiduPage = PageFactory.initElements(driver,\n\t\t\t\tBaiduSearchPage.class);\n\t\t\tLOG.info(\"before search url is:{}\",driver.getCurrentUrl());\n\t\t\tbaiduPage.searchFor(\"blueshen\");\n\t\t\tLOG.info(\"after search url is:{}\",driver.getCurrentUrl());\n\t\t}\n\t}\n```\n运行以上代码，发现已经可以正常运行，结果如下：\n\n```\n\t......\n\tbefore search url is:http://www.baidu.com/\n\t......\n\tafter search url is:http://www.baidu.com/s?wd=blueshen&rsv_bp=0&rsv_spt=3\n```\n\n可见，搜索后，已经转向了正确的搜索结果页面。然而WebElement是如何初始化的呢？玄机就在`BaiduSearchPage baiduPage = PageFactory.initElements(driver,BaiduSearchPage.class);`这行代码。PageFactory负责初始化了Page里的元素，amazing，用起来就是这么的优雅。   \n那么下来，我就要问了：PageFactory是怎么定位元素的呢？   \n>原来PageFactory初始化元素有一个惯例，样例中将WebElement的名称定为wd,那么PageFactory将按类似以下的形式对其进行初始化：    \n`driver.findElement(By.id(\"wd\"));`  \nPageFactory认为wd是HTML元素的id或者name字段的值,并且优先从id开始查找。至此，我们终于知道怎么回事了。   \n\n随着项目的变大，以及使用的更加深入，HTML元素的id，name字段并不一定唯一，并且Java Class的属性看起来都是一堆无意义的名称。这些要求我们必须要进行改进。幸好PageFactory已经提前考虑到了这一切，它支持annotations来显式定位元素。那么上述的百度搜索样例，可以修改为如下形式：   \n\n```java\n\tpublic class BaiduSearchPage {\n\t\tpublic static final Logger LOG = LoggerFactory\n\t\t\t.getLogger(BaiduSearchPage.class);\n\t\t@FindBy(how = How.NAME, using = \"wd\")\n\t\t@CacheLookup\n\t\tprivate WebElement serachBox;\n\n\t\tpublic void searchFor(String keyword) {\n\t\t\tserachBox.sendKeys(keyword);\n\t\t\tserachBox.submit();\n\t\t}\n\t......\n\t}\n```\n明确的指定HOW.NAME,using=\"wd\",意为查找name=\"wd\"的元素，并将其初始化赋值给searchBox这一有意义的属性名。其中@CacheLookup用于标识其只初始化一次，然后缓存起来备用。   \n\n感觉还不够简洁吗？继续修改： \n  \n```java\n \t@FindBy(name = \"wd\")\n  \tprivate WebElement searchBox;\n```\n这是其简略模式，还支持各种定位方式。   \n\n```java\n\t\t@FindBy(id=\"...\")\n\t\t@FindBy(className=\"...\")\n\t\t@FindBy(name=\"...\")\n\t\t@FindBy(xpath=\"...\")\n\t\t@FindBy(linkText=\"...\")\n\t\t@FindBy(partialLinkText=\"...\")\n\t\t@FindBy(tagName=\"...\")\n\t\t@FindBy(css=\"...\")\n```\n同时支持`@FindBys`用于支持列表元素查找定位，返回`List<WebElement>`类型。\n\n**总之，利用PageObjects设计模式并且配合PageFactory使用，将使你的自动化测试优雅、易懂、易维护。**","source":"_posts/2012-10-16-pageobjects-design-pattern.markdown","raw":"---\nlayout: post\ntitle: \"PageObjects 设计模式\"\ndate: 2012-10-16 16:40\ncomments: true\ncategories: selenium\ntags: [ webdriver, selenium, PageObjects, PageFactory ]\n---\n##什么是Page Objects(翻译为：页面对象？)...##\n简单的说，Page Objects是指UI界面上用于与用户进行交互的对象。它可以指整个页面，也可以指Page上的某个区域。Page Objects是你的test code的交互对象，是对实际UI的一种抽象模型化。通过Page Objects可以减少重复代码的编写，例如，很多页面都有同样的header，footer，navigator等部分，如果对这些进行抽象，只写一次就可以在其他地方通用了。  \n\n**注意PageObjects与Page Objects是不一样的**，PageObjects用于特指采用Page Objects进行封装的一种设计模式（Design Pattern）,而不仅仅是多一个空格的区别。哈。\n##如何实现PageObjects设计模式？##\n一般情况下，对于一个Page Objects对象，它有两个方面的特征：  \n \n* 自身元素(WebElement)  \n* 实现功能 (Services)  \n<!--more-->  \n\n自身元素很好理解，就是实实在在的页面元素。而Page Object通常也都是实现一定的功能的。就Test的开发人员来说，更关心的是Page Objects它们实现了什么交互功能，而不是其内部的实现，因此，这里的功能与开发人员理解的功能是**不一样的**。   \n\n以用户登录为例：在登录界面，点击登录后要么成功，转向首页。要么失败，出现提示出错信息。   \n相信这是一个很容易理解的场景吧！  \nJava Code可能类似如下：   \n\n```java\n\tpublic class LoginPage {\n\t\t//用户名录入框\n\t\tprivate WebElement usernameBox;\n\t\t//密码录入框\n\t\tprivate WebElement passwordBox;\n\t\t//提交按钮\n\t\tprivate WebElement submitButton;\n\n    \tpublic HomePage loginAs(String username, String password) {\n\t\t\tusernameBox.sendKeys(username);\n\t\t\tpasswordBox.sendKeys(password);\n\t\t\tsubmitButton.submit();\n        \treturn new HomePage(...)\n    \t}\n    \n    \tpublic LoginPage loginAsExpectingError(String username, String password) {\n       \t\t //  出错的username,password 仍留在LoginPage\n   \t\t }\n    \n    \tpublic String getErrorMessage() {\n        // 获取错误信息\n    \t}\n\t}  \n``` \n从上面可以看出，同时封装了元素以及功能。此处样例，元素是没有初始化的。可以通过类似于`driver.findElement()`的函数来直接进行初始化，另外WebDriver提供了一个PageFactory用于对PageObjects设计模式进行支持，下面将会讲到。  \n通过上面的这段代码，也展现出了一个重要的问题，那就是assertion不应该在Page Objects内部，而应该由tests进行处理。Page Objects只是返回需要验证的信息即可。\n\n##总结##\n* public方法代表Page提供的功能\n* 尽量不要暴露Page的内部细节\n* 不要assertion\n* 方法可以返回其他Page Objects\n* Page Objects不用代表整个页面，可以是任意一个部分\n* 一样的操作，不同的结果应该分开（正确登录，错误登录）   \n\n##样例##\n```java\t\n\tpublic class LoginPage {\n\t\tprivate final WebDriver driver;\n\t\t// 用户名录入框\n\t\tprivate WebElement usernameBox;\n\t\t// 密码录入框\n\t\tprivate WebElement passwordBox;\n\t\t// 提交按钮\n\t\tprivate WebElement submitButton;\n\n\t\tpublic LoginPage(WebDriver driver) {\n\t\t\tthis.driver = driver;\n\t\t\tif (!\"Login\".equals(driver.getTitle())) {\n\t\t\t\tthrow new IllegalStateException(\"This is not the login page\");\n\t\t\t}\n\t\t\tthis.usernameBox = driver.findElement(By.id(\"username\"));\n\t\t\tthis.passwordBox = driver.findElement(By.id(\"passwd\"));\n\t\t\tthis.submitButton = driver.findElement(By.id(\"login\"));\n\t\t}\n\n\t\tpublic HomePage loginAs(String username, String password) {\n\t\t\tusernameBox.sendKeys(username);\n\t\t\tpasswordBox.sendKeys(password);\n\t\t\tsubmitButton.submit();\n\t\t\treturn new HomePage(driver);\n\t\t}\n\t}\n```\n##PageFactory##\n从上面的样例中，有没有发现每个元素都要进行`driver.findElement()`这样的操作，写起来好累啊，一堆重复性的代码。有没有更好的，更优雅的处理方法呢？**`org.openqa.selenium.support.PageFactory`**就是用来负责处理这个的，真Happy!   \n下面以[百度搜索](http://www.baidu.com)作为样例场景，搜索一个关键字\n\n\t\n```java\n\timport org.openqa.selenium.WebDriver;\n\timport org.openqa.selenium.WebElement;\n\timport org.openqa.selenium.htmlunit.HtmlUnitDriver;\n\timport org.openqa.selenium.support.PageFactory;\n\timport org.slf4j.Logger;\n\timport org.slf4j.LoggerFactory;\n\n\t/**\n \t* @author shenyanchao\n \t* \n\t */\n\tpublic class BaiduSearchPage {\n\t\tpublic static final Logger LOG = LoggerFactory\n\t\t\t.getLogger(BaiduSearchPage.class);\n\t\tprivate WebElement wd;\n\n\t\tpublic void searchFor(String keyword) {\n\t\t\twd.sendKeys(keyword);\n\t\t\twd.submit();\n\t\t}\n\n\t\tpublic static void main(String[] args) {\n\t\t\tWebDriver driver = new HtmlUnitDriver();\n\t\t\tdriver.get(\"http://www.baidu.com\");\n\t\t\tBaiduSearchPage baiduPage = PageFactory.initElements(driver,\n\t\t\t\tBaiduSearchPage.class);\n\t\t\tLOG.info(\"before search url is:{}\",driver.getCurrentUrl());\n\t\t\tbaiduPage.searchFor(\"blueshen\");\n\t\t\tLOG.info(\"after search url is:{}\",driver.getCurrentUrl());\n\t\t}\n\t}\n```\n运行以上代码，发现已经可以正常运行，结果如下：\n\n```\n\t......\n\tbefore search url is:http://www.baidu.com/\n\t......\n\tafter search url is:http://www.baidu.com/s?wd=blueshen&rsv_bp=0&rsv_spt=3\n```\n\n可见，搜索后，已经转向了正确的搜索结果页面。然而WebElement是如何初始化的呢？玄机就在`BaiduSearchPage baiduPage = PageFactory.initElements(driver,BaiduSearchPage.class);`这行代码。PageFactory负责初始化了Page里的元素，amazing，用起来就是这么的优雅。   \n那么下来，我就要问了：PageFactory是怎么定位元素的呢？   \n>原来PageFactory初始化元素有一个惯例，样例中将WebElement的名称定为wd,那么PageFactory将按类似以下的形式对其进行初始化：    \n`driver.findElement(By.id(\"wd\"));`  \nPageFactory认为wd是HTML元素的id或者name字段的值,并且优先从id开始查找。至此，我们终于知道怎么回事了。   \n\n随着项目的变大，以及使用的更加深入，HTML元素的id，name字段并不一定唯一，并且Java Class的属性看起来都是一堆无意义的名称。这些要求我们必须要进行改进。幸好PageFactory已经提前考虑到了这一切，它支持annotations来显式定位元素。那么上述的百度搜索样例，可以修改为如下形式：   \n\n```java\n\tpublic class BaiduSearchPage {\n\t\tpublic static final Logger LOG = LoggerFactory\n\t\t\t.getLogger(BaiduSearchPage.class);\n\t\t@FindBy(how = How.NAME, using = \"wd\")\n\t\t@CacheLookup\n\t\tprivate WebElement serachBox;\n\n\t\tpublic void searchFor(String keyword) {\n\t\t\tserachBox.sendKeys(keyword);\n\t\t\tserachBox.submit();\n\t\t}\n\t......\n\t}\n```\n明确的指定HOW.NAME,using=\"wd\",意为查找name=\"wd\"的元素，并将其初始化赋值给searchBox这一有意义的属性名。其中@CacheLookup用于标识其只初始化一次，然后缓存起来备用。   \n\n感觉还不够简洁吗？继续修改： \n  \n```java\n \t@FindBy(name = \"wd\")\n  \tprivate WebElement searchBox;\n```\n这是其简略模式，还支持各种定位方式。   \n\n```java\n\t\t@FindBy(id=\"...\")\n\t\t@FindBy(className=\"...\")\n\t\t@FindBy(name=\"...\")\n\t\t@FindBy(xpath=\"...\")\n\t\t@FindBy(linkText=\"...\")\n\t\t@FindBy(partialLinkText=\"...\")\n\t\t@FindBy(tagName=\"...\")\n\t\t@FindBy(css=\"...\")\n```\n同时支持`@FindBys`用于支持列表元素查找定位，返回`List<WebElement>`类型。\n\n**总之，利用PageObjects设计模式并且配合PageFactory使用，将使你的自动化测试优雅、易懂、易维护。**","slug":"2012-10-16-pageobjects-design-pattern","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1n000kv8fyoldvk0hl","content":"<p>##什么是Page Objects(翻译为：页面对象？)…##<br>简单的说，Page Objects是指UI界面上用于与用户进行交互的对象。它可以指整个页面，也可以指Page上的某个区域。Page Objects是你的test code的交互对象，是对实际UI的一种抽象模型化。通过Page Objects可以减少重复代码的编写，例如，很多页面都有同样的header，footer，navigator等部分，如果对这些进行抽象，只写一次就可以在其他地方通用了。  </p>\n<p><strong>注意PageObjects与Page Objects是不一样的</strong>，PageObjects用于特指采用Page Objects进行封装的一种设计模式（Design Pattern）,而不仅仅是多一个空格的区别。哈。</p>\n<p>##如何实现PageObjects设计模式？##<br>一般情况下，对于一个Page Objects对象，它有两个方面的特征：  </p>\n<ul>\n<li>自身元素(WebElement)  </li>\n<li>实现功能 (Services)  <a id=\"more\"></a>  \n</li>\n</ul>\n<p>自身元素很好理解，就是实实在在的页面元素。而Page Object通常也都是实现一定的功能的。就Test的开发人员来说，更关心的是Page Objects它们实现了什么交互功能，而不是其内部的实现，因此，这里的功能与开发人员理解的功能是<strong>不一样的</strong>。   </p>\n<p>以用户登录为例：在登录界面，点击登录后要么成功，转向首页。要么失败，出现提示出错信息。<br>相信这是一个很容易理解的场景吧！<br>Java Code可能类似如下：   </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tpublic class LoginPage &#123;</div><div class=\"line\">\t\t//用户名录入框</div><div class=\"line\">\t\tprivate WebElement usernameBox;</div><div class=\"line\">\t\t//密码录入框</div><div class=\"line\">\t\tprivate WebElement passwordBox;</div><div class=\"line\">\t\t//提交按钮</div><div class=\"line\">\t\tprivate WebElement submitButton;</div><div class=\"line\"></div><div class=\"line\">    \tpublic HomePage loginAs(String username, String password) &#123;</div><div class=\"line\">\t\t\tusernameBox.sendKeys(username);</div><div class=\"line\">\t\t\tpasswordBox.sendKeys(password);</div><div class=\"line\">\t\t\tsubmitButton.submit();</div><div class=\"line\">        \treturn new HomePage(...)</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    </div><div class=\"line\">    \tpublic LoginPage loginAsExpectingError(String username, String password) &#123;</div><div class=\"line\">       \t\t //  出错的username,password 仍留在LoginPage</div><div class=\"line\">   \t\t &#125;</div><div class=\"line\">    </div><div class=\"line\">    \tpublic String getErrorMessage() &#123;</div><div class=\"line\">        // 获取错误信息</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;  </div><div class=\"line\">``` </div><div class=\"line\">从上面可以看出，同时封装了元素以及功能。此处样例，元素是没有初始化的。可以通过类似于`driver.findElement()`的函数来直接进行初始化，另外WebDriver提供了一个PageFactory用于对PageObjects设计模式进行支持，下面将会讲到。  </div><div class=\"line\">通过上面的这段代码，也展现出了一个重要的问题，那就是assertion不应该在Page Objects内部，而应该由tests进行处理。Page Objects只是返回需要验证的信息即可。</div><div class=\"line\"></div><div class=\"line\">##总结##</div><div class=\"line\">* public方法代表Page提供的功能</div><div class=\"line\">* 尽量不要暴露Page的内部细节</div><div class=\"line\">* 不要assertion</div><div class=\"line\">* 方法可以返回其他Page Objects</div><div class=\"line\">* Page Objects不用代表整个页面，可以是任意一个部分</div><div class=\"line\">* 一样的操作，不同的结果应该分开（正确登录，错误登录）   </div><div class=\"line\"></div><div class=\"line\">##样例##</div><div class=\"line\">```java\t</div><div class=\"line\">\tpublic class LoginPage &#123;</div><div class=\"line\">\t\tprivate final WebDriver driver;</div><div class=\"line\">\t\t// 用户名录入框</div><div class=\"line\">\t\tprivate WebElement usernameBox;</div><div class=\"line\">\t\t// 密码录入框</div><div class=\"line\">\t\tprivate WebElement passwordBox;</div><div class=\"line\">\t\t// 提交按钮</div><div class=\"line\">\t\tprivate WebElement submitButton;</div><div class=\"line\"></div><div class=\"line\">\t\tpublic LoginPage(WebDriver driver) &#123;</div><div class=\"line\">\t\t\tthis.driver = driver;</div><div class=\"line\">\t\t\tif (!\"Login\".equals(driver.getTitle())) &#123;</div><div class=\"line\">\t\t\t\tthrow new IllegalStateException(\"This is not the login page\");</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tthis.usernameBox = driver.findElement(By.id(\"username\"));</div><div class=\"line\">\t\t\tthis.passwordBox = driver.findElement(By.id(\"passwd\"));</div><div class=\"line\">\t\t\tthis.submitButton = driver.findElement(By.id(\"login\"));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tpublic HomePage loginAs(String username, String password) &#123;</div><div class=\"line\">\t\t\tusernameBox.sendKeys(username);</div><div class=\"line\">\t\t\tpasswordBox.sendKeys(password);</div><div class=\"line\">\t\t\tsubmitButton.submit();</div><div class=\"line\">\t\t\treturn new HomePage(driver);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>##PageFactory##<br>从上面的样例中，有没有发现每个元素都要进行<code>driver.findElement()</code>这样的操作，写起来好累啊，一堆重复性的代码。有没有更好的，更优雅的处理方法呢？<strong><code>org.openqa.selenium.support.PageFactory</code></strong>就是用来负责处理这个的，真Happy!<br>下面以<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"external\">百度搜索</a>作为样例场景，搜索一个关键字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.WebDriver;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.WebElement;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.htmlunit.HtmlUnitDriver;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.support.PageFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</div><div class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">\t* <span class=\"doctag\">@author</span> shenyanchao</div><div class=\"line\">\t* </div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSearchPage</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</div><div class=\"line\">\t\t.getLogger(BaiduSearchPage.class);</div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement wd;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">searchFor</span><span class=\"params\">(String keyword)</span> </span>&#123;</div><div class=\"line\">\t\twd.sendKeys(keyword);</div><div class=\"line\">\t\twd.submit();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tWebDriver driver = <span class=\"keyword\">new</span> HtmlUnitDriver();</div><div class=\"line\">\t\tdriver.get(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">\t\tBaiduSearchPage baiduPage = PageFactory.initElements(driver,</div><div class=\"line\">\t\t\tBaiduSearchPage.class);</div><div class=\"line\">\t\tLOG.info(<span class=\"string\">\"before search url is:&#123;&#125;\"</span>,driver.getCurrentUrl());</div><div class=\"line\">\t\tbaiduPage.searchFor(<span class=\"string\">\"blueshen\"</span>);</div><div class=\"line\">\t\tLOG.info(<span class=\"string\">\"after search url is:&#123;&#125;\"</span>,driver.getCurrentUrl());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行以上代码，发现已经可以正常运行，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">......</div><div class=\"line\">before search url is:http://www.baidu.com/</div><div class=\"line\">......</div><div class=\"line\">after search url is:http://www.baidu.com/s?wd=blueshen&amp;rsv_bp=0&amp;rsv_spt=3</div></pre></td></tr></table></figure>\n<p>可见，搜索后，已经转向了正确的搜索结果页面。然而WebElement是如何初始化的呢？玄机就在<code>BaiduSearchPage baiduPage = PageFactory.initElements(driver,BaiduSearchPage.class);</code>这行代码。PageFactory负责初始化了Page里的元素，amazing，用起来就是这么的优雅。<br>那么下来，我就要问了：PageFactory是怎么定位元素的呢？   </p>\n<blockquote>\n<p>原来PageFactory初始化元素有一个惯例，样例中将WebElement的名称定为wd,那么PageFactory将按类似以下的形式对其进行初始化：<br><code>driver.findElement(By.id(&quot;wd&quot;));</code><br>PageFactory认为wd是HTML元素的id或者name字段的值,并且优先从id开始查找。至此，我们终于知道怎么回事了。   </p>\n</blockquote>\n<p>随着项目的变大，以及使用的更加深入，HTML元素的id，name字段并不一定唯一，并且Java Class的属性看起来都是一堆无意义的名称。这些要求我们必须要进行改进。幸好PageFactory已经提前考虑到了这一切，它支持annotations来显式定位元素。那么上述的百度搜索样例，可以修改为如下形式：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSearchPage</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</div><div class=\"line\">\t\t.getLogger(BaiduSearchPage.class);</div><div class=\"line\">\t<span class=\"meta\">@FindBy</span>(how = How.NAME, using = <span class=\"string\">\"wd\"</span>)</div><div class=\"line\">\t<span class=\"meta\">@CacheLookup</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement serachBox;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">searchFor</span><span class=\"params\">(String keyword)</span> </span>&#123;</div><div class=\"line\">\t\tserachBox.sendKeys(keyword);</div><div class=\"line\">\t\tserachBox.submit();</div><div class=\"line\">\t&#125;</div><div class=\"line\">......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>明确的指定HOW.NAME,using=”wd”,意为查找name=”wd”的元素，并将其初始化赋值给searchBox这一有意义的属性名。其中@CacheLookup用于标识其只初始化一次，然后缓存起来备用。   </p>\n<p>感觉还不够简洁吗？继续修改： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FindBy</span>(name = <span class=\"string\">\"wd\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement searchBox;</div></pre></td></tr></table></figure>\n<p>这是其简略模式，还支持各种定位方式。   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FindBy</span>(id=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(className=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(name=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(xpath=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(linkText=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(partialLinkText=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(tagName=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(css=<span class=\"string\">\"...\"</span>)</div></pre></td></tr></table></figure>\n<p>同时支持<code>@FindBys</code>用于支持列表元素查找定位，返回<code>List&lt;WebElement&gt;</code>类型。</p>\n<p><strong>总之，利用PageObjects设计模式并且配合PageFactory使用，将使你的自动化测试优雅、易懂、易维护。</strong></p>\n","excerpt":"<p>##什么是Page Objects(翻译为：页面对象？)…##<br>简单的说，Page Objects是指UI界面上用于与用户进行交互的对象。它可以指整个页面，也可以指Page上的某个区域。Page Objects是你的test code的交互对象，是对实际UI的一种抽象模型化。通过Page Objects可以减少重复代码的编写，例如，很多页面都有同样的header，footer，navigator等部分，如果对这些进行抽象，只写一次就可以在其他地方通用了。  </p>\n<p><strong>注意PageObjects与Page Objects是不一样的</strong>，PageObjects用于特指采用Page Objects进行封装的一种设计模式（Design Pattern）,而不仅仅是多一个空格的区别。哈。</p>\n<p>##如何实现PageObjects设计模式？##<br>一般情况下，对于一个Page Objects对象，它有两个方面的特征：  </p>\n<ul>\n<li>自身元素(WebElement)  </li>\n<li>实现功能 (Services)","more":"</li>\n</ul>\n<p>自身元素很好理解，就是实实在在的页面元素。而Page Object通常也都是实现一定的功能的。就Test的开发人员来说，更关心的是Page Objects它们实现了什么交互功能，而不是其内部的实现，因此，这里的功能与开发人员理解的功能是<strong>不一样的</strong>。   </p>\n<p>以用户登录为例：在登录界面，点击登录后要么成功，转向首页。要么失败，出现提示出错信息。<br>相信这是一个很容易理解的场景吧！<br>Java Code可能类似如下：   </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">\tpublic class LoginPage &#123;</div><div class=\"line\">\t\t//用户名录入框</div><div class=\"line\">\t\tprivate WebElement usernameBox;</div><div class=\"line\">\t\t//密码录入框</div><div class=\"line\">\t\tprivate WebElement passwordBox;</div><div class=\"line\">\t\t//提交按钮</div><div class=\"line\">\t\tprivate WebElement submitButton;</div><div class=\"line\"></div><div class=\"line\">    \tpublic HomePage loginAs(String username, String password) &#123;</div><div class=\"line\">\t\t\tusernameBox.sendKeys(username);</div><div class=\"line\">\t\t\tpasswordBox.sendKeys(password);</div><div class=\"line\">\t\t\tsubmitButton.submit();</div><div class=\"line\">        \treturn new HomePage(...)</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    </div><div class=\"line\">    \tpublic LoginPage loginAsExpectingError(String username, String password) &#123;</div><div class=\"line\">       \t\t //  出错的username,password 仍留在LoginPage</div><div class=\"line\">   \t\t &#125;</div><div class=\"line\">    </div><div class=\"line\">    \tpublic String getErrorMessage() &#123;</div><div class=\"line\">        // 获取错误信息</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;  </div><div class=\"line\">``` </div><div class=\"line\">从上面可以看出，同时封装了元素以及功能。此处样例，元素是没有初始化的。可以通过类似于`driver.findElement()`的函数来直接进行初始化，另外WebDriver提供了一个PageFactory用于对PageObjects设计模式进行支持，下面将会讲到。  </div><div class=\"line\">通过上面的这段代码，也展现出了一个重要的问题，那就是assertion不应该在Page Objects内部，而应该由tests进行处理。Page Objects只是返回需要验证的信息即可。</div><div class=\"line\"></div><div class=\"line\">##总结##</div><div class=\"line\">* public方法代表Page提供的功能</div><div class=\"line\">* 尽量不要暴露Page的内部细节</div><div class=\"line\">* 不要assertion</div><div class=\"line\">* 方法可以返回其他Page Objects</div><div class=\"line\">* Page Objects不用代表整个页面，可以是任意一个部分</div><div class=\"line\">* 一样的操作，不同的结果应该分开（正确登录，错误登录）   </div><div class=\"line\"></div><div class=\"line\">##样例##</div><div class=\"line\">```java\t</div><div class=\"line\">\tpublic class LoginPage &#123;</div><div class=\"line\">\t\tprivate final WebDriver driver;</div><div class=\"line\">\t\t// 用户名录入框</div><div class=\"line\">\t\tprivate WebElement usernameBox;</div><div class=\"line\">\t\t// 密码录入框</div><div class=\"line\">\t\tprivate WebElement passwordBox;</div><div class=\"line\">\t\t// 提交按钮</div><div class=\"line\">\t\tprivate WebElement submitButton;</div><div class=\"line\"></div><div class=\"line\">\t\tpublic LoginPage(WebDriver driver) &#123;</div><div class=\"line\">\t\t\tthis.driver = driver;</div><div class=\"line\">\t\t\tif (!\"Login\".equals(driver.getTitle())) &#123;</div><div class=\"line\">\t\t\t\tthrow new IllegalStateException(\"This is not the login page\");</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tthis.usernameBox = driver.findElement(By.id(\"username\"));</div><div class=\"line\">\t\t\tthis.passwordBox = driver.findElement(By.id(\"passwd\"));</div><div class=\"line\">\t\t\tthis.submitButton = driver.findElement(By.id(\"login\"));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tpublic HomePage loginAs(String username, String password) &#123;</div><div class=\"line\">\t\t\tusernameBox.sendKeys(username);</div><div class=\"line\">\t\t\tpasswordBox.sendKeys(password);</div><div class=\"line\">\t\t\tsubmitButton.submit();</div><div class=\"line\">\t\t\treturn new HomePage(driver);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>##PageFactory##<br>从上面的样例中，有没有发现每个元素都要进行<code>driver.findElement()</code>这样的操作，写起来好累啊，一堆重复性的代码。有没有更好的，更优雅的处理方法呢？<strong><code>org.openqa.selenium.support.PageFactory</code></strong>就是用来负责处理这个的，真Happy!<br>下面以<a href=\"http://www.baidu.com\">百度搜索</a>作为样例场景，搜索一个关键字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.WebDriver;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.WebElement;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.htmlunit.HtmlUnitDriver;</div><div class=\"line\"><span class=\"keyword\">import</span> org.openqa.selenium.support.PageFactory;</div><div class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</div><div class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">\t* <span class=\"doctag\">@author</span> shenyanchao</div><div class=\"line\">\t* </div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSearchPage</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</div><div class=\"line\">\t\t.getLogger(BaiduSearchPage.class);</div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement wd;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">searchFor</span><span class=\"params\">(String keyword)</span> </span>&#123;</div><div class=\"line\">\t\twd.sendKeys(keyword);</div><div class=\"line\">\t\twd.submit();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tWebDriver driver = <span class=\"keyword\">new</span> HtmlUnitDriver();</div><div class=\"line\">\t\tdriver.get(<span class=\"string\">\"http://www.baidu.com\"</span>);</div><div class=\"line\">\t\tBaiduSearchPage baiduPage = PageFactory.initElements(driver,</div><div class=\"line\">\t\t\tBaiduSearchPage.class);</div><div class=\"line\">\t\tLOG.info(<span class=\"string\">\"before search url is:&#123;&#125;\"</span>,driver.getCurrentUrl());</div><div class=\"line\">\t\tbaiduPage.searchFor(<span class=\"string\">\"blueshen\"</span>);</div><div class=\"line\">\t\tLOG.info(<span class=\"string\">\"after search url is:&#123;&#125;\"</span>,driver.getCurrentUrl());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行以上代码，发现已经可以正常运行，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">......</div><div class=\"line\">before search url is:http://www.baidu.com/</div><div class=\"line\">......</div><div class=\"line\">after search url is:http://www.baidu.com/s?wd=blueshen&amp;rsv_bp=0&amp;rsv_spt=3</div></pre></td></tr></table></figure>\n<p>可见，搜索后，已经转向了正确的搜索结果页面。然而WebElement是如何初始化的呢？玄机就在<code>BaiduSearchPage baiduPage = PageFactory.initElements(driver,BaiduSearchPage.class);</code>这行代码。PageFactory负责初始化了Page里的元素，amazing，用起来就是这么的优雅。<br>那么下来，我就要问了：PageFactory是怎么定位元素的呢？   </p>\n<blockquote>\n<p>原来PageFactory初始化元素有一个惯例，样例中将WebElement的名称定为wd,那么PageFactory将按类似以下的形式对其进行初始化：<br><code>driver.findElement(By.id(&quot;wd&quot;));</code><br>PageFactory认为wd是HTML元素的id或者name字段的值,并且优先从id开始查找。至此，我们终于知道怎么回事了。   </p>\n</blockquote>\n<p>随着项目的变大，以及使用的更加深入，HTML元素的id，name字段并不一定唯一，并且Java Class的属性看起来都是一堆无意义的名称。这些要求我们必须要进行改进。幸好PageFactory已经提前考虑到了这一切，它支持annotations来显式定位元素。那么上述的百度搜索样例，可以修改为如下形式：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSearchPage</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger LOG = LoggerFactory</div><div class=\"line\">\t\t.getLogger(BaiduSearchPage.class);</div><div class=\"line\">\t<span class=\"meta\">@FindBy</span>(how = How.NAME, using = <span class=\"string\">\"wd\"</span>)</div><div class=\"line\">\t<span class=\"meta\">@CacheLookup</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement serachBox;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">searchFor</span><span class=\"params\">(String keyword)</span> </span>&#123;</div><div class=\"line\">\t\tserachBox.sendKeys(keyword);</div><div class=\"line\">\t\tserachBox.submit();</div><div class=\"line\">\t&#125;</div><div class=\"line\">......</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>明确的指定HOW.NAME,using=”wd”,意为查找name=”wd”的元素，并将其初始化赋值给searchBox这一有意义的属性名。其中@CacheLookup用于标识其只初始化一次，然后缓存起来备用。   </p>\n<p>感觉还不够简洁吗？继续修改： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FindBy</span>(name = <span class=\"string\">\"wd\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">private</span> WebElement searchBox;</div></pre></td></tr></table></figure>\n<p>这是其简略模式，还支持各种定位方式。   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FindBy</span>(id=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(className=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(name=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(xpath=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(linkText=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(partialLinkText=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(tagName=<span class=\"string\">\"...\"</span>)</div><div class=\"line\"><span class=\"meta\">@FindBy</span>(css=<span class=\"string\">\"...\"</span>)</div></pre></td></tr></table></figure>\n<p>同时支持<code>@FindBys</code>用于支持列表元素查找定位，返回<code>List&lt;WebElement&gt;</code>类型。</p>\n<p><strong>总之，利用PageObjects设计模式并且配合PageFactory使用，将使你的自动化测试优雅、易懂、易维护。</strong></p>"},{"layout":"post","title":"安装配置Maven","date":"2012-10-19T15:40:00.000Z","comments":1,"_content":"## Maven安装\t\n1.下载Maven：从[Maven官方](http://maven.apache.org/download.html)下载,并解压。比如解压到：D:\\apache-maven-3.0.4     \n2.配置环境变量：  \n\n*  M2_HOME：D:\\apache-maven-3.0.4\n*  path：%M2_HOME%\\bin;   \n\n打开cmd命令窗口,验证配置是否成功：`mvn -v`。成功后会显示正确的版本信息。  \n3.修改默认的repository   \nmaven默认放在C:\\Users\\user\\.m2\\repository目录下（不同系统可能不一样）。Window下一般不建议放在C盘。可以通过如下方式修改：   \n进入%M2_HOME%\\conf\\settings.xml中，添加`<localRepository>e:/repo</localRepository>`这样一行。默认的路径就指向新的目录了。","source":"_posts/2012-10-19-install-maven.markdown","raw":"---\nlayout: post\ntitle: \"安装配置Maven\"\ndate: 2012-10-19 23:40\ncomments: true\ncategories: maven\ntags: [ maven, install, config ]\n---\n## Maven安装\t\n1.下载Maven：从[Maven官方](http://maven.apache.org/download.html)下载,并解压。比如解压到：D:\\apache-maven-3.0.4     \n2.配置环境变量：  \n\n*  M2_HOME：D:\\apache-maven-3.0.4\n*  path：%M2_HOME%\\bin;   \n\n打开cmd命令窗口,验证配置是否成功：`mvn -v`。成功后会显示正确的版本信息。  \n3.修改默认的repository   \nmaven默认放在C:\\Users\\user\\.m2\\repository目录下（不同系统可能不一样）。Window下一般不建议放在C盘。可以通过如下方式修改：   \n进入%M2_HOME%\\conf\\settings.xml中，添加`<localRepository>e:/repo</localRepository>`这样一行。默认的路径就指向新的目录了。","slug":"2012-10-19-install-maven","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1p000ov8fyyd1y16fa","content":"<h2 id=\"Maven安装\"><a href=\"#Maven安装\" class=\"headerlink\" title=\"Maven安装\"></a>Maven安装</h2><p>1.下载Maven：从<a href=\"http://maven.apache.org/download.html\" target=\"_blank\" rel=\"external\">Maven官方</a>下载,并解压。比如解压到：D:\\apache-maven-3.0.4<br>2.配置环境变量：  </p>\n<ul>\n<li>M2_HOME：D:\\apache-maven-3.0.4</li>\n<li>path：%M2_HOME%\\bin;   </li>\n</ul>\n<p>打开cmd命令窗口,验证配置是否成功：<code>mvn -v</code>。成功后会显示正确的版本信息。<br>3.修改默认的repository<br>maven默认放在C:\\Users\\user.m2\\repository目录下（不同系统可能不一样）。Window下一般不建议放在C盘。可以通过如下方式修改：<br>进入%M2_HOME%\\conf\\settings.xml中，添加<code>&lt;localRepository&gt;e:/repo&lt;/localRepository&gt;</code>这样一行。默认的路径就指向新的目录了。</p>\n","excerpt":"","more":"<h2 id=\"Maven安装\"><a href=\"#Maven安装\" class=\"headerlink\" title=\"Maven安装\"></a>Maven安装</h2><p>1.下载Maven：从<a href=\"http://maven.apache.org/download.html\">Maven官方</a>下载,并解压。比如解压到：D:\\apache-maven-3.0.4<br>2.配置环境变量：  </p>\n<ul>\n<li>M2_HOME：D:\\apache-maven-3.0.4</li>\n<li>path：%M2_HOME%\\bin;   </li>\n</ul>\n<p>打开cmd命令窗口,验证配置是否成功：<code>mvn -v</code>。成功后会显示正确的版本信息。<br>3.修改默认的repository<br>maven默认放在C:\\Users\\user.m2\\repository目录下（不同系统可能不一样）。Window下一般不建议放在C盘。可以通过如下方式修改：<br>进入%M2_HOME%\\conf\\settings.xml中，添加<code>&lt;localRepository&gt;e:/repo&lt;/localRepository&gt;</code>这样一行。默认的路径就指向新的目录了。</p>\n"},{"layout":"post","title":"JVM参数选项","date":"2012-10-19T15:01:00.000Z","comments":1,"_content":"\n详情请看：<http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm>","source":"_posts/2012-10-19-java6-jvm-params.markdown","raw":"---\nlayout: post\ntitle: \"JVM参数选项\"\ndate: 2012-10-19 23:01\ncomments: true\ncategories: JVM\ntags: [ JVM, Java ]\n---\n\n详情请看：<http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm>","slug":"2012-10-19-java6-jvm-params","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1s000rv8fyy0gon43l","content":"<p>详情请看：<a href=\"http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm\" target=\"_blank\" rel=\"external\">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>\n","excerpt":"","more":"<p>详情请看：<a href=\"http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm\">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>\n"},{"layout":"post","title":"Java内存溢出详解","date":"2012-10-19T15:12:00.000Z","comments":1,"_content":"\n \n一、常见的Java内存溢出有以下三种：\n \n1. `java.lang.OutOfMemoryError: Java heap space` ----JVM Heap（堆）溢出\nJVM在启动的时候会自动设置JVM Heap的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)不可超过物理内存。\n可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。\n在JVM中如果98％的时间是用于GC，且可用的Heap size 不足2％的时候将抛出此异常信息。\n解决方法：手动设置JVM Heap（堆）的大小。    \n <!--more-->   \n2. `java.lang.OutOfMemoryError: PermGen space`  ---- PermGen space溢出。 \nPermGen space的全称是Permanent Generation space，是指内存的永久保存区域。\n为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信 息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。\n解决方法： 手动设置MaxPermSize大小\n \n3. `java.lang.StackOverflowError `  ---- 栈溢出\n栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。\n调用构造函数的 “层”太多了，以致于把栈区溢出了。\n通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。\n通常递归也不要递归的层次过多，很容易溢出。\n解决方法：修改程序。\n \n \n二、解决方法\n \n在生产环境中tomcat内存设置不好很容易出现jvm内存溢出。\n \n1、 linux下的tomcat：  \n修改TOMCAT_HOME/bin/catalina.sh \n在“echo \"Using CATALINA_BASE: $CATALINA_BASE\"”上面加入以下行： \n`JAVA_OPTS=\"-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m`\" \n \n2、 如果tomcat 5 注册成了windows服务，以services方式启动的，则需要修改注册表中的相应键值。\n修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Apache Software Foundation\\Tomcat Service Manager\\Tomcat5\\Parameters\\Java，右侧的Options\n原值为\n\n\t-Dcatalina.home=\"C:\\ApacheGroup\\Tomcat 5.0\"\n\t-Djava.endorsed.dirs=\"C:\\ApacheGroup\\Tomcat 5.0\\common\\endorsed\"\n-Xrs\n加入 -Xms256m -Xmx512m \n重起tomcat服务,设置生效\n \n3、 如果tomcat 6 注册成了windows服务，或者windows2003下用tomcat的安装版，\n在/bin/tomcat6w.exe里修改就可以了 。\n \n \n \n4、 如果要在myeclipse中启动tomcat，上述的修改就不起作用了，可如下设置：\nMyeclipse->preferences->myeclipse->servers->tomcat->tomcat×.×->JDK面板中的\nOptional Java VM arguments中添加：`-Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m`\n \n \n \n三、jvm参数说明：\n \n-server:一定要作为第一个参数，在多个CPU时性能佳    \n-Xms：java Heap初始大小。 默认是物理内存的1/64。   \n-Xmx：java heap最大值。建议均设为物理内存的一半。不可超过物理内存。  \n-XX:PermSize:设定内存的永久保存区初始大小，缺省值为64M。（我用visualvm.exe查看的）   \n-XX:MaxPermSize:设定内存的永久保存区最大 大小，缺省值为64M。（我用visualvm.exe查看的）   \n-XX:SurvivorRatio=2  :生还者池的大小,默认是2，如果垃圾回收变成了瓶颈，您可以尝试定制生成池设置    \n-XX:NewSize: 新生成的池的初始大小。 缺省值为2M。  \n-XX:MaxNewSize: 新生成的池的最大大小。   缺省值为32M。   \n如果 JVM 的堆大小大于 1GB，则应该使用值：-XX:newSize=640m -XX:MaxNewSize=640m -XX:SurvivorRatio=16，或者将堆的总大小的 50% 到 60% 分配给新生成的池。调大新对象区，减少Full GC次数。  \n+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。   \n-Xss：每个线程的Stack大小，“-Xss 15120” 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.    \n-verbose:gc 现实垃圾收集信息    \n-Xloggc:gc.log 指定垃圾收集日志文件  \n-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一    \n-XX:+UseParNewGC ：缩短minor收集的时间    \n-XX:+UseConcMarkSweepGC ：缩短major收集的时间 此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。   \n-XX:userParNewGC 可用来设置并行收集【多CPU】   \n-XX:ParallelGCThreads 可用来增加并行度【多CPU】   \n-XX:UseParallelGC 设置后可以使用并行清除收集器【多CPU】   ","source":"_posts/2012-10-19-jvm-out-of-memory.markdown","raw":"---\nlayout: post\ntitle: \"Java内存溢出详解\"\ndate: 2012-10-19 23:12\ncomments: true\ncategories: JVM\ntags: [ JVM, Tomcat, GC ]\n---\n\n \n一、常见的Java内存溢出有以下三种：\n \n1. `java.lang.OutOfMemoryError: Java heap space` ----JVM Heap（堆）溢出\nJVM在启动的时候会自动设置JVM Heap的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)不可超过物理内存。\n可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。\n在JVM中如果98％的时间是用于GC，且可用的Heap size 不足2％的时候将抛出此异常信息。\n解决方法：手动设置JVM Heap（堆）的大小。    \n <!--more-->   \n2. `java.lang.OutOfMemoryError: PermGen space`  ---- PermGen space溢出。 \nPermGen space的全称是Permanent Generation space，是指内存的永久保存区域。\n为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信 息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。\n解决方法： 手动设置MaxPermSize大小\n \n3. `java.lang.StackOverflowError `  ---- 栈溢出\n栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。\n调用构造函数的 “层”太多了，以致于把栈区溢出了。\n通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。\n通常递归也不要递归的层次过多，很容易溢出。\n解决方法：修改程序。\n \n \n二、解决方法\n \n在生产环境中tomcat内存设置不好很容易出现jvm内存溢出。\n \n1、 linux下的tomcat：  \n修改TOMCAT_HOME/bin/catalina.sh \n在“echo \"Using CATALINA_BASE: $CATALINA_BASE\"”上面加入以下行： \n`JAVA_OPTS=\"-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m`\" \n \n2、 如果tomcat 5 注册成了windows服务，以services方式启动的，则需要修改注册表中的相应键值。\n修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Apache Software Foundation\\Tomcat Service Manager\\Tomcat5\\Parameters\\Java，右侧的Options\n原值为\n\n\t-Dcatalina.home=\"C:\\ApacheGroup\\Tomcat 5.0\"\n\t-Djava.endorsed.dirs=\"C:\\ApacheGroup\\Tomcat 5.0\\common\\endorsed\"\n-Xrs\n加入 -Xms256m -Xmx512m \n重起tomcat服务,设置生效\n \n3、 如果tomcat 6 注册成了windows服务，或者windows2003下用tomcat的安装版，\n在/bin/tomcat6w.exe里修改就可以了 。\n \n \n \n4、 如果要在myeclipse中启动tomcat，上述的修改就不起作用了，可如下设置：\nMyeclipse->preferences->myeclipse->servers->tomcat->tomcat×.×->JDK面板中的\nOptional Java VM arguments中添加：`-Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m`\n \n \n \n三、jvm参数说明：\n \n-server:一定要作为第一个参数，在多个CPU时性能佳    \n-Xms：java Heap初始大小。 默认是物理内存的1/64。   \n-Xmx：java heap最大值。建议均设为物理内存的一半。不可超过物理内存。  \n-XX:PermSize:设定内存的永久保存区初始大小，缺省值为64M。（我用visualvm.exe查看的）   \n-XX:MaxPermSize:设定内存的永久保存区最大 大小，缺省值为64M。（我用visualvm.exe查看的）   \n-XX:SurvivorRatio=2  :生还者池的大小,默认是2，如果垃圾回收变成了瓶颈，您可以尝试定制生成池设置    \n-XX:NewSize: 新生成的池的初始大小。 缺省值为2M。  \n-XX:MaxNewSize: 新生成的池的最大大小。   缺省值为32M。   \n如果 JVM 的堆大小大于 1GB，则应该使用值：-XX:newSize=640m -XX:MaxNewSize=640m -XX:SurvivorRatio=16，或者将堆的总大小的 50% 到 60% 分配给新生成的池。调大新对象区，减少Full GC次数。  \n+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。   \n-Xss：每个线程的Stack大小，“-Xss 15120” 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.    \n-verbose:gc 现实垃圾收集信息    \n-Xloggc:gc.log 指定垃圾收集日志文件  \n-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一    \n-XX:+UseParNewGC ：缩短minor收集的时间    \n-XX:+UseConcMarkSweepGC ：缩短major收集的时间 此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。   \n-XX:userParNewGC 可用来设置并行收集【多CPU】   \n-XX:ParallelGCThreads 可用来增加并行度【多CPU】   \n-XX:UseParallelGC 设置后可以使用并行清除收集器【多CPU】   ","slug":"2012-10-19-jvm-out-of-memory","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1u000wv8fycxbrmp6j","content":"<p>一、常见的Java内存溢出有以下三种：</p>\n<ol>\n<li><code>java.lang.OutOfMemoryError: Java heap space</code> —-JVM Heap（堆）溢出<br>JVM在启动的时候会自动设置JVM Heap的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)不可超过物理内存。<br>可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。<br>在JVM中如果98％的时间是用于GC，且可用的Heap size 不足2％的时候将抛出此异常信息。<br>解决方法：手动设置JVM Heap（堆）的大小。    <a id=\"more\"></a>   </li>\n<li><p><code>java.lang.OutOfMemoryError: PermGen space</code>  —- PermGen space溢出。<br>PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。<br>为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信 息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。<br>解决方法： 手动设置MaxPermSize大小</p>\n</li>\n<li><p><code>java.lang.StackOverflowError</code>  —- 栈溢出<br>栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。<br>调用构造函数的 “层”太多了，以致于把栈区溢出了。<br>通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。<br>通常递归也不要递归的层次过多，很容易溢出。<br>解决方法：修改程序。</p>\n</li>\n</ol>\n<p>二、解决方法</p>\n<p>在生产环境中tomcat内存设置不好很容易出现jvm内存溢出。</p>\n<p>1、 linux下的tomcat：<br>修改TOMCAT_HOME/bin/catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br><code>JAVA_OPTS=&quot;-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code>“ </p>\n<p>2、 如果tomcat 5 注册成了windows服务，以services方式启动的，则需要修改注册表中的相应键值。<br>修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Apache Software Foundation\\Tomcat Service Manager\\Tomcat5\\Parameters\\Java，右侧的Options<br>原值为</p>\n<pre><code>-Dcatalina.home=&quot;C:\\ApacheGroup\\Tomcat 5.0&quot;\n-Djava.endorsed.dirs=&quot;C:\\ApacheGroup\\Tomcat 5.0\\common\\endorsed&quot;\n</code></pre><p>-Xrs<br>加入 -Xms256m -Xmx512m<br>重起tomcat服务,设置生效</p>\n<p>3、 如果tomcat 6 注册成了windows服务，或者windows2003下用tomcat的安装版，<br>在/bin/tomcat6w.exe里修改就可以了 。</p>\n<p>4、 如果要在myeclipse中启动tomcat，上述的修改就不起作用了，可如下设置：<br>Myeclipse-&gt;preferences-&gt;myeclipse-&gt;servers-&gt;tomcat-&gt;tomcat×.×-&gt;JDK面板中的<br>Optional Java VM arguments中添加：<code>-Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code></p>\n<p>三、jvm参数说明：</p>\n<p>-server:一定要作为第一个参数，在多个CPU时性能佳<br>-Xms：java Heap初始大小。 默认是物理内存的1/64。<br>-Xmx：java heap最大值。建议均设为物理内存的一半。不可超过物理内存。<br>-XX:PermSize:设定内存的永久保存区初始大小，缺省值为64M。（我用visualvm.exe查看的）<br>-XX:MaxPermSize:设定内存的永久保存区最大 大小，缺省值为64M。（我用visualvm.exe查看的）<br>-XX:SurvivorRatio=2  :生还者池的大小,默认是2，如果垃圾回收变成了瓶颈，您可以尝试定制生成池设置<br>-XX:NewSize: 新生成的池的初始大小。 缺省值为2M。<br>-XX:MaxNewSize: 新生成的池的最大大小。   缺省值为32M。<br>如果 JVM 的堆大小大于 1GB，则应该使用值：-XX:newSize=640m -XX:MaxNewSize=640m -XX:SurvivorRatio=16，或者将堆的总大小的 50% 到 60% 分配给新生成的池。调大新对象区，减少Full GC次数。<br>+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。<br>-Xss：每个线程的Stack大小，“-Xss 15120” 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.<br>-verbose:gc 现实垃圾收集信息<br>-Xloggc:gc.log 指定垃圾收集日志文件<br>-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一<br>-XX:+UseParNewGC ：缩短minor收集的时间<br>-XX:+UseConcMarkSweepGC ：缩短major收集的时间 此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。<br>-XX:userParNewGC 可用来设置并行收集【多CPU】<br>-XX:ParallelGCThreads 可用来增加并行度【多CPU】<br>-XX:UseParallelGC 设置后可以使用并行清除收集器【多CPU】   </p>\n","excerpt":"<p>一、常见的Java内存溢出有以下三种：</p>\n<ol>\n<li><code>java.lang.OutOfMemoryError: Java heap space</code> —-JVM Heap（堆）溢出<br>JVM在启动的时候会自动设置JVM Heap的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)不可超过物理内存。<br>可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。<br>在JVM中如果98％的时间是用于GC，且可用的Heap size 不足2％的时候将抛出此异常信息。<br>解决方法：手动设置JVM Heap（堆）的大小。","more":"</li>\n<li><p><code>java.lang.OutOfMemoryError: PermGen space</code>  —- PermGen space溢出。<br>PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。<br>为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信 息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。<br>解决方法： 手动设置MaxPermSize大小</p>\n</li>\n<li><p><code>java.lang.StackOverflowError</code>  —- 栈溢出<br>栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。<br>调用构造函数的 “层”太多了，以致于把栈区溢出了。<br>通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。<br>通常递归也不要递归的层次过多，很容易溢出。<br>解决方法：修改程序。</p>\n</li>\n</ol>\n<p>二、解决方法</p>\n<p>在生产环境中tomcat内存设置不好很容易出现jvm内存溢出。</p>\n<p>1、 linux下的tomcat：<br>修改TOMCAT_HOME/bin/catalina.sh<br>在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：<br><code>JAVA_OPTS=&quot;-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code>“ </p>\n<p>2、 如果tomcat 5 注册成了windows服务，以services方式启动的，则需要修改注册表中的相应键值。<br>修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Apache Software Foundation\\Tomcat Service Manager\\Tomcat5\\Parameters\\Java，右侧的Options<br>原值为</p>\n<pre><code>-Dcatalina.home=&quot;C:\\ApacheGroup\\Tomcat 5.0&quot;\n-Djava.endorsed.dirs=&quot;C:\\ApacheGroup\\Tomcat 5.0\\common\\endorsed&quot;\n</code></pre><p>-Xrs<br>加入 -Xms256m -Xmx512m<br>重起tomcat服务,设置生效</p>\n<p>3、 如果tomcat 6 注册成了windows服务，或者windows2003下用tomcat的安装版，<br>在/bin/tomcat6w.exe里修改就可以了 。</p>\n<p>4、 如果要在myeclipse中启动tomcat，上述的修改就不起作用了，可如下设置：<br>Myeclipse-&gt;preferences-&gt;myeclipse-&gt;servers-&gt;tomcat-&gt;tomcat×.×-&gt;JDK面板中的<br>Optional Java VM arguments中添加：<code>-Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m</code></p>\n<p>三、jvm参数说明：</p>\n<p>-server:一定要作为第一个参数，在多个CPU时性能佳<br>-Xms：java Heap初始大小。 默认是物理内存的1/64。<br>-Xmx：java heap最大值。建议均设为物理内存的一半。不可超过物理内存。<br>-XX:PermSize:设定内存的永久保存区初始大小，缺省值为64M。（我用visualvm.exe查看的）<br>-XX:MaxPermSize:设定内存的永久保存区最大 大小，缺省值为64M。（我用visualvm.exe查看的）<br>-XX:SurvivorRatio=2  :生还者池的大小,默认是2，如果垃圾回收变成了瓶颈，您可以尝试定制生成池设置<br>-XX:NewSize: 新生成的池的初始大小。 缺省值为2M。<br>-XX:MaxNewSize: 新生成的池的最大大小。   缺省值为32M。<br>如果 JVM 的堆大小大于 1GB，则应该使用值：-XX:newSize=640m -XX:MaxNewSize=640m -XX:SurvivorRatio=16，或者将堆的总大小的 50% 到 60% 分配给新生成的池。调大新对象区，减少Full GC次数。<br>+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。<br>-Xss：每个线程的Stack大小，“-Xss 15120” 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.<br>-verbose:gc 现实垃圾收集信息<br>-Xloggc:gc.log 指定垃圾收集日志文件<br>-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一<br>-XX:+UseParNewGC ：缩短minor收集的时间<br>-XX:+UseConcMarkSweepGC ：缩短major收集的时间 此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。<br>-XX:userParNewGC 可用来设置并行收集【多CPU】<br>-XX:ParallelGCThreads 可用来增加并行度【多CPU】<br>-XX:UseParallelGC 设置后可以使用并行清除收集器【多CPU】   </p>"},{"layout":"post","title":"maven生命周期详解","date":"2012-10-19T14:21:00.000Z","comments":1,"_content":"Maven强大的一个重要的原因是它有一个十分完善的生命周期模型(lifecycle)，这个生命周期可以从两方面来理解，第一，顾名思义，运行Maven的每个步骤都由它来定义的，这种预定义的默认行为使得我们使用Maven变得简单，相比而言，Ant的每个步骤都要你手工去定义。第二，这个模型是一种标准，在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，一般情况下，mvn clean install 这样的命令是通用的。我想，一定是吸收了许多项目的经验，Maven才能定义出如此完善的模型。   \n<!--more-->  \nMaven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：   \n\n* Clean Lifecycle 在进行真正的构建之前进行一些清理工作。  \n* Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。\n* Site Lifecycle 生成项目报告，站点，发布站点。\n\n我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。\n \n知道了每套生命周期的大概用途和相互关系以后，来逐个详细看一下每套生命周期，Clean和Site相对比较简单，先解释一下。   \n \n每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：  \n\n* pre-clean  执行一些需要在clean之前完成的工作\n* clean  移除所有上一次构建生成的文件\n* post-clean  执行一些需要在clean之后立刻完成的工作   \n\nmvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。\n \n下面看一下Site生命周期的各个阶段：  \n\n* pre-site     执行一些需要在生成站点文档之前完成的工作\n* site    生成项目的站点文档\n* post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备\n* site-deploy     将生成的站点文档部署到特定的服务器上   \n\n这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。\n \n最后，来看一下Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：\n\n* validate\n* generate-sources\n* process-sources\n* generate-resources\n* process-resources     复制并处理资源文件，至目标目录，准备打包。\n* compile     编译项目的源代码。\n* process-classes\n* generate-test-sources \n* process-test-sources \n* generate-test-resources\n* process-test-resources     复制并处理资源文件，至目标测试目录。\n* test-compile     编译测试源代码。\n* process-test-classes\n* test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。\n* prepare-package\n* package     接受编译好的代码，打包成可发布的格式，如 JAR 。\n* pre-integration-test\n* integration-test\n* post-integration-test\n* verify\n* install     将包安装至本地仓库，以让其它项目依赖。\n* deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。\n\n基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 <http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html>\n \n记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。\n \n此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，在之后的文章里，我将会进一步解释Maven的插件机制。   \n\n转摘自：<http://juvenshun.iteye.com/blog/213959>","source":"_posts/2012-10-19-maven-life-cycle.markdown","raw":"---\nlayout: post\ntitle: \"maven生命周期详解\"\ndate: 2012-10-19 22:21\ncomments: true\ncategories: maven\ntags: [ 配置, maven, LifeCycle, 生命周期 ]\n---\nMaven强大的一个重要的原因是它有一个十分完善的生命周期模型(lifecycle)，这个生命周期可以从两方面来理解，第一，顾名思义，运行Maven的每个步骤都由它来定义的，这种预定义的默认行为使得我们使用Maven变得简单，相比而言，Ant的每个步骤都要你手工去定义。第二，这个模型是一种标准，在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，一般情况下，mvn clean install 这样的命令是通用的。我想，一定是吸收了许多项目的经验，Maven才能定义出如此完善的模型。   \n<!--more-->  \nMaven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：   \n\n* Clean Lifecycle 在进行真正的构建之前进行一些清理工作。  \n* Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。\n* Site Lifecycle 生成项目报告，站点，发布站点。\n\n我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。\n \n知道了每套生命周期的大概用途和相互关系以后，来逐个详细看一下每套生命周期，Clean和Site相对比较简单，先解释一下。   \n \n每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：  \n\n* pre-clean  执行一些需要在clean之前完成的工作\n* clean  移除所有上一次构建生成的文件\n* post-clean  执行一些需要在clean之后立刻完成的工作   \n\nmvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。\n \n下面看一下Site生命周期的各个阶段：  \n\n* pre-site     执行一些需要在生成站点文档之前完成的工作\n* site    生成项目的站点文档\n* post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备\n* site-deploy     将生成的站点文档部署到特定的服务器上   \n\n这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。\n \n最后，来看一下Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：\n\n* validate\n* generate-sources\n* process-sources\n* generate-resources\n* process-resources     复制并处理资源文件，至目标目录，准备打包。\n* compile     编译项目的源代码。\n* process-classes\n* generate-test-sources \n* process-test-sources \n* generate-test-resources\n* process-test-resources     复制并处理资源文件，至目标测试目录。\n* test-compile     编译测试源代码。\n* process-test-classes\n* test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。\n* prepare-package\n* package     接受编译好的代码，打包成可发布的格式，如 JAR 。\n* pre-integration-test\n* integration-test\n* post-integration-test\n* verify\n* install     将包安装至本地仓库，以让其它项目依赖。\n* deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。\n\n基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 <http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html>\n \n记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。\n \n此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，在之后的文章里，我将会进一步解释Maven的插件机制。   \n\n转摘自：<http://juvenshun.iteye.com/blog/213959>","slug":"2012-10-19-maven-life-cycle","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1w000zv8fyfg2m1tdq","content":"<p>Maven强大的一个重要的原因是它有一个十分完善的生命周期模型(lifecycle)，这个生命周期可以从两方面来理解，第一，顾名思义，运行Maven的每个步骤都由它来定义的，这种预定义的默认行为使得我们使用Maven变得简单，相比而言，Ant的每个步骤都要你手工去定义。第二，这个模型是一种标准，在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，一般情况下，mvn clean install 这样的命令是通用的。我想，一定是吸收了许多项目的经验，Maven才能定义出如此完善的模型。<br><a id=\"more\"></a><br>Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：   </p>\n<ul>\n<li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。  </li>\n<li>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</li>\n<li>Site Lifecycle 生成项目报告，站点，发布站点。</li>\n</ul>\n<p>我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。</p>\n<p>知道了每套生命周期的大概用途和相互关系以后，来逐个详细看一下每套生命周期，Clean和Site相对比较简单，先解释一下。   </p>\n<p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：  </p>\n<ul>\n<li>pre-clean  执行一些需要在clean之前完成的工作</li>\n<li>clean  移除所有上一次构建生成的文件</li>\n<li>post-clean  执行一些需要在clean之后立刻完成的工作   </li>\n</ul>\n<p>mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。</p>\n<p>下面看一下Site生命周期的各个阶段：  </p>\n<ul>\n<li>pre-site     执行一些需要在生成站点文档之前完成的工作</li>\n<li>site    生成项目的站点文档</li>\n<li>post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>\n<li>site-deploy     将生成的站点文档部署到特定的服务器上   </li>\n</ul>\n<p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</p>\n<p>最后，来看一下Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：</p>\n<ul>\n<li>validate</li>\n<li>generate-sources</li>\n<li>process-sources</li>\n<li>generate-resources</li>\n<li>process-resources     复制并处理资源文件，至目标目录，准备打包。</li>\n<li>compile     编译项目的源代码。</li>\n<li>process-classes</li>\n<li>generate-test-sources </li>\n<li>process-test-sources </li>\n<li>generate-test-resources</li>\n<li>process-test-resources     复制并处理资源文件，至目标测试目录。</li>\n<li>test-compile     编译测试源代码。</li>\n<li>process-test-classes</li>\n<li>test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>\n<li>prepare-package</li>\n<li>package     接受编译好的代码，打包成可发布的格式，如 JAR 。</li>\n<li>pre-integration-test</li>\n<li>integration-test</li>\n<li>post-integration-test</li>\n<li>verify</li>\n<li>install     将包安装至本地仓库，以让其它项目依赖。</li>\n<li>deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。</li>\n</ul>\n<p>基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\" target=\"_blank\" rel=\"external\">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>\n<p>记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。</p>\n<p>此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，在之后的文章里，我将会进一步解释Maven的插件机制。   </p>\n<p>转摘自：<a href=\"http://juvenshun.iteye.com/blog/213959\" target=\"_blank\" rel=\"external\">http://juvenshun.iteye.com/blog/213959</a></p>\n","excerpt":"<p>Maven强大的一个重要的原因是它有一个十分完善的生命周期模型(lifecycle)，这个生命周期可以从两方面来理解，第一，顾名思义，运行Maven的每个步骤都由它来定义的，这种预定义的默认行为使得我们使用Maven变得简单，相比而言，Ant的每个步骤都要你手工去定义。第二，这个模型是一种标准，在不同的项目中，使用Maven的接口是一样的，这样就不用去仔细理解每个项目的构建了，一般情况下，mvn clean install 这样的命令是通用的。我想，一定是吸收了许多项目的经验，Maven才能定义出如此完善的模型。<br>","more":"<br>Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将Maven的生命周期看成一个整体，其实不然。这三套生命周期分别是：   </p>\n<ul>\n<li>Clean Lifecycle 在进行真正的构建之前进行一些清理工作。  </li>\n<li>Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</li>\n<li>Site Lifecycle 生成项目报告，站点，发布站点。</li>\n</ul>\n<p>我再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。</p>\n<p>知道了每套生命周期的大概用途和相互关系以后，来逐个详细看一下每套生命周期，Clean和Site相对比较简单，先解释一下。   </p>\n<p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有点绕？要知道有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：  </p>\n<ul>\n<li>pre-clean  执行一些需要在clean之前完成的工作</li>\n<li>clean  移除所有上一次构建生成的文件</li>\n<li>post-clean  执行一些需要在clean之后立刻完成的工作   </li>\n</ul>\n<p>mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。</p>\n<p>下面看一下Site生命周期的各个阶段：  </p>\n<ul>\n<li>pre-site     执行一些需要在生成站点文档之前完成的工作</li>\n<li>site    生成项目的站点文档</li>\n<li>post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>\n<li>site-deploy     将生成的站点文档部署到特定的服务器上   </li>\n</ul>\n<p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</p>\n<p>最后，来看一下Maven的最重要的Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：</p>\n<ul>\n<li>validate</li>\n<li>generate-sources</li>\n<li>process-sources</li>\n<li>generate-resources</li>\n<li>process-resources     复制并处理资源文件，至目标目录，准备打包。</li>\n<li>compile     编译项目的源代码。</li>\n<li>process-classes</li>\n<li>generate-test-sources </li>\n<li>process-test-sources </li>\n<li>generate-test-resources</li>\n<li>process-test-resources     复制并处理资源文件，至目标测试目录。</li>\n<li>test-compile     编译测试源代码。</li>\n<li>process-test-classes</li>\n<li>test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</li>\n<li>prepare-package</li>\n<li>package     接受编译好的代码，打包成可发布的格式，如 JAR 。</li>\n<li>pre-integration-test</li>\n<li>integration-test</li>\n<li>post-integration-test</li>\n<li>verify</li>\n<li>install     将包安装至本地仓库，以让其它项目依赖。</li>\n<li>deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。</li>\n</ul>\n<p>基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>\n<p>记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。</p>\n<p>此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要，在之后的文章里，我将会进一步解释Maven的插件机制。   </p>\n<p>转摘自：<a href=\"http://juvenshun.iteye.com/blog/213959\">http://juvenshun.iteye.com/blog/213959</a></p>"},{"layout":"post","title":"xpath 详解","date":"2012-10-20T02:43:00.000Z","comments":1,"_content":"<div id=\"intro\">\n<p><strong>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</strong></p>\n</div>\n\n\n<div>\n<h2>XML 实例文档</h2>\n<p>我们将在下面的例子中使用这个 XML 文档。</p>\n<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;\n\n&lt;bookstore&gt;\n\n&lt;book&gt;\n  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;\n  &lt;price&gt;29.99&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book&gt;\n  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;\n  &lt;price&gt;39.95&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;/bookstore&gt;</pre>\n</div>\n<!--more-->\n\n<div>\n<h2>选取节点</h2>\n\n<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p>\n\n<h3>下面列出了最有用的路径表达式：</h3>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">表达式</th>\n<th>描述</th>\n</tr>\n\n<tr>\n<td>nodename</td>\n<td>选取此节点的所有子节点。</td>\n</tr>\n\n<tr>\n<td>/</td>\n<td>从根节点选取。</td>\n</tr>\n\n<tr>\n<td>//</td>\n<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>\n</tr>\n\n<tr>\n<td>.</td>\n<td>选取当前节点。</td>\n</tr>\n\n<tr>\n<td>..</td>\n<td>选取当前节点的父节点。</td>\n</tr>\n\n<tr>\n<td>@</td>\n<td>选取属性。</td>\n</tr>\n</table>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>bookstore</td>\n<td>选取 bookstore 元素的所有子节点。</td>\n</tr>\n\n<tr>\n<td>/bookstore</td>\n<td>\n<p>选取根元素 bookstore。</p>\n<p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p>\n</td>\n</tr>\n\n<tr>\n<td>bookstore/book</td>\n<td>选取属于 bookstore 的子元素的所有 book 元素。</td>\n</tr>\n\n<tr>\n<td>//book</td>\n<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>\n</tr>\n\n<tr>\n<td>bookstore//book</td>\n<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>\n</tr>\n\n<tr>\n<td>//@lang</td>\n<td>选取名为 lang 的所有属性。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>谓语（Predicates）</h2>\n\n<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>\n<p>谓语被嵌在方括号中。</p>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:35%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>/bookstore/book[1]</td>\n<td>选取属于 bookstore 子元素的第一个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[last()]</td>\n<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[last()-1]</td>\n<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[position()&lt;3]</td>\n<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>\n</tr>\n\n<tr>\n<td>//title[@lang]</td>\n<td>选取所有拥有名为 lang 的属性的 title 元素。</td>\n</tr>\n\n<tr>\n<td>//title[@lang='eng']</td>\n<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[price&gt;35.00]</td>\n<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[price&gt;35.00]/title</td>\n<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>选取未知节点</h2>\n\n<p>XPath 通配符可用来选取未知的 XML 元素。</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">通配符</th>\n<th>描述</th>\n</tr>\n\n<tr>\n<td>*</td>\n<td>匹配任何元素节点。</td>\n</tr>\n\n<tr>\n<td>@*</td>\n<td>匹配任何属性节点。</td>\n</tr>\n\n<tr>\n<td>node()</td>\n<td>匹配任何类型的节点。</td>\n</tr>\n</table>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>/bookstore/*</td>\n<td>选取 bookstore 元素的所有子元素。</td>\n</tr>\n\n<tr>\n<td>//*</td>\n<td>选取文档中的所有元素。</td>\n</tr>\n\n<tr>\n<td>//title[@*]</td>\n<td>选取所有带有属性的 title 元素。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>选取若干路径</h2>\n\n<p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:35%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>//book/title | //book/price</td>\n<td>选取 book 元素的所有 title 和 price 元素。</td>\n</tr>\n\n<tr>\n<td>//title | //price</td>\n<td>选取文档中的所有 title 和 price 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book/title | //price</td>\n<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>\n</tr>\n</table>\n</div>\n\n","source":"_posts/2012-10-20-xpath.markdown","raw":"---\nlayout: post\ntitle: \"xpath 详解\"\ndate: 2012-10-20 10:43\ncomments: true\ncategories: selenium\ntags: [ webdriver, selenium, xpath, DOM ]\n---\n<div id=\"intro\">\n<p><strong>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</strong></p>\n</div>\n\n\n<div>\n<h2>XML 实例文档</h2>\n<p>我们将在下面的例子中使用这个 XML 文档。</p>\n<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;\n\n&lt;bookstore&gt;\n\n&lt;book&gt;\n  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;\n  &lt;price&gt;29.99&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;book&gt;\n  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;\n  &lt;price&gt;39.95&lt;/price&gt;\n&lt;/book&gt;\n\n&lt;/bookstore&gt;</pre>\n</div>\n<!--more-->\n\n<div>\n<h2>选取节点</h2>\n\n<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p>\n\n<h3>下面列出了最有用的路径表达式：</h3>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">表达式</th>\n<th>描述</th>\n</tr>\n\n<tr>\n<td>nodename</td>\n<td>选取此节点的所有子节点。</td>\n</tr>\n\n<tr>\n<td>/</td>\n<td>从根节点选取。</td>\n</tr>\n\n<tr>\n<td>//</td>\n<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>\n</tr>\n\n<tr>\n<td>.</td>\n<td>选取当前节点。</td>\n</tr>\n\n<tr>\n<td>..</td>\n<td>选取当前节点的父节点。</td>\n</tr>\n\n<tr>\n<td>@</td>\n<td>选取属性。</td>\n</tr>\n</table>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>bookstore</td>\n<td>选取 bookstore 元素的所有子节点。</td>\n</tr>\n\n<tr>\n<td>/bookstore</td>\n<td>\n<p>选取根元素 bookstore。</p>\n<p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p>\n</td>\n</tr>\n\n<tr>\n<td>bookstore/book</td>\n<td>选取属于 bookstore 的子元素的所有 book 元素。</td>\n</tr>\n\n<tr>\n<td>//book</td>\n<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>\n</tr>\n\n<tr>\n<td>bookstore//book</td>\n<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>\n</tr>\n\n<tr>\n<td>//@lang</td>\n<td>选取名为 lang 的所有属性。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>谓语（Predicates）</h2>\n\n<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>\n<p>谓语被嵌在方括号中。</p>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:35%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>/bookstore/book[1]</td>\n<td>选取属于 bookstore 子元素的第一个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[last()]</td>\n<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[last()-1]</td>\n<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[position()&lt;3]</td>\n<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>\n</tr>\n\n<tr>\n<td>//title[@lang]</td>\n<td>选取所有拥有名为 lang 的属性的 title 元素。</td>\n</tr>\n\n<tr>\n<td>//title[@lang='eng']</td>\n<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[price&gt;35.00]</td>\n<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book[price&gt;35.00]/title</td>\n<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>选取未知节点</h2>\n\n<p>XPath 通配符可用来选取未知的 XML 元素。</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">通配符</th>\n<th>描述</th>\n</tr>\n\n<tr>\n<td>*</td>\n<td>匹配任何元素节点。</td>\n</tr>\n\n<tr>\n<td>@*</td>\n<td>匹配任何属性节点。</td>\n</tr>\n\n<tr>\n<td>node()</td>\n<td>匹配任何类型的节点。</td>\n</tr>\n</table>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:25%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>/bookstore/*</td>\n<td>选取 bookstore 元素的所有子元素。</td>\n</tr>\n\n<tr>\n<td>//*</td>\n<td>选取文档中的所有元素。</td>\n</tr>\n\n<tr>\n<td>//title[@*]</td>\n<td>选取所有带有属性的 title 元素。</td>\n</tr>\n</table>\n</div>\n\n\n<div>\n<h2>选取若干路径</h2>\n\n<p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>\n\n<h3>实例</h3>\n\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n\n<table class=\"dataintable\">\n<tr>\n<th style=\"width:35%;\">路径表达式</th>\n<th>结果</th>\n</tr>\n\n<tr>\n<td>//book/title | //book/price</td>\n<td>选取 book 元素的所有 title 和 price 元素。</td>\n</tr>\n\n<tr>\n<td>//title | //price</td>\n<td>选取文档中的所有 title 和 price 元素。</td>\n</tr>\n\n<tr>\n<td>/bookstore/book/title | //price</td>\n<td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>\n</tr>\n</table>\n</div>\n\n","slug":"2012-10-20-xpath","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop1z0013v8fy0ifujnzz","content":"<div id=\"intro\"><br><p><strong>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</strong></p><br></div>\n\n\n<div><br><h2>XML 实例文档</h2><br><p>我们将在下面的例子中使用这个 XML 文档。</p><br><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;<br><br>&lt;bookstore&gt;<br><br>&lt;book&gt;<br>  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;<br>  &lt;price&gt;29.99&lt;/price&gt;<br>&lt;/book&gt;<br><br>&lt;book&gt;<br>  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;<br>  &lt;price&gt;39.95&lt;/price&gt;<br>&lt;/book&gt;<br><br>&lt;/bookstore&gt;</pre><br></div><br><a id=\"more\"></a><br><br><div><br><h2>选取节点</h2><br><br><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p><br><br><h3>下面列出了最有用的路径表达式：</h3><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">表达式</th><br><th>描述</th><br></tr><br><br><tr><br><td>nodename</td><br><td>选取此节点的所有子节点。</td><br></tr><br><br><tr><br><td>/</td><br><td>从根节点选取。</td><br></tr><br><br><tr><br><td>//</td><br><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td><br></tr><br><br><tr><br><td>.</td><br><td>选取当前节点。</td><br></tr><br><br><tr><br><td>..</td><br><td>选取当前节点的父节点。</td><br></tr><br><br><tr><br><td>@</td><br><td>选取属性。</td><br></tr><br></table><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>bookstore</td><br><td>选取 bookstore 元素的所有子节点。</td><br></tr><br><br><tr><br><td>/bookstore</td><br><td><br><p>选取根元素 bookstore。</p><br><p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p><br></td><br></tr><br><br><tr><br><td>bookstore/book</td><br><td>选取属于 bookstore 的子元素的所有 book 元素。</td><br></tr><br><br><tr><br><td>//book</td><br><td>选取所有 book 子元素，而不管它们在文档中的位置。</td><br></tr><br><br><tr><br><td>bookstore//book</td><br><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td><br></tr><br><br><tr><br><td>//@lang</td><br><td>选取名为 lang 的所有属性。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>谓语（Predicates）</h2><br><br><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p><br><p>谓语被嵌在方括号中。</p><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:35%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>/bookstore/book[1]</td><br><td>选取属于 bookstore 子元素的第一个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[last()]</td><br><td>选取属于 bookstore 子元素的最后一个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[last()-1]</td><br><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[position()&lt;3]</td><br><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td><br></tr><br><br><tr><br><td>//title[@lang]</td><br><td>选取所有拥有名为 lang 的属性的 title 元素。</td><br></tr><br><br><tr><br><td>//title[@lang=’eng’]</td><br><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td><br></tr><br><br><tr><br><td>/bookstore/book[price&gt;35.00]</td><br><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td><br></tr><br><br><tr><br><td>/bookstore/book[price&gt;35.00]/title</td><br><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>选取未知节点</h2><br><br><p>XPath 通配符可用来选取未知的 XML 元素。</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">通配符</th><br><th>描述</th><br></tr><br><br><tr><br><td><em></em></td><br><td>匹配任何元素节点。</td><br></tr><br><br><tr><br><td>@</td><br><td>匹配任何属性节点。</td><br></tr><br><br><tr><br><td>node()</td><br><td>匹配任何类型的节点。</td><br></tr><br></table><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>/bookstore/<em></em></td><br><td>选取 bookstore 元素的所有子元素。</td><br></tr><br><br><tr><br><td>//</td><br><td>选取文档中的所有元素。</td><br></tr><br><br><tr><br><td>//title[@*]</td><br><td>选取所有带有属性的 title 元素。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>选取若干路径</h2><br><br><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:35%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>//book/title | //book/price</td><br><td>选取 book 元素的所有 title 和 price 元素。</td><br></tr><br><br><tr><br><td>//title | //price</td><br><td>选取文档中的所有 title 和 price 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book/title | //price</td><br><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td><br></tr><br></table><br></div>\n\n","excerpt":"<div id=\"intro\"><br><p><strong>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</strong></p><br></div>\n\n\n<div><br><h2>XML 实例文档</h2><br><p>我们将在下面的例子中使用这个 XML 文档。</p><br><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;<br><br>&lt;bookstore&gt;<br><br>&lt;book&gt;<br>  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;<br>  &lt;price&gt;29.99&lt;/price&gt;<br>&lt;/book&gt;<br><br>&lt;book&gt;<br>  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;<br>  &lt;price&gt;39.95&lt;/price&gt;<br>&lt;/book&gt;<br><br>&lt;/bookstore&gt;</pre><br></div><br>","more":"<br><br><div><br><h2>选取节点</h2><br><br><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p><br><br><h3>下面列出了最有用的路径表达式：</h3><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">表达式</th><br><th>描述</th><br></tr><br><br><tr><br><td>nodename</td><br><td>选取此节点的所有子节点。</td><br></tr><br><br><tr><br><td>/</td><br><td>从根节点选取。</td><br></tr><br><br><tr><br><td>//</td><br><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td><br></tr><br><br><tr><br><td>.</td><br><td>选取当前节点。</td><br></tr><br><br><tr><br><td>..</td><br><td>选取当前节点的父节点。</td><br></tr><br><br><tr><br><td>@</td><br><td>选取属性。</td><br></tr><br></table><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>bookstore</td><br><td>选取 bookstore 元素的所有子节点。</td><br></tr><br><br><tr><br><td>/bookstore</td><br><td><br><p>选取根元素 bookstore。</p><br><p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p><br></td><br></tr><br><br><tr><br><td>bookstore/book</td><br><td>选取属于 bookstore 的子元素的所有 book 元素。</td><br></tr><br><br><tr><br><td>//book</td><br><td>选取所有 book 子元素，而不管它们在文档中的位置。</td><br></tr><br><br><tr><br><td>bookstore//book</td><br><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td><br></tr><br><br><tr><br><td>//@lang</td><br><td>选取名为 lang 的所有属性。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>谓语（Predicates）</h2><br><br><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p><br><p>谓语被嵌在方括号中。</p><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:35%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>/bookstore/book[1]</td><br><td>选取属于 bookstore 子元素的第一个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[last()]</td><br><td>选取属于 bookstore 子元素的最后一个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[last()-1]</td><br><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book[position()&lt;3]</td><br><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td><br></tr><br><br><tr><br><td>//title[@lang]</td><br><td>选取所有拥有名为 lang 的属性的 title 元素。</td><br></tr><br><br><tr><br><td>//title[@lang=’eng’]</td><br><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td><br></tr><br><br><tr><br><td>/bookstore/book[price&gt;35.00]</td><br><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td><br></tr><br><br><tr><br><td>/bookstore/book[price&gt;35.00]/title</td><br><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>选取未知节点</h2><br><br><p>XPath 通配符可用来选取未知的 XML 元素。</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">通配符</th><br><th>描述</th><br></tr><br><br><tr><br><td><em></td><br><td>匹配任何元素节点。</td><br></tr><br><br><tr><br><td>@</em></td><br><td>匹配任何属性节点。</td><br></tr><br><br><tr><br><td>node()</td><br><td>匹配任何类型的节点。</td><br></tr><br></table><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:25%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>/bookstore/<em></td><br><td>选取 bookstore 元素的所有子元素。</td><br></tr><br><br><tr><br><td>//</em></td><br><td>选取文档中的所有元素。</td><br></tr><br><br><tr><br><td>//title[@*]</td><br><td>选取所有带有属性的 title 元素。</td><br></tr><br></table><br></div>\n\n\n<div><br><h2>选取若干路径</h2><br><br><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><br><br><h3>实例</h3><br><br><p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><br><br><table class=\"dataintable\"><br><tr><br><th style=\"width:35%;\">路径表达式</th><br><th>结果</th><br></tr><br><br><tr><br><td>//book/title | //book/price</td><br><td>选取 book 元素的所有 title 和 price 元素。</td><br></tr><br><br><tr><br><td>//title | //price</td><br><td>选取文档中的所有 title 和 price 元素。</td><br></tr><br><br><tr><br><td>/bookstore/book/title | //price</td><br><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td><br></tr><br></table><br></div>"},{"layout":"post","title":"Git 命令","date":"2012-10-20T02:56:00.000Z","comments":1,"_content":"##Git 命令结构图：  \n \n<!--more-->\n\n![git command](/images/blog/git-command.png)","source":"_posts/2012-10-20-git-command.markdown","raw":"---\nlayout: post\ntitle: \"Git 命令\"\ndate: 2012-10-20 10:56\ncomments: true\ncategories: git\ntags: [ git, command ]\n---\n##Git 命令结构图：  \n \n<!--more-->\n\n![git command](/images/blog/git-command.png)","slug":"2012-10-20-git-command","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop210016v8fyce2wtlyp","content":"<p>##Git 命令结构图：  </p>\n<a id=\"more\"></a>\n<p><img src=\"/images/blog/git-command.png\" alt=\"git command\"></p>\n","excerpt":"<p>##Git 命令结构图：  </p>","more":"<p><img src=\"/images/blog/git-command.png\" alt=\"git command\"></p>"},{"layout":"post","title":"23个经典JDK设计模式","date":"2012-10-22T12:49:00.000Z","comments":1,"_content":"\n下面是JDK中有关23个经典设计模式的示例：\n\n<!--more-->\n\n##Structural（结构模式）##\n\n**Adapter:**\n\n把一个接口或是类变成另外一种。\n\n● java.util.Arrays#asList()  \n● javax.swing.JTable(TableModel)  \n● java.io.InputStreamReader(InputStream)   \n● java.io.OutputStreamWriter(OutputStream)   \n● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()  \n● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()   \n\n**Bridge:**\n\n把抽象和实现解藕，于是接口和实现可在完全独立开来。 \n\n● AWT (提供了抽象层映射于实际的操作系统)  \n● JDBC  \n\n**Composite:**\n\n让使用者把单独的对象和组合对象混用。\n\n● javax.swing.JComponent#add(Component)   \n● java.awt.Container#add(Component)   \n● java.util.Map#putAll(Map)   \n● java.util.List#addAll(Collection)   \n● java.util.Set#addAll(Collection)   \n\n**Decorator:**\n\n为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。\n\n● java.io.BufferedInputStream(InputStream)   \n● java.io.DataInputStream(InputStream)   \n● java.io.BufferedOutputStream(OutputStream)   \n● java.util.zip.ZipOutputStream(OutputStream)   \n● java.util.Collections#checked\\[List|Map|Set|SortedSet|SortedMap\\]()   \n\n**Facade:**\n\n用一个简单的接口包状一组组件，接口，抽象或是子系统。\n\n● java.lang.Class   \n● javax.faces.webapp.FacesServlet   \n\n**Flyweight:**\n\n有效率地存储大量的小的对象。   \n\n● java.lang.Integer#valueOf(int)   \n● java.lang.Boolean#valueOf(boolean)   \n● java.lang.Byte#valueOf(byte)   \n● java.lang.Character#valueOf(char)   \n\n**Proxy:**\n\n用一个简单的对象来代替一个复杂的对象。\n\n● java.lang.reflect.Proxy   \n● RMI   \n\n##Creational（创建模式）##\n\n**Abstract factory:**\n\n创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。\n\n● java.util.Calendar#getInstance()    \n● java.util.Arrays#asList()   \n● java.util.ResourceBundle#getBundle()   \n● java.sql.DriverManager#getConnection()   \n● java.sql.Connection#createStatement()   \n● java.sql.Statement#executeQuery()   \n● java.text.NumberFormat#getInstance()   \n● javax.xml.transform.TransformerFactory#newInstance()   \n\n**Builder:**\n\n主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。\n\n● java.lang.StringBuilder#append()   \n● java.lang.StringBuffer#append()   \n● java.sql.PreparedStatement   \n● javax.swing.GroupLayout.Group#addComponent()   \n\n**Factory:**\n\n简单来说，按照需求返回一个类型的实例。\n\n● java.lang.Proxy#newProxyInstance()   \n● java.lang.Object#toString()   \n● java.lang.Class#newInstance()   \n● java.lang.reflect.Array#newInstance()   \n● java.lang.reflect.Constructor#newInstance()   \n● java.lang.Boolean#valueOf(String)   \n● java.lang.Class#forName()   \n\n**Prototype:**\n\n使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。\n\n● java.lang.Object#clone()   \n● java.lang.Cloneable   \n\n**Singleton:**\n\n只允许一个实例。在 Effective Java中建议使用Emun.\n\n● java.lang.Runtime#getRuntime()   \n● java.awt.Toolkit#getDefaultToolkit()   \n● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()   \n● java.awt.Desktop#getDesktop()   \n\n##Behavioral(行为模式)##\n\n**Chain of responsibility:**   \n\n把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。\n\n● java.util.logging.Logger#log()   \n● javax.servlet.Filter#doFilter()   \n\n**Command:**\n\n把一个或一些命令封装到一个对象中。\n\n● java.lang.Runnable   \n● javax.swing.Action   \n\n**Interpreter:**\n\n一个语法解释器的模式。\n\n● java.util.Pattern    \n● java.text.Normalizer   \n● java.text.Format   \n\n**Iterator:**\n\n提供一种一致的方法来顺序遍历一个容器中的所有元素。  \n\n● java.util.Iterator   \n● java.util.Enumeration   \n\n**Mediator:**\n\n用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。\n\n● java.util.Timer   \n● java.util.concurrent.Executor#execute()   \n● java.util.concurrent.ExecutorService#submit()   \n● java.lang.reflect.Method#invoke()   \n\n**Memento:**\n\n给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。\n\n● java.util.Date   \n● java.io.Serializable   \n\n**Null Object:**\n\n这个模式用来解决如果一个Collection中没有元素的情况。  \n\n● java.util.Collections#emptyList()   \n● java.util.Collections#emptyMap()   \n● java.util.Collections#emptySet()   \n\n**Observer:**\n\n允许一个对象向所有的侦听的对象广播自己的消息或事件。\n\n● java.util.EventListener   \n● javax.servlet.http.HttpSessionBindingListener   \n● javax.servlet.http.HttpSessionAttributeListener   \n● javax.faces.event.PhaseListener   \n\n**State:**\n\n这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。\n\n● java.util.Iterator   \n● javax.faces.lifecycle.LifeCycle#execute()   \n\n**Strategy:**\n\n定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。  \n\n● java.util.Comparator#compare()   \n● javax.servlet.http.HttpServlet   \n● javax.servlet.Filter#doFilter()   \n\n**Template method:**\n\n允许子类重载部分父类而不需要完全重写。\n\n● java.util.Collections#sort()   \n● java.io.InputStream#skip()   \n● java.io.InputStream#read()   \n● java.util.AbstractList#indexOf()   \n\n**Visitor:**\n\n作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作. \n\n● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor   \n● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor   \n\n\n在stakeoverflow也有相应的讨论：\n\n<http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns>\n\n摘自：<http://www.csdn.net/article/2010-11-29/282644>","source":"_posts/2012-10-22-design-pattern-in-jdk-index.markdown","raw":"---\nlayout: post\ntitle: \"23个经典JDK设计模式\"\ndate: 2012-10-22 20:49\ncomments: true\ncategories: 设计模式\ntags: [ JDK, design pattern ]\n---\n\n下面是JDK中有关23个经典设计模式的示例：\n\n<!--more-->\n\n##Structural（结构模式）##\n\n**Adapter:**\n\n把一个接口或是类变成另外一种。\n\n● java.util.Arrays#asList()  \n● javax.swing.JTable(TableModel)  \n● java.io.InputStreamReader(InputStream)   \n● java.io.OutputStreamWriter(OutputStream)   \n● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()  \n● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()   \n\n**Bridge:**\n\n把抽象和实现解藕，于是接口和实现可在完全独立开来。 \n\n● AWT (提供了抽象层映射于实际的操作系统)  \n● JDBC  \n\n**Composite:**\n\n让使用者把单独的对象和组合对象混用。\n\n● javax.swing.JComponent#add(Component)   \n● java.awt.Container#add(Component)   \n● java.util.Map#putAll(Map)   \n● java.util.List#addAll(Collection)   \n● java.util.Set#addAll(Collection)   \n\n**Decorator:**\n\n为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。\n\n● java.io.BufferedInputStream(InputStream)   \n● java.io.DataInputStream(InputStream)   \n● java.io.BufferedOutputStream(OutputStream)   \n● java.util.zip.ZipOutputStream(OutputStream)   \n● java.util.Collections#checked\\[List|Map|Set|SortedSet|SortedMap\\]()   \n\n**Facade:**\n\n用一个简单的接口包状一组组件，接口，抽象或是子系统。\n\n● java.lang.Class   \n● javax.faces.webapp.FacesServlet   \n\n**Flyweight:**\n\n有效率地存储大量的小的对象。   \n\n● java.lang.Integer#valueOf(int)   \n● java.lang.Boolean#valueOf(boolean)   \n● java.lang.Byte#valueOf(byte)   \n● java.lang.Character#valueOf(char)   \n\n**Proxy:**\n\n用一个简单的对象来代替一个复杂的对象。\n\n● java.lang.reflect.Proxy   \n● RMI   \n\n##Creational（创建模式）##\n\n**Abstract factory:**\n\n创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。\n\n● java.util.Calendar#getInstance()    \n● java.util.Arrays#asList()   \n● java.util.ResourceBundle#getBundle()   \n● java.sql.DriverManager#getConnection()   \n● java.sql.Connection#createStatement()   \n● java.sql.Statement#executeQuery()   \n● java.text.NumberFormat#getInstance()   \n● javax.xml.transform.TransformerFactory#newInstance()   \n\n**Builder:**\n\n主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。\n\n● java.lang.StringBuilder#append()   \n● java.lang.StringBuffer#append()   \n● java.sql.PreparedStatement   \n● javax.swing.GroupLayout.Group#addComponent()   \n\n**Factory:**\n\n简单来说，按照需求返回一个类型的实例。\n\n● java.lang.Proxy#newProxyInstance()   \n● java.lang.Object#toString()   \n● java.lang.Class#newInstance()   \n● java.lang.reflect.Array#newInstance()   \n● java.lang.reflect.Constructor#newInstance()   \n● java.lang.Boolean#valueOf(String)   \n● java.lang.Class#forName()   \n\n**Prototype:**\n\n使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。\n\n● java.lang.Object#clone()   \n● java.lang.Cloneable   \n\n**Singleton:**\n\n只允许一个实例。在 Effective Java中建议使用Emun.\n\n● java.lang.Runtime#getRuntime()   \n● java.awt.Toolkit#getDefaultToolkit()   \n● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()   \n● java.awt.Desktop#getDesktop()   \n\n##Behavioral(行为模式)##\n\n**Chain of responsibility:**   \n\n把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。\n\n● java.util.logging.Logger#log()   \n● javax.servlet.Filter#doFilter()   \n\n**Command:**\n\n把一个或一些命令封装到一个对象中。\n\n● java.lang.Runnable   \n● javax.swing.Action   \n\n**Interpreter:**\n\n一个语法解释器的模式。\n\n● java.util.Pattern    \n● java.text.Normalizer   \n● java.text.Format   \n\n**Iterator:**\n\n提供一种一致的方法来顺序遍历一个容器中的所有元素。  \n\n● java.util.Iterator   \n● java.util.Enumeration   \n\n**Mediator:**\n\n用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。\n\n● java.util.Timer   \n● java.util.concurrent.Executor#execute()   \n● java.util.concurrent.ExecutorService#submit()   \n● java.lang.reflect.Method#invoke()   \n\n**Memento:**\n\n给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。\n\n● java.util.Date   \n● java.io.Serializable   \n\n**Null Object:**\n\n这个模式用来解决如果一个Collection中没有元素的情况。  \n\n● java.util.Collections#emptyList()   \n● java.util.Collections#emptyMap()   \n● java.util.Collections#emptySet()   \n\n**Observer:**\n\n允许一个对象向所有的侦听的对象广播自己的消息或事件。\n\n● java.util.EventListener   \n● javax.servlet.http.HttpSessionBindingListener   \n● javax.servlet.http.HttpSessionAttributeListener   \n● javax.faces.event.PhaseListener   \n\n**State:**\n\n这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。\n\n● java.util.Iterator   \n● javax.faces.lifecycle.LifeCycle#execute()   \n\n**Strategy:**\n\n定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。  \n\n● java.util.Comparator#compare()   \n● javax.servlet.http.HttpServlet   \n● javax.servlet.Filter#doFilter()   \n\n**Template method:**\n\n允许子类重载部分父类而不需要完全重写。\n\n● java.util.Collections#sort()   \n● java.io.InputStream#skip()   \n● java.io.InputStream#read()   \n● java.util.AbstractList#indexOf()   \n\n**Visitor:**\n\n作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作. \n\n● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor   \n● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor   \n\n\n在stakeoverflow也有相应的讨论：\n\n<http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns>\n\n摘自：<http://www.csdn.net/article/2010-11-29/282644>","slug":"2012-10-22-design-pattern-in-jdk-index","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop230018v8fyye1sv9ho","content":"<p>下面是JDK中有关23个经典设计模式的示例：</p>\n<a id=\"more\"></a>\n<p>##Structural（结构模式）##</p>\n<p><strong>Adapter:</strong></p>\n<p>把一个接口或是类变成另外一种。</p>\n<p>● java.util.Arrays#asList()<br>● javax.swing.JTable(TableModel)<br>● java.io.InputStreamReader(InputStream)<br>● java.io.OutputStreamWriter(OutputStream)<br>● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br>● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()   </p>\n<p><strong>Bridge:</strong></p>\n<p>把抽象和实现解藕，于是接口和实现可在完全独立开来。 </p>\n<p>● AWT (提供了抽象层映射于实际的操作系统)<br>● JDBC  </p>\n<p><strong>Composite:</strong></p>\n<p>让使用者把单独的对象和组合对象混用。</p>\n<p>● javax.swing.JComponent#add(Component)<br>● java.awt.Container#add(Component)<br>● java.util.Map#putAll(Map)<br>● java.util.List#addAll(Collection)<br>● java.util.Set#addAll(Collection)   </p>\n<p><strong>Decorator:</strong></p>\n<p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。</p>\n<p>● java.io.BufferedInputStream(InputStream)<br>● java.io.DataInputStream(InputStream)<br>● java.io.BufferedOutputStream(OutputStream)<br>● java.util.zip.ZipOutputStream(OutputStream)<br>● java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()   </p>\n<p><strong>Facade:</strong></p>\n<p>用一个简单的接口包状一组组件，接口，抽象或是子系统。</p>\n<p>● java.lang.Class<br>● javax.faces.webapp.FacesServlet   </p>\n<p><strong>Flyweight:</strong></p>\n<p>有效率地存储大量的小的对象。   </p>\n<p>● java.lang.Integer#valueOf(int)<br>● java.lang.Boolean#valueOf(boolean)<br>● java.lang.Byte#valueOf(byte)<br>● java.lang.Character#valueOf(char)   </p>\n<p><strong>Proxy:</strong></p>\n<p>用一个简单的对象来代替一个复杂的对象。</p>\n<p>● java.lang.reflect.Proxy<br>● RMI   </p>\n<p>##Creational（创建模式）##</p>\n<p><strong>Abstract factory:</strong></p>\n<p>创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p>\n<p>● java.util.Calendar#getInstance()<br>● java.util.Arrays#asList()<br>● java.util.ResourceBundle#getBundle()<br>● java.sql.DriverManager#getConnection()<br>● java.sql.Connection#createStatement()<br>● java.sql.Statement#executeQuery()<br>● java.text.NumberFormat#getInstance()<br>● javax.xml.transform.TransformerFactory#newInstance()   </p>\n<p><strong>Builder:</strong></p>\n<p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。</p>\n<p>● java.lang.StringBuilder#append()<br>● java.lang.StringBuffer#append()<br>● java.sql.PreparedStatement<br>● javax.swing.GroupLayout.Group#addComponent()   </p>\n<p><strong>Factory:</strong></p>\n<p>简单来说，按照需求返回一个类型的实例。</p>\n<p>● java.lang.Proxy#newProxyInstance()<br>● java.lang.Object#toString()<br>● java.lang.Class#newInstance()<br>● java.lang.reflect.Array#newInstance()<br>● java.lang.reflect.Constructor#newInstance()<br>● java.lang.Boolean#valueOf(String)<br>● java.lang.Class#forName()   </p>\n<p><strong>Prototype:</strong></p>\n<p>使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。</p>\n<p>● java.lang.Object#clone()<br>● java.lang.Cloneable   </p>\n<p><strong>Singleton:</strong></p>\n<p>只允许一个实例。在 Effective Java中建议使用Emun.</p>\n<p>● java.lang.Runtime#getRuntime()<br>● java.awt.Toolkit#getDefaultToolkit()<br>● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()<br>● java.awt.Desktop#getDesktop()   </p>\n<p>##Behavioral(行为模式)##</p>\n<p><strong>Chain of responsibility:</strong>   </p>\n<p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。</p>\n<p>● java.util.logging.Logger#log()<br>● javax.servlet.Filter#doFilter()   </p>\n<p><strong>Command:</strong></p>\n<p>把一个或一些命令封装到一个对象中。</p>\n<p>● java.lang.Runnable<br>● javax.swing.Action   </p>\n<p><strong>Interpreter:</strong></p>\n<p>一个语法解释器的模式。</p>\n<p>● java.util.Pattern<br>● java.text.Normalizer<br>● java.text.Format   </p>\n<p><strong>Iterator:</strong></p>\n<p>提供一种一致的方法来顺序遍历一个容器中的所有元素。  </p>\n<p>● java.util.Iterator<br>● java.util.Enumeration   </p>\n<p><strong>Mediator:</strong></p>\n<p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。</p>\n<p>● java.util.Timer<br>● java.util.concurrent.Executor#execute()<br>● java.util.concurrent.ExecutorService#submit()<br>● java.lang.reflect.Method#invoke()   </p>\n<p><strong>Memento:</strong></p>\n<p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。</p>\n<p>● java.util.Date<br>● java.io.Serializable   </p>\n<p><strong>Null Object:</strong></p>\n<p>这个模式用来解决如果一个Collection中没有元素的情况。  </p>\n<p>● java.util.Collections#emptyList()<br>● java.util.Collections#emptyMap()<br>● java.util.Collections#emptySet()   </p>\n<p><strong>Observer:</strong></p>\n<p>允许一个对象向所有的侦听的对象广播自己的消息或事件。</p>\n<p>● java.util.EventListener<br>● javax.servlet.http.HttpSessionBindingListener<br>● javax.servlet.http.HttpSessionAttributeListener<br>● javax.faces.event.PhaseListener   </p>\n<p><strong>State:</strong></p>\n<p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。</p>\n<p>● java.util.Iterator<br>● javax.faces.lifecycle.LifeCycle#execute()   </p>\n<p><strong>Strategy:</strong></p>\n<p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。  </p>\n<p>● java.util.Comparator#compare()<br>● javax.servlet.http.HttpServlet<br>● javax.servlet.Filter#doFilter()   </p>\n<p><strong>Template method:</strong></p>\n<p>允许子类重载部分父类而不需要完全重写。</p>\n<p>● java.util.Collections#sort()<br>● java.io.InputStream#skip()<br>● java.io.InputStream#read()<br>● java.util.AbstractList#indexOf()   </p>\n<p><strong>Visitor:</strong></p>\n<p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作. </p>\n<p>● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor<br>● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor   </p>\n<p>在stakeoverflow也有相应的讨论：</p>\n<p><a href=\"http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns</a></p>\n<p>摘自：<a href=\"http://www.csdn.net/article/2010-11-29/282644\" target=\"_blank\" rel=\"external\">http://www.csdn.net/article/2010-11-29/282644</a></p>\n","excerpt":"<p>下面是JDK中有关23个经典设计模式的示例：</p>","more":"<p>##Structural（结构模式）##</p>\n<p><strong>Adapter:</strong></p>\n<p>把一个接口或是类变成另外一种。</p>\n<p>● java.util.Arrays#asList()<br>● javax.swing.JTable(TableModel)<br>● java.io.InputStreamReader(InputStream)<br>● java.io.OutputStreamWriter(OutputStream)<br>● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br>● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()   </p>\n<p><strong>Bridge:</strong></p>\n<p>把抽象和实现解藕，于是接口和实现可在完全独立开来。 </p>\n<p>● AWT (提供了抽象层映射于实际的操作系统)<br>● JDBC  </p>\n<p><strong>Composite:</strong></p>\n<p>让使用者把单独的对象和组合对象混用。</p>\n<p>● javax.swing.JComponent#add(Component)<br>● java.awt.Container#add(Component)<br>● java.util.Map#putAll(Map)<br>● java.util.List#addAll(Collection)<br>● java.util.Set#addAll(Collection)   </p>\n<p><strong>Decorator:</strong></p>\n<p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。</p>\n<p>● java.io.BufferedInputStream(InputStream)<br>● java.io.DataInputStream(InputStream)<br>● java.io.BufferedOutputStream(OutputStream)<br>● java.util.zip.ZipOutputStream(OutputStream)<br>● java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()   </p>\n<p><strong>Facade:</strong></p>\n<p>用一个简单的接口包状一组组件，接口，抽象或是子系统。</p>\n<p>● java.lang.Class<br>● javax.faces.webapp.FacesServlet   </p>\n<p><strong>Flyweight:</strong></p>\n<p>有效率地存储大量的小的对象。   </p>\n<p>● java.lang.Integer#valueOf(int)<br>● java.lang.Boolean#valueOf(boolean)<br>● java.lang.Byte#valueOf(byte)<br>● java.lang.Character#valueOf(char)   </p>\n<p><strong>Proxy:</strong></p>\n<p>用一个简单的对象来代替一个复杂的对象。</p>\n<p>● java.lang.reflect.Proxy<br>● RMI   </p>\n<p>##Creational（创建模式）##</p>\n<p><strong>Abstract factory:</strong></p>\n<p>创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p>\n<p>● java.util.Calendar#getInstance()<br>● java.util.Arrays#asList()<br>● java.util.ResourceBundle#getBundle()<br>● java.sql.DriverManager#getConnection()<br>● java.sql.Connection#createStatement()<br>● java.sql.Statement#executeQuery()<br>● java.text.NumberFormat#getInstance()<br>● javax.xml.transform.TransformerFactory#newInstance()   </p>\n<p><strong>Builder:</strong></p>\n<p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。</p>\n<p>● java.lang.StringBuilder#append()<br>● java.lang.StringBuffer#append()<br>● java.sql.PreparedStatement<br>● javax.swing.GroupLayout.Group#addComponent()   </p>\n<p><strong>Factory:</strong></p>\n<p>简单来说，按照需求返回一个类型的实例。</p>\n<p>● java.lang.Proxy#newProxyInstance()<br>● java.lang.Object#toString()<br>● java.lang.Class#newInstance()<br>● java.lang.reflect.Array#newInstance()<br>● java.lang.reflect.Constructor#newInstance()<br>● java.lang.Boolean#valueOf(String)<br>● java.lang.Class#forName()   </p>\n<p><strong>Prototype:</strong></p>\n<p>使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。</p>\n<p>● java.lang.Object#clone()<br>● java.lang.Cloneable   </p>\n<p><strong>Singleton:</strong></p>\n<p>只允许一个实例。在 Effective Java中建议使用Emun.</p>\n<p>● java.lang.Runtime#getRuntime()<br>● java.awt.Toolkit#getDefaultToolkit()<br>● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()<br>● java.awt.Desktop#getDesktop()   </p>\n<p>##Behavioral(行为模式)##</p>\n<p><strong>Chain of responsibility:</strong>   </p>\n<p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。</p>\n<p>● java.util.logging.Logger#log()<br>● javax.servlet.Filter#doFilter()   </p>\n<p><strong>Command:</strong></p>\n<p>把一个或一些命令封装到一个对象中。</p>\n<p>● java.lang.Runnable<br>● javax.swing.Action   </p>\n<p><strong>Interpreter:</strong></p>\n<p>一个语法解释器的模式。</p>\n<p>● java.util.Pattern<br>● java.text.Normalizer<br>● java.text.Format   </p>\n<p><strong>Iterator:</strong></p>\n<p>提供一种一致的方法来顺序遍历一个容器中的所有元素。  </p>\n<p>● java.util.Iterator<br>● java.util.Enumeration   </p>\n<p><strong>Mediator:</strong></p>\n<p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。</p>\n<p>● java.util.Timer<br>● java.util.concurrent.Executor#execute()<br>● java.util.concurrent.ExecutorService#submit()<br>● java.lang.reflect.Method#invoke()   </p>\n<p><strong>Memento:</strong></p>\n<p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。</p>\n<p>● java.util.Date<br>● java.io.Serializable   </p>\n<p><strong>Null Object:</strong></p>\n<p>这个模式用来解决如果一个Collection中没有元素的情况。  </p>\n<p>● java.util.Collections#emptyList()<br>● java.util.Collections#emptyMap()<br>● java.util.Collections#emptySet()   </p>\n<p><strong>Observer:</strong></p>\n<p>允许一个对象向所有的侦听的对象广播自己的消息或事件。</p>\n<p>● java.util.EventListener<br>● javax.servlet.http.HttpSessionBindingListener<br>● javax.servlet.http.HttpSessionAttributeListener<br>● javax.faces.event.PhaseListener   </p>\n<p><strong>State:</strong></p>\n<p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。</p>\n<p>● java.util.Iterator<br>● javax.faces.lifecycle.LifeCycle#execute()   </p>\n<p><strong>Strategy:</strong></p>\n<p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。  </p>\n<p>● java.util.Comparator#compare()<br>● javax.servlet.http.HttpServlet<br>● javax.servlet.Filter#doFilter()   </p>\n<p><strong>Template method:</strong></p>\n<p>允许子类重载部分父类而不需要完全重写。</p>\n<p>● java.util.Collections#sort()<br>● java.io.InputStream#skip()<br>● java.io.InputStream#read()<br>● java.util.AbstractList#indexOf()   </p>\n<p><strong>Visitor:</strong></p>\n<p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作. </p>\n<p>● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor<br>● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor   </p>\n<p>在stakeoverflow也有相应的讨论：</p>\n<p><a href=\"http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns\">http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns</a></p>\n<p>摘自：<a href=\"http://www.csdn.net/article/2010-11-29/282644\">http://www.csdn.net/article/2010-11-29/282644</a></p>"},{"layout":"post","title":"字符集与编码的故事","date":"2012-10-22T12:13:00.000Z","comments":1,"_content":"很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为\"字节\"。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为\"计算机\"。 \n<!--more-->\n\n开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为\"控制码\"。  \n   \n他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的\"ASCII\"编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 \n\n后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称\"扩展字符集\"。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  \n\n等中国人得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。  中国人民看到这样很不错，于是就把这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。 \n\n但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。  后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 \n\n中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 \"DBCS\"（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。\n    \n因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。当时的中国人想让电脑显示汉字，就必须装上一个\"汉字系统\"，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么\"倚天汉字系统\"才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ \n\n正在这时，大天使加百列及时出现了：一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它\"Universal Multiple-Octet Coded Character Set\"，简称 UCS, 俗称 \"UNICODE\"。 \n\nUNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些\"半角\"字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于\"半角\"英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。\n  \n从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。  \n\n但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 \n\n如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！  \n\nUNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。 \n\n受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符。如果之后的文本是高位在位，那就发送\"FEFF\"，反之，则发送\"FFFE\"。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？  \n\n讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入\"联通\"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。\n\n原文：<http://turandot.iteye.com/blog/1703258>","source":"_posts/2012-10-22-encode-story.markdown","raw":"---\nlayout: post\ntitle: \"字符集与编码的故事\"\ndate: 2012-10-22 20:13\ncomments: true\ncategories: encode\ntags: [ story, encode ]\n---\n很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为\"字节\"。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为\"计算机\"。 \n<!--more-->\n\n开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为\"控制码\"。  \n   \n他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的\"ASCII\"编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 \n\n后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称\"扩展字符集\"。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  \n\n等中国人得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。  中国人民看到这样很不错，于是就把这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。 \n\n但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。  后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 \n\n中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 \"DBCS\"（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。\n    \n因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。当时的中国人想让电脑显示汉字，就必须装上一个\"汉字系统\"，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么\"倚天汉字系统\"才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ \n\n正在这时，大天使加百列及时出现了：一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它\"Universal Multiple-Octet Coded Character Set\"，简称 UCS, 俗称 \"UNICODE\"。 \n\nUNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些\"半角\"字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于\"半角\"英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。\n  \n从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。  \n\n但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 \n\n如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！  \n\nUNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。 \n\n受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符。如果之后的文本是高位在位，那就发送\"FEFF\"，反之，则发送\"FFFE\"。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？  \n\n讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入\"联通\"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。\n\n原文：<http://turandot.iteye.com/blog/1703258>","slug":"2012-10-22-encode-story","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop26001dv8fy9jfrpk29","content":"<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节”。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。<br><a id=\"more\"></a></p>\n<p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。  </p>\n<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”ASCII”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 </p>\n<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  </p>\n<p>等中国人得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。  中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。 </p>\n<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。  后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 </p>\n<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。</p>\n<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ </p>\n<p>正在这时，大天使加百列及时出现了：一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 </p>\n<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p>\n<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。  </p>\n<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 </p>\n<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！  </p>\n<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。 </p>\n<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符。如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？  </p>\n<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p>\n<p>原文：<a href=\"http://turandot.iteye.com/blog/1703258\" target=\"_blank\" rel=\"external\">http://turandot.iteye.com/blog/1703258</a></p>\n","excerpt":"<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节”。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。<br>","more":"</p>\n<p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。  </p>\n<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”ASCII”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 </p>\n<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  </p>\n<p>等中国人得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。  中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。 </p>\n<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。  后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 </p>\n<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。</p>\n<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案。当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ </p>\n<p>正在这时，大天使加百列及时出现了：一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 </p>\n<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p>\n<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。  </p>\n<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 </p>\n<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！  </p>\n<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。 </p>\n<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符。如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？  </p>\n<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p>\n<p>原文：<a href=\"http://turandot.iteye.com/blog/1703258\">http://turandot.iteye.com/blog/1703258</a></p>"},{"layout":"post","title":"HTTP Header","date":"2012-10-22T12:34:00.000Z","comments":1,"_content":"HTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而 言，包括message-header和message-body两部分。首先传递message-header，即http header消息。http header 消息通常被分为4个部分：general; header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分.   \n<!--more-->   \n**Response部分**\n<div>\n<table border=\"1\" width=\"90%\" >\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\tHeader</th>\n\t\t\t<th>\n\t\t\t\t解释</th>\n\t\t\t<th>\n\t\t\t\t示例</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges</td>\n\t\t\t<td >\n\t\t\t\t表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges: bytes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAge</td>\n\t\t\t<td >\n\t\t\t\t从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n\t\t\t<td >\n\t\t\t\tAge: 12</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAllow</td>\n\t\t\t<td >\n\t\t\t\t对某网络资源的有效的请求行为，不允许则返回405</td>\n\t\t\t<td >\n\t\t\t\tAllow: GET, HEAD</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCache-Control</td>\n\t\t\t<td >\n\t\t\t\t告诉所有的缓存机制是否可以缓存及哪种类型</td>\n\t\t\t<td >\n\t\t\t\tCache-Control: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Encoding</td>\n\t\t\t<td >\n\t\t\t\tweb服务器支持的返回内容压缩编码类型。</td>\n\t\t\t<td >\n\t\t\t\tContent-Encoding: gzip</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Language</td>\n\t\t\t<td >\n\t\t\t\t响应体的语言</td>\n\t\t\t<td >\n\t\t\t\tContent-Language: en,zh</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Length</td>\n\t\t\t<td >\n\t\t\t\t响应体的长度</td>\n\t\t\t<td >\n\t\t\t\tContent-Length: 348</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Location</td>\n\t\t\t<td >\n\t\t\t\t请求资源可替代的备用的另一地址</td>\n\t\t\t<td >\n\t\t\t\tContent-Location: /index.htm</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-MD5</td>\n\t\t\t<td >\n\t\t\t\t返回资源的MD5校验值</td>\n\t\t\t<td >\n\t\t\t\tContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Range</td>\n\t\t\t<td >\n\t\t\t\t在整个返回体中本部分的字节位置</td>\n\t\t\t<td >\n\t\t\t\tContent-Range: bytes 21010-47021/47022</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Type</td>\n\t\t\t<td >\n\t\t\t\t返回内容的MIME类型</td>\n\t\t\t<td >\n\t\t\t\tContent-Type: text/html; charset=utf-8</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tDate</td>\n\t\t\t<td >\n\t\t\t\t原始服务器消息发出的时间</td>\n\t\t\t<td >\n\t\t\t\tDate: Tue, 15 Nov 2010 08:12:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tETag</td>\n\t\t\t<td >\n\t\t\t\t请求变量的实体标签的当前值</td>\n\t\t\t<td >\n\t\t\t\tETag: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tExpires</td>\n\t\t\t<td >\n\t\t\t\t响应过期的日期和时间</td>\n\t\t\t<td >\n\t\t\t\tExpires: Thu, 01 Dec 2010 16:00:00 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tLast-Modified</td>\n\t\t\t<td >\n\t\t\t\t请求资源的最后修改时间</td>\n\t\t\t<td >\n\t\t\t\tLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tLocation</td>\n\t\t\t<td >\n\t\t\t\t用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n\t\t\t<td >\n\t\t\t\tLocation: http://www.zcmhi.com/archives/94.html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tPragma</td>\n\t\t\t<td >\n\t\t\t\t包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n\t\t\t<td >\n\t\t\t\tPragma: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tProxy-Authenticate</td>\n\t\t\t<td >\n\t\t\t\t它指出认证方案和可应用到代理的该URL上的参数</td>\n\t\t\t<td >\n\t\t\t\tProxy-Authenticate: Basic</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\trefresh</td>\n\t\t\t<td >\n\t\t\t\t应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n\t\t\t<td >\n\t\t\t\t<div>\n\t\t\t\t\t&nbsp;</div>\n\t\t\t\t<p style=\"margin-left:auto;\">\n\t\t\t\t\t&nbsp;</p>\n\t\t\t\t<div id=\"_mcePaste\">\n\t\t\t\t\tRefresh: 5; url=</div>\n\t\t\t\t<div>\n\t\t\t\t\thttp://www.zcmhi.com/archives/94.html</div>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tRetry-After</td>\n\t\t\t<td >\n\t\t\t\t如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n\t\t\t<td >\n\t\t\t\tRetry-After: 120</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tServer</td>\n\t\t\t<td >\n\t\t\t\tweb服务器软件名称</td>\n\t\t\t<td >\n\t\t\t\tServer: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tSet-Cookie</td>\n\t\t\t<td >\n\t\t\t\t设置Http Cookie</td>\n\t\t\t<td >\n\t\t\t\tSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTrailer</td>\n\t\t\t<td >\n\t\t\t\t指出头域在分块传输编码的尾部存在</td>\n\t\t\t<td >\n\t\t\t\tTrailer: Max-Forwards</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTransfer-Encoding</td>\n\t\t\t<td >\n\t\t\t\t文件传输编码</td>\n\t\t\t<td >\n\t\t\t\tTransfer-Encoding:chunked</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVary</td>\n\t\t\t<td >\n\t\t\t\t告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n\t\t\t<td >\n\t\t\t\tVary: *</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVia</td>\n\t\t\t<td >\n\t\t\t\t告知代理客户端响应是通过哪里发送的</td>\n\t\t\t<td >\n\t\t\t\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWarning</td>\n\t\t\t<td >\n\t\t\t\t警告实体可能存在的问题</td>\n\t\t\t<td >\n\t\t\t\tWarning: 199 Miscellaneous warning</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWWW-Authenticate</td>\n\t\t\t<td >\n\t\t\t\t表明客户端请求实体应该使用的授权方案</td>\n\t\t\t<td >\n\t\t\t\tWWW-Authenticate: Basic</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n更多参见 [w3c官网](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n<table border=\"1\" width=\"90%\" >\n\t<tbody>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Type</td>\n\t\t\t<td >\n\t\t\t\t请求的与实体对应的MIME信息</td>\n\t\t\t<td >\n\t\t\t\tContent-Type: application/x-www-form-urlencoded</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tDate</td>\n\t\t\t<td >\n\t\t\t\t请求发送的日期和时间</td>\n\t\t\t<td >\n\t\t\t\tDate: Tue, 15 Nov&nbsp;2010 08:12:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tExpect</td>\n\t\t\t<td >\n\t\t\t\t请求的特定的服务器行为</td>\n\t\t\t<td >\n\t\t\t\tExpect: 100-continue</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tFrom</td>\n\t\t\t<td >\n\t\t\t\t发出请求的用户的Email</td>\n\t\t\t<td >\n\t\t\t\tFrom: user@email.com</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tHost</td>\n\t\t\t<td >\n\t\t\t\t指定请求的服务器的域名和端口号</td>\n\t\t\t<td >\n\t\t\t\tHost: www.zcmhi.com</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Match</td>\n\t\t\t<td >\n\t\t\t\t只有请求内容与实体相匹配才有效</td>\n\t\t\t<td >\n\t\t\t\tIf-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Modified-Since</td>\n\t\t\t<td >\n\t\t\t\t如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n\t\t\t<td >\n\t\t\t\tIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-None-Match</td>\n\t\t\t<td >\n\t\t\t\t如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n\t\t\t<td >\n\t\t\t\tIf-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Range</td>\n\t\t\t<td >\n\t\t\t\t如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n\t\t\t<td >\n\t\t\t\tIf-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Unmodified-Since</td>\n\t\t\t<td >\n\t\t\t\t只在实体在指定时间之后未被修改才请求成功</td>\n\t\t\t<td >\n\t\t\t\tIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tMax-Forwards</td>\n\t\t\t<td >\n\t\t\t\t限制信息通过代理和网关传送的时间</td>\n\t\t\t<td >\n\t\t\t\tMax-Forwards: 10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tPragma</td>\n\t\t\t<td >\n\t\t\t\t用来包含实现特定的指令</td>\n\t\t\t<td >\n\t\t\t\tPragma: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tProxy-Authorization</td>\n\t\t\t<td >\n\t\t\t\t连接到代理的授权证书</td>\n\t\t\t<td >\n\t\t\t\tProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tRange</td>\n\t\t\t<td >\n\t\t\t\t只请求实体的一部分，指定范围</td>\n\t\t\t<td >\n\t\t\t\tRange: bytes=500-999</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tReferer</td>\n\t\t\t<td >\n\t\t\t\t先前网页的地址，当前请求网页紧随其后,即来路</td>\n\t\t\t<td >\n\t\t\t\tReferer: http://www.zcmhi.com/archives/71.html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTE</td>\n\t\t\t<td >\n\t\t\t\t客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n\t\t\t<td >\n\t\t\t\tTE: trailers,deflate;q=0.5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tUpgrade</td>\n\t\t\t<td >\n\t\t\t\t向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n\t\t\t<td >\n\t\t\t\tUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tUser-Agent</td>\n\t\t\t<td >\n\t\t\t\tUser-Agent的内容包含发出请求的用户信息</td>\n\t\t\t<td >\n\t\t\t\tUser-Agent: Mozilla/5.0 (Linux; X11)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVia</td>\n\t\t\t<td >\n\t\t\t\t通知中间网关或代理服务器地址，通信协议</td>\n\t\t\t<td >\n\t\t\t\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWarning</td>\n\t\t\t<td >\n\t\t\t\t关于消息实体的警告信息</td>\n\t\t\t<td >\n\t\t\t\tWarn: 199 Miscellaneous warning<br />\n\t\t\t\t&nbsp;</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n**Requests部分**\n<table border=\"1\"  width=\"90%\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\tHeader</th>\n\t\t\t<th>\n\t\t\t\t解释</th>\n\t\t\t<th>\n\t\t\t\t示例</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept</td>\n\t\t\t<td >\n\t\t\t\t指定客户端能够接收的内容类型</td>\n\t\t\t<td >\n\t\t\t\tAccept: text/plain, text/html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Charset</td>\n\t\t\t<td >\n\t\t\t\t浏览器可以接受的字符编码集。</td>\n\t\t\t<td >\n\t\t\t\tAccept-Charset: iso-8859-5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Encoding</td>\n\t\t\t<td >\n\t\t\t\t指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>\n\t\t\t<td >\n\t\t\t\tAccept-Encoding: compress, gzip</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Language</td>\n\t\t\t<td >\n\t\t\t\t浏览器可接受的语言</td>\n\t\t\t<td >\n\t\t\t\tAccept-Language: en,zh</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges</td>\n\t\t\t<td >\n\t\t\t\t可以请求网页实体的一个或者多个子范围字段</td>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges: bytes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAuthorization</td>\n\t\t\t<td >\n\t\t\t\tHTTP授权的授权证书</td>\n\t\t\t<td >\n\t\t\t\tAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCache-Control</td>\n\t\t\t<td >\n\t\t\t\t指定请求和响应遵循的缓存机制</td>\n\t\t\t<td >\n\t\t\t\tCache-Control: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tConnection</td>\n\t\t\t<td >\n\t\t\t\t表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>\n\t\t\t<td >\n\t\t\t\tConnection: close</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCookie</td>\n\t\t\t<td >\n\t\t\t\tHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>\n\t\t\t<td >\n\t\t\t\tCookie: $Version=1; Skin=new;</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Length</td>\n\t\t\t<td >\n\t\t\t\t请求的内容长度</td>\n\t\t\t<td >\n\t\t\t\tContent-Length: 348</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n</div>\n \n参考文档：<http://www.itniwo.net/blog/v/26466.html>","source":"_posts/2012-10-22-http-header.markdown","raw":"---\nlayout: post\ntitle: \"HTTP Header\"\ndate: 2012-10-22 20:34\ncomments: true\ncategories: HTTP\ntags: [ HTTP, header, request, response ]\n---\nHTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而 言，包括message-header和message-body两部分。首先传递message-header，即http header消息。http header 消息通常被分为4个部分：general; header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分.   \n<!--more-->   \n**Response部分**\n<div>\n<table border=\"1\" width=\"90%\" >\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\tHeader</th>\n\t\t\t<th>\n\t\t\t\t解释</th>\n\t\t\t<th>\n\t\t\t\t示例</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges</td>\n\t\t\t<td >\n\t\t\t\t表明服务器是否支持指定范围请求及哪种类型的分段请求</td>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges: bytes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAge</td>\n\t\t\t<td >\n\t\t\t\t从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>\n\t\t\t<td >\n\t\t\t\tAge: 12</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAllow</td>\n\t\t\t<td >\n\t\t\t\t对某网络资源的有效的请求行为，不允许则返回405</td>\n\t\t\t<td >\n\t\t\t\tAllow: GET, HEAD</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCache-Control</td>\n\t\t\t<td >\n\t\t\t\t告诉所有的缓存机制是否可以缓存及哪种类型</td>\n\t\t\t<td >\n\t\t\t\tCache-Control: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Encoding</td>\n\t\t\t<td >\n\t\t\t\tweb服务器支持的返回内容压缩编码类型。</td>\n\t\t\t<td >\n\t\t\t\tContent-Encoding: gzip</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Language</td>\n\t\t\t<td >\n\t\t\t\t响应体的语言</td>\n\t\t\t<td >\n\t\t\t\tContent-Language: en,zh</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Length</td>\n\t\t\t<td >\n\t\t\t\t响应体的长度</td>\n\t\t\t<td >\n\t\t\t\tContent-Length: 348</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Location</td>\n\t\t\t<td >\n\t\t\t\t请求资源可替代的备用的另一地址</td>\n\t\t\t<td >\n\t\t\t\tContent-Location: /index.htm</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-MD5</td>\n\t\t\t<td >\n\t\t\t\t返回资源的MD5校验值</td>\n\t\t\t<td >\n\t\t\t\tContent-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Range</td>\n\t\t\t<td >\n\t\t\t\t在整个返回体中本部分的字节位置</td>\n\t\t\t<td >\n\t\t\t\tContent-Range: bytes 21010-47021/47022</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Type</td>\n\t\t\t<td >\n\t\t\t\t返回内容的MIME类型</td>\n\t\t\t<td >\n\t\t\t\tContent-Type: text/html; charset=utf-8</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tDate</td>\n\t\t\t<td >\n\t\t\t\t原始服务器消息发出的时间</td>\n\t\t\t<td >\n\t\t\t\tDate: Tue, 15 Nov 2010 08:12:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tETag</td>\n\t\t\t<td >\n\t\t\t\t请求变量的实体标签的当前值</td>\n\t\t\t<td >\n\t\t\t\tETag: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tExpires</td>\n\t\t\t<td >\n\t\t\t\t响应过期的日期和时间</td>\n\t\t\t<td >\n\t\t\t\tExpires: Thu, 01 Dec 2010 16:00:00 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tLast-Modified</td>\n\t\t\t<td >\n\t\t\t\t请求资源的最后修改时间</td>\n\t\t\t<td >\n\t\t\t\tLast-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tLocation</td>\n\t\t\t<td >\n\t\t\t\t用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>\n\t\t\t<td >\n\t\t\t\tLocation: http://www.zcmhi.com/archives/94.html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tPragma</td>\n\t\t\t<td >\n\t\t\t\t包括实现特定的指令，它可应用到响应链上的任何接收方</td>\n\t\t\t<td >\n\t\t\t\tPragma: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tProxy-Authenticate</td>\n\t\t\t<td >\n\t\t\t\t它指出认证方案和可应用到代理的该URL上的参数</td>\n\t\t\t<td >\n\t\t\t\tProxy-Authenticate: Basic</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\trefresh</td>\n\t\t\t<td >\n\t\t\t\t应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>\n\t\t\t<td >\n\t\t\t\t<div>\n\t\t\t\t\t&nbsp;</div>\n\t\t\t\t<p style=\"margin-left:auto;\">\n\t\t\t\t\t&nbsp;</p>\n\t\t\t\t<div id=\"_mcePaste\">\n\t\t\t\t\tRefresh: 5; url=</div>\n\t\t\t\t<div>\n\t\t\t\t\thttp://www.zcmhi.com/archives/94.html</div>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tRetry-After</td>\n\t\t\t<td >\n\t\t\t\t如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>\n\t\t\t<td >\n\t\t\t\tRetry-After: 120</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tServer</td>\n\t\t\t<td >\n\t\t\t\tweb服务器软件名称</td>\n\t\t\t<td >\n\t\t\t\tServer: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tSet-Cookie</td>\n\t\t\t<td >\n\t\t\t\t设置Http Cookie</td>\n\t\t\t<td >\n\t\t\t\tSet-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTrailer</td>\n\t\t\t<td >\n\t\t\t\t指出头域在分块传输编码的尾部存在</td>\n\t\t\t<td >\n\t\t\t\tTrailer: Max-Forwards</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTransfer-Encoding</td>\n\t\t\t<td >\n\t\t\t\t文件传输编码</td>\n\t\t\t<td >\n\t\t\t\tTransfer-Encoding:chunked</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVary</td>\n\t\t\t<td >\n\t\t\t\t告诉下游代理是使用缓存响应还是从原始服务器请求</td>\n\t\t\t<td >\n\t\t\t\tVary: *</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVia</td>\n\t\t\t<td >\n\t\t\t\t告知代理客户端响应是通过哪里发送的</td>\n\t\t\t<td >\n\t\t\t\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWarning</td>\n\t\t\t<td >\n\t\t\t\t警告实体可能存在的问题</td>\n\t\t\t<td >\n\t\t\t\tWarning: 199 Miscellaneous warning</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWWW-Authenticate</td>\n\t\t\t<td >\n\t\t\t\t表明客户端请求实体应该使用的授权方案</td>\n\t\t\t<td >\n\t\t\t\tWWW-Authenticate: Basic</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n更多参见 [w3c官网](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n<table border=\"1\" width=\"90%\" >\n\t<tbody>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Type</td>\n\t\t\t<td >\n\t\t\t\t请求的与实体对应的MIME信息</td>\n\t\t\t<td >\n\t\t\t\tContent-Type: application/x-www-form-urlencoded</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tDate</td>\n\t\t\t<td >\n\t\t\t\t请求发送的日期和时间</td>\n\t\t\t<td >\n\t\t\t\tDate: Tue, 15 Nov&nbsp;2010 08:12:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tExpect</td>\n\t\t\t<td >\n\t\t\t\t请求的特定的服务器行为</td>\n\t\t\t<td >\n\t\t\t\tExpect: 100-continue</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tFrom</td>\n\t\t\t<td >\n\t\t\t\t发出请求的用户的Email</td>\n\t\t\t<td >\n\t\t\t\tFrom: user@email.com</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tHost</td>\n\t\t\t<td >\n\t\t\t\t指定请求的服务器的域名和端口号</td>\n\t\t\t<td >\n\t\t\t\tHost: www.zcmhi.com</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Match</td>\n\t\t\t<td >\n\t\t\t\t只有请求内容与实体相匹配才有效</td>\n\t\t\t<td >\n\t\t\t\tIf-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Modified-Since</td>\n\t\t\t<td >\n\t\t\t\t如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>\n\t\t\t<td >\n\t\t\t\tIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-None-Match</td>\n\t\t\t<td >\n\t\t\t\t如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>\n\t\t\t<td >\n\t\t\t\tIf-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Range</td>\n\t\t\t<td >\n\t\t\t\t如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>\n\t\t\t<td >\n\t\t\t\tIf-Range: “737060cd8c284d8af7ad3082f209582d”</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tIf-Unmodified-Since</td>\n\t\t\t<td >\n\t\t\t\t只在实体在指定时间之后未被修改才请求成功</td>\n\t\t\t<td >\n\t\t\t\tIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tMax-Forwards</td>\n\t\t\t<td >\n\t\t\t\t限制信息通过代理和网关传送的时间</td>\n\t\t\t<td >\n\t\t\t\tMax-Forwards: 10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tPragma</td>\n\t\t\t<td >\n\t\t\t\t用来包含实现特定的指令</td>\n\t\t\t<td >\n\t\t\t\tPragma: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tProxy-Authorization</td>\n\t\t\t<td >\n\t\t\t\t连接到代理的授权证书</td>\n\t\t\t<td >\n\t\t\t\tProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tRange</td>\n\t\t\t<td >\n\t\t\t\t只请求实体的一部分，指定范围</td>\n\t\t\t<td >\n\t\t\t\tRange: bytes=500-999</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tReferer</td>\n\t\t\t<td >\n\t\t\t\t先前网页的地址，当前请求网页紧随其后,即来路</td>\n\t\t\t<td >\n\t\t\t\tReferer: http://www.zcmhi.com/archives/71.html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tTE</td>\n\t\t\t<td >\n\t\t\t\t客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>\n\t\t\t<td >\n\t\t\t\tTE: trailers,deflate;q=0.5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tUpgrade</td>\n\t\t\t<td >\n\t\t\t\t向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>\n\t\t\t<td >\n\t\t\t\tUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tUser-Agent</td>\n\t\t\t<td >\n\t\t\t\tUser-Agent的内容包含发出请求的用户信息</td>\n\t\t\t<td >\n\t\t\t\tUser-Agent: Mozilla/5.0 (Linux; X11)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tVia</td>\n\t\t\t<td >\n\t\t\t\t通知中间网关或代理服务器地址，通信协议</td>\n\t\t\t<td >\n\t\t\t\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tWarning</td>\n\t\t\t<td >\n\t\t\t\t关于消息实体的警告信息</td>\n\t\t\t<td >\n\t\t\t\tWarn: 199 Miscellaneous warning<br />\n\t\t\t\t&nbsp;</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n**Requests部分**\n<table border=\"1\"  width=\"90%\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\tHeader</th>\n\t\t\t<th>\n\t\t\t\t解释</th>\n\t\t\t<th>\n\t\t\t\t示例</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept</td>\n\t\t\t<td >\n\t\t\t\t指定客户端能够接收的内容类型</td>\n\t\t\t<td >\n\t\t\t\tAccept: text/plain, text/html</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Charset</td>\n\t\t\t<td >\n\t\t\t\t浏览器可以接受的字符编码集。</td>\n\t\t\t<td >\n\t\t\t\tAccept-Charset: iso-8859-5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Encoding</td>\n\t\t\t<td >\n\t\t\t\t指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>\n\t\t\t<td >\n\t\t\t\tAccept-Encoding: compress, gzip</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Language</td>\n\t\t\t<td >\n\t\t\t\t浏览器可接受的语言</td>\n\t\t\t<td >\n\t\t\t\tAccept-Language: en,zh</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges</td>\n\t\t\t<td >\n\t\t\t\t可以请求网页实体的一个或者多个子范围字段</td>\n\t\t\t<td >\n\t\t\t\tAccept-Ranges: bytes</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tAuthorization</td>\n\t\t\t<td >\n\t\t\t\tHTTP授权的授权证书</td>\n\t\t\t<td >\n\t\t\t\tAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCache-Control</td>\n\t\t\t<td >\n\t\t\t\t指定请求和响应遵循的缓存机制</td>\n\t\t\t<td >\n\t\t\t\tCache-Control: no-cache</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tConnection</td>\n\t\t\t<td >\n\t\t\t\t表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>\n\t\t\t<td >\n\t\t\t\tConnection: close</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tCookie</td>\n\t\t\t<td >\n\t\t\t\tHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>\n\t\t\t<td >\n\t\t\t\tCookie: $Version=1; Skin=new;</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td >\n\t\t\t\tContent-Length</td>\n\t\t\t<td >\n\t\t\t\t请求的内容长度</td>\n\t\t\t<td >\n\t\t\t\tContent-Length: 348</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n</div>\n \n参考文档：<http://www.itniwo.net/blog/v/26466.html>","slug":"2012-10-22-http-header","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2a001gv8fyaintxjm5","content":"<p>HTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而 言，包括message-header和message-body两部分。首先传递message-header，即http header消息。http header 消息通常被分为4个部分：general; header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分.<br><a id=\"more\"></a><br><strong>Response部分</strong></p>\n<div><br><table border=\"1\" width=\"90%\"><br>    <tbody><br>        <tr><br>            <th><br>                Header</th><br>            <th><br>                解释</th><br>            <th><br>                示例</th><br>        </tr><br>        <tr><br>            <td><br>                Accept-Ranges</td><br>            <td><br>                表明服务器是否支持指定范围请求及哪种类型的分段请求</td><br>            <td><br>                Accept-Ranges: bytes</td><br>        </tr><br>        <tr><br>            <td><br>                Age</td><br>            <td><br>                从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><br>            <td><br>                Age: 12</td><br>        </tr><br>        <tr><br>            <td><br>                Allow</td><br>            <td><br>                对某网络资源的有效的请求行为，不允许则返回405</td><br>            <td><br>                Allow: GET, HEAD</td><br>        </tr><br>        <tr><br>            <td><br>                Cache-Control</td><br>            <td><br>                告诉所有的缓存机制是否可以缓存及哪种类型</td><br>            <td><br>                Cache-Control: no-cache</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Encoding</td><br>            <td><br>                web服务器支持的返回内容压缩编码类型。</td><br>            <td><br>                Content-Encoding: gzip</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Language</td><br>            <td><br>                响应体的语言</td><br>            <td><br>                Content-Language: en,zh</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Length</td><br>            <td><br>                响应体的长度</td><br>            <td><br>                Content-Length: 348</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Location</td><br>            <td><br>                请求资源可替代的备用的另一地址</td><br>            <td><br>                Content-Location: /index.htm</td><br>        </tr><br>        <tr><br>            <td><br>                Content-MD5</td><br>            <td><br>                返回资源的MD5校验值</td><br>            <td><br>                Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Range</td><br>            <td><br>                在整个返回体中本部分的字节位置</td><br>            <td><br>                Content-Range: bytes 21010-47021/47022</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Type</td><br>            <td><br>                返回内容的MIME类型</td><br>            <td><br>                Content-Type: text/html; charset=utf-8</td><br>        </tr><br>        <tr><br>            <td><br>                Date</td><br>            <td><br>                原始服务器消息发出的时间</td><br>            <td><br>                Date: Tue, 15 Nov 2010 08:12:31 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                ETag</td><br>            <td><br>                请求变量的实体标签的当前值</td><br>            <td><br>                ETag: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td><br>                Expires</td><br>            <td><br>                响应过期的日期和时间</td><br>            <td><br>                Expires: Thu, 01 Dec 2010 16:00:00 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                Last-Modified</td><br>            <td><br>                请求资源的最后修改时间</td><br>            <td><br>                Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                Location</td><br>            <td><br>                用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><br>            <td><br>                Location: <a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"external\">http://www.zcmhi.com/archives/94.html</a></td><br>        </tr><br>        <tr><br>            <td><br>                Pragma</td><br>            <td><br>                包括实现特定的指令，它可应用到响应链上的任何接收方</td><br>            <td><br>                Pragma: no-cache</td><br>        </tr><br>        <tr><br>            <td><br>                Proxy-Authenticate</td><br>            <td><br>                它指出认证方案和可应用到代理的该URL上的参数</td><br>            <td><br>                Proxy-Authenticate: Basic</td><br>        </tr><br>        <tr><br>            <td><br>                refresh</td><br>            <td><br>                应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><br>            <td><br>                <div><br>                    &nbsp;</div><br>                <p style=\"margin-left:auto;\"><br>                    &nbsp;</p><br>                <div id=\"_mcePaste\"><br>                    Refresh: 5; url=</div><br>                <div><br>                    <a href=\"http://www.zcmhi.com/archives/94.html\" target=\"_blank\" rel=\"external\">http://www.zcmhi.com/archives/94.html</a></div><br>            </td><br>        </tr><br>        <tr><br>            <td><br>                Retry-After</td><br>            <td><br>                如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><br>            <td><br>                Retry-After: 120</td><br>        </tr><br>        <tr><br>            <td><br>                Server</td><br>            <td><br>                web服务器软件名称</td><br>            <td><br>                Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td><br>        </tr><br>        <tr><br>            <td><br>                Set-Cookie</td><br>            <td><br>                设置Http Cookie</td><br>            <td><br>                Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td><br>        </tr><br>        <tr><br>            <td><br>                Trailer</td><br>            <td><br>                指出头域在分块传输编码的尾部存在</td><br>            <td><br>                Trailer: Max-Forwards</td><br>        </tr><br>        <tr><br>            <td><br>                Transfer-Encoding</td><br>            <td><br>                文件传输编码</td><br>            <td><br>                Transfer-Encoding:chunked</td><br>        </tr><br>        <tr><br>            <td><br>                Vary</td><br>            <td><br>                告诉下游代理是使用缓存响应还是从原始服务器请求</td><br>            <td><br>                Vary: <em></em></td><br>        </tr><br>        <tr><br>            <td><br>                Via</td><br>            <td><br>                告知代理客户端响应是通过哪里发送的</td><br>            <td><br>                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td><br>        </tr><br>        <tr><br>            <td><br>                Warning</td><br>            <td><br>                警告实体可能存在的问题</td><br>            <td><br>                Warning: 199 Miscellaneous warning</td><br>        </tr><br>        <tr><br>            <td><br>                WWW-Authenticate</td><br>            <td><br>                表明客户端请求实体应该使用的授权方案</td><br>            <td><br>                WWW-Authenticate: Basic</td><br>        </tr><br>    </tbody><br></table><br><br>更多参见 <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"external\">w3c官网</a><br><table border=\"1\" width=\"90%\"><br>    <tbody><br>        <tr><br>            <td><br>                Content-Type</td><br>            <td><br>                请求的与实体对应的MIME信息</td><br>            <td><br>                Content-Type: application/x-www-form-urlencoded</td><br>        </tr><br>        <tr><br>            <td><br>                Date</td><br>            <td><br>                请求发送的日期和时间</td><br>            <td><br>                Date: Tue, 15 Nov&nbsp;2010 08:12:31 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                Expect</td><br>            <td><br>                请求的特定的服务器行为</td><br>            <td><br>                Expect: 100-continue</td><br>        </tr><br>        <tr><br>            <td><br>                From</td><br>            <td><br>                发出请求的用户的Email</td><br>            <td><br>                From: user@email.com</td><br>        </tr><br>        <tr><br>            <td><br>                Host</td><br>            <td><br>                指定请求的服务器的域名和端口号</td><br>            <td><br>                Host: www.zcmhi.com</td><br>        </tr><br>        <tr><br>            <td><br>                If-Match</td><br>            <td><br>                只有请求内容与实体相匹配才有效</td><br>            <td><br>                If-Match: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td><br>                If-Modified-Since</td><br>            <td><br>                如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><br>            <td><br>                If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                If-None-Match</td><br>            <td><br>                如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><br>            <td><br>                If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td><br>                If-Range</td><br>            <td><br>                如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><br>            <td><br>                If-Range: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td><br>                If-Unmodified-Since</td><br>            <td><br>                只在实体在指定时间之后未被修改才请求成功</td><br>            <td><br>                If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td><br>        </tr><br>        <tr><br>            <td><br>                Max-Forwards</td><br>            <td><br>                限制信息通过代理和网关传送的时间</td><br>            <td><br>                Max-Forwards: 10</td><br>        </tr><br>        <tr><br>            <td><br>                Pragma</td><br>            <td><br>                用来包含实现特定的指令</td><br>            <td><br>                Pragma: no-cache</td><br>        </tr><br>        <tr><br>            <td><br>                Proxy-Authorization</td><br>            <td><br>                连接到代理的授权证书</td><br>            <td><br>                Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td><br>        </tr><br>        <tr><br>            <td><br>                Range</td><br>            <td><br>                只请求实体的一部分，指定范围</td><br>            <td><br>                Range: bytes=500-999</td><br>        </tr><br>        <tr><br>            <td><br>                Referer</td><br>            <td><br>                先前网页的地址，当前请求网页紧随其后,即来路</td><br>            <td><br>                Referer: <a href=\"http://www.zcmhi.com/archives/71.html\" target=\"_blank\" rel=\"external\">http://www.zcmhi.com/archives/71.html</a></td><br>        </tr><br>        <tr><br>            <td><br>                TE</td><br>            <td><br>                客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><br>            <td><br>                TE: trailers,deflate;q=0.5</td><br>        </tr><br>        <tr><br>            <td><br>                Upgrade</td><br>            <td><br>                向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><br>            <td><br>                Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><br>        </tr><br>        <tr><br>            <td><br>                User-Agent</td><br>            <td><br>                User-Agent的内容包含发出请求的用户信息</td><br>            <td><br>                User-Agent: Mozilla/5.0 (Linux; X11)</td><br>        </tr><br>        <tr><br>            <td><br>                Via</td><br>            <td><br>                通知中间网关或代理服务器地址，通信协议</td><br>            <td><br>                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td><br>        </tr><br>        <tr><br>            <td><br>                Warning</td><br>            <td><br>                关于消息实体的警告信息</td><br>            <td><br>                Warn: 199 Miscellaneous warning<br><br>                &nbsp;</td><br>        </tr><br>    </tbody><br></table><br><br><em>*Requests部分</em><br><table border=\"1\" width=\"90%\"><br>    <tbody><br>        <tr><br>            <th><br>                Header</th><br>            <th><br>                解释</th><br>            <th><br>                示例</th><br>        </tr><br>        <tr><br>            <td><br>                Accept</td><br>            <td><br>                指定客户端能够接收的内容类型</td><br>            <td><br>                Accept: text/plain, text/html</td><br>        </tr><br>        <tr><br>            <td><br>                Accept-Charset</td><br>            <td><br>                浏览器可以接受的字符编码集。</td><br>            <td><br>                Accept-Charset: iso-8859-5</td><br>        </tr><br>        <tr><br>            <td><br>                Accept-Encoding</td><br>            <td><br>                指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><br>            <td><br>                Accept-Encoding: compress, gzip</td><br>        </tr><br>        <tr><br>            <td><br>                Accept-Language</td><br>            <td><br>                浏览器可接受的语言</td><br>            <td><br>                Accept-Language: en,zh</td><br>        </tr><br>        <tr><br>            <td><br>                Accept-Ranges</td><br>            <td><br>                可以请求网页实体的一个或者多个子范围字段</td><br>            <td><br>                Accept-Ranges: bytes</td><br>        </tr><br>        <tr><br>            <td><br>                Authorization</td><br>            <td><br>                HTTP授权的授权证书</td><br>            <td><br>                Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td><br>        </tr><br>        <tr><br>            <td><br>                Cache-Control</td><br>            <td><br>                指定请求和响应遵循的缓存机制</td><br>            <td><br>                Cache-Control: no-cache</td><br>        </tr><br>        <tr><br>            <td><br>                Connection</td><br>            <td><br>                表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><br>            <td><br>                Connection: close</td><br>        </tr><br>        <tr><br>            <td><br>                Cookie</td><br>            <td><br>                HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><br>            <td><br>                Cookie: $Version=1; Skin=new;</td><br>        </tr><br>        <tr><br>            <td><br>                Content-Length</td><br>            <td><br>                请求的内容长度</td><br>            <td><br>                Content-Length: 348</td><br>        </tr><br>    </tbody><br></table><br><br></div>\n\n<p>参考文档：<a href=\"http://www.itniwo.net/blog/v/26466.html\" target=\"_blank\" rel=\"external\">http://www.itniwo.net/blog/v/26466.html</a></p>\n","excerpt":"<p>HTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而 言，包括message-header和message-body两部分。首先传递message-header，即http header消息。http header 消息通常被分为4个部分：general; header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分.<br>","more":"<br><strong>Response部分</strong></p>\n<div><br><table border=\"1\" width=\"90%\" ><br>    <tbody><br>        <tr><br>            <th><br>                Header</th><br>            <th><br>                解释</th><br>            <th><br>                示例</th><br>        </tr><br>        <tr><br>            <td ><br>                Accept-Ranges</td><br>            <td ><br>                表明服务器是否支持指定范围请求及哪种类型的分段请求</td><br>            <td ><br>                Accept-Ranges: bytes</td><br>        </tr><br>        <tr><br>            <td ><br>                Age</td><br>            <td ><br>                从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><br>            <td ><br>                Age: 12</td><br>        </tr><br>        <tr><br>            <td ><br>                Allow</td><br>            <td ><br>                对某网络资源的有效的请求行为，不允许则返回405</td><br>            <td ><br>                Allow: GET, HEAD</td><br>        </tr><br>        <tr><br>            <td ><br>                Cache-Control</td><br>            <td ><br>                告诉所有的缓存机制是否可以缓存及哪种类型</td><br>            <td ><br>                Cache-Control: no-cache</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Encoding</td><br>            <td ><br>                web服务器支持的返回内容压缩编码类型。</td><br>            <td ><br>                Content-Encoding: gzip</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Language</td><br>            <td ><br>                响应体的语言</td><br>            <td ><br>                Content-Language: en,zh</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Length</td><br>            <td ><br>                响应体的长度</td><br>            <td ><br>                Content-Length: 348</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Location</td><br>            <td ><br>                请求资源可替代的备用的另一地址</td><br>            <td ><br>                Content-Location: /index.htm</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-MD5</td><br>            <td ><br>                返回资源的MD5校验值</td><br>            <td ><br>                Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Range</td><br>            <td ><br>                在整个返回体中本部分的字节位置</td><br>            <td ><br>                Content-Range: bytes 21010-47021/47022</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Type</td><br>            <td ><br>                返回内容的MIME类型</td><br>            <td ><br>                Content-Type: text/html; charset=utf-8</td><br>        </tr><br>        <tr><br>            <td ><br>                Date</td><br>            <td ><br>                原始服务器消息发出的时间</td><br>            <td ><br>                Date: Tue, 15 Nov 2010 08:12:31 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                ETag</td><br>            <td ><br>                请求变量的实体标签的当前值</td><br>            <td ><br>                ETag: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td ><br>                Expires</td><br>            <td ><br>                响应过期的日期和时间</td><br>            <td ><br>                Expires: Thu, 01 Dec 2010 16:00:00 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                Last-Modified</td><br>            <td ><br>                请求资源的最后修改时间</td><br>            <td ><br>                Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                Location</td><br>            <td ><br>                用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><br>            <td ><br>                Location: <a href=\"http://www.zcmhi.com/archives/94.html\">http://www.zcmhi.com/archives/94.html</a></td><br>        </tr><br>        <tr><br>            <td ><br>                Pragma</td><br>            <td ><br>                包括实现特定的指令，它可应用到响应链上的任何接收方</td><br>            <td ><br>                Pragma: no-cache</td><br>        </tr><br>        <tr><br>            <td ><br>                Proxy-Authenticate</td><br>            <td ><br>                它指出认证方案和可应用到代理的该URL上的参数</td><br>            <td ><br>                Proxy-Authenticate: Basic</td><br>        </tr><br>        <tr><br>            <td ><br>                refresh</td><br>            <td ><br>                应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><br>            <td ><br>                <div><br>                    &nbsp;</div><br>                <p style=\"margin-left:auto;\"><br>                    &nbsp;</p><br>                <div id=\"_mcePaste\"><br>                    Refresh: 5; url=</div><br>                <div><br>                    <a href=\"http://www.zcmhi.com/archives/94.html\">http://www.zcmhi.com/archives/94.html</a></div><br>            </td><br>        </tr><br>        <tr><br>            <td ><br>                Retry-After</td><br>            <td ><br>                如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><br>            <td ><br>                Retry-After: 120</td><br>        </tr><br>        <tr><br>            <td ><br>                Server</td><br>            <td ><br>                web服务器软件名称</td><br>            <td ><br>                Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td><br>        </tr><br>        <tr><br>            <td ><br>                Set-Cookie</td><br>            <td ><br>                设置Http Cookie</td><br>            <td ><br>                Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td><br>        </tr><br>        <tr><br>            <td ><br>                Trailer</td><br>            <td ><br>                指出头域在分块传输编码的尾部存在</td><br>            <td ><br>                Trailer: Max-Forwards</td><br>        </tr><br>        <tr><br>            <td ><br>                Transfer-Encoding</td><br>            <td ><br>                文件传输编码</td><br>            <td ><br>                Transfer-Encoding:chunked</td><br>        </tr><br>        <tr><br>            <td ><br>                Vary</td><br>            <td ><br>                告诉下游代理是使用缓存响应还是从原始服务器请求</td><br>            <td ><br>                Vary: <em></td><br>        </tr><br>        <tr><br>            <td ><br>                Via</td><br>            <td ><br>                告知代理客户端响应是通过哪里发送的</td><br>            <td ><br>                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td><br>        </tr><br>        <tr><br>            <td ><br>                Warning</td><br>            <td ><br>                警告实体可能存在的问题</td><br>            <td ><br>                Warning: 199 Miscellaneous warning</td><br>        </tr><br>        <tr><br>            <td ><br>                WWW-Authenticate</td><br>            <td ><br>                表明客户端请求实体应该使用的授权方案</td><br>            <td ><br>                WWW-Authenticate: Basic</td><br>        </tr><br>    </tbody><br></table><br><br>更多参见 <a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\">w3c官网</a><br><table border=\"1\" width=\"90%\" ><br>    <tbody><br>        <tr><br>            <td ><br>                Content-Type</td><br>            <td ><br>                请求的与实体对应的MIME信息</td><br>            <td ><br>                Content-Type: application/x-www-form-urlencoded</td><br>        </tr><br>        <tr><br>            <td ><br>                Date</td><br>            <td ><br>                请求发送的日期和时间</td><br>            <td ><br>                Date: Tue, 15 Nov&nbsp;2010 08:12:31 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                Expect</td><br>            <td ><br>                请求的特定的服务器行为</td><br>            <td ><br>                Expect: 100-continue</td><br>        </tr><br>        <tr><br>            <td ><br>                From</td><br>            <td ><br>                发出请求的用户的Email</td><br>            <td ><br>                From: user@email.com</td><br>        </tr><br>        <tr><br>            <td ><br>                Host</td><br>            <td ><br>                指定请求的服务器的域名和端口号</td><br>            <td ><br>                Host: www.zcmhi.com</td><br>        </tr><br>        <tr><br>            <td ><br>                If-Match</td><br>            <td ><br>                只有请求内容与实体相匹配才有效</td><br>            <td ><br>                If-Match: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td ><br>                If-Modified-Since</td><br>            <td ><br>                如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><br>            <td ><br>                If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                If-None-Match</td><br>            <td ><br>                如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><br>            <td ><br>                If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td ><br>                If-Range</td><br>            <td ><br>                如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><br>            <td ><br>                If-Range: “737060cd8c284d8af7ad3082f209582d”</td><br>        </tr><br>        <tr><br>            <td ><br>                If-Unmodified-Since</td><br>            <td ><br>                只在实体在指定时间之后未被修改才请求成功</td><br>            <td ><br>                If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td><br>        </tr><br>        <tr><br>            <td ><br>                Max-Forwards</td><br>            <td ><br>                限制信息通过代理和网关传送的时间</td><br>            <td ><br>                Max-Forwards: 10</td><br>        </tr><br>        <tr><br>            <td ><br>                Pragma</td><br>            <td ><br>                用来包含实现特定的指令</td><br>            <td ><br>                Pragma: no-cache</td><br>        </tr><br>        <tr><br>            <td ><br>                Proxy-Authorization</td><br>            <td ><br>                连接到代理的授权证书</td><br>            <td ><br>                Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td><br>        </tr><br>        <tr><br>            <td ><br>                Range</td><br>            <td ><br>                只请求实体的一部分，指定范围</td><br>            <td ><br>                Range: bytes=500-999</td><br>        </tr><br>        <tr><br>            <td ><br>                Referer</td><br>            <td ><br>                先前网页的地址，当前请求网页紧随其后,即来路</td><br>            <td ><br>                Referer: <a href=\"http://www.zcmhi.com/archives/71.html\">http://www.zcmhi.com/archives/71.html</a></td><br>        </tr><br>        <tr><br>            <td ><br>                TE</td><br>            <td ><br>                客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><br>            <td ><br>                TE: trailers,deflate;q=0.5</td><br>        </tr><br>        <tr><br>            <td ><br>                Upgrade</td><br>            <td ><br>                向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><br>            <td ><br>                Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><br>        </tr><br>        <tr><br>            <td ><br>                User-Agent</td><br>            <td ><br>                User-Agent的内容包含发出请求的用户信息</td><br>            <td ><br>                User-Agent: Mozilla/5.0 (Linux; X11)</td><br>        </tr><br>        <tr><br>            <td ><br>                Via</td><br>            <td ><br>                通知中间网关或代理服务器地址，通信协议</td><br>            <td ><br>                Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td><br>        </tr><br>        <tr><br>            <td ><br>                Warning</td><br>            <td ><br>                关于消息实体的警告信息</td><br>            <td ><br>                Warn: 199 Miscellaneous warning<br /><br>                &nbsp;</td><br>        </tr><br>    </tbody><br></table><br><br><em>*Requests部分</em></em><br><table border=\"1\"  width=\"90%\"><br>    <tbody><br>        <tr><br>            <th><br>                Header</th><br>            <th><br>                解释</th><br>            <th><br>                示例</th><br>        </tr><br>        <tr><br>            <td ><br>                Accept</td><br>            <td ><br>                指定客户端能够接收的内容类型</td><br>            <td ><br>                Accept: text/plain, text/html</td><br>        </tr><br>        <tr><br>            <td ><br>                Accept-Charset</td><br>            <td ><br>                浏览器可以接受的字符编码集。</td><br>            <td ><br>                Accept-Charset: iso-8859-5</td><br>        </tr><br>        <tr><br>            <td ><br>                Accept-Encoding</td><br>            <td ><br>                指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><br>            <td ><br>                Accept-Encoding: compress, gzip</td><br>        </tr><br>        <tr><br>            <td ><br>                Accept-Language</td><br>            <td ><br>                浏览器可接受的语言</td><br>            <td ><br>                Accept-Language: en,zh</td><br>        </tr><br>        <tr><br>            <td ><br>                Accept-Ranges</td><br>            <td ><br>                可以请求网页实体的一个或者多个子范围字段</td><br>            <td ><br>                Accept-Ranges: bytes</td><br>        </tr><br>        <tr><br>            <td ><br>                Authorization</td><br>            <td ><br>                HTTP授权的授权证书</td><br>            <td ><br>                Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td><br>        </tr><br>        <tr><br>            <td ><br>                Cache-Control</td><br>            <td ><br>                指定请求和响应遵循的缓存机制</td><br>            <td ><br>                Cache-Control: no-cache</td><br>        </tr><br>        <tr><br>            <td ><br>                Connection</td><br>            <td ><br>                表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><br>            <td ><br>                Connection: close</td><br>        </tr><br>        <tr><br>            <td ><br>                Cookie</td><br>            <td ><br>                HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><br>            <td ><br>                Cookie: $Version=1; Skin=new;</td><br>        </tr><br>        <tr><br>            <td ><br>                Content-Length</td><br>            <td ><br>                请求的内容长度</td><br>            <td ><br>                Content-Length: 348</td><br>        </tr><br>    </tbody><br></table><br><br></div>\n\n<p>参考文档：<a href=\"http://www.itniwo.net/blog/v/26466.html\">http://www.itniwo.net/blog/v/26466.html</a></p>"},{"layout":"post","title":"什么是BOM(Byte Order Mark)?","date":"2012-10-23T09:05:00.000Z","comments":1,"_content":"###引子###\n在使用诸如UltraEditor,NotePad++等编辑工具时，经常会遇到encode进行转换的情况。以NotePad++为例，一篇ASCII编码的文本，通过菜单栏Encoding->convert to **进行编码格式的转换。我却发现一个奇怪的问题，下拉框里有这样两个选项：\n   \n* Convert to UTF-8   \n* Convert to UTF-8 without BOM   \n\n同样的是转化为UTF-8编码，为什么还牵涉到BOM呢。\n<!--more-->\n\n###原因###\n\n1、big endian和little endian  \n \nbig endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。那么在读文件的时间 “endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。 \n我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  \nUTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？  \n \n2.如何解决以上问题？   \n\n在UCS 编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。  \n\nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符\"ZERO WIDTH NO-BREAK SPACE\"的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。\n\n3.BOM在XML中的使用   \n\n W3C定义了三条XML解析器如何正确读取XML文件的编码的规则：   \n\n* 如果文档有BOM(字节顺序标记，一般来说，如果保存为unicode格式，则包含BOM，ANSI则无)，就定义了文件编码   \n* 如果没有BOM，就查看XML声明的编码属性   \n* 如果上述两个都没有，就假定XML文挡采用UTF-8编码   ","source":"_posts/2012-10-23-bom-in-utf8-text.markdown","raw":"---\nlayout: post\ntitle: \"什么是BOM(Byte Order Mark)?\"\ndate: 2012-10-23 17:05\ncomments: true\ncategories: encode\ntags: [ UTF8, encode, BOM, XML ]\n---\n###引子###\n在使用诸如UltraEditor,NotePad++等编辑工具时，经常会遇到encode进行转换的情况。以NotePad++为例，一篇ASCII编码的文本，通过菜单栏Encoding->convert to **进行编码格式的转换。我却发现一个奇怪的问题，下拉框里有这样两个选项：\n   \n* Convert to UTF-8   \n* Convert to UTF-8 without BOM   \n\n同样的是转化为UTF-8编码，为什么还牵涉到BOM呢。\n<!--more-->\n\n###原因###\n\n1、big endian和little endian  \n \nbig endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。那么在读文件的时间 “endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。 \n我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  \nUTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？  \n \n2.如何解决以上问题？   \n\n在UCS 编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。  \n\nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符\"ZERO WIDTH NO-BREAK SPACE\"的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。\n\n3.BOM在XML中的使用   \n\n W3C定义了三条XML解析器如何正确读取XML文件的编码的规则：   \n\n* 如果文档有BOM(字节顺序标记，一般来说，如果保存为unicode格式，则包含BOM，ANSI则无)，就定义了文件编码   \n* 如果没有BOM，就查看XML声明的编码属性   \n* 如果上述两个都没有，就假定XML文挡采用UTF-8编码   ","slug":"2012-10-23-bom-in-utf8-text","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2d001lv8fyy7yt9phy","content":"<p>###引子###<br>在使用诸如UltraEditor,NotePad++等编辑工具时，经常会遇到encode进行转换的情况。以NotePad++为例，一篇ASCII编码的文本，通过菜单栏Encoding-&gt;convert to **进行编码格式的转换。我却发现一个奇怪的问题，下拉框里有这样两个选项：</p>\n<ul>\n<li>Convert to UTF-8   </li>\n<li>Convert to UTF-8 without BOM   </li>\n</ul>\n<p>同样的是转化为UTF-8编码，为什么还牵涉到BOM呢。<br><a id=\"more\"></a></p>\n<p>###原因###</p>\n<p>1、big endian和little endian  </p>\n<p>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。那么在读文件的时间 “endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。<br>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。<br>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？  </p>\n<p>2.如何解决以上问题？   </p>\n<p>在UCS 编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。  </p>\n<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>\n<p>3.BOM在XML中的使用   </p>\n<p> W3C定义了三条XML解析器如何正确读取XML文件的编码的规则：   </p>\n<ul>\n<li>如果文档有BOM(字节顺序标记，一般来说，如果保存为unicode格式，则包含BOM，ANSI则无)，就定义了文件编码   </li>\n<li>如果没有BOM，就查看XML声明的编码属性   </li>\n<li>如果上述两个都没有，就假定XML文挡采用UTF-8编码   </li>\n</ul>\n","excerpt":"<p>###引子###<br>在使用诸如UltraEditor,NotePad++等编辑工具时，经常会遇到encode进行转换的情况。以NotePad++为例，一篇ASCII编码的文本，通过菜单栏Encoding-&gt;convert to **进行编码格式的转换。我却发现一个奇怪的问题，下拉框里有这样两个选项：</p>\n<ul>\n<li>Convert to UTF-8   </li>\n<li>Convert to UTF-8 without BOM   </li>\n</ul>\n<p>同样的是转化为UTF-8编码，为什么还牵涉到BOM呢。<br>","more":"</p>\n<p>###原因###</p>\n<p>1、big endian和little endian  </p>\n<p>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。那么在读文件的时间 “endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。<br>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。<br>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？  </p>\n<p>2.如何解决以上问题？   </p>\n<p>在UCS 编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。  </p>\n<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>\n<p>3.BOM在XML中的使用   </p>\n<p> W3C定义了三条XML解析器如何正确读取XML文件的编码的规则：   </p>\n<ul>\n<li>如果文档有BOM(字节顺序标记，一般来说，如果保存为unicode格式，则包含BOM，ANSI则无)，就定义了文件编码   </li>\n<li>如果没有BOM，就查看XML声明的编码属性   </li>\n<li>如果上述两个都没有，就假定XML文挡采用UTF-8编码   </li>\n</ul>"},{"layout":"post","title":"Java字符编码及其使用详解","date":"2012-10-23T10:58:00.000Z","comments":1,"_content":"##Java的编译存储##\nJava是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。  \n**简言之**  \n\n.java(任意编码) ---> .class(Unicode) ---> JVM内（Unicode）   \n\n<!--more-->\n\n##是什么导致了乱码的出现？##\n在JVM内，从class文件加载的源码全部以UNICODE编码。即使如`String str = \"中国\";`这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。\n\n##Java中如何实现字符编码转换？##\nString类提供了三个重要的函数：   \n\n\tgetBytes(String charsetName)\n\tgetBytes()\n\tnew String(byte[],String charsetName)\n`getBytes(String charset)`的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode-->charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode->ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。    \n\n`getBytes()`与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过`Charset.defaultCharset()`来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地扑面而来了。哭吧！     \n \n`new String(byte[],String charsetName)`的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。   \n\n因此，使用诸如`new String(str.getBytes(\"utf-8\"), \"gbk\")`这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。   \n\n**完美解决方案：**   \n考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是：   \n任意编码的字符 --> unicode --->任意编码的目标字符\n也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。\n以OutputStream为例：  \n \n\tString str = \"123中文\";\n\tSystem.out.println(str);\n\tSystem.out.println(\"默认字符:\" +Charset.defaultCharset());\n\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(\"e://encode.txt\")),\"GBK\"));\n\twriter.write(str);\n\twriter.close();\n在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。  \n\n在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？`System.out.println()`是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。   \n好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数`-encoding`来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为`Charset.defaultCharset()`,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。`System.out.println()`只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。  \n\n\tjavac -encoding utf-8 *.java    \n这也就可以理解，maven中pom.xml定义编码的原因了：   \n\n\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n同样Ant的build.xml中，也有相应的编码配置选项：   \n\n\t<javac destdir=\"${build.dir}\" encoding=\"UTF-8\">\n\t\t<src path=\"${src.dir}\" />\n\t\t<classpath refid=\"project.classpath\" />\n\t</javac>\n##HTTP的request与response乱码问题##\n1.HTTP请求主要分为POST,GET两种情况。  \n> POST的情况下，如何设置数据的编码格式呢。首先可以通过`<form accept-charset= \"UTF-8\">`来设置表单的编码格式。如果不设置，浏览器会直接使用网页的编码。JSP的网页编码一般通过`<%@page pageEncoding=\"UTF-8\"%>`来指定JSP文件的**存储编码**。而通过`<%@ page contentType=\"text/html; charset=UTF-8\" %>`来指定**输出内容编码**。`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">`这一meta设置，用来指定**网页编码**，这一设置同样使用于静态页面。  \n\n>GET情况下，参数都是放在URL内的，这时处理起来都比较麻烦。URL中的中文字符，一般都会进行`UrlEncode.encode()`处理,此时编码方式以系统默认编码为准，而在服务器端通过`getParameter`获得字符串是通过ISO-8859-1进行编码的。因此，需要从web服务器、浏览器端来同时考虑解决问题。服务器端的默认编码一般由`LC_ALL,LANG`决定的。通常可以设置为zh_CN.UTF-8。至于从浏览器端来解决，则没有统一的方法，毕竟环境多样。  \n\n2.setCharacterEncoding()方法   \n这一函数用来设置HTTP请求与相应的编码。前面提到过，通过`getParameter()`获得的字符串默认是以ISO-8859-1编码的。然而，如果使用了`request.setCharacterEncoding()`,则改变了其默认编码。同理，使用了`response.setCharacterEncoding`则保证了页面输出内容的编码，告诉浏览器输出内容采用什么编码。   \n在spring的WEB项目中，有这样一个常用的filter：   \n\n\t<filter>\n\t\t<filter-name>encodingFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t\t<init-param>\n\t\t\t<param-name>forceEncoding</param-name>\n\t\t\t<param-value>true</param-value>\n\t\t</init-param>\n\t</filter>\n这个filter，一看就知道是给编码有关，但是它具体做了哪些操作呢？源码来了：   \n\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.encoding != null && (this.forceEncoding || request.getCharacterEncoding() == null)) {\n\t\t\trequest.setCharacterEncoding(this.encoding);**\n\t\t\tif (this.forceEncoding) {\n\t\t\t\tresponse.setCharacterEncoding(this.encoding);\n\t\t\t}\n\t\t}\n\t\tfilterChain.doFilter(request, response);\n\t}\n可以看出，就是做了request、response的setCharacterEncoding()操作，防止乱码的问题出现。   \n##数据库乱码##\n前面讲到过，乱码的原因是JVM内可能会读到外界的未知编码字符，导致在内存中的Unicode编码为乱码。显然数据库就是其中之一，并且是经常遇到的问题。  \n1.首先，数据库要支持多语言，应该考虑将数据库设置成UTF或者Unicode编码，而UTF更适合存储（UTF是变长存储的）。如果中文数据中包含的英文字符很少，建议Unicode。数据库编码设置，一般通过在配置文件设置`default-character-set=utf8`，这个在建库的时间也可以直接指定。   \n2.读库的时候，可以在JDBC连接串中指定读取编码。如`useUnicode=true&characterEncoding=UTF-8`。并保证两者一致。\t\t\n##SecureCRT类似工具乱码##\n这种问题，通常是由于SecureCRT等客户端与LINUX环境编码不一致造成的。同样的，在这些客户端读取数据库内容进行显示出现乱码，也是由于编码不一致的问题。   \n可以通过设置客户端的编码，以及设置Linux环境的编码，使其保持一致来解决。\n\n参考文档：<http://blog.csdn.net/qinysong/article/details/1179513>","source":"_posts/2012-10-23-encode-in-java.markdown","raw":"---\nlayout: post\ntitle: \"Java字符编码及其使用详解\"\ndate: 2012-10-23 18:58\ncomments: true\ncategories: encode Java\ntags: [ Java, class, String, encode ]\n---\n##Java的编译存储##\nJava是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。  \n**简言之**  \n\n.java(任意编码) ---> .class(Unicode) ---> JVM内（Unicode）   \n\n<!--more-->\n\n##是什么导致了乱码的出现？##\n在JVM内，从class文件加载的源码全部以UNICODE编码。即使如`String str = \"中国\";`这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。\n\n##Java中如何实现字符编码转换？##\nString类提供了三个重要的函数：   \n\n\tgetBytes(String charsetName)\n\tgetBytes()\n\tnew String(byte[],String charsetName)\n`getBytes(String charset)`的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode-->charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode->ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。    \n\n`getBytes()`与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过`Charset.defaultCharset()`来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地扑面而来了。哭吧！     \n \n`new String(byte[],String charsetName)`的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。   \n\n因此，使用诸如`new String(str.getBytes(\"utf-8\"), \"gbk\")`这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。   \n\n**完美解决方案：**   \n考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是：   \n任意编码的字符 --> unicode --->任意编码的目标字符\n也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。\n以OutputStream为例：  \n \n\tString str = \"123中文\";\n\tSystem.out.println(str);\n\tSystem.out.println(\"默认字符:\" +Charset.defaultCharset());\n\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(\"e://encode.txt\")),\"GBK\"));\n\twriter.write(str);\n\twriter.close();\n在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。  \n\n在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？`System.out.println()`是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。   \n好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数`-encoding`来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为`Charset.defaultCharset()`,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。`System.out.println()`只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。  \n\n\tjavac -encoding utf-8 *.java    \n这也就可以理解，maven中pom.xml定义编码的原因了：   \n\n\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n同样Ant的build.xml中，也有相应的编码配置选项：   \n\n\t<javac destdir=\"${build.dir}\" encoding=\"UTF-8\">\n\t\t<src path=\"${src.dir}\" />\n\t\t<classpath refid=\"project.classpath\" />\n\t</javac>\n##HTTP的request与response乱码问题##\n1.HTTP请求主要分为POST,GET两种情况。  \n> POST的情况下，如何设置数据的编码格式呢。首先可以通过`<form accept-charset= \"UTF-8\">`来设置表单的编码格式。如果不设置，浏览器会直接使用网页的编码。JSP的网页编码一般通过`<%@page pageEncoding=\"UTF-8\"%>`来指定JSP文件的**存储编码**。而通过`<%@ page contentType=\"text/html; charset=UTF-8\" %>`来指定**输出内容编码**。`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">`这一meta设置，用来指定**网页编码**，这一设置同样使用于静态页面。  \n\n>GET情况下，参数都是放在URL内的，这时处理起来都比较麻烦。URL中的中文字符，一般都会进行`UrlEncode.encode()`处理,此时编码方式以系统默认编码为准，而在服务器端通过`getParameter`获得字符串是通过ISO-8859-1进行编码的。因此，需要从web服务器、浏览器端来同时考虑解决问题。服务器端的默认编码一般由`LC_ALL,LANG`决定的。通常可以设置为zh_CN.UTF-8。至于从浏览器端来解决，则没有统一的方法，毕竟环境多样。  \n\n2.setCharacterEncoding()方法   \n这一函数用来设置HTTP请求与相应的编码。前面提到过，通过`getParameter()`获得的字符串默认是以ISO-8859-1编码的。然而，如果使用了`request.setCharacterEncoding()`,则改变了其默认编码。同理，使用了`response.setCharacterEncoding`则保证了页面输出内容的编码，告诉浏览器输出内容采用什么编码。   \n在spring的WEB项目中，有这样一个常用的filter：   \n\n\t<filter>\n\t\t<filter-name>encodingFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t\t<init-param>\n\t\t\t<param-name>forceEncoding</param-name>\n\t\t\t<param-value>true</param-value>\n\t\t</init-param>\n\t</filter>\n这个filter，一看就知道是给编码有关，但是它具体做了哪些操作呢？源码来了：   \n\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.encoding != null && (this.forceEncoding || request.getCharacterEncoding() == null)) {\n\t\t\trequest.setCharacterEncoding(this.encoding);**\n\t\t\tif (this.forceEncoding) {\n\t\t\t\tresponse.setCharacterEncoding(this.encoding);\n\t\t\t}\n\t\t}\n\t\tfilterChain.doFilter(request, response);\n\t}\n可以看出，就是做了request、response的setCharacterEncoding()操作，防止乱码的问题出现。   \n##数据库乱码##\n前面讲到过，乱码的原因是JVM内可能会读到外界的未知编码字符，导致在内存中的Unicode编码为乱码。显然数据库就是其中之一，并且是经常遇到的问题。  \n1.首先，数据库要支持多语言，应该考虑将数据库设置成UTF或者Unicode编码，而UTF更适合存储（UTF是变长存储的）。如果中文数据中包含的英文字符很少，建议Unicode。数据库编码设置，一般通过在配置文件设置`default-character-set=utf8`，这个在建库的时间也可以直接指定。   \n2.读库的时候，可以在JDBC连接串中指定读取编码。如`useUnicode=true&characterEncoding=UTF-8`。并保证两者一致。\t\t\n##SecureCRT类似工具乱码##\n这种问题，通常是由于SecureCRT等客户端与LINUX环境编码不一致造成的。同样的，在这些客户端读取数据库内容进行显示出现乱码，也是由于编码不一致的问题。   \n可以通过设置客户端的编码，以及设置Linux环境的编码，使其保持一致来解决。\n\n参考文档：<http://blog.csdn.net/qinysong/article/details/1179513>","slug":"2012-10-23-encode-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2f001ov8fypjpz83lp","content":"<p>##Java的编译存储##<br>Java是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。<br><strong>简言之</strong>  </p>\n<p>.java(任意编码) —&gt; .class(Unicode) —&gt; JVM内（Unicode）   </p>\n<a id=\"more\"></a>\n<p>##是什么导致了乱码的出现？##<br>在JVM内，从class文件加载的源码全部以UNICODE编码。即使如<code>String str = &quot;中国&quot;;</code>这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。</p>\n<p>##Java中如何实现字符编码转换？##<br>String类提供了三个重要的函数：   </p>\n<pre><code>getBytes(String charsetName)\ngetBytes()\nnew String(byte[],String charsetName)\n</code></pre><p><code>getBytes(String charset)</code>的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode–&gt;charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode-&gt;ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。    </p>\n<p><code>getBytes()</code>与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过<code>Charset.defaultCharset()</code>来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地扑面而来了。哭吧！     </p>\n<p><code>new String(byte[],String charsetName)</code>的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。   </p>\n<p>因此，使用诸如<code>new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;)</code>这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。   </p>\n<p><strong>完美解决方案：</strong><br>考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是：<br>任意编码的字符 –&gt; unicode —&gt;任意编码的目标字符<br>也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。<br>以OutputStream为例：  </p>\n<pre><code>String str = &quot;123中文&quot;;\nSystem.out.println(str);\nSystem.out.println(&quot;默认字符:&quot; +Charset.defaultCharset());\nBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(&quot;e://encode.txt&quot;)),&quot;GBK&quot;));\nwriter.write(str);\nwriter.close();\n</code></pre><p>在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。  </p>\n<p>在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？<code>System.out.println()</code>是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。<br>好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数<code>-encoding</code>来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为<code>Charset.defaultCharset()</code>,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。<code>System.out.println()</code>只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。  </p>\n<pre><code>javac -encoding utf-8 *.java    \n</code></pre><p>这也就可以理解，maven中pom.xml定义编码的原因了：   </p>\n<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n</code></pre><p>同样Ant的build.xml中，也有相应的编码配置选项：   </p>\n<pre><code>&lt;javac destdir=&quot;${build.dir}&quot; encoding=&quot;UTF-8&quot;&gt;\n    &lt;src path=&quot;${src.dir}&quot; /&gt;\n    &lt;classpath refid=&quot;project.classpath&quot; /&gt;\n&lt;/javac&gt;\n</code></pre><p>##HTTP的request与response乱码问题##<br>1.HTTP请求主要分为POST,GET两种情况。  </p>\n<blockquote>\n<p>POST的情况下，如何设置数据的编码格式呢。首先可以通过<code>&lt;form accept-charset= &quot;UTF-8&quot;&gt;</code>来设置表单的编码格式。如果不设置，浏览器会直接使用网页的编码。JSP的网页编码一般通过<code>&lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</code>来指定JSP文件的<strong>存储编码</strong>。而通过<code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; %&gt;</code>来指定<strong>输出内容编码</strong>。<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code>这一meta设置，用来指定<strong>网页编码</strong>，这一设置同样使用于静态页面。  </p>\n<p>GET情况下，参数都是放在URL内的，这时处理起来都比较麻烦。URL中的中文字符，一般都会进行<code>UrlEncode.encode()</code>处理,此时编码方式以系统默认编码为准，而在服务器端通过<code>getParameter</code>获得字符串是通过ISO-8859-1进行编码的。因此，需要从web服务器、浏览器端来同时考虑解决问题。服务器端的默认编码一般由<code>LC_ALL,LANG</code>决定的。通常可以设置为zh_CN.UTF-8。至于从浏览器端来解决，则没有统一的方法，毕竟环境多样。  </p>\n</blockquote>\n<p>2.setCharacterEncoding()方法<br>这一函数用来设置HTTP请求与相应的编码。前面提到过，通过<code>getParameter()</code>获得的字符串默认是以ISO-8859-1编码的。然而，如果使用了<code>request.setCharacterEncoding()</code>,则改变了其默认编码。同理，使用了<code>response.setCharacterEncoding</code>则保证了页面输出内容的编码，告诉浏览器输出内容采用什么编码。<br>在spring的WEB项目中，有这样一个常用的filter：   </p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n</code></pre><p>这个filter，一看就知道是给编码有关，但是它具体做了哪些操作呢？源码来了：   </p>\n<pre><code>protected void doFilterInternal(\n        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n        throws ServletException, IOException {\n\n    if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) {\n        request.setCharacterEncoding(this.encoding);**\n        if (this.forceEncoding) {\n            response.setCharacterEncoding(this.encoding);\n        }\n    }\n    filterChain.doFilter(request, response);\n}\n</code></pre><p>可以看出，就是做了request、response的setCharacterEncoding()操作，防止乱码的问题出现。   </p>\n<p>##数据库乱码##<br>前面讲到过，乱码的原因是JVM内可能会读到外界的未知编码字符，导致在内存中的Unicode编码为乱码。显然数据库就是其中之一，并且是经常遇到的问题。<br>1.首先，数据库要支持多语言，应该考虑将数据库设置成UTF或者Unicode编码，而UTF更适合存储（UTF是变长存储的）。如果中文数据中包含的英文字符很少，建议Unicode。数据库编码设置，一般通过在配置文件设置<code>default-character-set=utf8</code>，这个在建库的时间也可以直接指定。<br>2.读库的时候，可以在JDBC连接串中指定读取编码。如<code>useUnicode=true&amp;characterEncoding=UTF-8</code>。并保证两者一致。        </p>\n<p>##SecureCRT类似工具乱码##<br>这种问题，通常是由于SecureCRT等客户端与LINUX环境编码不一致造成的。同样的，在这些客户端读取数据库内容进行显示出现乱码，也是由于编码不一致的问题。<br>可以通过设置客户端的编码，以及设置Linux环境的编码，使其保持一致来解决。</p>\n<p>参考文档：<a href=\"http://blog.csdn.net/qinysong/article/details/1179513\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qinysong/article/details/1179513</a></p>\n","excerpt":"<p>##Java的编译存储##<br>Java是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。<br><strong>简言之</strong>  </p>\n<p>.java(任意编码) —&gt; .class(Unicode) —&gt; JVM内（Unicode）   </p>","more":"<p>##是什么导致了乱码的出现？##<br>在JVM内，从class文件加载的源码全部以UNICODE编码。即使如<code>String str = &quot;中国&quot;;</code>这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。</p>\n<p>##Java中如何实现字符编码转换？##<br>String类提供了三个重要的函数：   </p>\n<pre><code>getBytes(String charsetName)\ngetBytes()\nnew String(byte[],String charsetName)\n</code></pre><p><code>getBytes(String charset)</code>的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode–&gt;charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode-&gt;ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。    </p>\n<p><code>getBytes()</code>与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过<code>Charset.defaultCharset()</code>来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地扑面而来了。哭吧！     </p>\n<p><code>new String(byte[],String charsetName)</code>的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。   </p>\n<p>因此，使用诸如<code>new String(str.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;)</code>这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。   </p>\n<p><strong>完美解决方案：</strong><br>考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是：<br>任意编码的字符 –&gt; unicode —&gt;任意编码的目标字符<br>也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。<br>以OutputStream为例：  </p>\n<pre><code>String str = &quot;123中文&quot;;\nSystem.out.println(str);\nSystem.out.println(&quot;默认字符:&quot; +Charset.defaultCharset());\nBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(&quot;e://encode.txt&quot;)),&quot;GBK&quot;));\nwriter.write(str);\nwriter.close();\n</code></pre><p>在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。  </p>\n<p>在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？<code>System.out.println()</code>是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。<br>好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数<code>-encoding</code>来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为<code>Charset.defaultCharset()</code>,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。<code>System.out.println()</code>只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。  </p>\n<pre><code>javac -encoding utf-8 *.java    \n</code></pre><p>这也就可以理解，maven中pom.xml定义编码的原因了：   </p>\n<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n</code></pre><p>同样Ant的build.xml中，也有相应的编码配置选项：   </p>\n<pre><code>&lt;javac destdir=&quot;${build.dir}&quot; encoding=&quot;UTF-8&quot;&gt;\n    &lt;src path=&quot;${src.dir}&quot; /&gt;\n    &lt;classpath refid=&quot;project.classpath&quot; /&gt;\n&lt;/javac&gt;\n</code></pre><p>##HTTP的request与response乱码问题##<br>1.HTTP请求主要分为POST,GET两种情况。  </p>\n<blockquote>\n<p>POST的情况下，如何设置数据的编码格式呢。首先可以通过<code>&lt;form accept-charset= &quot;UTF-8&quot;&gt;</code>来设置表单的编码格式。如果不设置，浏览器会直接使用网页的编码。JSP的网页编码一般通过<code>&lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt;</code>来指定JSP文件的<strong>存储编码</strong>。而通过<code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; %&gt;</code>来指定<strong>输出内容编码</strong>。<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code>这一meta设置，用来指定<strong>网页编码</strong>，这一设置同样使用于静态页面。  </p>\n<p>GET情况下，参数都是放在URL内的，这时处理起来都比较麻烦。URL中的中文字符，一般都会进行<code>UrlEncode.encode()</code>处理,此时编码方式以系统默认编码为准，而在服务器端通过<code>getParameter</code>获得字符串是通过ISO-8859-1进行编码的。因此，需要从web服务器、浏览器端来同时考虑解决问题。服务器端的默认编码一般由<code>LC_ALL,LANG</code>决定的。通常可以设置为zh_CN.UTF-8。至于从浏览器端来解决，则没有统一的方法，毕竟环境多样。  </p>\n</blockquote>\n<p>2.setCharacterEncoding()方法<br>这一函数用来设置HTTP请求与相应的编码。前面提到过，通过<code>getParameter()</code>获得的字符串默认是以ISO-8859-1编码的。然而，如果使用了<code>request.setCharacterEncoding()</code>,则改变了其默认编码。同理，使用了<code>response.setCharacterEncoding</code>则保证了页面输出内容的编码，告诉浏览器输出内容采用什么编码。<br>在spring的WEB项目中，有这样一个常用的filter：   </p>\n<pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n</code></pre><p>这个filter，一看就知道是给编码有关，但是它具体做了哪些操作呢？源码来了：   </p>\n<pre><code>protected void doFilterInternal(\n        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n        throws ServletException, IOException {\n\n    if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) {\n        request.setCharacterEncoding(this.encoding);**\n        if (this.forceEncoding) {\n            response.setCharacterEncoding(this.encoding);\n        }\n    }\n    filterChain.doFilter(request, response);\n}\n</code></pre><p>可以看出，就是做了request、response的setCharacterEncoding()操作，防止乱码的问题出现。   </p>\n<p>##数据库乱码##<br>前面讲到过，乱码的原因是JVM内可能会读到外界的未知编码字符，导致在内存中的Unicode编码为乱码。显然数据库就是其中之一，并且是经常遇到的问题。<br>1.首先，数据库要支持多语言，应该考虑将数据库设置成UTF或者Unicode编码，而UTF更适合存储（UTF是变长存储的）。如果中文数据中包含的英文字符很少，建议Unicode。数据库编码设置，一般通过在配置文件设置<code>default-character-set=utf8</code>，这个在建库的时间也可以直接指定。<br>2.读库的时候，可以在JDBC连接串中指定读取编码。如<code>useUnicode=true&amp;characterEncoding=UTF-8</code>。并保证两者一致。        </p>\n<p>##SecureCRT类似工具乱码##<br>这种问题，通常是由于SecureCRT等客户端与LINUX环境编码不一致造成的。同样的，在这些客户端读取数据库内容进行显示出现乱码，也是由于编码不一致的问题。<br>可以通过设置客户端的编码，以及设置Linux环境的编码，使其保持一致来解决。</p>\n<p>参考文档：<a href=\"http://blog.csdn.net/qinysong/article/details/1179513\">http://blog.csdn.net/qinysong/article/details/1179513</a></p>"},{"layout":"post","title":"字符集编码","date":"2012-10-22T12:29:00.000Z","comments":1,"_content":"##GB2312字符集##\nGB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施，是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。 \n<!--more-->\n\nGB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 \n\nGB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码。 \n\n它是用双字节表示的，两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为“高字节” ，而称第二字节为“低字节”。“高位字节”使用了0xA1-0xF7(把01-87区的区号加上0xA0)，“低位字节”使用了0xA1-0xFE(把01-94加上0xA0)。 \n\n以GB2312字符集的第一个汉字“啊”字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。 \n\n##GBK字符集##\nGBK字符集是GB2312的扩展(K)，GBK1.0收录了21886个符号，它分为汉字区和图形符号区，汉字区包括21003个字符。GBK字符集主要扩展了繁体中文字的支持。 \n\n\n##BIG5 字符集##\n\nBIG5又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五间软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。  \n\nBig5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。  \n\nBig5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。  \n\n尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。  \n\n例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等) 也没有收录到Big5之中。  \n\n\n##GB18030 字符集##\n\nGB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。GB 18030字符集标准的出台经过广泛参与和论证，来自国内外知名信息技术行业的公司，信息产业部和原国家质量技术监督局联合实施。  \n\nGB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。  \n\n编码方法：  \nGB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。   \n\n按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。   \n\n接着是国际通用的unicode字符集    \n\n##Unicode字符集（简称为UCS）##\n\n1．名称的由来   \n\nUnicode字符集编码是（Universal Multiple-Octet Coded Character Set） 通用多八位编码字符集的简称，支持世界上超过650种语言的国际字符集。Unicode允许在同一服务器上混合使用不同语言组的不同语言。它是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。该编码于1990年开始研发，1994年正式公布，最新版本是2005年3月31日的Unicode 4.1.0。Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。  \n\n2．编码方法   \n\nUnicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，例如字母“A”的编码为 004116 。所以“A”的编码书写为“U+0041”。 \n\n3．UTF-8 编码   \nUTF-8是Unicode的其中一个使用方式。 UTF是 Unicode Translation Format，即把Unicode转做某种格式的意思。 \n\nUTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的Unicode能够在现存的处理单字节的系统上正确传输。 \n\nUTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。 \n\n4．UTF-16 和 UTF-32 编码    \nUTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案，UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码；UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数 \n\n通过一个问题了解unicode编码   \n\n**问题：**使用Windows记事本的“另存为”，可以在ANSI、GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows怎样识别编码方式的呢？    \n我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？    \n\n**答案：**   \n\nANSI字符集定义：ASCII字符集，以及由此派生并兼容的字符集，如：GB2312，正式的名称为MBCS(Multi-Byte Chactacter System，多字节字符系统)，通常也称为ANSI字符集。   \n\n##UNICODE 与 UTF8、UTF16##\n\n由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits(两个字节)来表示一个字符，共可以表示65536个字符    \n标准的 Unicode 称为UTF-16(UTF:UCS Transformation Format )。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。(Unicode字符集有多种编码形式)    \n例如\"连通\"两个字的Unicode标准编码UTF-16 (big endian)为：DE 8F 1A 90   \n而其UTF-8编码为：E8 BF 9E E9 80 9A   \n\n当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： \n检测文件头标识，提示用户选择，根据一定的规则猜测 \n最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：  \nEF BB BF UTF-8  \nFE FF UTF-16/UCS-2, little endian    \nFF FE UTF-16/UCS-2, big endian    \nFF FE 00 00 UTF-32/UCS-4, little endian.   \n00 00 FE FF UTF-32/UCS-4, big-endian.    \n\n\n1、big endian和little endian   \nbig endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。 \n“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。   \n我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  \n\n2、字符编码、内码，顺带介绍汉字编码    \n字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。    \nGB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。   \nGB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。    \n从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。    \n有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。   \n这里还有一些细节：   \nGB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。   \n在DBCS中，GB内码的存储格式始终是big endian，即高位在前。   \nGB2312的两个字节的最高位都是1。但符合这个条件的码位只有128*128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。   \n\n3、Unicode、UCS和UTF(UCS Transformation Format)    \n前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。 \n\nUCS规定了怎么用多个字节表示各种文字。而怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的！常见的UTF规范包括UTF-8、UTF-7、UTF-16。  \n\n4、UTF的字节序和BOM   \nUTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？   \nUnicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：     \n在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。 \n这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。    \nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符\"ZERO WIDTH NO-BREAK SPACE\"的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。    \nWindows就是使用BOM来标记文本文件的编码方式的。   \n\n\n写到这里对编码有了大致的了解了，就可以理解网上一些文章的话了，比如有一篇很流行的文章《URL编码与SQL注射》里面有一段是这么说的：   \n\n其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。呵呵，知道怎么转换的了吧。   \n\n\n这得从ASCII说起，扩展的ASCII字符集采用8bit255个字符显然不够用，于是各个国家纷纷制定了自己的文字编码规范，其中中文的文字编码规范叫做“GB2312-80”（就是GB2312)，它是和ASCII兼容的一种编码规范，其实就是用扩展ASCII没有真正标准化这一点，把一个中文字符用两个扩展ASCII字符来表示。文中说的的中文ASCII码实际上就是简体中文的编码2312GB！它把ASCII又扩充了一个字节，由于高位的第一位是0，所以会出现负数的形式，url编码就是将汉字的这个GB2312编码转化成UTF-8的编码并且每8位即一个字节前面加上%符号表示。   \n\n那为何UTF-8是进行网络的规范传输编码呢？   \n\n在Unicode里，所有的字符被一视同仁。汉字不再使用“两个扩展ASCII”，而是使用“1个Unicode”，注意，现在的汉字是“一个字符”了，于是，拆字、统计字数这些问题也就自然而然的解决了。但是，这个世界不是理想的，不可能在一夜之间所有的系统都使用Unicode来处理字符，所以Unicode在诞生之日，就必须考虑一个严峻的问题：和ASCII字符集之间的不兼容问题。   \n\n我们知道，ASCII字符是单个字节的，比如“A”的ASCII是65。而Unicode是双字节的，比如“A”的Unicode是0065，这就造成了一个非常大的问题：以前处理ASCII的那套机制不能被用来处理Unicode了   \n\n另一个更加严重的问题是，C语言使用'\\0'作为字符串结尾，而Unicode里恰恰有很多字符都有一个字节为0，这样一来，C语言的字符串函数将无法正常处理Unicode，除非把世界上所有用C写的程序以及他们所用的函数库全部换掉    \n\n于是，比Unicode更伟大的东东诞生了，之所以说它更伟大是因为它让Unicode不再存在于纸上，而是真实的存在于我们大家的电脑中。那就是：UTF   \n\nUTF= UCS Transformation Format UCS转换格式，它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16   \n\n其中UTF-16和上面提到的Unicode本身的编码规范是一致的，这里不多说了。而UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容，这样做的好处是压缩了字符在西欧一些国家的内存消耗，减少了不必要的资源浪费，这在实际应用中是非常有必要的。   \n\nUTF-8有点类似于Haffman编码，它将Unicode编码为：  \n00000000-0000007F的字符，用单个字节来表示； \n\n00000080-000007FF的字符用两个字节表示 （中文的编码范围）  \n\n00000800-0000FFFF的字符用3字节表示    \n\n因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。  \n\n在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的）。  \n\n\n看看编码之多：ANSI,AscII,GB2312,GBK,BIG5,GB18030,Unicode,UCS（就是unicode）Utf-8,utf-16,utf-32 整整10种编码～，算是够复杂了 \n可是这还仅仅是个开始，应用方面变化无穷，不过现在看到这些东西起码再不会头大了！呼呼～ \n\n\n哦，漏了一个加密的base64编码。  \n\n##什么是Base64？##\n\n按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） \n\n**为什么要使用Base64？**\n\n在设计这个编码的时候，我想设计人员最主要考虑了3个问题：   \n1.是否加密？    \n2.加密算法复杂程度和效率    \n3.如何处理传输？    \n\n加密是肯定的，但是加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”。即达到一眼望去完全看不出内容即可。   \n基于这个目的加密算法的复杂程度和效率也就不能太大和太低。和上一个理由类似，MIME协议等用于发送Email的协议解决的是如何收发Email，而并不是如何安全的收发Email。因此算法的复杂程度要小，效率要高，否则因为发送Email而大量占用资源，路就有点走歪了。    \n\n但是，如果是基于以上两点，那么我们使用最简单的恺撒法即可，为什么Base64看起来要比恺撒法复杂呢？这是因为在Email的传送过程中，由于历史原因，Email只被允许传送ASCII字符，即一个8位字节的低7位。因此，如果您发送了一封带有非ASCII字符（即字节的最高位是1）的Email通过有“历史问题”的网关时就可能会出现问题。网关可能会把最高位置为0！很明显，问题就这样产生了！因此，为了能够正常的传送Email，这个问题就必须考虑！所以，单单靠改变字母的位置的恺撒之类的方案也就不行了。关于这一点可以参考RFC2046。    \n基于以上的一些主要原因产生了Base64编码。   \n\n参考文档：<http://cafardcn.iteye.com/blog/300239>","source":"_posts/2012-10-22-word-charset.markdown","raw":"---\nlayout: post\ntitle: \"字符集编码\"\ndate: 2012-10-22 20:29\ncomments: true\ncategories: encode\ntags: [ UTF, encode ]\n---\n##GB2312字符集##\nGB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施，是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。 \n<!--more-->\n\nGB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 \n\nGB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码。 \n\n它是用双字节表示的，两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为“高字节” ，而称第二字节为“低字节”。“高位字节”使用了0xA1-0xF7(把01-87区的区号加上0xA0)，“低位字节”使用了0xA1-0xFE(把01-94加上0xA0)。 \n\n以GB2312字符集的第一个汉字“啊”字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。 \n\n##GBK字符集##\nGBK字符集是GB2312的扩展(K)，GBK1.0收录了21886个符号，它分为汉字区和图形符号区，汉字区包括21003个字符。GBK字符集主要扩展了繁体中文字的支持。 \n\n\n##BIG5 字符集##\n\nBIG5又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五间软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。  \n\nBig5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。  \n\nBig5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。  \n\n尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。  \n\n例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等) 也没有收录到Big5之中。  \n\n\n##GB18030 字符集##\n\nGB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。GB 18030字符集标准的出台经过广泛参与和论证，来自国内外知名信息技术行业的公司，信息产业部和原国家质量技术监督局联合实施。  \n\nGB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。  \n\n编码方法：  \nGB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。   \n\n按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。   \n\n接着是国际通用的unicode字符集    \n\n##Unicode字符集（简称为UCS）##\n\n1．名称的由来   \n\nUnicode字符集编码是（Universal Multiple-Octet Coded Character Set） 通用多八位编码字符集的简称，支持世界上超过650种语言的国际字符集。Unicode允许在同一服务器上混合使用不同语言组的不同语言。它是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。该编码于1990年开始研发，1994年正式公布，最新版本是2005年3月31日的Unicode 4.1.0。Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。  \n\n2．编码方法   \n\nUnicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，例如字母“A”的编码为 004116 。所以“A”的编码书写为“U+0041”。 \n\n3．UTF-8 编码   \nUTF-8是Unicode的其中一个使用方式。 UTF是 Unicode Translation Format，即把Unicode转做某种格式的意思。 \n\nUTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的Unicode能够在现存的处理单字节的系统上正确传输。 \n\nUTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。 \n\n4．UTF-16 和 UTF-32 编码    \nUTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案，UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码；UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数 \n\n通过一个问题了解unicode编码   \n\n**问题：**使用Windows记事本的“另存为”，可以在ANSI、GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows怎样识别编码方式的呢？    \n我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？    \n\n**答案：**   \n\nANSI字符集定义：ASCII字符集，以及由此派生并兼容的字符集，如：GB2312，正式的名称为MBCS(Multi-Byte Chactacter System，多字节字符系统)，通常也称为ANSI字符集。   \n\n##UNICODE 与 UTF8、UTF16##\n\n由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits(两个字节)来表示一个字符，共可以表示65536个字符    \n标准的 Unicode 称为UTF-16(UTF:UCS Transformation Format )。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。(Unicode字符集有多种编码形式)    \n例如\"连通\"两个字的Unicode标准编码UTF-16 (big endian)为：DE 8F 1A 90   \n而其UTF-8编码为：E8 BF 9E E9 80 9A   \n\n当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： \n检测文件头标识，提示用户选择，根据一定的规则猜测 \n最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：  \nEF BB BF UTF-8  \nFE FF UTF-16/UCS-2, little endian    \nFF FE UTF-16/UCS-2, big endian    \nFF FE 00 00 UTF-32/UCS-4, little endian.   \n00 00 FE FF UTF-32/UCS-4, big-endian.    \n\n\n1、big endian和little endian   \nbig endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。 \n“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。   \n我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  \n\n2、字符编码、内码，顺带介绍汉字编码    \n字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。    \nGB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。   \nGB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。    \n从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。    \n有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。   \n这里还有一些细节：   \nGB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。   \n在DBCS中，GB内码的存储格式始终是big endian，即高位在前。   \nGB2312的两个字节的最高位都是1。但符合这个条件的码位只有128*128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。   \n\n3、Unicode、UCS和UTF(UCS Transformation Format)    \n前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。 \n\nUCS规定了怎么用多个字节表示各种文字。而怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的！常见的UTF规范包括UTF-8、UTF-7、UTF-16。  \n\n4、UTF的字节序和BOM   \nUTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？   \nUnicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：     \n在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。 \n这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。    \nUTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符\"ZERO WIDTH NO-BREAK SPACE\"的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。    \nWindows就是使用BOM来标记文本文件的编码方式的。   \n\n\n写到这里对编码有了大致的了解了，就可以理解网上一些文章的话了，比如有一篇很流行的文章《URL编码与SQL注射》里面有一段是这么说的：   \n\n其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。呵呵，知道怎么转换的了吧。   \n\n\n这得从ASCII说起，扩展的ASCII字符集采用8bit255个字符显然不够用，于是各个国家纷纷制定了自己的文字编码规范，其中中文的文字编码规范叫做“GB2312-80”（就是GB2312)，它是和ASCII兼容的一种编码规范，其实就是用扩展ASCII没有真正标准化这一点，把一个中文字符用两个扩展ASCII字符来表示。文中说的的中文ASCII码实际上就是简体中文的编码2312GB！它把ASCII又扩充了一个字节，由于高位的第一位是0，所以会出现负数的形式，url编码就是将汉字的这个GB2312编码转化成UTF-8的编码并且每8位即一个字节前面加上%符号表示。   \n\n那为何UTF-8是进行网络的规范传输编码呢？   \n\n在Unicode里，所有的字符被一视同仁。汉字不再使用“两个扩展ASCII”，而是使用“1个Unicode”，注意，现在的汉字是“一个字符”了，于是，拆字、统计字数这些问题也就自然而然的解决了。但是，这个世界不是理想的，不可能在一夜之间所有的系统都使用Unicode来处理字符，所以Unicode在诞生之日，就必须考虑一个严峻的问题：和ASCII字符集之间的不兼容问题。   \n\n我们知道，ASCII字符是单个字节的，比如“A”的ASCII是65。而Unicode是双字节的，比如“A”的Unicode是0065，这就造成了一个非常大的问题：以前处理ASCII的那套机制不能被用来处理Unicode了   \n\n另一个更加严重的问题是，C语言使用'\\0'作为字符串结尾，而Unicode里恰恰有很多字符都有一个字节为0，这样一来，C语言的字符串函数将无法正常处理Unicode，除非把世界上所有用C写的程序以及他们所用的函数库全部换掉    \n\n于是，比Unicode更伟大的东东诞生了，之所以说它更伟大是因为它让Unicode不再存在于纸上，而是真实的存在于我们大家的电脑中。那就是：UTF   \n\nUTF= UCS Transformation Format UCS转换格式，它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16   \n\n其中UTF-16和上面提到的Unicode本身的编码规范是一致的，这里不多说了。而UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容，这样做的好处是压缩了字符在西欧一些国家的内存消耗，减少了不必要的资源浪费，这在实际应用中是非常有必要的。   \n\nUTF-8有点类似于Haffman编码，它将Unicode编码为：  \n00000000-0000007F的字符，用单个字节来表示； \n\n00000080-000007FF的字符用两个字节表示 （中文的编码范围）  \n\n00000800-0000FFFF的字符用3字节表示    \n\n因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。  \n\n在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的）。  \n\n\n看看编码之多：ANSI,AscII,GB2312,GBK,BIG5,GB18030,Unicode,UCS（就是unicode）Utf-8,utf-16,utf-32 整整10种编码～，算是够复杂了 \n可是这还仅仅是个开始，应用方面变化无穷，不过现在看到这些东西起码再不会头大了！呼呼～ \n\n\n哦，漏了一个加密的base64编码。  \n\n##什么是Base64？##\n\n按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） \n\n**为什么要使用Base64？**\n\n在设计这个编码的时候，我想设计人员最主要考虑了3个问题：   \n1.是否加密？    \n2.加密算法复杂程度和效率    \n3.如何处理传输？    \n\n加密是肯定的，但是加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”。即达到一眼望去完全看不出内容即可。   \n基于这个目的加密算法的复杂程度和效率也就不能太大和太低。和上一个理由类似，MIME协议等用于发送Email的协议解决的是如何收发Email，而并不是如何安全的收发Email。因此算法的复杂程度要小，效率要高，否则因为发送Email而大量占用资源，路就有点走歪了。    \n\n但是，如果是基于以上两点，那么我们使用最简单的恺撒法即可，为什么Base64看起来要比恺撒法复杂呢？这是因为在Email的传送过程中，由于历史原因，Email只被允许传送ASCII字符，即一个8位字节的低7位。因此，如果您发送了一封带有非ASCII字符（即字节的最高位是1）的Email通过有“历史问题”的网关时就可能会出现问题。网关可能会把最高位置为0！很明显，问题就这样产生了！因此，为了能够正常的传送Email，这个问题就必须考虑！所以，单单靠改变字母的位置的恺撒之类的方案也就不行了。关于这一点可以参考RFC2046。    \n基于以上的一些主要原因产生了Base64编码。   \n\n参考文档：<http://cafardcn.iteye.com/blog/300239>","slug":"2012-10-22-word-charset","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2k001rv8fy0q07097w","content":"<p>##GB2312字符集##<br>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施，是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。<br><a id=\"more\"></a></p>\n<p>GB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 </p>\n<p>GB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码。 </p>\n<p>它是用双字节表示的，两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为“高字节” ，而称第二字节为“低字节”。“高位字节”使用了0xA1-0xF7(把01-87区的区号加上0xA0)，“低位字节”使用了0xA1-0xFE(把01-94加上0xA0)。 </p>\n<p>以GB2312字符集的第一个汉字“啊”字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。 </p>\n<p>##GBK字符集##<br>GBK字符集是GB2312的扩展(K)，GBK1.0收录了21886个符号，它分为汉字区和图形符号区，汉字区包括21003个字符。GBK字符集主要扩展了繁体中文字的支持。 </p>\n<p>##BIG5 字符集##</p>\n<p>BIG5又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五间软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。  </p>\n<p>Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。  </p>\n<p>Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。  </p>\n<p>尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。  </p>\n<p>例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等) 也没有收录到Big5之中。  </p>\n<p>##GB18030 字符集##</p>\n<p>GB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。GB 18030字符集标准的出台经过广泛参与和论证，来自国内外知名信息技术行业的公司，信息产业部和原国家质量技术监督局联合实施。  </p>\n<p>GB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。  </p>\n<p>编码方法：<br>GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。   </p>\n<p>按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。   </p>\n<p>接着是国际通用的unicode字符集    </p>\n<p>##Unicode字符集（简称为UCS）##</p>\n<p>1．名称的由来   </p>\n<p>Unicode字符集编码是（Universal Multiple-Octet Coded Character Set） 通用多八位编码字符集的简称，支持世界上超过650种语言的国际字符集。Unicode允许在同一服务器上混合使用不同语言组的不同语言。它是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。该编码于1990年开始研发，1994年正式公布，最新版本是2005年3月31日的Unicode 4.1.0。Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。  </p>\n<p>2．编码方法   </p>\n<p>Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，例如字母“A”的编码为 004116 。所以“A”的编码书写为“U+0041”。 </p>\n<p>3．UTF-8 编码<br>UTF-8是Unicode的其中一个使用方式。 UTF是 Unicode Translation Format，即把Unicode转做某种格式的意思。 </p>\n<p>UTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的Unicode能够在现存的处理单字节的系统上正确传输。 </p>\n<p>UTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。 </p>\n<p>4．UTF-16 和 UTF-32 编码<br>UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案，UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码；UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数 </p>\n<p>通过一个问题了解unicode编码   </p>\n<p><strong>问题：</strong>使用Windows记事本的“另存为”，可以在ANSI、GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows怎样识别编码方式的呢？<br>我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？    </p>\n<p><strong>答案：</strong>   </p>\n<p>ANSI字符集定义：ASCII字符集，以及由此派生并兼容的字符集，如：GB2312，正式的名称为MBCS(Multi-Byte Chactacter System，多字节字符系统)，通常也称为ANSI字符集。   </p>\n<p>##UNICODE 与 UTF8、UTF16##</p>\n<p>由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits(两个字节)来表示一个字符，共可以表示65536个字符<br>标准的 Unicode 称为UTF-16(UTF:UCS Transformation Format )。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。(Unicode字符集有多种编码形式)<br>例如”连通”两个字的Unicode标准编码UTF-16 (big endian)为：DE 8F 1A 90<br>而其UTF-8编码为：E8 BF 9E E9 80 9A   </p>\n<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：<br>检测文件头标识，提示用户选择，根据一定的规则猜测<br>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：<br>EF BB BF UTF-8<br>FE FF UTF-16/UCS-2, little endian<br>FF FE UTF-16/UCS-2, big endian<br>FF FE 00 00 UTF-32/UCS-4, little endian.<br>00 00 FE FF UTF-32/UCS-4, big-endian.    </p>\n<p>1、big endian和little endian<br>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。<br>“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。<br>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  </p>\n<p>2、字符编码、内码，顺带介绍汉字编码<br>字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。<br>GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72<em>94=6768。其中有5个空位是D7FA-D7FE。<br>GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。<br>从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。<br>有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。<br>这里还有一些细节：<br>GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。<br>在DBCS中，GB内码的存储格式始终是big endian，即高位在前。<br>GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128</em>128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。   </p>\n<p>3、Unicode、UCS和UTF(UCS Transformation Format)<br>前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。 </p>\n<p>UCS规定了怎么用多个字节表示各种文字。而怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的！常见的UTF规范包括UTF-8、UTF-7、UTF-16。  </p>\n<p>4、UTF的字节序和BOM<br>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？<br>Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：<br>在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。<br>这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。<br>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。<br>Windows就是使用BOM来标记文本文件的编码方式的。   </p>\n<p>写到这里对编码有了大致的了解了，就可以理解网上一些文章的话了，比如有一篇很流行的文章《URL编码与SQL注射》里面有一段是这么说的：   </p>\n<p>其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。呵呵，知道怎么转换的了吧。   </p>\n<p>这得从ASCII说起，扩展的ASCII字符集采用8bit255个字符显然不够用，于是各个国家纷纷制定了自己的文字编码规范，其中中文的文字编码规范叫做“GB2312-80”（就是GB2312)，它是和ASCII兼容的一种编码规范，其实就是用扩展ASCII没有真正标准化这一点，把一个中文字符用两个扩展ASCII字符来表示。文中说的的中文ASCII码实际上就是简体中文的编码2312GB！它把ASCII又扩充了一个字节，由于高位的第一位是0，所以会出现负数的形式，url编码就是将汉字的这个GB2312编码转化成UTF-8的编码并且每8位即一个字节前面加上%符号表示。   </p>\n<p>那为何UTF-8是进行网络的规范传输编码呢？   </p>\n<p>在Unicode里，所有的字符被一视同仁。汉字不再使用“两个扩展ASCII”，而是使用“1个Unicode”，注意，现在的汉字是“一个字符”了，于是，拆字、统计字数这些问题也就自然而然的解决了。但是，这个世界不是理想的，不可能在一夜之间所有的系统都使用Unicode来处理字符，所以Unicode在诞生之日，就必须考虑一个严峻的问题：和ASCII字符集之间的不兼容问题。   </p>\n<p>我们知道，ASCII字符是单个字节的，比如“A”的ASCII是65。而Unicode是双字节的，比如“A”的Unicode是0065，这就造成了一个非常大的问题：以前处理ASCII的那套机制不能被用来处理Unicode了   </p>\n<p>另一个更加严重的问题是，C语言使用’\\0’作为字符串结尾，而Unicode里恰恰有很多字符都有一个字节为0，这样一来，C语言的字符串函数将无法正常处理Unicode，除非把世界上所有用C写的程序以及他们所用的函数库全部换掉    </p>\n<p>于是，比Unicode更伟大的东东诞生了，之所以说它更伟大是因为它让Unicode不再存在于纸上，而是真实的存在于我们大家的电脑中。那就是：UTF   </p>\n<p>UTF= UCS Transformation Format UCS转换格式，它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16   </p>\n<p>其中UTF-16和上面提到的Unicode本身的编码规范是一致的，这里不多说了。而UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容，这样做的好处是压缩了字符在西欧一些国家的内存消耗，减少了不必要的资源浪费，这在实际应用中是非常有必要的。   </p>\n<p>UTF-8有点类似于Haffman编码，它将Unicode编码为：<br>00000000-0000007F的字符，用单个字节来表示； </p>\n<p>00000080-000007FF的字符用两个字节表示 （中文的编码范围）  </p>\n<p>00000800-0000FFFF的字符用3字节表示    </p>\n<p>因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。  </p>\n<p>在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的）。  </p>\n<p>看看编码之多：ANSI,AscII,GB2312,GBK,BIG5,GB18030,Unicode,UCS（就是unicode）Utf-8,utf-16,utf-32 整整10种编码～，算是够复杂了<br>可是这还仅仅是个开始，应用方面变化无穷，不过现在看到这些东西起码再不会头大了！呼呼～ </p>\n<p>哦，漏了一个加密的base64编码。  </p>\n<p>##什么是Base64？##</p>\n<p>按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） </p>\n<p><strong>为什么要使用Base64？</strong></p>\n<p>在设计这个编码的时候，我想设计人员最主要考虑了3个问题：<br>1.是否加密？<br>2.加密算法复杂程度和效率<br>3.如何处理传输？    </p>\n<p>加密是肯定的，但是加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”。即达到一眼望去完全看不出内容即可。<br>基于这个目的加密算法的复杂程度和效率也就不能太大和太低。和上一个理由类似，MIME协议等用于发送Email的协议解决的是如何收发Email，而并不是如何安全的收发Email。因此算法的复杂程度要小，效率要高，否则因为发送Email而大量占用资源，路就有点走歪了。    </p>\n<p>但是，如果是基于以上两点，那么我们使用最简单的恺撒法即可，为什么Base64看起来要比恺撒法复杂呢？这是因为在Email的传送过程中，由于历史原因，Email只被允许传送ASCII字符，即一个8位字节的低7位。因此，如果您发送了一封带有非ASCII字符（即字节的最高位是1）的Email通过有“历史问题”的网关时就可能会出现问题。网关可能会把最高位置为0！很明显，问题就这样产生了！因此，为了能够正常的传送Email，这个问题就必须考虑！所以，单单靠改变字母的位置的恺撒之类的方案也就不行了。关于这一点可以参考RFC2046。<br>基于以上的一些主要原因产生了Base64编码。   </p>\n<p>参考文档：<a href=\"http://cafardcn.iteye.com/blog/300239\" target=\"_blank\" rel=\"external\">http://cafardcn.iteye.com/blog/300239</a></p>\n","excerpt":"<p>##GB2312字符集##<br>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施，是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。<br>","more":"</p>\n<p>GB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 </p>\n<p>GB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码。 </p>\n<p>它是用双字节表示的，两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为“高字节” ，而称第二字节为“低字节”。“高位字节”使用了0xA1-0xF7(把01-87区的区号加上0xA0)，“低位字节”使用了0xA1-0xFE(把01-94加上0xA0)。 </p>\n<p>以GB2312字符集的第一个汉字“啊”字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。 </p>\n<p>##GBK字符集##<br>GBK字符集是GB2312的扩展(K)，GBK1.0收录了21886个符号，它分为汉字区和图形符号区，汉字区包括21003个字符。GBK字符集主要扩展了繁体中文字的支持。 </p>\n<p>##BIG5 字符集##</p>\n<p>BIG5又称大五码或五大码，1984年由台湾财团法人信息工业策进会和五间软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。  </p>\n<p>Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：“兀”(0xA461及0xC94A)、“嗀”(0xDCD1及0xDDFC)。  </p>\n<p>Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。  </p>\n<p>尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假字母。  </p>\n<p>例如台湾视“着”为“著”的异体字，故没有收录“着”字。康熙字典中的一些部首用字(如“亠”、“疒”、“辵”、“癶”等)、常见的人名用字(如“堃”、“煊”、“栢”、“喆”等) 也没有收录到Big5之中。  </p>\n<p>##GB18030 字符集##</p>\n<p>GB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。GB 18030字符集标准的出台经过广泛参与和论证，来自国内外知名信息技术行业的公司，信息产业部和原国家质量技术监督局联合实施。  </p>\n<p>GB 18030字符集标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇“统一汉字扩展A”的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。  </p>\n<p>编码方法：<br>GB 18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。   </p>\n<p>按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。   </p>\n<p>接着是国际通用的unicode字符集    </p>\n<p>##Unicode字符集（简称为UCS）##</p>\n<p>1．名称的由来   </p>\n<p>Unicode字符集编码是（Universal Multiple-Octet Coded Character Set） 通用多八位编码字符集的简称，支持世界上超过650种语言的国际字符集。Unicode允许在同一服务器上混合使用不同语言组的不同语言。它是由一个名为 Unicode 学术学会(Unicode Consortium)的机构制订的字符编码系统，支持现今世界各种不同语言的书面文本的交换、处理及显示。该编码于1990年开始研发，1994年正式公布，最新版本是2005年3月31日的Unicode 4.1.0。Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。  </p>\n<p>2．编码方法   </p>\n<p>Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，例如字母“A”的编码为 004116 。所以“A”的编码书写为“U+0041”。 </p>\n<p>3．UTF-8 编码<br>UTF-8是Unicode的其中一个使用方式。 UTF是 Unicode Translation Format，即把Unicode转做某种格式的意思。 </p>\n<p>UTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的Unicode能够在现存的处理单字节的系统上正确传输。 </p>\n<p>UTF-8使用可变长度字节来储存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。 </p>\n<p>4．UTF-16 和 UTF-32 编码<br>UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案，UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码；UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数 </p>\n<p>通过一个问题了解unicode编码   </p>\n<p><strong>问题：</strong>使用Windows记事本的“另存为”，可以在ANSI、GBK、Unicode、Unicode big endian和UTF-8这几种编码方式间相互转换。同样是txt文件，Windows怎样识别编码方式的呢？<br>我很早前就发现Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）。但这些标记是基于什么标准呢？    </p>\n<p><strong>答案：</strong>   </p>\n<p>ANSI字符集定义：ASCII字符集，以及由此派生并兼容的字符集，如：GB2312，正式的名称为MBCS(Multi-Byte Chactacter System，多字节字符系统)，通常也称为ANSI字符集。   </p>\n<p>##UNICODE 与 UTF8、UTF16##</p>\n<p>由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，产生了Unicode字符集，它固定使用16 bits(两个字节)来表示一个字符，共可以表示65536个字符<br>标准的 Unicode 称为UTF-16(UTF:UCS Transformation Format )。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。(Unicode字符集有多种编码形式)<br>例如”连通”两个字的Unicode标准编码UTF-16 (big endian)为：DE 8F 1A 90<br>而其UTF-8编码为：E8 BF 9E E9 80 9A   </p>\n<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：<br>检测文件头标识，提示用户选择，根据一定的规则猜测<br>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：<br>EF BB BF UTF-8<br>FE FF UTF-16/UCS-2, little endian<br>FF FE UTF-16/UCS-2, big endian<br>FF FE 00 00 UTF-32/UCS-4, little endian.<br>00 00 FE FF UTF-32/UCS-4, big-endian.    </p>\n<p>1、big endian和little endian<br>big endian和little endian是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C写在前面，还是将49写在前面？如果将6C写在前面，就是big endian。还是将49写在前面，就是little endian。<br>“endian”这个词出自《格列佛游记》。小人国的内战就源于吃鸡蛋时是究竟从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。<br>我们一般将endian翻译成“字节序”，将big endian和little endian称作“大尾”和“小尾”。  </p>\n<p>2、字符编码、内码，顺带介绍汉字编码<br>字符必须编码后才能被计算机处理。计算机使用的缺省编码方式就是计算机的内码。早期的计算机使用7位的ASCII编码，为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。<br>GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72<em>94=6768。其中有5个空位是D7FA-D7FE。<br>GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。<br>从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。按照程序员的称呼，GB2312、GBK到GB18030都属于双字节字符集 (DBCS)。<br>有的中文Windows的缺省内码还是GBK，可以通过GB18030升级包升级到GB18030。不过GB18030相对GBK增加的字符，普通人是很难用到的，通常我们还是用GBK指代中文Windows内码。<br>这里还有一些细节：<br>GB2312的原文还是区位码，从区位码到内码，需要在高字节和低字节上分别加上A0。<br>在DBCS中，GB内码的存储格式始终是big endian，即高位在前。<br>GB2312的两个字节的最高位都是1。但符合这个条件的码位只有128</em>128=16384个。所以GBK和GB18030的低字节最高位都可能不是1。不过这不影响DBCS字符流的解析：在读取DBCS字符流时，只要遇到高位为1的字节，就可以将下两个字节作为一个双字节编码，而不用管低字节的高位是什么。   </p>\n<p>3、Unicode、UCS和UTF(UCS Transformation Format)<br>前面提到从ASCII、GB2312、GBK到GB18030的编码方法是向下兼容的。而Unicode只与ASCII兼容（更准确地说，是与ISO-8859-1兼容），与GB码不兼容。例如“汉”字的Unicode编码是6C49，而GB码是BABA。 </p>\n<p>UCS规定了怎么用多个字节表示各种文字。而怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的！常见的UTF规范包括UTF-8、UTF-7、UTF-16。  </p>\n<p>4、UTF的字节序和BOM<br>UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚每个编码单元的字节序。例如收到一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？<br>Unicode规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte Order Mark。BOM是一个有点小聪明的想法：<br>在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。<br>这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。<br>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF（读者可以用我们前面介绍的编码方法验证一下）。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。<br>Windows就是使用BOM来标记文本文件的编码方式的。   </p>\n<p>写到这里对编码有了大致的了解了，就可以理解网上一些文章的话了，比如有一篇很流行的文章《URL编码与SQL注射》里面有一段是这么说的：   </p>\n<p>其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。呵呵，知道怎么转换的了吧。   </p>\n<p>这得从ASCII说起，扩展的ASCII字符集采用8bit255个字符显然不够用，于是各个国家纷纷制定了自己的文字编码规范，其中中文的文字编码规范叫做“GB2312-80”（就是GB2312)，它是和ASCII兼容的一种编码规范，其实就是用扩展ASCII没有真正标准化这一点，把一个中文字符用两个扩展ASCII字符来表示。文中说的的中文ASCII码实际上就是简体中文的编码2312GB！它把ASCII又扩充了一个字节，由于高位的第一位是0，所以会出现负数的形式，url编码就是将汉字的这个GB2312编码转化成UTF-8的编码并且每8位即一个字节前面加上%符号表示。   </p>\n<p>那为何UTF-8是进行网络的规范传输编码呢？   </p>\n<p>在Unicode里，所有的字符被一视同仁。汉字不再使用“两个扩展ASCII”，而是使用“1个Unicode”，注意，现在的汉字是“一个字符”了，于是，拆字、统计字数这些问题也就自然而然的解决了。但是，这个世界不是理想的，不可能在一夜之间所有的系统都使用Unicode来处理字符，所以Unicode在诞生之日，就必须考虑一个严峻的问题：和ASCII字符集之间的不兼容问题。   </p>\n<p>我们知道，ASCII字符是单个字节的，比如“A”的ASCII是65。而Unicode是双字节的，比如“A”的Unicode是0065，这就造成了一个非常大的问题：以前处理ASCII的那套机制不能被用来处理Unicode了   </p>\n<p>另一个更加严重的问题是，C语言使用’\\0’作为字符串结尾，而Unicode里恰恰有很多字符都有一个字节为0，这样一来，C语言的字符串函数将无法正常处理Unicode，除非把世界上所有用C写的程序以及他们所用的函数库全部换掉    </p>\n<p>于是，比Unicode更伟大的东东诞生了，之所以说它更伟大是因为它让Unicode不再存在于纸上，而是真实的存在于我们大家的电脑中。那就是：UTF   </p>\n<p>UTF= UCS Transformation Format UCS转换格式，它是将Unicode编码规则和计算机的实际编码对应起来的一个规则。现在流行的UTF有2种：UTF-8和UTF-16   </p>\n<p>其中UTF-16和上面提到的Unicode本身的编码规范是一致的，这里不多说了。而UTF-8不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容，这样做的好处是压缩了字符在西欧一些国家的内存消耗，减少了不必要的资源浪费，这在实际应用中是非常有必要的。   </p>\n<p>UTF-8有点类似于Haffman编码，它将Unicode编码为：<br>00000000-0000007F的字符，用单个字节来表示； </p>\n<p>00000080-000007FF的字符用两个字节表示 （中文的编码范围）  </p>\n<p>00000800-0000FFFF的字符用3字节表示    </p>\n<p>因为目前为止Unicode-16规范没有指定FFFF以上的字符，所以UTF-8最多是使用3个字节来表示一个字符。但理论上来说，UTF-8最多需要用6字节表示一个字符。  </p>\n<p>在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的）。  </p>\n<p>看看编码之多：ANSI,AscII,GB2312,GBK,BIG5,GB18030,Unicode,UCS（就是unicode）Utf-8,utf-16,utf-32 整整10种编码～，算是够复杂了<br>可是这还仅仅是个开始，应用方面变化无穷，不过现在看到这些东西起码再不会头大了！呼呼～ </p>\n<p>哦，漏了一个加密的base64编码。  </p>\n<p>##什么是Base64？##</p>\n<p>按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） </p>\n<p><strong>为什么要使用Base64？</strong></p>\n<p>在设计这个编码的时候，我想设计人员最主要考虑了3个问题：<br>1.是否加密？<br>2.加密算法复杂程度和效率<br>3.如何处理传输？    </p>\n<p>加密是肯定的，但是加密的目的不是让用户发送非常安全的Email。这种加密方式主要就是“防君子不防小人”。即达到一眼望去完全看不出内容即可。<br>基于这个目的加密算法的复杂程度和效率也就不能太大和太低。和上一个理由类似，MIME协议等用于发送Email的协议解决的是如何收发Email，而并不是如何安全的收发Email。因此算法的复杂程度要小，效率要高，否则因为发送Email而大量占用资源，路就有点走歪了。    </p>\n<p>但是，如果是基于以上两点，那么我们使用最简单的恺撒法即可，为什么Base64看起来要比恺撒法复杂呢？这是因为在Email的传送过程中，由于历史原因，Email只被允许传送ASCII字符，即一个8位字节的低7位。因此，如果您发送了一封带有非ASCII字符（即字节的最高位是1）的Email通过有“历史问题”的网关时就可能会出现问题。网关可能会把最高位置为0！很明显，问题就这样产生了！因此，为了能够正常的传送Email，这个问题就必须考虑！所以，单单靠改变字母的位置的恺撒之类的方案也就不行了。关于这一点可以参考RFC2046。<br>基于以上的一些主要原因产生了Base64编码。   </p>\n<p>参考文档：<a href=\"http://cafardcn.iteye.com/blog/300239\">http://cafardcn.iteye.com/blog/300239</a></p>"},{"layout":"post","title":"设计模式：适配器（Adapter）in Java","date":"2012-10-30T13:24:00.000Z","comments":1,"_content":"**类适配器**:客户的开发人员定义了一个接口，期望用这个接口来完成整数的求和操作，接口定义如下：     \nJava代码    \n\n\tpublic interface Operation{  \n      \tpublic int add(int a,int b);  \n\t}  \n\n开发人员在了解这个接口的定义后，发现一个第三方类，里面有一个方法能实现他们期望的功能，其代码如下：    \nJava代码    \n\n\tpublic class OtherOperation{  \n      \tpublic int otherAdd(int a,int b){  \n           \treturn a + b;  \n      \t}  \n\t}  \n<!--more-->\n以上第三方类OtherOperation的方法public int otherAdd(int a,int b)所提供的功能，完全能符合客户的期望，所以只需要想办法把OtherOperation的otherAdd(int a,int b)和客户的Operation接口联系起来，让这个第三方类来为客户提供他们期望的服务就行了，这样就避免了开发人员再度去研究类似OtherOperation的otherAdd(int a,int b)方法的实现（利用已有的轮子，避免重复发明），这方法之一，就是用适配器模式：   \nJava代码  \n\n\tpublic class AdapterOperation extends OtherOperation implements Operation{  \n      \tpublic int add(int a,int b){  \n           return otherAdd(a,b);  \n     \t }  \n\t}  \n\n以上就是适配器的实现方法之一，**类适配器**，在以上实现中存在着三中角色分别是：    \n1：适配目标角色：Operation。  \n2：适配类（原）角色：OtherOperation。  \n3：适配器角色：AdapterOperation。  \n其中适配器角色是适配器模式的核心。 \n适配器的主要工作就是通过封装现有的功能，使他满足需要的接口。 \n\n**对象适配器**  \n我们再来看看另一种情况： \n假如客户接口期望的功能不止一个，而是多个：   \nJava代码   \n\n\tpublic interface Operation{  \n      \tpublic int add(int a,int b);  \n      \tpublic int minus(int a,int b);  \n      \tpublic int multiplied(int a,int b);  \n\t}  \n\n而能提供这些实现的原可能不止一个：   \nJava代码   \n\n\tpublic class OtherAdd{  \n      \tpublic int otherAdd(int a,int b){  \n          \t return a + b;  \n      \t}  \n\t}  \n  \n\tpublic class OtherMinus{  \n      \tpublic int minus(int a,int b){  \n           return a - b;  \n      \t}  \n\t}  \n  \n\tpublic class OtherMultiplied{  \n      \tpublic int multiplied(int a,int b){  \n           return a * b;  \n      \t}  \n\t}  \n\n由于java是不能实现多继承的，所以我们不能通过构建一个适配器，让他来继承所有原以完成我们的期望，这时候怎么办呢?只能用适配器的另一种实现--对象适配器：  \nJava代码   \n\n\tpublic class AdapterOperation implements Operation{  \n      \tprivate OtherAdd add;  \n      \tprivate OtherMinus minus;  \n      \tprivate OtherMultiplied multiplied;  \n  \n      \tpublic void setAdd(OtherAdd add){  \n            this.add = add;  \n      \t}  \n  \n      \tpublic void setMinus(OtherMinus minus){  \n            this.minus = minus;  \n      \t}  \n  \n      \tpublic void setMultiplied(OtherMultiplied multiplied){  \n            this.multiplied = multiplied;  \n      \t}  \n  \n      \t//适配加法运算  \n      \tpublic int add(int a,int b){  \n           return add.otherAdd(a,b);  \n      \t}  \n  \n      \t//适配减法运算  \n      \tpublic int minus(int a,int b){  \n          return minus.minus(a,b);  \n      \t}  \n  \n      \t//适配乘法运算  \n     \tpublic int multiplied(int a,int b){  \n         return multiplied.multiplied(a,b);  \n      \t}  \n\t}  \n\n上面代码很明显，适配器并不是通过继承来获取适配类（原）的功能的，而是通过适配类的对象来获取的，这就解决了java不能多继承所带来的不便了。这也是java提倡的编程思想之一，即尽量使用聚合不要使用继承。  \n还有一种情况是需要使用对象适配器的。我们来看看， \n单我们的客户提供的需求并不是一个明确的接口，而是一个类，并没有定义期望的方法，如下   \nJava代码   \n \n\tpublic class A{  \n   \t\tpublic int add(int a,int b){  \n      \t\treturn a + b;  \n   \t\t}  \n\t}  \n\n现在客户要一个新类B，要求能在保留类A功能的情况下增加一个运算减法的功能，并要求B能随时替换掉A但不能对已有系统造成影响。这样我们只能新建一个类B，并让B继承A。 \t\nJava代码  \n\n\tpublic class B extends A{  \n    \tB(){  \n      \t\tsuper();  \n    \t\t}  \n  \n    \tpublic int minus(int a,int b){  \n           //待实现的减法运算函数..  \n    \t}  \n\t}  \n\n这时候，我们发现类C已经提供了实现减法的函数，\t\t \nJava代码   \n  \n\tpublic class C{  \n    \tpublic int minus(int a,int b){  \n           return a - b;  \n    \t}  \n\t}  \n\n为了避免重复去设计该函数，我们决定引入C类，通过适配C类来达到我们的期望，但问题是A和C都是一个具体类，我们无法让B同时继承这个两个类，而B继承A又是必须的，所以我们只能考虑把C给内聚到B内部，对象适配器又得派上用场了。  \nJava代码  \t\n\n\tpublic class B extends A{  \n    \tprivate C c;  \n  \n    \tB(){  \n      \t\tsuper();  \n    \t\t}  \n  \n   \t\tpublic void setMinus(C c){  \n         \tthis.c= c;  \n    \t}  \n  \n    \tpublic int minus(int a,int b){  \n           return c.minus(a,b);  \n    \t}  \n\t}  \n这样，在需要A类的地方都能用B类来代替，同时又保证了新的功能的引入。 \t\n\n更灵活的实现--**隐藏目标接口的抽象适配器**\n\n做java 桌面应用的都知道WindowListener接口，   \nJava代码  \n\n\tpublic interface WindowListener extends EventListener{  \n\t\t public void windowActivated(WindowEvent e)；  \n\t\t public void windowClosed(WindowEvent e)；  \n\t\t public void windowClosing(WindowEvent e)；  \n\t\t public void windowDeactivated(WindowEvent e)；  \n\t\t public void windowDeiconified(WindowEvent e)；  \n\t\t public void windowIconified(WindowEvent e)；  \n\t\t public void windowOpened(WindowEvent e)；  \n\t}  \n要实现这个接口，我们就必须实现它所定义的所有方法，但是实际上，我们很少需要同时用到所有的方法，我们要的只是其中的两三个。为了不使我们实现多余的方法，\t\t \njdk WindowListener提供了一个WindowListener的默认实现类WindowAdapter类，这是一个抽象类，   \nJava代码\t\t\n  \n\tpublic abstract class WindowAdapter implements WindowListener{  \n \t\tpublic void windowActivated(WindowEvent e){}  \n \t\tpublic void windowClosed(WindowEvent e){}  \n \t\tpublic void windowClosing(WindowEvent e){}  \n \t\tpublic void windowDeactivated(WindowEvent e){}  \n\t\tpublic void windowDeiconified(WindowEvent e){}  \n \t\tpublic void windowIconified(WindowEvent e){}  \n \t\tpublic void windowOpened(WindowEvent e){}  \n\t}  \n\nWindowAdapter类对WindowListener接口的所有有方法都提供了空实现， \n有了WindowAdapter类，我们只需要去继承WindowAdapter，然后选择我们所关心的方法来实现就行了，这样就避免了直接去实现WindowListener接口。   \n\n参考文献：<http://chjl2020.iteye.com/blog/262370>","source":"_posts/2012-10-30-adapter-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：适配器（Adapter）in Java\"\ndate: 2012-10-30 21:24\ncomments: true\ncategories: 设计模式\ntags: [ 设计模式, Java, Adapter ]\n---\n**类适配器**:客户的开发人员定义了一个接口，期望用这个接口来完成整数的求和操作，接口定义如下：     \nJava代码    \n\n\tpublic interface Operation{  \n      \tpublic int add(int a,int b);  \n\t}  \n\n开发人员在了解这个接口的定义后，发现一个第三方类，里面有一个方法能实现他们期望的功能，其代码如下：    \nJava代码    \n\n\tpublic class OtherOperation{  \n      \tpublic int otherAdd(int a,int b){  \n           \treturn a + b;  \n      \t}  \n\t}  \n<!--more-->\n以上第三方类OtherOperation的方法public int otherAdd(int a,int b)所提供的功能，完全能符合客户的期望，所以只需要想办法把OtherOperation的otherAdd(int a,int b)和客户的Operation接口联系起来，让这个第三方类来为客户提供他们期望的服务就行了，这样就避免了开发人员再度去研究类似OtherOperation的otherAdd(int a,int b)方法的实现（利用已有的轮子，避免重复发明），这方法之一，就是用适配器模式：   \nJava代码  \n\n\tpublic class AdapterOperation extends OtherOperation implements Operation{  \n      \tpublic int add(int a,int b){  \n           return otherAdd(a,b);  \n     \t }  \n\t}  \n\n以上就是适配器的实现方法之一，**类适配器**，在以上实现中存在着三中角色分别是：    \n1：适配目标角色：Operation。  \n2：适配类（原）角色：OtherOperation。  \n3：适配器角色：AdapterOperation。  \n其中适配器角色是适配器模式的核心。 \n适配器的主要工作就是通过封装现有的功能，使他满足需要的接口。 \n\n**对象适配器**  \n我们再来看看另一种情况： \n假如客户接口期望的功能不止一个，而是多个：   \nJava代码   \n\n\tpublic interface Operation{  \n      \tpublic int add(int a,int b);  \n      \tpublic int minus(int a,int b);  \n      \tpublic int multiplied(int a,int b);  \n\t}  \n\n而能提供这些实现的原可能不止一个：   \nJava代码   \n\n\tpublic class OtherAdd{  \n      \tpublic int otherAdd(int a,int b){  \n          \t return a + b;  \n      \t}  \n\t}  \n  \n\tpublic class OtherMinus{  \n      \tpublic int minus(int a,int b){  \n           return a - b;  \n      \t}  \n\t}  \n  \n\tpublic class OtherMultiplied{  \n      \tpublic int multiplied(int a,int b){  \n           return a * b;  \n      \t}  \n\t}  \n\n由于java是不能实现多继承的，所以我们不能通过构建一个适配器，让他来继承所有原以完成我们的期望，这时候怎么办呢?只能用适配器的另一种实现--对象适配器：  \nJava代码   \n\n\tpublic class AdapterOperation implements Operation{  \n      \tprivate OtherAdd add;  \n      \tprivate OtherMinus minus;  \n      \tprivate OtherMultiplied multiplied;  \n  \n      \tpublic void setAdd(OtherAdd add){  \n            this.add = add;  \n      \t}  \n  \n      \tpublic void setMinus(OtherMinus minus){  \n            this.minus = minus;  \n      \t}  \n  \n      \tpublic void setMultiplied(OtherMultiplied multiplied){  \n            this.multiplied = multiplied;  \n      \t}  \n  \n      \t//适配加法运算  \n      \tpublic int add(int a,int b){  \n           return add.otherAdd(a,b);  \n      \t}  \n  \n      \t//适配减法运算  \n      \tpublic int minus(int a,int b){  \n          return minus.minus(a,b);  \n      \t}  \n  \n      \t//适配乘法运算  \n     \tpublic int multiplied(int a,int b){  \n         return multiplied.multiplied(a,b);  \n      \t}  \n\t}  \n\n上面代码很明显，适配器并不是通过继承来获取适配类（原）的功能的，而是通过适配类的对象来获取的，这就解决了java不能多继承所带来的不便了。这也是java提倡的编程思想之一，即尽量使用聚合不要使用继承。  \n还有一种情况是需要使用对象适配器的。我们来看看， \n单我们的客户提供的需求并不是一个明确的接口，而是一个类，并没有定义期望的方法，如下   \nJava代码   \n \n\tpublic class A{  \n   \t\tpublic int add(int a,int b){  \n      \t\treturn a + b;  \n   \t\t}  \n\t}  \n\n现在客户要一个新类B，要求能在保留类A功能的情况下增加一个运算减法的功能，并要求B能随时替换掉A但不能对已有系统造成影响。这样我们只能新建一个类B，并让B继承A。 \t\nJava代码  \n\n\tpublic class B extends A{  \n    \tB(){  \n      \t\tsuper();  \n    \t\t}  \n  \n    \tpublic int minus(int a,int b){  \n           //待实现的减法运算函数..  \n    \t}  \n\t}  \n\n这时候，我们发现类C已经提供了实现减法的函数，\t\t \nJava代码   \n  \n\tpublic class C{  \n    \tpublic int minus(int a,int b){  \n           return a - b;  \n    \t}  \n\t}  \n\n为了避免重复去设计该函数，我们决定引入C类，通过适配C类来达到我们的期望，但问题是A和C都是一个具体类，我们无法让B同时继承这个两个类，而B继承A又是必须的，所以我们只能考虑把C给内聚到B内部，对象适配器又得派上用场了。  \nJava代码  \t\n\n\tpublic class B extends A{  \n    \tprivate C c;  \n  \n    \tB(){  \n      \t\tsuper();  \n    \t\t}  \n  \n   \t\tpublic void setMinus(C c){  \n         \tthis.c= c;  \n    \t}  \n  \n    \tpublic int minus(int a,int b){  \n           return c.minus(a,b);  \n    \t}  \n\t}  \n这样，在需要A类的地方都能用B类来代替，同时又保证了新的功能的引入。 \t\n\n更灵活的实现--**隐藏目标接口的抽象适配器**\n\n做java 桌面应用的都知道WindowListener接口，   \nJava代码  \n\n\tpublic interface WindowListener extends EventListener{  \n\t\t public void windowActivated(WindowEvent e)；  \n\t\t public void windowClosed(WindowEvent e)；  \n\t\t public void windowClosing(WindowEvent e)；  \n\t\t public void windowDeactivated(WindowEvent e)；  \n\t\t public void windowDeiconified(WindowEvent e)；  \n\t\t public void windowIconified(WindowEvent e)；  \n\t\t public void windowOpened(WindowEvent e)；  \n\t}  \n要实现这个接口，我们就必须实现它所定义的所有方法，但是实际上，我们很少需要同时用到所有的方法，我们要的只是其中的两三个。为了不使我们实现多余的方法，\t\t \njdk WindowListener提供了一个WindowListener的默认实现类WindowAdapter类，这是一个抽象类，   \nJava代码\t\t\n  \n\tpublic abstract class WindowAdapter implements WindowListener{  \n \t\tpublic void windowActivated(WindowEvent e){}  \n \t\tpublic void windowClosed(WindowEvent e){}  \n \t\tpublic void windowClosing(WindowEvent e){}  \n \t\tpublic void windowDeactivated(WindowEvent e){}  \n\t\tpublic void windowDeiconified(WindowEvent e){}  \n \t\tpublic void windowIconified(WindowEvent e){}  \n \t\tpublic void windowOpened(WindowEvent e){}  \n\t}  \n\nWindowAdapter类对WindowListener接口的所有有方法都提供了空实现， \n有了WindowAdapter类，我们只需要去继承WindowAdapter，然后选择我们所关心的方法来实现就行了，这样就避免了直接去实现WindowListener接口。   \n\n参考文献：<http://chjl2020.iteye.com/blog/262370>","slug":"2012-10-30-adapter-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2n001tv8fyxq99sjme","content":"<p><strong>类适配器</strong>:客户的开发人员定义了一个接口，期望用这个接口来完成整数的求和操作，接口定义如下：<br>Java代码    </p>\n<pre><code>public interface Operation{  \n      public int add(int a,int b);  \n}  \n</code></pre><p>开发人员在了解这个接口的定义后，发现一个第三方类，里面有一个方法能实现他们期望的功能，其代码如下：<br>Java代码    </p>\n<pre><code>public class OtherOperation{  \n      public int otherAdd(int a,int b){  \n           return a + b;  \n      }  \n}  \n</code></pre><a id=\"more\"></a>\n<p>以上第三方类OtherOperation的方法public int otherAdd(int a,int b)所提供的功能，完全能符合客户的期望，所以只需要想办法把OtherOperation的otherAdd(int a,int b)和客户的Operation接口联系起来，让这个第三方类来为客户提供他们期望的服务就行了，这样就避免了开发人员再度去研究类似OtherOperation的otherAdd(int a,int b)方法的实现（利用已有的轮子，避免重复发明），这方法之一，就是用适配器模式：<br>Java代码  </p>\n<pre><code>public class AdapterOperation extends OtherOperation implements Operation{  \n      public int add(int a,int b){  \n       return otherAdd(a,b);  \n      }  \n}  \n</code></pre><p>以上就是适配器的实现方法之一，<strong>类适配器</strong>，在以上实现中存在着三中角色分别是：<br>1：适配目标角色：Operation。<br>2：适配类（原）角色：OtherOperation。<br>3：适配器角色：AdapterOperation。<br>其中适配器角色是适配器模式的核心。<br>适配器的主要工作就是通过封装现有的功能，使他满足需要的接口。 </p>\n<p><strong>对象适配器</strong><br>我们再来看看另一种情况：<br>假如客户接口期望的功能不止一个，而是多个：<br>Java代码   </p>\n<pre><code>public interface Operation{  \n      public int add(int a,int b);  \n      public int minus(int a,int b);  \n      public int multiplied(int a,int b);  \n}  \n</code></pre><p>而能提供这些实现的原可能不止一个：<br>Java代码   </p>\n<pre><code>public class OtherAdd{  \n      public int otherAdd(int a,int b){  \n           return a + b;  \n      }  \n}  \n\npublic class OtherMinus{  \n      public int minus(int a,int b){  \n       return a - b;  \n      }  \n}  \n\npublic class OtherMultiplied{  \n      public int multiplied(int a,int b){  \n       return a * b;  \n      }  \n}  \n</code></pre><p>由于java是不能实现多继承的，所以我们不能通过构建一个适配器，让他来继承所有原以完成我们的期望，这时候怎么办呢?只能用适配器的另一种实现–对象适配器：<br>Java代码   </p>\n<pre><code>public class AdapterOperation implements Operation{  \n      private OtherAdd add;  \n      private OtherMinus minus;  \n      private OtherMultiplied multiplied;  \n\n      public void setAdd(OtherAdd add){  \n        this.add = add;  \n      }  \n\n      public void setMinus(OtherMinus minus){  \n        this.minus = minus;  \n      }  \n\n      public void setMultiplied(OtherMultiplied multiplied){  \n        this.multiplied = multiplied;  \n      }  \n\n      //适配加法运算  \n      public int add(int a,int b){  \n       return add.otherAdd(a,b);  \n      }  \n\n      //适配减法运算  \n      public int minus(int a,int b){  \n      return minus.minus(a,b);  \n      }  \n\n      //适配乘法运算  \n     public int multiplied(int a,int b){  \n     return multiplied.multiplied(a,b);  \n      }  \n}  \n</code></pre><p>上面代码很明显，适配器并不是通过继承来获取适配类（原）的功能的，而是通过适配类的对象来获取的，这就解决了java不能多继承所带来的不便了。这也是java提倡的编程思想之一，即尽量使用聚合不要使用继承。<br>还有一种情况是需要使用对象适配器的。我们来看看，<br>单我们的客户提供的需求并不是一个明确的接口，而是一个类，并没有定义期望的方法，如下<br>Java代码   </p>\n<pre><code>public class A{  \n       public int add(int a,int b){  \n          return a + b;  \n       }  \n}  \n</code></pre><p>现在客户要一个新类B，要求能在保留类A功能的情况下增加一个运算减法的功能，并要求B能随时替换掉A但不能对已有系统造成影响。这样我们只能新建一个类B，并让B继承A。<br>Java代码  </p>\n<pre><code>public class B extends A{  \n    B(){  \n          super();  \n        }  \n\n    public int minus(int a,int b){  \n       //待实现的减法运算函数..  \n    }  \n}  \n</code></pre><p>这时候，我们发现类C已经提供了实现减法的函数，<br>Java代码   </p>\n<pre><code>public class C{  \n    public int minus(int a,int b){  \n       return a - b;  \n    }  \n}  \n</code></pre><p>为了避免重复去设计该函数，我们决定引入C类，通过适配C类来达到我们的期望，但问题是A和C都是一个具体类，我们无法让B同时继承这个两个类，而B继承A又是必须的，所以我们只能考虑把C给内聚到B内部，对象适配器又得派上用场了。<br>Java代码      </p>\n<pre><code>public class B extends A{  \n    private C c;  \n\n    B(){  \n          super();  \n        }  \n\n       public void setMinus(C c){  \n         this.c= c;  \n    }  \n\n    public int minus(int a,int b){  \n       return c.minus(a,b);  \n    }  \n}  \n</code></pre><p>这样，在需要A类的地方都能用B类来代替，同时又保证了新的功能的引入。     </p>\n<p>更灵活的实现–<strong>隐藏目标接口的抽象适配器</strong></p>\n<p>做java 桌面应用的都知道WindowListener接口，<br>Java代码  </p>\n<pre><code>public interface WindowListener extends EventListener{  \n     public void windowActivated(WindowEvent e)；  \n     public void windowClosed(WindowEvent e)；  \n     public void windowClosing(WindowEvent e)；  \n     public void windowDeactivated(WindowEvent e)；  \n     public void windowDeiconified(WindowEvent e)；  \n     public void windowIconified(WindowEvent e)；  \n     public void windowOpened(WindowEvent e)；  \n}  \n</code></pre><p>要实现这个接口，我们就必须实现它所定义的所有方法，但是实际上，我们很少需要同时用到所有的方法，我们要的只是其中的两三个。为了不使我们实现多余的方法，<br>jdk WindowListener提供了一个WindowListener的默认实现类WindowAdapter类，这是一个抽象类，<br>Java代码        </p>\n<pre><code>public abstract class WindowAdapter implements WindowListener{  \n     public void windowActivated(WindowEvent e){}  \n     public void windowClosed(WindowEvent e){}  \n     public void windowClosing(WindowEvent e){}  \n     public void windowDeactivated(WindowEvent e){}  \n    public void windowDeiconified(WindowEvent e){}  \n     public void windowIconified(WindowEvent e){}  \n     public void windowOpened(WindowEvent e){}  \n}  \n</code></pre><p>WindowAdapter类对WindowListener接口的所有有方法都提供了空实现，<br>有了WindowAdapter类，我们只需要去继承WindowAdapter，然后选择我们所关心的方法来实现就行了，这样就避免了直接去实现WindowListener接口。   </p>\n<p>参考文献：<a href=\"http://chjl2020.iteye.com/blog/262370\" target=\"_blank\" rel=\"external\">http://chjl2020.iteye.com/blog/262370</a></p>\n","excerpt":"<p><strong>类适配器</strong>:客户的开发人员定义了一个接口，期望用这个接口来完成整数的求和操作，接口定义如下：<br>Java代码    </p>\n<pre><code>public interface Operation{  \n      public int add(int a,int b);  \n}  \n</code></pre><p>开发人员在了解这个接口的定义后，发现一个第三方类，里面有一个方法能实现他们期望的功能，其代码如下：<br>Java代码    </p>\n<pre><code>public class OtherOperation{  \n      public int otherAdd(int a,int b){  \n           return a + b;  \n      }  \n}  \n</code></pre>","more":"<p>以上第三方类OtherOperation的方法public int otherAdd(int a,int b)所提供的功能，完全能符合客户的期望，所以只需要想办法把OtherOperation的otherAdd(int a,int b)和客户的Operation接口联系起来，让这个第三方类来为客户提供他们期望的服务就行了，这样就避免了开发人员再度去研究类似OtherOperation的otherAdd(int a,int b)方法的实现（利用已有的轮子，避免重复发明），这方法之一，就是用适配器模式：<br>Java代码  </p>\n<pre><code>public class AdapterOperation extends OtherOperation implements Operation{  \n      public int add(int a,int b){  \n       return otherAdd(a,b);  \n      }  \n}  \n</code></pre><p>以上就是适配器的实现方法之一，<strong>类适配器</strong>，在以上实现中存在着三中角色分别是：<br>1：适配目标角色：Operation。<br>2：适配类（原）角色：OtherOperation。<br>3：适配器角色：AdapterOperation。<br>其中适配器角色是适配器模式的核心。<br>适配器的主要工作就是通过封装现有的功能，使他满足需要的接口。 </p>\n<p><strong>对象适配器</strong><br>我们再来看看另一种情况：<br>假如客户接口期望的功能不止一个，而是多个：<br>Java代码   </p>\n<pre><code>public interface Operation{  \n      public int add(int a,int b);  \n      public int minus(int a,int b);  \n      public int multiplied(int a,int b);  \n}  \n</code></pre><p>而能提供这些实现的原可能不止一个：<br>Java代码   </p>\n<pre><code>public class OtherAdd{  \n      public int otherAdd(int a,int b){  \n           return a + b;  \n      }  \n}  \n\npublic class OtherMinus{  \n      public int minus(int a,int b){  \n       return a - b;  \n      }  \n}  \n\npublic class OtherMultiplied{  \n      public int multiplied(int a,int b){  \n       return a * b;  \n      }  \n}  \n</code></pre><p>由于java是不能实现多继承的，所以我们不能通过构建一个适配器，让他来继承所有原以完成我们的期望，这时候怎么办呢?只能用适配器的另一种实现–对象适配器：<br>Java代码   </p>\n<pre><code>public class AdapterOperation implements Operation{  \n      private OtherAdd add;  \n      private OtherMinus minus;  \n      private OtherMultiplied multiplied;  \n\n      public void setAdd(OtherAdd add){  \n        this.add = add;  \n      }  \n\n      public void setMinus(OtherMinus minus){  \n        this.minus = minus;  \n      }  \n\n      public void setMultiplied(OtherMultiplied multiplied){  \n        this.multiplied = multiplied;  \n      }  \n\n      //适配加法运算  \n      public int add(int a,int b){  \n       return add.otherAdd(a,b);  \n      }  \n\n      //适配减法运算  \n      public int minus(int a,int b){  \n      return minus.minus(a,b);  \n      }  \n\n      //适配乘法运算  \n     public int multiplied(int a,int b){  \n     return multiplied.multiplied(a,b);  \n      }  \n}  \n</code></pre><p>上面代码很明显，适配器并不是通过继承来获取适配类（原）的功能的，而是通过适配类的对象来获取的，这就解决了java不能多继承所带来的不便了。这也是java提倡的编程思想之一，即尽量使用聚合不要使用继承。<br>还有一种情况是需要使用对象适配器的。我们来看看，<br>单我们的客户提供的需求并不是一个明确的接口，而是一个类，并没有定义期望的方法，如下<br>Java代码   </p>\n<pre><code>public class A{  \n       public int add(int a,int b){  \n          return a + b;  \n       }  \n}  \n</code></pre><p>现在客户要一个新类B，要求能在保留类A功能的情况下增加一个运算减法的功能，并要求B能随时替换掉A但不能对已有系统造成影响。这样我们只能新建一个类B，并让B继承A。<br>Java代码  </p>\n<pre><code>public class B extends A{  \n    B(){  \n          super();  \n        }  \n\n    public int minus(int a,int b){  \n       //待实现的减法运算函数..  \n    }  \n}  \n</code></pre><p>这时候，我们发现类C已经提供了实现减法的函数，<br>Java代码   </p>\n<pre><code>public class C{  \n    public int minus(int a,int b){  \n       return a - b;  \n    }  \n}  \n</code></pre><p>为了避免重复去设计该函数，我们决定引入C类，通过适配C类来达到我们的期望，但问题是A和C都是一个具体类，我们无法让B同时继承这个两个类，而B继承A又是必须的，所以我们只能考虑把C给内聚到B内部，对象适配器又得派上用场了。<br>Java代码      </p>\n<pre><code>public class B extends A{  \n    private C c;  \n\n    B(){  \n          super();  \n        }  \n\n       public void setMinus(C c){  \n         this.c= c;  \n    }  \n\n    public int minus(int a,int b){  \n       return c.minus(a,b);  \n    }  \n}  \n</code></pre><p>这样，在需要A类的地方都能用B类来代替，同时又保证了新的功能的引入。     </p>\n<p>更灵活的实现–<strong>隐藏目标接口的抽象适配器</strong></p>\n<p>做java 桌面应用的都知道WindowListener接口，<br>Java代码  </p>\n<pre><code>public interface WindowListener extends EventListener{  \n     public void windowActivated(WindowEvent e)；  \n     public void windowClosed(WindowEvent e)；  \n     public void windowClosing(WindowEvent e)；  \n     public void windowDeactivated(WindowEvent e)；  \n     public void windowDeiconified(WindowEvent e)；  \n     public void windowIconified(WindowEvent e)；  \n     public void windowOpened(WindowEvent e)；  \n}  \n</code></pre><p>要实现这个接口，我们就必须实现它所定义的所有方法，但是实际上，我们很少需要同时用到所有的方法，我们要的只是其中的两三个。为了不使我们实现多余的方法，<br>jdk WindowListener提供了一个WindowListener的默认实现类WindowAdapter类，这是一个抽象类，<br>Java代码        </p>\n<pre><code>public abstract class WindowAdapter implements WindowListener{  \n     public void windowActivated(WindowEvent e){}  \n     public void windowClosed(WindowEvent e){}  \n     public void windowClosing(WindowEvent e){}  \n     public void windowDeactivated(WindowEvent e){}  \n    public void windowDeiconified(WindowEvent e){}  \n     public void windowIconified(WindowEvent e){}  \n     public void windowOpened(WindowEvent e){}  \n}  \n</code></pre><p>WindowAdapter类对WindowListener接口的所有有方法都提供了空实现，<br>有了WindowAdapter类，我们只需要去继承WindowAdapter，然后选择我们所关心的方法来实现就行了，这样就避免了直接去实现WindowListener接口。   </p>\n<p>参考文献：<a href=\"http://chjl2020.iteye.com/blog/262370\">http://chjl2020.iteye.com/blog/262370</a></p>"},{"layout":"post","title":"设计模式：装饰器（Decorator）in Java","date":"2012-10-30T13:25:00.000Z","comments":1,"_content":"1.认识装饰器模式\n\n装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。 \n \n<!--more-->\n2.模式结构和说明  \n\n装饰模式的结构如下图所示。\n\nComponent：组件对象的接口，可以给这些对象动态的添加职责；\n\nConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；\n\nDecorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。\n\nConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。\n\n装饰器模式的示例代码如下(Java语言描述)：\n\n   (1)组件对象的接口，可以给这些对象动态的添加职责\n\n\tpublic abstract class Component {  \n    \tpublic abstract void operation();  \n\t}  \n(2)具体实现组件对象接口的对象\n  \n\tpublic class ConcreteComponent extends Component {  \n  \n    \tpublic void operation() {  \n        \t//相应的功能处理  \n    \t}  \n  \t}  \n \n(3)装饰器接口，维持一个指向组件对象的接口对象， 并定义一个与组件接口一致的接口\n \n\tpublic abstract class Decorator extends Component {  \n    \t/** \n     \t* 持有组件对象 \n     \t*/  \n    \tprotected Component component;  \n  \n    \t/** \n     \t* 构造方法，传入组件对象 \n     \t* @param component 组件对象 \n    \t*/  \n    \tpublic Decorator(Component component) {  \n        \tthis.component = component;  \n    \t}  \n  \n    \tpublic void operation() {  \n        \t//转发请求给组件对象，可以在转发前后执行一些附加动作  \n        \tcomponent.operation();  \n    \t}   \n\t}  \n \n\n(4)装饰器的具体实现对象，向组件对象添加职责，operationFirst()，operationLast()为前后需要添加的功能。具体的装饰器类ConcreteDecoratorB代码相似，不在给出。\n \n\tpublic class ConcreteDecoratorA extends Decorator {  \n       \tpublic ConcreteDecoratorA(Component component) {  \n            super(component);  \n   \t\t}  \n       private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  \n       private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  \n       public void operation() {  \n           //调用父类的方法，可以在调用前后执行一些附加动作  \n           operationFirst(); //添加的功能  \n           super.operation();  //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能  \n           operationLast(); //添加的功能  \n   \t\t}  \n\t}  \n(5) 客户端使用装饰器的代码\n\n\tpublic class Client{  \n   \t\tpublic static void main(String[] args){  \n    \tComponent c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  \n    \tDecorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  \n    \tdecoratorA .operation();  \n    \tDecorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  \n    \tdecoratorB .operation();  \n    \tDecorator decoratorBandA = new ConcreteDecoratorB(decoratorA);//装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  \n    \tdecoratorBandA.operation();  \n  \t\t}  \n\t}  \n \n3.小结\n\nJava中的IO是明显的装饰器模式的运用。FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以给我们提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。我们使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。\n\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); //其中file为某个具体文件的File或者FileDescription对象  \n    在以下两种情况下可以考虑使用装饰器模式：\n\n    (1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。\n\n    (2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。\n\n\n参考文档：<http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html>","source":"_posts/2012-10-30-decorator-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：装饰器（Decorator）in Java\"\ndate: 2012-10-30 21:25\ncomments: true\ncategories: 设计模式\ntags: [ Java, decorator, IO ]\n---\n1.认识装饰器模式\n\n装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。 \n \n<!--more-->\n2.模式结构和说明  \n\n装饰模式的结构如下图所示。\n\nComponent：组件对象的接口，可以给这些对象动态的添加职责；\n\nConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；\n\nDecorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。\n\nConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。\n\n装饰器模式的示例代码如下(Java语言描述)：\n\n   (1)组件对象的接口，可以给这些对象动态的添加职责\n\n\tpublic abstract class Component {  \n    \tpublic abstract void operation();  \n\t}  \n(2)具体实现组件对象接口的对象\n  \n\tpublic class ConcreteComponent extends Component {  \n  \n    \tpublic void operation() {  \n        \t//相应的功能处理  \n    \t}  \n  \t}  \n \n(3)装饰器接口，维持一个指向组件对象的接口对象， 并定义一个与组件接口一致的接口\n \n\tpublic abstract class Decorator extends Component {  \n    \t/** \n     \t* 持有组件对象 \n     \t*/  \n    \tprotected Component component;  \n  \n    \t/** \n     \t* 构造方法，传入组件对象 \n     \t* @param component 组件对象 \n    \t*/  \n    \tpublic Decorator(Component component) {  \n        \tthis.component = component;  \n    \t}  \n  \n    \tpublic void operation() {  \n        \t//转发请求给组件对象，可以在转发前后执行一些附加动作  \n        \tcomponent.operation();  \n    \t}   \n\t}  \n \n\n(4)装饰器的具体实现对象，向组件对象添加职责，operationFirst()，operationLast()为前后需要添加的功能。具体的装饰器类ConcreteDecoratorB代码相似，不在给出。\n \n\tpublic class ConcreteDecoratorA extends Decorator {  \n       \tpublic ConcreteDecoratorA(Component component) {  \n            super(component);  \n   \t\t}  \n       private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  \n       private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  \n       public void operation() {  \n           //调用父类的方法，可以在调用前后执行一些附加动作  \n           operationFirst(); //添加的功能  \n           super.operation();  //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能  \n           operationLast(); //添加的功能  \n   \t\t}  \n\t}  \n(5) 客户端使用装饰器的代码\n\n\tpublic class Client{  \n   \t\tpublic static void main(String[] args){  \n    \tComponent c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  \n    \tDecorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  \n    \tdecoratorA .operation();  \n    \tDecorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  \n    \tdecoratorB .operation();  \n    \tDecorator decoratorBandA = new ConcreteDecoratorB(decoratorA);//装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  \n    \tdecoratorBandA.operation();  \n  \t\t}  \n\t}  \n \n3.小结\n\nJava中的IO是明显的装饰器模式的运用。FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以给我们提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。我们使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。\n\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); //其中file为某个具体文件的File或者FileDescription对象  \n    在以下两种情况下可以考虑使用装饰器模式：\n\n    (1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。\n\n    (2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。\n\n\n参考文档：<http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html>","slug":"2012-10-30-decorator-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2r001wv8fyabnzsajp","content":"<p>1.认识装饰器模式</p>\n<p>装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。 </p>\n<a id=\"more\"></a>\n<p>2.模式结构和说明  </p>\n<p>装饰模式的结构如下图所示。</p>\n<p>Component：组件对象的接口，可以给这些对象动态的添加职责；</p>\n<p>ConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；</p>\n<p>Decorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。</p>\n<p>ConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。</p>\n<p>装饰器模式的示例代码如下(Java语言描述)：</p>\n<p>   (1)组件对象的接口，可以给这些对象动态的添加职责</p>\n<pre><code>public abstract class Component {  \n    public abstract void operation();  \n}  \n</code></pre><p>(2)具体实现组件对象接口的对象</p>\n<pre><code>public class ConcreteComponent extends Component {  \n\n    public void operation() {  \n        //相应的功能处理  \n    }  \n  }  \n</code></pre><p>(3)装饰器接口，维持一个指向组件对象的接口对象， 并定义一个与组件接口一致的接口</p>\n<pre><code>public abstract class Decorator extends Component {  \n    /** \n     * 持有组件对象 \n     */  \n    protected Component component;  \n\n    /** \n     * 构造方法，传入组件对象 \n     * @param component 组件对象 \n    */  \n    public Decorator(Component component) {  \n        this.component = component;  \n    }  \n\n    public void operation() {  \n        //转发请求给组件对象，可以在转发前后执行一些附加动作  \n        component.operation();  \n    }   \n}  \n</code></pre><p>(4)装饰器的具体实现对象，向组件对象添加职责，operationFirst()，operationLast()为前后需要添加的功能。具体的装饰器类ConcreteDecoratorB代码相似，不在给出。</p>\n<pre><code>public class ConcreteDecoratorA extends Decorator {  \n       public ConcreteDecoratorA(Component component) {  \n        super(component);  \n       }  \n   private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  \n   private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  \n   public void operation() {  \n       //调用父类的方法，可以在调用前后执行一些附加动作  \n       operationFirst(); //添加的功能  \n       super.operation();  //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能  \n       operationLast(); //添加的功能  \n       }  \n}  \n</code></pre><p>(5) 客户端使用装饰器的代码</p>\n<pre><code>public class Client{  \n       public static void main(String[] args){  \n    Component c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  \n    Decorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  \n    decoratorA .operation();  \n    Decorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  \n    decoratorB .operation();  \n    Decorator decoratorBandA = new ConcreteDecoratorB(decoratorA);//装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  \n    decoratorBandA.operation();  \n      }  \n}  \n</code></pre><p>3.小结</p>\n<p>Java中的IO是明显的装饰器模式的运用。FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以给我们提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。我们使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。</p>\n<p>BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); //其中file为某个具体文件的File或者FileDescription对象<br>    在以下两种情况下可以考虑使用装饰器模式：</p>\n<pre><code>(1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。\n\n(2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。\n</code></pre><p>参考文档：<a href=\"http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html</a></p>\n","excerpt":"<p>1.认识装饰器模式</p>\n<p>装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。 </p>","more":"<p>2.模式结构和说明  </p>\n<p>装饰模式的结构如下图所示。</p>\n<p>Component：组件对象的接口，可以给这些对象动态的添加职责；</p>\n<p>ConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；</p>\n<p>Decorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。</p>\n<p>ConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。</p>\n<p>装饰器模式的示例代码如下(Java语言描述)：</p>\n<p>   (1)组件对象的接口，可以给这些对象动态的添加职责</p>\n<pre><code>public abstract class Component {  \n    public abstract void operation();  \n}  \n</code></pre><p>(2)具体实现组件对象接口的对象</p>\n<pre><code>public class ConcreteComponent extends Component {  \n\n    public void operation() {  \n        //相应的功能处理  \n    }  \n  }  \n</code></pre><p>(3)装饰器接口，维持一个指向组件对象的接口对象， 并定义一个与组件接口一致的接口</p>\n<pre><code>public abstract class Decorator extends Component {  \n    /** \n     * 持有组件对象 \n     */  \n    protected Component component;  \n\n    /** \n     * 构造方法，传入组件对象 \n     * @param component 组件对象 \n    */  \n    public Decorator(Component component) {  \n        this.component = component;  \n    }  \n\n    public void operation() {  \n        //转发请求给组件对象，可以在转发前后执行一些附加动作  \n        component.operation();  \n    }   \n}  \n</code></pre><p>(4)装饰器的具体实现对象，向组件对象添加职责，operationFirst()，operationLast()为前后需要添加的功能。具体的装饰器类ConcreteDecoratorB代码相似，不在给出。</p>\n<pre><code>public class ConcreteDecoratorA extends Decorator {  \n       public ConcreteDecoratorA(Component component) {  \n        super(component);  \n       }  \n   private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  \n   private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  \n   public void operation() {  \n       //调用父类的方法，可以在调用前后执行一些附加动作  \n       operationFirst(); //添加的功能  \n       super.operation();  //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能  \n       operationLast(); //添加的功能  \n       }  \n}  \n</code></pre><p>(5) 客户端使用装饰器的代码</p>\n<pre><code>public class Client{  \n       public static void main(String[] args){  \n    Component c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  \n    Decorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  \n    decoratorA .operation();  \n    Decorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  \n    decoratorB .operation();  \n    Decorator decoratorBandA = new ConcreteDecoratorB(decoratorA);//装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  \n    decoratorBandA.operation();  \n      }  \n}  \n</code></pre><p>3.小结</p>\n<p>Java中的IO是明显的装饰器模式的运用。FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以给我们提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。我们使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。</p>\n<p>BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); //其中file为某个具体文件的File或者FileDescription对象<br>    在以下两种情况下可以考虑使用装饰器模式：</p>\n<pre><code>(1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。\n\n(2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。\n</code></pre><p>参考文档：<a href=\"http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html\">http://www.cnblogs.com/chenying99/archive/2012/10/05/2712524.html</a></p>"},{"layout":"post","title":"云南之行","date":"2012-10-30T09:47:00.000Z","comments":1,"_content":"\n##拉市海##\n我是有多胖，真得减肥了！    \n\n![](/images/blog/psb.jpg)\n\n\n---","source":"_posts/2012-10-30-travel-in-yunnan.markdown","raw":"---\nlayout: post\ntitle: \"云南之行\"\ndate: 2012-10-30 17:47\ncomments: true\ncategories: 个人\ntags: [ 云南, 旅游 ]\n---\n\n##拉市海##\n我是有多胖，真得减肥了！    \n\n![](/images/blog/psb.jpg)\n\n\n---","slug":"2012-10-30-travel-in-yunnan","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2s001xv8fyxd3gnqsx","content":"<p>##拉市海##<br>我是有多胖，真得减肥了！    </p>\n<p><img src=\"/images/blog/psb.jpg\" alt=\"\"></p>\n<hr>\n","excerpt":"","more":"<p>##拉市海##<br>我是有多胖，真得减肥了！    </p>\n<p><img src=\"/images/blog/psb.jpg\" alt=\"\"></p>\n<hr>\n"},{"layout":"post","title":"设计模式：桥接(bridge) in java","date":"2012-11-02T12:06:00.000Z","comments":1,"_content":"**定义：**Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。     \n\n###为什么要使用桥接模式？    \n场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。    \n我们可能很快就会想到这样的方案：    \n\n![方案1](/images/blog/bridge-pattern-1.png)        \n按照上面的说法，我们可能要新建4*3=12个类来完成。   \n但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。   \n<!--more-->\n那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。  \n \n![方案2](/images/blog/bridge-pattern-2.png)\n\n###桥接模式的角色和职责  \n\n- Client   \n    Bridge模式的使用者\n- Abstraction   \n   它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。   \n- Refined Abstraction    \n    修正抽象化角色。它引用实现化角色对抽象化角色进行修正。   \n- Implementor    \n    实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。   \n- ConcreteImplementor    \n    它实现接口或者抽象类定义的方法和属性。     \n    \n###使用Bridge模式来实现绘图场景\nAbstraction：    \n\n    public abstract class Shape {\n    \n        protected   Color color;\n        public Shape(){\n            this.color = new BlackColor();\n        }\n        public Shape(Color color){\n            this.color = color;\n        }\n    \n        public void setColor(Color color) {\n            this.color = color;\n        }\n        public abstract void draw();\n    \n    }\nRefined Abstraction：   \n\n    //圆形\n    public class CircleShape extends Shape{\n    \n        public CircleShape(){\n            super();\n        }\n        public CircleShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个圆形\");\n            color.draw();\n        }\n    }\n    //椭圆形\n    public class EllipseShape extends Shape {\n    \n        public EllipseShape(){\n            super();\n        }\n        public EllipseShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个椭圆形\");\n            color.draw();\n        }\n    }\n    //矩形\n    public class RectangleShape extends Shape {\n    \n        public  RectangleShape(){\n            super();\n        }\n        public  RectangleShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个矩形\");\n            color.draw();\n        }\n    }\n    \nImplementor：   \n\n    public interface Color {\n    \n        public void draw();\n    \n    }\nConcreteImplementor：   \n \n    public class WhiteColor implements Color {\n        @Override\n        public void draw() {\n            System.out.println(\"颜色是白色的\");\n        }\n    }  \n    \n    public class GrayColor implements Color {\n    \n        @Override\n        public void draw() {\n            System.out.println(\"颜色是灰色的\");\n        }\n    }\n    \n    public class BlackColor implements Color {\n    \n        @Override\n        public void draw() {\n            System.out.println(\"颜色是黑色的\");\n        }\n    } \n    \n上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。     \n\n    public class Client {\n    \n        public static void main(String[] args) {\n            Color whiteColor = new WhiteColor();\n            Color grayColor = new GrayColor();\n            Color blackColor = new BlackColor();\n    \n            Shape circleShape = new CircleShape();\n            Shape ellipseShape = new EllipseShape();\n            Shape rectangleShape = new RectangleShape();\n    \n            //画一个黑色的圆形\n            circleShape.setColor(blackColor);\n            circleShape.draw();\n    \n            //画一个白色的椭圆\n            ellipseShape.setColor(whiteColor);\n            ellipseShape.draw();\n    \n            //画一个灰色的矩形\n            rectangleShape.setColor(grayColor);\n            rectangleShape.draw();\n        }\n    }\n这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。    \n","source":"_posts/2012-11-02-bridge-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：桥接(bridge) in java\"\ndate: 2012-11-02 20:06\ncomments: true\ncategories: 设计模式\ntags: [ bridge, pattern ]\n---\n**定义：**Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。     \n\n###为什么要使用桥接模式？    \n场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。    \n我们可能很快就会想到这样的方案：    \n\n![方案1](/images/blog/bridge-pattern-1.png)        \n按照上面的说法，我们可能要新建4*3=12个类来完成。   \n但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。   \n<!--more-->\n那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。  \n \n![方案2](/images/blog/bridge-pattern-2.png)\n\n###桥接模式的角色和职责  \n\n- Client   \n    Bridge模式的使用者\n- Abstraction   \n   它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。   \n- Refined Abstraction    \n    修正抽象化角色。它引用实现化角色对抽象化角色进行修正。   \n- Implementor    \n    实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。   \n- ConcreteImplementor    \n    它实现接口或者抽象类定义的方法和属性。     \n    \n###使用Bridge模式来实现绘图场景\nAbstraction：    \n\n    public abstract class Shape {\n    \n        protected   Color color;\n        public Shape(){\n            this.color = new BlackColor();\n        }\n        public Shape(Color color){\n            this.color = color;\n        }\n    \n        public void setColor(Color color) {\n            this.color = color;\n        }\n        public abstract void draw();\n    \n    }\nRefined Abstraction：   \n\n    //圆形\n    public class CircleShape extends Shape{\n    \n        public CircleShape(){\n            super();\n        }\n        public CircleShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个圆形\");\n            color.draw();\n        }\n    }\n    //椭圆形\n    public class EllipseShape extends Shape {\n    \n        public EllipseShape(){\n            super();\n        }\n        public EllipseShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个椭圆形\");\n            color.draw();\n        }\n    }\n    //矩形\n    public class RectangleShape extends Shape {\n    \n        public  RectangleShape(){\n            super();\n        }\n        public  RectangleShape(Color color){\n            super(color);\n        }\n    \n        @Override\n        public void draw() {\n            System.out.println(\"画一个矩形\");\n            color.draw();\n        }\n    }\n    \nImplementor：   \n\n    public interface Color {\n    \n        public void draw();\n    \n    }\nConcreteImplementor：   \n \n    public class WhiteColor implements Color {\n        @Override\n        public void draw() {\n            System.out.println(\"颜色是白色的\");\n        }\n    }  \n    \n    public class GrayColor implements Color {\n    \n        @Override\n        public void draw() {\n            System.out.println(\"颜色是灰色的\");\n        }\n    }\n    \n    public class BlackColor implements Color {\n    \n        @Override\n        public void draw() {\n            System.out.println(\"颜色是黑色的\");\n        }\n    } \n    \n上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。     \n\n    public class Client {\n    \n        public static void main(String[] args) {\n            Color whiteColor = new WhiteColor();\n            Color grayColor = new GrayColor();\n            Color blackColor = new BlackColor();\n    \n            Shape circleShape = new CircleShape();\n            Shape ellipseShape = new EllipseShape();\n            Shape rectangleShape = new RectangleShape();\n    \n            //画一个黑色的圆形\n            circleShape.setColor(blackColor);\n            circleShape.draw();\n    \n            //画一个白色的椭圆\n            ellipseShape.setColor(whiteColor);\n            ellipseShape.draw();\n    \n            //画一个灰色的矩形\n            rectangleShape.setColor(grayColor);\n            rectangleShape.draw();\n        }\n    }\n这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。    \n","slug":"2012-11-02-bridge-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2u0020v8fyrizacemk","content":"<p><strong>定义：</strong>Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。     </p>\n<p>###为什么要使用桥接模式？<br>场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。<br>我们可能很快就会想到这样的方案：    </p>\n<p><img src=\"/images/blog/bridge-pattern-1.png\" alt=\"方案1\"><br>按照上面的说法，我们可能要新建4*3=12个类来完成。<br>但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。<br><a id=\"more\"></a><br>那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。  </p>\n<p><img src=\"/images/blog/bridge-pattern-2.png\" alt=\"方案2\"></p>\n<p>###桥接模式的角色和职责  </p>\n<ul>\n<li>Client<br>  Bridge模式的使用者</li>\n<li>Abstraction<br> 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。   </li>\n<li>Refined Abstraction<br>  修正抽象化角色。它引用实现化角色对抽象化角色进行修正。   </li>\n<li>Implementor<br>  实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。   </li>\n<li>ConcreteImplementor<br>  它实现接口或者抽象类定义的方法和属性。     </li>\n</ul>\n<p>###使用Bridge模式来实现绘图场景<br>Abstraction：    </p>\n<pre><code>public abstract class Shape {\n\n    protected   Color color;\n    public Shape(){\n        this.color = new BlackColor();\n    }\n    public Shape(Color color){\n        this.color = color;\n    }\n\n    public void setColor(Color color) {\n        this.color = color;\n    }\n    public abstract void draw();\n\n}\n</code></pre><p>Refined Abstraction：   </p>\n<pre><code>//圆形\npublic class CircleShape extends Shape{\n\n    public CircleShape(){\n        super();\n    }\n    public CircleShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个圆形&quot;);\n        color.draw();\n    }\n}\n//椭圆形\npublic class EllipseShape extends Shape {\n\n    public EllipseShape(){\n        super();\n    }\n    public EllipseShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个椭圆形&quot;);\n        color.draw();\n    }\n}\n//矩形\npublic class RectangleShape extends Shape {\n\n    public  RectangleShape(){\n        super();\n    }\n    public  RectangleShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个矩形&quot;);\n        color.draw();\n    }\n}\n</code></pre><p>Implementor：   </p>\n<pre><code>public interface Color {\n\n    public void draw();\n\n}\n</code></pre><p>ConcreteImplementor：   </p>\n<pre><code>public class WhiteColor implements Color {\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是白色的&quot;);\n    }\n}  \n\npublic class GrayColor implements Color {\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是灰色的&quot;);\n    }\n}\n\npublic class BlackColor implements Color {\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是黑色的&quot;);\n    }\n} \n</code></pre><p>上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。     </p>\n<pre><code>public class Client {\n\n    public static void main(String[] args) {\n        Color whiteColor = new WhiteColor();\n        Color grayColor = new GrayColor();\n        Color blackColor = new BlackColor();\n\n        Shape circleShape = new CircleShape();\n        Shape ellipseShape = new EllipseShape();\n        Shape rectangleShape = new RectangleShape();\n\n        //画一个黑色的圆形\n        circleShape.setColor(blackColor);\n        circleShape.draw();\n\n        //画一个白色的椭圆\n        ellipseShape.setColor(whiteColor);\n        ellipseShape.draw();\n\n        //画一个灰色的矩形\n        rectangleShape.setColor(grayColor);\n        rectangleShape.draw();\n    }\n}\n</code></pre><p>这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。    </p>\n","excerpt":"<p><strong>定义：</strong>Bridge 模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。     </p>\n<p>###为什么要使用桥接模式？<br>场景：我们想绘制矩形、圆形、椭圆形、正方形，我们至少需要4个形状类。但是如果又需要绘制的图形是不同颜色的，比如白色、灰色、蓝色的。<br>我们可能很快就会想到这样的方案：    </p>\n<p><img src=\"/images/blog/bridge-pattern-1.png\" alt=\"方案1\"><br>按照上面的说法，我们可能要新建4*3=12个类来完成。<br>但是如果需要画更多的图形，并有更多的颜色呢。如此扩展下去很可能出现类爆炸。<br>","more":"<br>那如何解决呢？使用Bridge来组合这些方案吧。这种方案只需要4+3个类就搞定了。  </p>\n<p><img src=\"/images/blog/bridge-pattern-2.png\" alt=\"方案2\"></p>\n<p>###桥接模式的角色和职责  </p>\n<ul>\n<li>Client<br>  Bridge模式的使用者</li>\n<li>Abstraction<br> 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。   </li>\n<li>Refined Abstraction<br>  修正抽象化角色。它引用实现化角色对抽象化角色进行修正。   </li>\n<li>Implementor<br>  实现化角色。它是接口或者抽象类，定义角色必须的行为和属性。   </li>\n<li>ConcreteImplementor<br>  它实现接口或者抽象类定义的方法和属性。     </li>\n</ul>\n<p>###使用Bridge模式来实现绘图场景<br>Abstraction：    </p>\n<pre><code>public abstract class Shape {\n\n    protected   Color color;\n    public Shape(){\n        this.color = new BlackColor();\n    }\n    public Shape(Color color){\n        this.color = color;\n    }\n\n    public void setColor(Color color) {\n        this.color = color;\n    }\n    public abstract void draw();\n\n}\n</code></pre><p>Refined Abstraction：   </p>\n<pre><code>//圆形\npublic class CircleShape extends Shape{\n\n    public CircleShape(){\n        super();\n    }\n    public CircleShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个圆形&quot;);\n        color.draw();\n    }\n}\n//椭圆形\npublic class EllipseShape extends Shape {\n\n    public EllipseShape(){\n        super();\n    }\n    public EllipseShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个椭圆形&quot;);\n        color.draw();\n    }\n}\n//矩形\npublic class RectangleShape extends Shape {\n\n    public  RectangleShape(){\n        super();\n    }\n    public  RectangleShape(Color color){\n        super(color);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;画一个矩形&quot;);\n        color.draw();\n    }\n}\n</code></pre><p>Implementor：   </p>\n<pre><code>public interface Color {\n\n    public void draw();\n\n}\n</code></pre><p>ConcreteImplementor：   </p>\n<pre><code>public class WhiteColor implements Color {\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是白色的&quot;);\n    }\n}  \n\npublic class GrayColor implements Color {\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是灰色的&quot;);\n    }\n}\n\npublic class BlackColor implements Color {\n\n    @Override\n    public void draw() {\n        System.out.println(&quot;颜色是黑色的&quot;);\n    }\n} \n</code></pre><p>上面已经完成了各个部分，接下来就组合来使用这些类画出不同颜色的各种图形了。     </p>\n<pre><code>public class Client {\n\n    public static void main(String[] args) {\n        Color whiteColor = new WhiteColor();\n        Color grayColor = new GrayColor();\n        Color blackColor = new BlackColor();\n\n        Shape circleShape = new CircleShape();\n        Shape ellipseShape = new EllipseShape();\n        Shape rectangleShape = new RectangleShape();\n\n        //画一个黑色的圆形\n        circleShape.setColor(blackColor);\n        circleShape.draw();\n\n        //画一个白色的椭圆\n        ellipseShape.setColor(whiteColor);\n        ellipseShape.draw();\n\n        //画一个灰色的矩形\n        rectangleShape.setColor(grayColor);\n        rectangleShape.draw();\n    }\n}\n</code></pre><p>这样就实现了。各种组合来满足条件。如果要添加更多的颜色以及图形，只需要分别扩展就行，不用该原来的代码。使用的时候随心组合就OK了。    </p>"},{"layout":"post","title":"设计模式：构建者（builder） in java","date":"2012-11-05T12:08:00.000Z","comments":1,"_content":"**定义：**建造者模式,又叫生成器模式，将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.   \n**适用性**:\n>a.当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式.    \n>b.当构建过程必须允许构造的对象有不同的表示.\n\n构建者模式的**核心思想**:    \n>将一个“**复杂对象的构建算法**”与它的“**部件及组装方式**”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式。\n\n\n建造者者模式有4个角色：  \n\n* Product产品类:  \n要构建的对象\n* Builder抽象构建者:   \n定义操作接口\n* ConcreteBuilder具体建造者:  \n实现Builder所有方法   \n* Director导演类：     \n每个观察者在接收到消息后的更新操作是不同的。   \n     \n<!--more-->\n下面以参考文献里提到的造人来说明:   \n首先定义以下产品类person,本例的产品就是\"人\"了.     \n\n    public class Person {\n\n\n        private List<String> arms = new ArrayList<String>();\n\n        private List<String> heads = new ArrayList<String>();\n\n        private List<String> legs = new ArrayList<String>();\n\n        private List<String> bodys = new ArrayList<String>();\n\n        public Person(){\n            System.out.println(\"person开始构建......\");\n        }\n\n        @Override\n        public String toString() {\n            return \"我有\"+heads.size()+\"个头,\"+bodys.size()+\"个身体,\"+arms.size()+\"个手臂,\"+legs.size()+\"个腿.\";\n        }\n\n        //setter and getter ...\n    }\n人嘛,一般都有头,身体,手臂,腿了.   \n\n下面是一个抽象的Builder:   \n\n    public  abstract class Builder {\n\n        protected Person person = new Person();\n\n        public abstract void buildHead();\n        public abstract void buildArm();\n        public abstract void buildLeg();\n        public abstract void buildBody();\n\n\n        public abstract Person getPerson();\n    }\n这里面定义了如何装配头,身体,手臂,腿的方法.    \n到这里,我可能想构建一个普通人:  \n\n    public class HumanBuilder extends Builder {\n\n        @Override\n        public void buildHead() {\n            person.getHeads().add(\"human head\");\n        }\n\n        @Override\n        public void buildArm() {\n            person.getArms().add(\"human arm\");\n        }\n\n        @Override\n        public void buildLeg() {\n            person.getLegs().add(\"human leg\");\n        }\n\n        @Override\n        public void buildBody() {\n            person.getBodys().add(\"human body\");\n        }\n\n        @Override\n        public Person getPerson() {\n            return person;  \n        }\n    }\n在这个类里,定义了实际的构建过程,需要注意的是各个部分可都是\"human\"的.    \n另外,我如果想构建另外一种人呢,比方奥特曼,那自然需要另外的一个Builder了.     \n\n    public class UltramanBuilder extends Builder {\n    \n        @Override\n        public void buildHead() {\n            person.getHeads().add(\"ultraman head\");\n        }\n        \n        @Override\n        public void buildArm() {\n            person.getArms().add(\"ultraman arm\");\n        }\n        \n        @Override\n        public void buildLeg() {\n            person.getLegs().add(\"ultraman leg\");\n        }\n        \n        @Override\n        public void buildBody() {\n            person.getBodys().add(\"ultraman body\");\n        }\n        \n        @Override\n        public Person getPerson() {\n            return person;\n        }\n    }\n接下了,就是导演要出场了,到底是要一个普通人还是奥特曼呢,一切都是导演说了算.     \n\n    public class PersonDirector {\n    \n        private Builder builder;\n    \n        public PersonDirector(Builder builder){\n            this.builder = builder;\n        }\n    \n        public Person createPerson(){\n            builder.buildBody();\n            builder.buildLeg();\n            builder.buildLeg();\n            if (builder instanceof HumanBuilder){\n                builder.buildHead();\n                builder.buildArm();\n            }else if(builder instanceof UltramanBuilder){\n                for(int i=0;i<3;i++){//3 head\n                    builder.buildHead();\n                }\n                for(int i=0;i<6;i++){//6 arms\n                    builder.buildArm();\n                }\n    \n            }\n            return builder.getPerson();\n        }\n    }    \n奥特曼可不像普通人一样,那可是有3头6臂的.   \n\n到这里构建者模式已经好了,到具体场景里用一下吧.    \n    public class Client {\n        public static void main(String[] args) {\n            PersonDirector personDirector = null;\n            Person person = null;\n            Builder builder = null;\n            builder = new HumanBuilder();\n            personDirector = new PersonDirector(builder);\n            person = personDirector.createPerson();\n            System.out.println(person);\n    \n            builder = new UltramanBuilder();\n            personDirector = new PersonDirector(builder);\n            person = personDirector.createPerson();\n            System.out.println(person);\n        }\n    }\n运行结果如下:    \n\n    person开始构建......\n    我有1个头,1个身体,1个手臂,2个腿.\n    person开始构建......\n    我有3个头,1个身体,6个手臂,2个腿.\n可见,不同的builder构建出的是不同的人.完全满足需要.     \n\n**需要注意**\n* 构建算法由Director来确定,Builder只负责提供装配接口.\n* 组成不见不能替换,比如普通人的头给奥特曼的头明显是不一样的.\n\n**Builder in Java**:   \n在Java中有一个StringBuilder,看名字应该就知道了.    \n\n       //Client同时充当了Director的角色\n       StringBuilder builder = new StringBuilder();\n       builder.Append(\"www\");\n       builder.Append(\".shenyanchao\");\n       builder.Append(\".cn\");\n       //返回string对象：www.shenyanchao.cn\n       builder.toString(); \n这中间没有了director,用client进行了代替.StringBuilder既是抽象接口又是具体构建者. 返回的字符串自然就是产品了. 这是一种简单的Builder模式.   \n\n\n参考文档:   \n<http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html>","source":"_posts/2012-11-02-builder-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：构建者（builder） in java\"\ndate: 2012-11-05 20:08\ncomments: true\ncategories: 设计模式\ntags: [ Java, builder ]\n---\n**定义：**建造者模式,又叫生成器模式，将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.   \n**适用性**:\n>a.当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式.    \n>b.当构建过程必须允许构造的对象有不同的表示.\n\n构建者模式的**核心思想**:    \n>将一个“**复杂对象的构建算法**”与它的“**部件及组装方式**”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式。\n\n\n建造者者模式有4个角色：  \n\n* Product产品类:  \n要构建的对象\n* Builder抽象构建者:   \n定义操作接口\n* ConcreteBuilder具体建造者:  \n实现Builder所有方法   \n* Director导演类：     \n每个观察者在接收到消息后的更新操作是不同的。   \n     \n<!--more-->\n下面以参考文献里提到的造人来说明:   \n首先定义以下产品类person,本例的产品就是\"人\"了.     \n\n    public class Person {\n\n\n        private List<String> arms = new ArrayList<String>();\n\n        private List<String> heads = new ArrayList<String>();\n\n        private List<String> legs = new ArrayList<String>();\n\n        private List<String> bodys = new ArrayList<String>();\n\n        public Person(){\n            System.out.println(\"person开始构建......\");\n        }\n\n        @Override\n        public String toString() {\n            return \"我有\"+heads.size()+\"个头,\"+bodys.size()+\"个身体,\"+arms.size()+\"个手臂,\"+legs.size()+\"个腿.\";\n        }\n\n        //setter and getter ...\n    }\n人嘛,一般都有头,身体,手臂,腿了.   \n\n下面是一个抽象的Builder:   \n\n    public  abstract class Builder {\n\n        protected Person person = new Person();\n\n        public abstract void buildHead();\n        public abstract void buildArm();\n        public abstract void buildLeg();\n        public abstract void buildBody();\n\n\n        public abstract Person getPerson();\n    }\n这里面定义了如何装配头,身体,手臂,腿的方法.    \n到这里,我可能想构建一个普通人:  \n\n    public class HumanBuilder extends Builder {\n\n        @Override\n        public void buildHead() {\n            person.getHeads().add(\"human head\");\n        }\n\n        @Override\n        public void buildArm() {\n            person.getArms().add(\"human arm\");\n        }\n\n        @Override\n        public void buildLeg() {\n            person.getLegs().add(\"human leg\");\n        }\n\n        @Override\n        public void buildBody() {\n            person.getBodys().add(\"human body\");\n        }\n\n        @Override\n        public Person getPerson() {\n            return person;  \n        }\n    }\n在这个类里,定义了实际的构建过程,需要注意的是各个部分可都是\"human\"的.    \n另外,我如果想构建另外一种人呢,比方奥特曼,那自然需要另外的一个Builder了.     \n\n    public class UltramanBuilder extends Builder {\n    \n        @Override\n        public void buildHead() {\n            person.getHeads().add(\"ultraman head\");\n        }\n        \n        @Override\n        public void buildArm() {\n            person.getArms().add(\"ultraman arm\");\n        }\n        \n        @Override\n        public void buildLeg() {\n            person.getLegs().add(\"ultraman leg\");\n        }\n        \n        @Override\n        public void buildBody() {\n            person.getBodys().add(\"ultraman body\");\n        }\n        \n        @Override\n        public Person getPerson() {\n            return person;\n        }\n    }\n接下了,就是导演要出场了,到底是要一个普通人还是奥特曼呢,一切都是导演说了算.     \n\n    public class PersonDirector {\n    \n        private Builder builder;\n    \n        public PersonDirector(Builder builder){\n            this.builder = builder;\n        }\n    \n        public Person createPerson(){\n            builder.buildBody();\n            builder.buildLeg();\n            builder.buildLeg();\n            if (builder instanceof HumanBuilder){\n                builder.buildHead();\n                builder.buildArm();\n            }else if(builder instanceof UltramanBuilder){\n                for(int i=0;i<3;i++){//3 head\n                    builder.buildHead();\n                }\n                for(int i=0;i<6;i++){//6 arms\n                    builder.buildArm();\n                }\n    \n            }\n            return builder.getPerson();\n        }\n    }    \n奥特曼可不像普通人一样,那可是有3头6臂的.   \n\n到这里构建者模式已经好了,到具体场景里用一下吧.    \n    public class Client {\n        public static void main(String[] args) {\n            PersonDirector personDirector = null;\n            Person person = null;\n            Builder builder = null;\n            builder = new HumanBuilder();\n            personDirector = new PersonDirector(builder);\n            person = personDirector.createPerson();\n            System.out.println(person);\n    \n            builder = new UltramanBuilder();\n            personDirector = new PersonDirector(builder);\n            person = personDirector.createPerson();\n            System.out.println(person);\n        }\n    }\n运行结果如下:    \n\n    person开始构建......\n    我有1个头,1个身体,1个手臂,2个腿.\n    person开始构建......\n    我有3个头,1个身体,6个手臂,2个腿.\n可见,不同的builder构建出的是不同的人.完全满足需要.     \n\n**需要注意**\n* 构建算法由Director来确定,Builder只负责提供装配接口.\n* 组成不见不能替换,比如普通人的头给奥特曼的头明显是不一样的.\n\n**Builder in Java**:   \n在Java中有一个StringBuilder,看名字应该就知道了.    \n\n       //Client同时充当了Director的角色\n       StringBuilder builder = new StringBuilder();\n       builder.Append(\"www\");\n       builder.Append(\".shenyanchao\");\n       builder.Append(\".cn\");\n       //返回string对象：www.shenyanchao.cn\n       builder.toString(); \n这中间没有了director,用client进行了代替.StringBuilder既是抽象接口又是具体构建者. 返回的字符串自然就是产品了. 这是一种简单的Builder模式.   \n\n\n参考文档:   \n<http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html>","slug":"2012-11-02-builder-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2w0023v8fyzi77bh0e","content":"<p><strong>定义：</strong>建造者模式,又叫生成器模式，将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.<br><strong>适用性</strong>:</p>\n<blockquote>\n<p>a.当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式.<br>b.当构建过程必须允许构造的对象有不同的表示.</p>\n</blockquote>\n<p>构建者模式的<strong>核心思想</strong>:    </p>\n<blockquote>\n<p>将一个“<strong>复杂对象的构建算法</strong>”与它的“<strong>部件及组装方式</strong>”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式。</p>\n</blockquote>\n<p>建造者者模式有4个角色：  </p>\n<ul>\n<li>Product产品类:<br>要构建的对象</li>\n<li>Builder抽象构建者:<br>定义操作接口</li>\n<li>ConcreteBuilder具体建造者:<br>实现Builder所有方法   </li>\n<li>Director导演类：<br>每个观察者在接收到消息后的更新操作是不同的。   </li>\n</ul>\n<a id=\"more\"></a>\n<p>下面以参考文献里提到的造人来说明:<br>首先定义以下产品类person,本例的产品就是”人”了.     </p>\n<pre><code>public class Person {\n\n\n    private List&lt;String&gt; arms = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; heads = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; legs = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; bodys = new ArrayList&lt;String&gt;();\n\n    public Person(){\n        System.out.println(&quot;person开始构建......&quot;);\n    }\n\n    @Override\n    public String toString() {\n        return &quot;我有&quot;+heads.size()+&quot;个头,&quot;+bodys.size()+&quot;个身体,&quot;+arms.size()+&quot;个手臂,&quot;+legs.size()+&quot;个腿.&quot;;\n    }\n\n    //setter and getter ...\n}\n</code></pre><p>人嘛,一般都有头,身体,手臂,腿了.   </p>\n<p>下面是一个抽象的Builder:   </p>\n<pre><code>public  abstract class Builder {\n\n    protected Person person = new Person();\n\n    public abstract void buildHead();\n    public abstract void buildArm();\n    public abstract void buildLeg();\n    public abstract void buildBody();\n\n\n    public abstract Person getPerson();\n}\n</code></pre><p>这里面定义了如何装配头,身体,手臂,腿的方法.<br>到这里,我可能想构建一个普通人:  </p>\n<pre><code>public class HumanBuilder extends Builder {\n\n    @Override\n    public void buildHead() {\n        person.getHeads().add(&quot;human head&quot;);\n    }\n\n    @Override\n    public void buildArm() {\n        person.getArms().add(&quot;human arm&quot;);\n    }\n\n    @Override\n    public void buildLeg() {\n        person.getLegs().add(&quot;human leg&quot;);\n    }\n\n    @Override\n    public void buildBody() {\n        person.getBodys().add(&quot;human body&quot;);\n    }\n\n    @Override\n    public Person getPerson() {\n        return person;  \n    }\n}\n</code></pre><p>在这个类里,定义了实际的构建过程,需要注意的是各个部分可都是”human”的.<br>另外,我如果想构建另外一种人呢,比方奥特曼,那自然需要另外的一个Builder了.     </p>\n<pre><code>public class UltramanBuilder extends Builder {\n\n    @Override\n    public void buildHead() {\n        person.getHeads().add(&quot;ultraman head&quot;);\n    }\n\n    @Override\n    public void buildArm() {\n        person.getArms().add(&quot;ultraman arm&quot;);\n    }\n\n    @Override\n    public void buildLeg() {\n        person.getLegs().add(&quot;ultraman leg&quot;);\n    }\n\n    @Override\n    public void buildBody() {\n        person.getBodys().add(&quot;ultraman body&quot;);\n    }\n\n    @Override\n    public Person getPerson() {\n        return person;\n    }\n}\n</code></pre><p>接下了,就是导演要出场了,到底是要一个普通人还是奥特曼呢,一切都是导演说了算.     </p>\n<pre><code>public class PersonDirector {\n\n    private Builder builder;\n\n    public PersonDirector(Builder builder){\n        this.builder = builder;\n    }\n\n    public Person createPerson(){\n        builder.buildBody();\n        builder.buildLeg();\n        builder.buildLeg();\n        if (builder instanceof HumanBuilder){\n            builder.buildHead();\n            builder.buildArm();\n        }else if(builder instanceof UltramanBuilder){\n            for(int i=0;i&lt;3;i++){//3 head\n                builder.buildHead();\n            }\n            for(int i=0;i&lt;6;i++){//6 arms\n                builder.buildArm();\n            }\n\n        }\n        return builder.getPerson();\n    }\n}    \n</code></pre><p>奥特曼可不像普通人一样,那可是有3头6臂的.   </p>\n<p>到这里构建者模式已经好了,到具体场景里用一下吧.<br>    public class Client {<br>        public static void main(String[] args) {<br>            PersonDirector personDirector = null;<br>            Person person = null;<br>            Builder builder = null;<br>            builder = new HumanBuilder();<br>            personDirector = new PersonDirector(builder);<br>            person = personDirector.createPerson();<br>            System.out.println(person);</p>\n<pre><code>        builder = new UltramanBuilder();\n        personDirector = new PersonDirector(builder);\n        person = personDirector.createPerson();\n        System.out.println(person);\n    }\n}\n</code></pre><p>运行结果如下:    </p>\n<pre><code>person开始构建......\n我有1个头,1个身体,1个手臂,2个腿.\nperson开始构建......\n我有3个头,1个身体,6个手臂,2个腿.\n</code></pre><p>可见,不同的builder构建出的是不同的人.完全满足需要.     </p>\n<p><strong>需要注意</strong></p>\n<ul>\n<li>构建算法由Director来确定,Builder只负责提供装配接口.</li>\n<li>组成不见不能替换,比如普通人的头给奥特曼的头明显是不一样的.</li>\n</ul>\n<p><strong>Builder in Java</strong>:<br>在Java中有一个StringBuilder,看名字应该就知道了.    </p>\n<pre><code>//Client同时充当了Director的角色\nStringBuilder builder = new StringBuilder();\nbuilder.Append(&quot;www&quot;);\nbuilder.Append(&quot;.shenyanchao&quot;);\nbuilder.Append(&quot;.cn&quot;);\n//返回string对象：www.shenyanchao.cn\nbuilder.toString(); \n</code></pre><p>这中间没有了director,用client进行了代替.StringBuilder既是抽象接口又是具体构建者. 返回的字符串自然就是产品了. 这是一种简单的Builder模式.   </p>\n<p>参考文档:<br><a href=\"http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html</a></p>\n","excerpt":"<p><strong>定义：</strong>建造者模式,又叫生成器模式，将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.<br><strong>适用性</strong>:</p>\n<blockquote>\n<p>a.当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式.<br>b.当构建过程必须允许构造的对象有不同的表示.</p>\n</blockquote>\n<p>构建者模式的<strong>核心思想</strong>:    </p>\n<blockquote>\n<p>将一个“<strong>复杂对象的构建算法</strong>”与它的“<strong>部件及组装方式</strong>”分离，使得构件算法和组装方式可以独立应对变化；复用同样的构建算法可以创建不同的表示，不同的构建过程可以复用相同的部件组装方式。</p>\n</blockquote>\n<p>建造者者模式有4个角色：  </p>\n<ul>\n<li>Product产品类:<br>要构建的对象</li>\n<li>Builder抽象构建者:<br>定义操作接口</li>\n<li>ConcreteBuilder具体建造者:<br>实现Builder所有方法   </li>\n<li>Director导演类：<br>每个观察者在接收到消息后的更新操作是不同的。   </li>\n</ul>","more":"<p>下面以参考文献里提到的造人来说明:<br>首先定义以下产品类person,本例的产品就是”人”了.     </p>\n<pre><code>public class Person {\n\n\n    private List&lt;String&gt; arms = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; heads = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; legs = new ArrayList&lt;String&gt;();\n\n    private List&lt;String&gt; bodys = new ArrayList&lt;String&gt;();\n\n    public Person(){\n        System.out.println(&quot;person开始构建......&quot;);\n    }\n\n    @Override\n    public String toString() {\n        return &quot;我有&quot;+heads.size()+&quot;个头,&quot;+bodys.size()+&quot;个身体,&quot;+arms.size()+&quot;个手臂,&quot;+legs.size()+&quot;个腿.&quot;;\n    }\n\n    //setter and getter ...\n}\n</code></pre><p>人嘛,一般都有头,身体,手臂,腿了.   </p>\n<p>下面是一个抽象的Builder:   </p>\n<pre><code>public  abstract class Builder {\n\n    protected Person person = new Person();\n\n    public abstract void buildHead();\n    public abstract void buildArm();\n    public abstract void buildLeg();\n    public abstract void buildBody();\n\n\n    public abstract Person getPerson();\n}\n</code></pre><p>这里面定义了如何装配头,身体,手臂,腿的方法.<br>到这里,我可能想构建一个普通人:  </p>\n<pre><code>public class HumanBuilder extends Builder {\n\n    @Override\n    public void buildHead() {\n        person.getHeads().add(&quot;human head&quot;);\n    }\n\n    @Override\n    public void buildArm() {\n        person.getArms().add(&quot;human arm&quot;);\n    }\n\n    @Override\n    public void buildLeg() {\n        person.getLegs().add(&quot;human leg&quot;);\n    }\n\n    @Override\n    public void buildBody() {\n        person.getBodys().add(&quot;human body&quot;);\n    }\n\n    @Override\n    public Person getPerson() {\n        return person;  \n    }\n}\n</code></pre><p>在这个类里,定义了实际的构建过程,需要注意的是各个部分可都是”human”的.<br>另外,我如果想构建另外一种人呢,比方奥特曼,那自然需要另外的一个Builder了.     </p>\n<pre><code>public class UltramanBuilder extends Builder {\n\n    @Override\n    public void buildHead() {\n        person.getHeads().add(&quot;ultraman head&quot;);\n    }\n\n    @Override\n    public void buildArm() {\n        person.getArms().add(&quot;ultraman arm&quot;);\n    }\n\n    @Override\n    public void buildLeg() {\n        person.getLegs().add(&quot;ultraman leg&quot;);\n    }\n\n    @Override\n    public void buildBody() {\n        person.getBodys().add(&quot;ultraman body&quot;);\n    }\n\n    @Override\n    public Person getPerson() {\n        return person;\n    }\n}\n</code></pre><p>接下了,就是导演要出场了,到底是要一个普通人还是奥特曼呢,一切都是导演说了算.     </p>\n<pre><code>public class PersonDirector {\n\n    private Builder builder;\n\n    public PersonDirector(Builder builder){\n        this.builder = builder;\n    }\n\n    public Person createPerson(){\n        builder.buildBody();\n        builder.buildLeg();\n        builder.buildLeg();\n        if (builder instanceof HumanBuilder){\n            builder.buildHead();\n            builder.buildArm();\n        }else if(builder instanceof UltramanBuilder){\n            for(int i=0;i&lt;3;i++){//3 head\n                builder.buildHead();\n            }\n            for(int i=0;i&lt;6;i++){//6 arms\n                builder.buildArm();\n            }\n\n        }\n        return builder.getPerson();\n    }\n}    \n</code></pre><p>奥特曼可不像普通人一样,那可是有3头6臂的.   </p>\n<p>到这里构建者模式已经好了,到具体场景里用一下吧.<br>    public class Client {<br>        public static void main(String[] args) {<br>            PersonDirector personDirector = null;<br>            Person person = null;<br>            Builder builder = null;<br>            builder = new HumanBuilder();<br>            personDirector = new PersonDirector(builder);<br>            person = personDirector.createPerson();<br>            System.out.println(person);</p>\n<pre><code>        builder = new UltramanBuilder();\n        personDirector = new PersonDirector(builder);\n        person = personDirector.createPerson();\n        System.out.println(person);\n    }\n}\n</code></pre><p>运行结果如下:    </p>\n<pre><code>person开始构建......\n我有1个头,1个身体,1个手臂,2个腿.\nperson开始构建......\n我有3个头,1个身体,6个手臂,2个腿.\n</code></pre><p>可见,不同的builder构建出的是不同的人.完全满足需要.     </p>\n<p><strong>需要注意</strong></p>\n<ul>\n<li>构建算法由Director来确定,Builder只负责提供装配接口.</li>\n<li>组成不见不能替换,比如普通人的头给奥特曼的头明显是不一样的.</li>\n</ul>\n<p><strong>Builder in Java</strong>:<br>在Java中有一个StringBuilder,看名字应该就知道了.    </p>\n<pre><code>//Client同时充当了Director的角色\nStringBuilder builder = new StringBuilder();\nbuilder.Append(&quot;www&quot;);\nbuilder.Append(&quot;.shenyanchao&quot;);\nbuilder.Append(&quot;.cn&quot;);\n//返回string对象：www.shenyanchao.cn\nbuilder.toString(); \n</code></pre><p>这中间没有了director,用client进行了代替.StringBuilder既是抽象接口又是具体构建者. 返回的字符串自然就是产品了. 这是一种简单的Builder模式.   </p>\n<p>参考文档:<br><a href=\"http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html\">http://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html</a></p>"},{"layout":"post","title":"设计模式：责任链（chain of responsibility） in java","date":"2012-11-02T12:09:00.000Z","comments":1,"_content":"**定义：**使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。    \n\n责任链由2个角色组成：   \n\n- Handler抽象处理者角色    \n它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。    \n- Concrete Handler具体处理者角色    \n实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。  \n\n比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。    ","source":"_posts/2012-11-02-chain-of-responsibility-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：责任链（chain of responsibility） in java\"\ndate: 2012-11-02 20:09\ncomments: true\ncategories: 设计模式\ntags: [ chain, pattern, 责任链 ]\n---\n**定义：**使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。    \n\n责任链由2个角色组成：   \n\n- Handler抽象处理者角色    \n它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。    \n- Concrete Handler具体处理者角色    \n实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。  \n\n比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。    ","slug":"2012-11-02-chain-of-responsibility-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop2z0027v8fy0u8ss44o","content":"<p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。    </p>\n<p>责任链由2个角色组成：   </p>\n<ul>\n<li>Handler抽象处理者角色<br>它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。    </li>\n<li>Concrete Handler具体处理者角色<br>实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。  </li>\n</ul>\n<p>比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。    </p>\n","excerpt":"","more":"<p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。    </p>\n<p>责任链由2个角色组成：   </p>\n<ul>\n<li>Handler抽象处理者角色<br>它定义了一个处理请求的接口。当然对于链子的不同实现，也可以在这个角色中实现后继链。    </li>\n<li>Concrete Handler具体处理者角色<br>实现抽象角色中定义的接口，并处理它所负责的请求。如果不能处理则访问它的后继者。  </li>\n</ul>\n<p>比如Filter就类似这种，每个Filter都对请求进行处理，如果解决不了，则交给下一个进行处理。    </p>\n"},{"layout":"post","title":"设计模式：命令（Command） in java","date":"2012-11-08T07:09:00.000Z","comments":1,"_content":"**定义：**命令模式是一种高内聚的模式。它将一个请求封装成一个对象，从而让使用不同请求来把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销与恢复功能。   \n听起来，好复杂！  \n\n在程序员之间，流传着这样一句话：程序写到最后，就是if-else,for,while。  \n真是枯燥啊！其实能体会到这种感觉，说明作为一个程序员，你已经有了一定的造诣了。那如何提高呢？   \n\n试想，在代码中，你有很多if-else或者case语句。为什么有这样的语句呢？因为判断条件多啊，需要根据不同的条件来做不同的事情。2、3个条件还可以写，如果有20个条件呢，或者N多呢。那么我们的if-else那就判断N重条件，这简直是无法忍受的，写出的代码可维护性更不用说了。    \n<!--more-->   \n**命令模式**就是可以解决这种问题的方法之一。下面就来提高一下程序员的自我修养了。\n   \n命令模式中，主要有3个角色：  \n\n* Receiver命令接收者\n* Command命令\n* Invoker命令调用者  \n\n下面开始分别定义：   \n**Receiver:**定义命令的N种接收者   \n\n\tpublic abstract class AbstractReceiver {\n\t\tpublic abstract void doSomething();\n\t}\n\n\tpublic class Receiver1 extends AbstractReceiver {\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(\"receiver1 do something\");\n\t\t}\n\t}\n\tpublic class Receiver2 extends AbstractReceiver {\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(\"receiver2 do something\");\n\t\t}\n\t}\n\t...\n\tpublic class ReceiverN\n\t...\n\n**Command:**定义N种命令   \n\n\tpublic abstract class AbstractCommand {\n\t\tpublic abstract void execute();\n\t}\n\t\n\tpublic class Command1 extends AbstractCommand {\n\t\tprivate AbstractReceiver receiver;\n\t\tpublic Command1(AbstractReceiver receiver) {\n\t\t\tthis.receiver = receiver;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\tSystem.out.println(\"command1 命令发出\");\n\t\t\treceiver.doSomething();\n\t\t}\n\t}\n\tpublic class Command2 extends AbstractCommand {\n\t\tprivate AbstractReceiver receiver;\n\t\tpublic Command2(AbstractReceiver receiver) {\n\t\t\tthis.receiver = receiver;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\tSystem.out.println(\"command2 命令发出\");\n\t\t\treceiver.doSomething();\n\t\t}\n\t}\n\t...\n    public class CommandN\n\t....\n\n**Invoker:**定义调用者   \n\n\tpublic class Invoker {\n\n\t\tprivate List<AbstractCommand> commandList = new LinkedList<AbstractCommand>();\n\n\t\tpublic void addCommand(AbstractCommand command) {\n\t\t\tcommandList.add(command);\n\t\t}\n\n\t\tpublic void addCommands(LinkedList<AbstractCommand> commands) {\n\t\t\tcommandList.addAll(commands);\n\t\t}\n\n\t\tpublic void action() {\n\t\t\tfor (AbstractCommand command : commandList) {\n\t\t\t\tcommand.execute();\n\t\t\t}\n\t\t}\n\n\t}\n使用场景：  \n\n\tInvoker invoker = new Invoker();\n\tAbstractReceiver receiver1 = new Receiver1();\n\tAbstractReceiver receiver2 = new Receiver2();\n\tAbstractCommand command1 = new Command1(receiver2);\n\tAbstractCommand command2 = new Command2(receiver1);\n\tinvoker.addCommand(command1);\n\tinvoker.addCommand(command2);\n\tinvoker.action();\n运行结果：  \n\n\tcommand1 命令发出\n\treceiver2 do something\n\tcommand2 命令发出\n\treceiver1 do something\n现在再回过来看命令模式的定义，就比较明白了吧。也就是说有N种请求条件，那么就定义N个类来封装请求，我们称之为命令（Command）。每个命令做什么操作呢，谁来执行这个命令呢，有命令自己来进行定义。这样就避免了if-else，而由N种命令来决定跳转关系。   \n\n调用者（Invoker）呢，它维护了一个命令列表，并按照一定的顺序来发起命令调用。当然这个列表也有可能就只有一个命令了，就简化了一下。与if-else对比更直观的了。  \n\n定义中还提到了命令撤销或恢复的功能，这种撤销与恢复也是命令的一种了，一般可以通过扩展一个命令出来，通过诸如日志等来恢复之前的操作。其实这个也是可以通过备忘录模式来实现的。\n##命令模式 in JDK##\n\n\tjava.lang.Runnable#run()\n\tjavax.swing.Action#actionPeformed(ActionEvent e)\n从Runnable来说，不同的实现者，通过调用run()来实现在不同线程执行不同的操作。\n从Action来说，由于桌面UI有很多的操作事件，这些事件就是命令。通过actionPerformed函数，接受不同的命令参数来做出不同的表现。  ","source":"_posts/2012-11-02-command-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：命令（Command） in java\"\ndate: 2012-11-08 15:09\ncomments: true\ncategories: 设计模式\ntags: [ Java, command ]\n---\n**定义：**命令模式是一种高内聚的模式。它将一个请求封装成一个对象，从而让使用不同请求来把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销与恢复功能。   \n听起来，好复杂！  \n\n在程序员之间，流传着这样一句话：程序写到最后，就是if-else,for,while。  \n真是枯燥啊！其实能体会到这种感觉，说明作为一个程序员，你已经有了一定的造诣了。那如何提高呢？   \n\n试想，在代码中，你有很多if-else或者case语句。为什么有这样的语句呢？因为判断条件多啊，需要根据不同的条件来做不同的事情。2、3个条件还可以写，如果有20个条件呢，或者N多呢。那么我们的if-else那就判断N重条件，这简直是无法忍受的，写出的代码可维护性更不用说了。    \n<!--more-->   \n**命令模式**就是可以解决这种问题的方法之一。下面就来提高一下程序员的自我修养了。\n   \n命令模式中，主要有3个角色：  \n\n* Receiver命令接收者\n* Command命令\n* Invoker命令调用者  \n\n下面开始分别定义：   \n**Receiver:**定义命令的N种接收者   \n\n\tpublic abstract class AbstractReceiver {\n\t\tpublic abstract void doSomething();\n\t}\n\n\tpublic class Receiver1 extends AbstractReceiver {\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(\"receiver1 do something\");\n\t\t}\n\t}\n\tpublic class Receiver2 extends AbstractReceiver {\n\t\t@Override\n\t\tpublic void doSomething() {\n\t\t\tSystem.out.println(\"receiver2 do something\");\n\t\t}\n\t}\n\t...\n\tpublic class ReceiverN\n\t...\n\n**Command:**定义N种命令   \n\n\tpublic abstract class AbstractCommand {\n\t\tpublic abstract void execute();\n\t}\n\t\n\tpublic class Command1 extends AbstractCommand {\n\t\tprivate AbstractReceiver receiver;\n\t\tpublic Command1(AbstractReceiver receiver) {\n\t\t\tthis.receiver = receiver;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\tSystem.out.println(\"command1 命令发出\");\n\t\t\treceiver.doSomething();\n\t\t}\n\t}\n\tpublic class Command2 extends AbstractCommand {\n\t\tprivate AbstractReceiver receiver;\n\t\tpublic Command2(AbstractReceiver receiver) {\n\t\t\tthis.receiver = receiver;\n\t\t}\n\t\t@Override\n\t\tpublic void execute() {\n\t\t\tSystem.out.println(\"command2 命令发出\");\n\t\t\treceiver.doSomething();\n\t\t}\n\t}\n\t...\n    public class CommandN\n\t....\n\n**Invoker:**定义调用者   \n\n\tpublic class Invoker {\n\n\t\tprivate List<AbstractCommand> commandList = new LinkedList<AbstractCommand>();\n\n\t\tpublic void addCommand(AbstractCommand command) {\n\t\t\tcommandList.add(command);\n\t\t}\n\n\t\tpublic void addCommands(LinkedList<AbstractCommand> commands) {\n\t\t\tcommandList.addAll(commands);\n\t\t}\n\n\t\tpublic void action() {\n\t\t\tfor (AbstractCommand command : commandList) {\n\t\t\t\tcommand.execute();\n\t\t\t}\n\t\t}\n\n\t}\n使用场景：  \n\n\tInvoker invoker = new Invoker();\n\tAbstractReceiver receiver1 = new Receiver1();\n\tAbstractReceiver receiver2 = new Receiver2();\n\tAbstractCommand command1 = new Command1(receiver2);\n\tAbstractCommand command2 = new Command2(receiver1);\n\tinvoker.addCommand(command1);\n\tinvoker.addCommand(command2);\n\tinvoker.action();\n运行结果：  \n\n\tcommand1 命令发出\n\treceiver2 do something\n\tcommand2 命令发出\n\treceiver1 do something\n现在再回过来看命令模式的定义，就比较明白了吧。也就是说有N种请求条件，那么就定义N个类来封装请求，我们称之为命令（Command）。每个命令做什么操作呢，谁来执行这个命令呢，有命令自己来进行定义。这样就避免了if-else，而由N种命令来决定跳转关系。   \n\n调用者（Invoker）呢，它维护了一个命令列表，并按照一定的顺序来发起命令调用。当然这个列表也有可能就只有一个命令了，就简化了一下。与if-else对比更直观的了。  \n\n定义中还提到了命令撤销或恢复的功能，这种撤销与恢复也是命令的一种了，一般可以通过扩展一个命令出来，通过诸如日志等来恢复之前的操作。其实这个也是可以通过备忘录模式来实现的。\n##命令模式 in JDK##\n\n\tjava.lang.Runnable#run()\n\tjavax.swing.Action#actionPeformed(ActionEvent e)\n从Runnable来说，不同的实现者，通过调用run()来实现在不同线程执行不同的操作。\n从Action来说，由于桌面UI有很多的操作事件，这些事件就是命令。通过actionPerformed函数，接受不同的命令参数来做出不同的表现。  ","slug":"2012-11-02-command-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop31002bv8fyx6tvkpj2","content":"<p><strong>定义：</strong>命令模式是一种高内聚的模式。它将一个请求封装成一个对象，从而让使用不同请求来把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销与恢复功能。<br>听起来，好复杂！  </p>\n<p>在程序员之间，流传着这样一句话：程序写到最后，就是if-else,for,while。<br>真是枯燥啊！其实能体会到这种感觉，说明作为一个程序员，你已经有了一定的造诣了。那如何提高呢？   </p>\n<p>试想，在代码中，你有很多if-else或者case语句。为什么有这样的语句呢？因为判断条件多啊，需要根据不同的条件来做不同的事情。2、3个条件还可以写，如果有20个条件呢，或者N多呢。那么我们的if-else那就判断N重条件，这简直是无法忍受的，写出的代码可维护性更不用说了。<br><a id=\"more\"></a><br><strong>命令模式</strong>就是可以解决这种问题的方法之一。下面就来提高一下程序员的自我修养了。</p>\n<p>命令模式中，主要有3个角色：  </p>\n<ul>\n<li>Receiver命令接收者</li>\n<li>Command命令</li>\n<li>Invoker命令调用者  </li>\n</ul>\n<p>下面开始分别定义：<br><strong>Receiver:</strong>定义命令的N种接收者   </p>\n<pre><code>public abstract class AbstractReceiver {\n    public abstract void doSomething();\n}\n\npublic class Receiver1 extends AbstractReceiver {\n    @Override\n    public void doSomething() {\n        System.out.println(&quot;receiver1 do something&quot;);\n    }\n}\npublic class Receiver2 extends AbstractReceiver {\n    @Override\n    public void doSomething() {\n        System.out.println(&quot;receiver2 do something&quot;);\n    }\n}\n...\npublic class ReceiverN\n...\n</code></pre><p><strong>Command:</strong>定义N种命令   </p>\n<pre><code>public abstract class AbstractCommand {\n    public abstract void execute();\n}\n\npublic class Command1 extends AbstractCommand {\n    private AbstractReceiver receiver;\n    public Command1(AbstractReceiver receiver) {\n        this.receiver = receiver;\n    }\n    @Override\n    public void execute() {\n        System.out.println(&quot;command1 命令发出&quot;);\n        receiver.doSomething();\n    }\n}\npublic class Command2 extends AbstractCommand {\n    private AbstractReceiver receiver;\n    public Command2(AbstractReceiver receiver) {\n        this.receiver = receiver;\n    }\n    @Override\n    public void execute() {\n        System.out.println(&quot;command2 命令发出&quot;);\n        receiver.doSomething();\n    }\n}\n...\npublic class CommandN\n....\n</code></pre><p><strong>Invoker:</strong>定义调用者   </p>\n<pre><code>public class Invoker {\n\n    private List&lt;AbstractCommand&gt; commandList = new LinkedList&lt;AbstractCommand&gt;();\n\n    public void addCommand(AbstractCommand command) {\n        commandList.add(command);\n    }\n\n    public void addCommands(LinkedList&lt;AbstractCommand&gt; commands) {\n        commandList.addAll(commands);\n    }\n\n    public void action() {\n        for (AbstractCommand command : commandList) {\n            command.execute();\n        }\n    }\n\n}\n</code></pre><p>使用场景：  </p>\n<pre><code>Invoker invoker = new Invoker();\nAbstractReceiver receiver1 = new Receiver1();\nAbstractReceiver receiver2 = new Receiver2();\nAbstractCommand command1 = new Command1(receiver2);\nAbstractCommand command2 = new Command2(receiver1);\ninvoker.addCommand(command1);\ninvoker.addCommand(command2);\ninvoker.action();\n</code></pre><p>运行结果：  </p>\n<pre><code>command1 命令发出\nreceiver2 do something\ncommand2 命令发出\nreceiver1 do something\n</code></pre><p>现在再回过来看命令模式的定义，就比较明白了吧。也就是说有N种请求条件，那么就定义N个类来封装请求，我们称之为命令（Command）。每个命令做什么操作呢，谁来执行这个命令呢，有命令自己来进行定义。这样就避免了if-else，而由N种命令来决定跳转关系。   </p>\n<p>调用者（Invoker）呢，它维护了一个命令列表，并按照一定的顺序来发起命令调用。当然这个列表也有可能就只有一个命令了，就简化了一下。与if-else对比更直观的了。  </p>\n<p>定义中还提到了命令撤销或恢复的功能，这种撤销与恢复也是命令的一种了，一般可以通过扩展一个命令出来，通过诸如日志等来恢复之前的操作。其实这个也是可以通过备忘录模式来实现的。</p>\n<p>##命令模式 in JDK##</p>\n<pre><code>java.lang.Runnable#run()\njavax.swing.Action#actionPeformed(ActionEvent e)\n</code></pre><p>从Runnable来说，不同的实现者，通过调用run()来实现在不同线程执行不同的操作。<br>从Action来说，由于桌面UI有很多的操作事件，这些事件就是命令。通过actionPerformed函数，接受不同的命令参数来做出不同的表现。  </p>\n","excerpt":"<p><strong>定义：</strong>命令模式是一种高内聚的模式。它将一个请求封装成一个对象，从而让使用不同请求来把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销与恢复功能。<br>听起来，好复杂！  </p>\n<p>在程序员之间，流传着这样一句话：程序写到最后，就是if-else,for,while。<br>真是枯燥啊！其实能体会到这种感觉，说明作为一个程序员，你已经有了一定的造诣了。那如何提高呢？   </p>\n<p>试想，在代码中，你有很多if-else或者case语句。为什么有这样的语句呢？因为判断条件多啊，需要根据不同的条件来做不同的事情。2、3个条件还可以写，如果有20个条件呢，或者N多呢。那么我们的if-else那就判断N重条件，这简直是无法忍受的，写出的代码可维护性更不用说了。<br>","more":"<br><strong>命令模式</strong>就是可以解决这种问题的方法之一。下面就来提高一下程序员的自我修养了。</p>\n<p>命令模式中，主要有3个角色：  </p>\n<ul>\n<li>Receiver命令接收者</li>\n<li>Command命令</li>\n<li>Invoker命令调用者  </li>\n</ul>\n<p>下面开始分别定义：<br><strong>Receiver:</strong>定义命令的N种接收者   </p>\n<pre><code>public abstract class AbstractReceiver {\n    public abstract void doSomething();\n}\n\npublic class Receiver1 extends AbstractReceiver {\n    @Override\n    public void doSomething() {\n        System.out.println(&quot;receiver1 do something&quot;);\n    }\n}\npublic class Receiver2 extends AbstractReceiver {\n    @Override\n    public void doSomething() {\n        System.out.println(&quot;receiver2 do something&quot;);\n    }\n}\n...\npublic class ReceiverN\n...\n</code></pre><p><strong>Command:</strong>定义N种命令   </p>\n<pre><code>public abstract class AbstractCommand {\n    public abstract void execute();\n}\n\npublic class Command1 extends AbstractCommand {\n    private AbstractReceiver receiver;\n    public Command1(AbstractReceiver receiver) {\n        this.receiver = receiver;\n    }\n    @Override\n    public void execute() {\n        System.out.println(&quot;command1 命令发出&quot;);\n        receiver.doSomething();\n    }\n}\npublic class Command2 extends AbstractCommand {\n    private AbstractReceiver receiver;\n    public Command2(AbstractReceiver receiver) {\n        this.receiver = receiver;\n    }\n    @Override\n    public void execute() {\n        System.out.println(&quot;command2 命令发出&quot;);\n        receiver.doSomething();\n    }\n}\n...\npublic class CommandN\n....\n</code></pre><p><strong>Invoker:</strong>定义调用者   </p>\n<pre><code>public class Invoker {\n\n    private List&lt;AbstractCommand&gt; commandList = new LinkedList&lt;AbstractCommand&gt;();\n\n    public void addCommand(AbstractCommand command) {\n        commandList.add(command);\n    }\n\n    public void addCommands(LinkedList&lt;AbstractCommand&gt; commands) {\n        commandList.addAll(commands);\n    }\n\n    public void action() {\n        for (AbstractCommand command : commandList) {\n            command.execute();\n        }\n    }\n\n}\n</code></pre><p>使用场景：  </p>\n<pre><code>Invoker invoker = new Invoker();\nAbstractReceiver receiver1 = new Receiver1();\nAbstractReceiver receiver2 = new Receiver2();\nAbstractCommand command1 = new Command1(receiver2);\nAbstractCommand command2 = new Command2(receiver1);\ninvoker.addCommand(command1);\ninvoker.addCommand(command2);\ninvoker.action();\n</code></pre><p>运行结果：  </p>\n<pre><code>command1 命令发出\nreceiver2 do something\ncommand2 命令发出\nreceiver1 do something\n</code></pre><p>现在再回过来看命令模式的定义，就比较明白了吧。也就是说有N种请求条件，那么就定义N个类来封装请求，我们称之为命令（Command）。每个命令做什么操作呢，谁来执行这个命令呢，有命令自己来进行定义。这样就避免了if-else，而由N种命令来决定跳转关系。   </p>\n<p>调用者（Invoker）呢，它维护了一个命令列表，并按照一定的顺序来发起命令调用。当然这个列表也有可能就只有一个命令了，就简化了一下。与if-else对比更直观的了。  </p>\n<p>定义中还提到了命令撤销或恢复的功能，这种撤销与恢复也是命令的一种了，一般可以通过扩展一个命令出来，通过诸如日志等来恢复之前的操作。其实这个也是可以通过备忘录模式来实现的。</p>\n<p>##命令模式 in JDK##</p>\n<pre><code>java.lang.Runnable#run()\njavax.swing.Action#actionPeformed(ActionEvent e)\n</code></pre><p>从Runnable来说，不同的实现者，通过调用run()来实现在不同线程执行不同的操作。<br>从Action来说，由于桌面UI有很多的操作事件，这些事件就是命令。通过actionPerformed函数，接受不同的命令参数来做出不同的表现。  </p>"},{"layout":"post","title":"设计模式：门面（Facade） in java","date":"2012-11-07T12:00:00.000Z","comments":1,"_content":"**定义：**为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。   \n就是说，Facade提供了一个统一的接口，掩盖下层系统的复杂性，用户用起来更加的方便。\n\n以医院的例子，做个比喻：  \n<!--more-->  \n \n在无接待员的时候，病人要做业务，好复杂啊，好累！\n\n![无接待员](/images/blog/facade-hospital1.png)\n\n有了接待员，各种就医流程好流畅的说。因为有接待员与各个部门打交道。\n\n![有接待员](/images/blog/facade-hospital2.png)  \n\n这个例子很好的说出了facade的作用。甚至都不需要代码来表达了。\n\n门面模式的优点：\n\n　　●松散耦合\n\n　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。\n\n　　●简单易用\n\n　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。\n\n　　●更好的划分访问层次\n\n　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节    \n\n##门面模式 in JDK##\n这个具体的例子，我首先想到的就是[slf4j](http://www.slf4j.org/)这个日志框架。通过名字Simple Logging Facade for Java (SLF4J)就知道是采用的Facade模式了。下面是其官方的介绍：   \nThe Simple Logging Facade for Java or (SLF4J) serves as a simple facade or abstraction for various logging frameworks, e.g. java.util.logging, log4j and logback, allowing the end user to plug in the desired logging framework at deployment time.   \n也就是说，他屏蔽了各种日志框架的差异，提供了一个统一的日志接口给用户使用。不得不说，[slf4j](http://www.slf4j.org/)很好用，推荐！\n\n","source":"_posts/2012-11-02-facade-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：门面（Facade） in java\"\ndate: 2012-11-07 20:00\ncomments: true\ncategories: 设计模式\ntags: [ Java, Facade, slf4j ]\n---\n**定义：**为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。   \n就是说，Facade提供了一个统一的接口，掩盖下层系统的复杂性，用户用起来更加的方便。\n\n以医院的例子，做个比喻：  \n<!--more-->  \n \n在无接待员的时候，病人要做业务，好复杂啊，好累！\n\n![无接待员](/images/blog/facade-hospital1.png)\n\n有了接待员，各种就医流程好流畅的说。因为有接待员与各个部门打交道。\n\n![有接待员](/images/blog/facade-hospital2.png)  \n\n这个例子很好的说出了facade的作用。甚至都不需要代码来表达了。\n\n门面模式的优点：\n\n　　●松散耦合\n\n　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。\n\n　　●简单易用\n\n　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。\n\n　　●更好的划分访问层次\n\n　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节    \n\n##门面模式 in JDK##\n这个具体的例子，我首先想到的就是[slf4j](http://www.slf4j.org/)这个日志框架。通过名字Simple Logging Facade for Java (SLF4J)就知道是采用的Facade模式了。下面是其官方的介绍：   \nThe Simple Logging Facade for Java or (SLF4J) serves as a simple facade or abstraction for various logging frameworks, e.g. java.util.logging, log4j and logback, allowing the end user to plug in the desired logging framework at deployment time.   \n也就是说，他屏蔽了各种日志框架的差异，提供了一个统一的日志接口给用户使用。不得不说，[slf4j](http://www.slf4j.org/)很好用，推荐！\n\n","slug":"2012-11-02-facade-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop36002ev8fykmyiunl6","content":"<p><strong>定义：</strong>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>就是说，Facade提供了一个统一的接口，掩盖下层系统的复杂性，用户用起来更加的方便。</p>\n<p>以医院的例子，做个比喻：<br><a id=\"more\"></a>  </p>\n<p>在无接待员的时候，病人要做业务，好复杂啊，好累！</p>\n<p><img src=\"/images/blog/facade-hospital1.png\" alt=\"无接待员\"></p>\n<p>有了接待员，各种就医流程好流畅的说。因为有接待员与各个部门打交道。</p>\n<p><img src=\"/images/blog/facade-hospital2.png\" alt=\"有接待员\">  </p>\n<p>这个例子很好的说出了facade的作用。甚至都不需要代码来表达了。</p>\n<p>门面模式的优点：</p>\n<p>　　●松散耦合</p>\n<p>　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>\n<p>　　●简单易用</p>\n<p>　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p>\n<p>　　●更好的划分访问层次</p>\n<p>　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节    </p>\n<p>##门面模式 in JDK##<br>这个具体的例子，我首先想到的就是<a href=\"http://www.slf4j.org/\" target=\"_blank\" rel=\"external\">slf4j</a>这个日志框架。通过名字Simple Logging Facade for Java (SLF4J)就知道是采用的Facade模式了。下面是其官方的介绍：<br>The Simple Logging Facade for Java or (SLF4J) serves as a simple facade or abstraction for various logging frameworks, e.g. java.util.logging, log4j and logback, allowing the end user to plug in the desired logging framework at deployment time.<br>也就是说，他屏蔽了各种日志框架的差异，提供了一个统一的日志接口给用户使用。不得不说，<a href=\"http://www.slf4j.org/\" target=\"_blank\" rel=\"external\">slf4j</a>很好用，推荐！</p>\n","excerpt":"<p><strong>定义：</strong>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>就是说，Facade提供了一个统一的接口，掩盖下层系统的复杂性，用户用起来更加的方便。</p>\n<p>以医院的例子，做个比喻：<br>","more":"</p>\n<p>在无接待员的时候，病人要做业务，好复杂啊，好累！</p>\n<p><img src=\"/images/blog/facade-hospital1.png\" alt=\"无接待员\"></p>\n<p>有了接待员，各种就医流程好流畅的说。因为有接待员与各个部门打交道。</p>\n<p><img src=\"/images/blog/facade-hospital2.png\" alt=\"有接待员\">  </p>\n<p>这个例子很好的说出了facade的作用。甚至都不需要代码来表达了。</p>\n<p>门面模式的优点：</p>\n<p>　　●松散耦合</p>\n<p>　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>\n<p>　　●简单易用</p>\n<p>　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p>\n<p>　　●更好的划分访问层次</p>\n<p>　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节    </p>\n<p>##门面模式 in JDK##<br>这个具体的例子，我首先想到的就是<a href=\"http://www.slf4j.org/\">slf4j</a>这个日志框架。通过名字Simple Logging Facade for Java (SLF4J)就知道是采用的Facade模式了。下面是其官方的介绍：<br>The Simple Logging Facade for Java or (SLF4J) serves as a simple facade or abstraction for various logging frameworks, e.g. java.util.logging, log4j and logback, allowing the end user to plug in the desired logging framework at deployment time.<br>也就是说，他屏蔽了各种日志框架的差异，提供了一个统一的日志接口给用户使用。不得不说，<a href=\"http://www.slf4j.org/\">slf4j</a>很好用，推荐！</p>"},{"layout":"post","title":"设计模式：组合（composite） in java","date":"2012-11-02T12:07:00.000Z","comments":1,"_content":"**定义：**组合模式（Composite Pattern）也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系。确切的定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。   \n\n组合模式类图如下：    \n\n![组合模式](/images/blog/composite-pattern.jpg)    \n\n组合模式有以下几个角色：   \n\n- Component抽象构件角色   \n定义参加组合对象的共有方法和树形，可以定义一些默认的行为或属性。   \n- Leaf叶子构件    \n叶子对象，下面没有其他分支，也就是最小的遍历单位。   \n- Composite树枝构件    \n树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。    \n\n\n这个说白了就是一个树形结构，不再具体使用例子了。     \n","source":"_posts/2012-11-02-composite-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：组合（composite） in java\"\ndate: 2012-11-02 20:07\ncomments: true\ncategories: 设计模式\ntags: [ composite, pattern ]\n---\n**定义：**组合模式（Composite Pattern）也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系。确切的定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。   \n\n组合模式类图如下：    \n\n![组合模式](/images/blog/composite-pattern.jpg)    \n\n组合模式有以下几个角色：   \n\n- Component抽象构件角色   \n定义参加组合对象的共有方法和树形，可以定义一些默认的行为或属性。   \n- Leaf叶子构件    \n叶子对象，下面没有其他分支，也就是最小的遍历单位。   \n- Composite树枝构件    \n树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。    \n\n\n这个说白了就是一个树形结构，不再具体使用例子了。     \n","slug":"2012-11-02-composite-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop39002hv8fyv3k6bm7s","content":"<p><strong>定义：</strong>组合模式（Composite Pattern）也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系。确切的定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。   </p>\n<p>组合模式类图如下：    </p>\n<p><img src=\"/images/blog/composite-pattern.jpg\" alt=\"组合模式\">    </p>\n<p>组合模式有以下几个角色：   </p>\n<ul>\n<li>Component抽象构件角色<br>定义参加组合对象的共有方法和树形，可以定义一些默认的行为或属性。   </li>\n<li>Leaf叶子构件<br>叶子对象，下面没有其他分支，也就是最小的遍历单位。   </li>\n<li>Composite树枝构件<br>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。    </li>\n</ul>\n<p>这个说白了就是一个树形结构，不再具体使用例子了。     </p>\n","excerpt":"","more":"<p><strong>定义：</strong>组合模式（Composite Pattern）也叫合成模式，有时又叫做部分-整体模式（Part-Whole），主要是用来描述部分与整体的关系。确切的定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。   </p>\n<p>组合模式类图如下：    </p>\n<p><img src=\"/images/blog/composite-pattern.jpg\" alt=\"组合模式\">    </p>\n<p>组合模式有以下几个角色：   </p>\n<ul>\n<li>Component抽象构件角色<br>定义参加组合对象的共有方法和树形，可以定义一些默认的行为或属性。   </li>\n<li>Leaf叶子构件<br>叶子对象，下面没有其他分支，也就是最小的遍历单位。   </li>\n<li>Composite树枝构件<br>树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。    </li>\n</ul>\n<p>这个说白了就是一个树形结构，不再具体使用例子了。     </p>\n"},{"layout":"post","title":"设计模式:工厂（factory） in java","date":"2012-11-07T09:43:00.000Z","comments":1,"_content":"工厂模式，直接按名字来说，就是负责专门生产产品的。   \n大致分为3类： \n\n* 工厂方法\n* 简单工厂\n* 抽象工厂\n\n同时，也有人认为简单工厂只是工厂方法的一种特列，那么就分为两种了。本文就按3种分别进行介绍了。   \n###工厂方法###\n**定义：**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。  \n<!--more-->\n简单的说，就是有一个抽象类定义了一个方法，而实现类来决定到底初始化那个实例。这些实例，就是一个个产品了。   \n产品接口（主要是考虑面向接口变成吧，个人感觉不要也行，对理解模式没有影响）：   \n\n\tpublic interface IProduct {\n\t\tpublic void sayName();\n\t}\n下面呢，假设有两种产品：\n\t\n\tpublic class ProductA implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"I am ProductA\");\n\t\t}\n\t}\n\tpublic class ProductB implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\tSystem.out.println(\"I am productB\");\n\t\t}\n\t}\n有了产品定义，那么下面就要建一个工厂了，怎么建呢？依据定义来说，首先要定义一个接口了：   \n\n\tpublic abstract class AbstractProductFactory {\n\t\tpublic abstract <T extends IProduct> T createProduct(\n\t\t\tClass<T> productType);\n\t}\n下面就是一个子类了，也就是具体负责初始化实例的工厂了。\n\n\tpublic class ProductFactory extends AbstractProductFactory {\n\n\t\t@Override\n\t\tpublic <T extends IProduct> T createProduct(Class<T> productType) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tIProduct product = null;\n\t\t\ttry {\n\t\t\t\tproduct = productType.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) product;\n\t\t}\n\t}\n如何生成不同的产品呢，本例是根据传入的不同的类，来返回不同的实例的。当然了也可以用一个标识符了,如果传入的是“A”那么返回一个ProductA。诸如此类，这就是工厂方法了。  \n具体使用时，是这样的：   \n\n\tProductFactory productFactory = new ProductFactory();\n\tIProduct productA = productFactory.createProduct(ProductA.class);\n\tIProduct productB = productFactory.createProduct(ProductB.class);\n\tproductA.sayName();\n\tproductB.sayName();\n\n##简单工厂##\n简单工厂，可以说是工厂方法的一种扩展。上例中，发现在使用`ProductFactory`的时候，还需要先实例化一个。怎么那么麻烦呢？就像在实际生活中，我想要某个产品，我还需要先建一个工厂是一个道理的。   \n\n还好，Java提供了这样一个关键字`static`,简单工厂类就变成这个样子了。\n\n\tpublic class SimpleProductFactory {\n\n\t\tpublic static <T extends IProduct> T createProduct(Class<T> productType) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tIProduct product = null;\n\t\t\ttry {\n\t\t\t\tproduct = productType.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) product;\n\t\t}\n\t}\n这样在使用的时间是方便了不少呢？\n\n\tIProduct productA = SimpleProductFactory.createProduct(ProductA.class);\n\tIProduct productB = SimpleProductFactory.createProduct(ProductB.class);\n\tproductA.sayName();\n\tproductB.sayName();\n##抽象工厂##\n情况进一步发展，大家对美的追求不断提高。工厂也是需要对自己的产品不断升级的。那就对现有的产品ProductA，ProductB进行升级，各自推出红，蓝两种颜色的产品。那么，我就需要两个工厂了，一个工厂来生产红色产品，一个工厂来生产蓝色产品。   \n下面，先对产品进行改造：  \n\n\tpublic interface IProduct {\n\t\tpublic void sayName();\n\t\tpublic void sayColor();\n\t}\n\tpublic abstract class ProductA implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"I am ProductA\");\n\t\t}\n\t}\n\tpublic abstract class ProductB implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\tSystem.out.println(\"I am productB\");\n\t\t}\n\t}\n哎呀，貌似ProductA，ProductB没什么变化啊！还是有些变化的，都变为`abstract`了，也就是说他俩都是半成品，还没给上色呢。怎么能实例化，然后往外销售呢，这不坑人，影响工厂形象啊。当然了，没上色，那也没办法`sayColor`了，鬼知道将会涂成什么颜色。   \n\n好吧，有了半成品，现在进行上色操作。  \n\n\tpublic class RedProductA extends ProductA {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Red!\");\n\t\t}\n\t}\n\tpublic class BlueProductA extends ProductA {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Blue!\");\n\t\t}\n\t}\n\t\n\tpublic class RedProductB extends ProductB {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Red!\");\n\t\t}\n\t}\n\tpublic class BlueProductB extends ProductB {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Blue!\");\n\t\t}\n\t}\n到此为止，产品定义完成了。    \n下面就开建工厂了。一个**红色工厂**、一个**蓝色工厂**   \n先来个抽象的：   \n\t\n\tpublic abstract class AbstractProductFactory {\n\t\tpublic abstract IProduct createProductA();\n\n\t\tpublic abstract IProduct createProductB();\n\t}\n工厂就是为负责生产两种产品的了。\n\n\tpublic class RedProductFactory extends AbstractProductFactory {\n\n\t\t@Override\n\t\tpublic IProduct createProductA() {\n\t\t\treturn new RedProductA();\n\t\t}\n\n\t\t@Override\n\t\tpublic IProduct createProductB() {\n\t\t\treturn new RedProductB();\n\t\t}\n\t}\n\n\tpublic class BlueProductFactory  extends AbstractProductFactory{\n\t\t@Override\n\t\tpublic IProduct createProductA() {\n\t\t\treturn new BlueProductA();\n\t\t}\n\n\t\t@Override\n\t\tpublic IProduct createProductB() {\n\t\t\treturn new BlueProductB();\n\t\t}\n\t}\n那么，通过这两种工厂生产出的产品，不论是A,还是B，颜色铁定是一致的啊。\n使用场景如下：  \n\n\t\tRedProductFactory redProductFactory = new RedProductFactory();\n\t\tSystem.out.println(\"red factory is producing\");\n\t\tIProduct product1 = redProductFactory.createProductA();\n\t\tproduct1.sayName();\n\t\tproduct1.sayColor();\n\t\tIProduct product2 = redProductFactory.createProductB();\n\t\tproduct2.sayName();\n\t\tproduct2.sayColor();\n\t\t\n\t\tBlueProductFactory blueProductFactory = new BlueProductFactory();\n\t\tSystem.out.println(\"blue factory is producing\");\n\t\tIProduct product3 = blueProductFactory.createProductA();\n\t\tproduct3.sayName();\n\t\tproduct3.sayColor();\n\t\tIProduct product4 = blueProductFactory.createProductB();\n\t\tproduct4.sayName();\n\t\tproduct4.sayColor();\n\n这样两个工厂分别开工了，一个出的产品都是红色的，一个都是蓝色的。这就是**抽象工厂**了。\n##工厂模式 in JDK##\n\n\n\tClass.forName(String className);   \n\n这种应该就是简单工厂的典型了。依据不同的className来生产相应的对象，只不过这里是Class对象了，不要混淆。\n\n\tjavax.xml.parsers.DocumentBuilderFactory#newInstance()\n\tjavax.xml.transform.TransformerFactory#newInstance()\n\tjavax.xml.xpath.XPathFactory#newInstance()\n这几个为什么就是抽象工厂了呢？不理解。高人指点。\n\n---","source":"_posts/2012-11-02-factory-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式:工厂（factory） in java\"\ndate: 2012-11-07 17:43\ncomments: true\ncategories: 设计模式\ntags: [ Java, Factory ]\n---\n工厂模式，直接按名字来说，就是负责专门生产产品的。   \n大致分为3类： \n\n* 工厂方法\n* 简单工厂\n* 抽象工厂\n\n同时，也有人认为简单工厂只是工厂方法的一种特列，那么就分为两种了。本文就按3种分别进行介绍了。   \n###工厂方法###\n**定义：**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。  \n<!--more-->\n简单的说，就是有一个抽象类定义了一个方法，而实现类来决定到底初始化那个实例。这些实例，就是一个个产品了。   \n产品接口（主要是考虑面向接口变成吧，个人感觉不要也行，对理解模式没有影响）：   \n\n\tpublic interface IProduct {\n\t\tpublic void sayName();\n\t}\n下面呢，假设有两种产品：\n\t\n\tpublic class ProductA implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"I am ProductA\");\n\t\t}\n\t}\n\tpublic class ProductB implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\tSystem.out.println(\"I am productB\");\n\t\t}\n\t}\n有了产品定义，那么下面就要建一个工厂了，怎么建呢？依据定义来说，首先要定义一个接口了：   \n\n\tpublic abstract class AbstractProductFactory {\n\t\tpublic abstract <T extends IProduct> T createProduct(\n\t\t\tClass<T> productType);\n\t}\n下面就是一个子类了，也就是具体负责初始化实例的工厂了。\n\n\tpublic class ProductFactory extends AbstractProductFactory {\n\n\t\t@Override\n\t\tpublic <T extends IProduct> T createProduct(Class<T> productType) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tIProduct product = null;\n\t\t\ttry {\n\t\t\t\tproduct = productType.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) product;\n\t\t}\n\t}\n如何生成不同的产品呢，本例是根据传入的不同的类，来返回不同的实例的。当然了也可以用一个标识符了,如果传入的是“A”那么返回一个ProductA。诸如此类，这就是工厂方法了。  \n具体使用时，是这样的：   \n\n\tProductFactory productFactory = new ProductFactory();\n\tIProduct productA = productFactory.createProduct(ProductA.class);\n\tIProduct productB = productFactory.createProduct(ProductB.class);\n\tproductA.sayName();\n\tproductB.sayName();\n\n##简单工厂##\n简单工厂，可以说是工厂方法的一种扩展。上例中，发现在使用`ProductFactory`的时候，还需要先实例化一个。怎么那么麻烦呢？就像在实际生活中，我想要某个产品，我还需要先建一个工厂是一个道理的。   \n\n还好，Java提供了这样一个关键字`static`,简单工厂类就变成这个样子了。\n\n\tpublic class SimpleProductFactory {\n\n\t\tpublic static <T extends IProduct> T createProduct(Class<T> productType) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tIProduct product = null;\n\t\t\ttry {\n\t\t\t\tproduct = productType.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn (T) product;\n\t\t}\n\t}\n这样在使用的时间是方便了不少呢？\n\n\tIProduct productA = SimpleProductFactory.createProduct(ProductA.class);\n\tIProduct productB = SimpleProductFactory.createProduct(ProductB.class);\n\tproductA.sayName();\n\tproductB.sayName();\n##抽象工厂##\n情况进一步发展，大家对美的追求不断提高。工厂也是需要对自己的产品不断升级的。那就对现有的产品ProductA，ProductB进行升级，各自推出红，蓝两种颜色的产品。那么，我就需要两个工厂了，一个工厂来生产红色产品，一个工厂来生产蓝色产品。   \n下面，先对产品进行改造：  \n\n\tpublic interface IProduct {\n\t\tpublic void sayName();\n\t\tpublic void sayColor();\n\t}\n\tpublic abstract class ProductA implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"I am ProductA\");\n\t\t}\n\t}\n\tpublic abstract class ProductB implements IProduct {\n\t\t@Override\n\t\tpublic void sayName() {\n\t\t\tSystem.out.println(\"I am productB\");\n\t\t}\n\t}\n哎呀，貌似ProductA，ProductB没什么变化啊！还是有些变化的，都变为`abstract`了，也就是说他俩都是半成品，还没给上色呢。怎么能实例化，然后往外销售呢，这不坑人，影响工厂形象啊。当然了，没上色，那也没办法`sayColor`了，鬼知道将会涂成什么颜色。   \n\n好吧，有了半成品，现在进行上色操作。  \n\n\tpublic class RedProductA extends ProductA {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Red!\");\n\t\t}\n\t}\n\tpublic class BlueProductA extends ProductA {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Blue!\");\n\t\t}\n\t}\n\t\n\tpublic class RedProductB extends ProductB {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Red!\");\n\t\t}\n\t}\n\tpublic class BlueProductB extends ProductB {\n\t\t@Override\n\t\tpublic void sayColor() {\n\t\t\tSystem.out.println(\"my color is Blue!\");\n\t\t}\n\t}\n到此为止，产品定义完成了。    \n下面就开建工厂了。一个**红色工厂**、一个**蓝色工厂**   \n先来个抽象的：   \n\t\n\tpublic abstract class AbstractProductFactory {\n\t\tpublic abstract IProduct createProductA();\n\n\t\tpublic abstract IProduct createProductB();\n\t}\n工厂就是为负责生产两种产品的了。\n\n\tpublic class RedProductFactory extends AbstractProductFactory {\n\n\t\t@Override\n\t\tpublic IProduct createProductA() {\n\t\t\treturn new RedProductA();\n\t\t}\n\n\t\t@Override\n\t\tpublic IProduct createProductB() {\n\t\t\treturn new RedProductB();\n\t\t}\n\t}\n\n\tpublic class BlueProductFactory  extends AbstractProductFactory{\n\t\t@Override\n\t\tpublic IProduct createProductA() {\n\t\t\treturn new BlueProductA();\n\t\t}\n\n\t\t@Override\n\t\tpublic IProduct createProductB() {\n\t\t\treturn new BlueProductB();\n\t\t}\n\t}\n那么，通过这两种工厂生产出的产品，不论是A,还是B，颜色铁定是一致的啊。\n使用场景如下：  \n\n\t\tRedProductFactory redProductFactory = new RedProductFactory();\n\t\tSystem.out.println(\"red factory is producing\");\n\t\tIProduct product1 = redProductFactory.createProductA();\n\t\tproduct1.sayName();\n\t\tproduct1.sayColor();\n\t\tIProduct product2 = redProductFactory.createProductB();\n\t\tproduct2.sayName();\n\t\tproduct2.sayColor();\n\t\t\n\t\tBlueProductFactory blueProductFactory = new BlueProductFactory();\n\t\tSystem.out.println(\"blue factory is producing\");\n\t\tIProduct product3 = blueProductFactory.createProductA();\n\t\tproduct3.sayName();\n\t\tproduct3.sayColor();\n\t\tIProduct product4 = blueProductFactory.createProductB();\n\t\tproduct4.sayName();\n\t\tproduct4.sayColor();\n\n这样两个工厂分别开工了，一个出的产品都是红色的，一个都是蓝色的。这就是**抽象工厂**了。\n##工厂模式 in JDK##\n\n\n\tClass.forName(String className);   \n\n这种应该就是简单工厂的典型了。依据不同的className来生产相应的对象，只不过这里是Class对象了，不要混淆。\n\n\tjavax.xml.parsers.DocumentBuilderFactory#newInstance()\n\tjavax.xml.transform.TransformerFactory#newInstance()\n\tjavax.xml.xpath.XPathFactory#newInstance()\n这几个为什么就是抽象工厂了呢？不理解。高人指点。\n\n---","slug":"2012-11-02-factory-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3e002jv8fy1mvjaf6r","content":"<p>工厂模式，直接按名字来说，就是负责专门生产产品的。<br>大致分为3类： </p>\n<ul>\n<li>工厂方法</li>\n<li>简单工厂</li>\n<li>抽象工厂</li>\n</ul>\n<p>同时，也有人认为简单工厂只是工厂方法的一种特列，那么就分为两种了。本文就按3种分别进行介绍了。   </p>\n<p>###工厂方法###<br><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。<br><a id=\"more\"></a><br>简单的说，就是有一个抽象类定义了一个方法，而实现类来决定到底初始化那个实例。这些实例，就是一个个产品了。<br>产品接口（主要是考虑面向接口变成吧，个人感觉不要也行，对理解模式没有影响）：   </p>\n<pre><code>public interface IProduct {\n    public void sayName();\n}\n</code></pre><p>下面呢，假设有两种产品：</p>\n<pre><code>public class ProductA implements IProduct {\n    @Override\n    public void sayName() {\n        // TODO Auto-generated method stub\n        System.out.println(&quot;I am ProductA&quot;);\n    }\n}\npublic class ProductB implements IProduct {\n    @Override\n    public void sayName() {\n        System.out.println(&quot;I am productB&quot;);\n    }\n}\n</code></pre><p>有了产品定义，那么下面就要建一个工厂了，怎么建呢？依据定义来说，首先要定义一个接口了：   </p>\n<pre><code>public abstract class AbstractProductFactory {\n    public abstract &lt;T extends IProduct&gt; T createProduct(\n        Class&lt;T&gt; productType);\n}\n</code></pre><p>下面就是一个子类了，也就是具体负责初始化实例的工厂了。</p>\n<pre><code>public class ProductFactory extends AbstractProductFactory {\n\n    @Override\n    public &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {\n        // TODO Auto-generated method stub\n        IProduct product = null;\n        try {\n            product = productType.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n}\n</code></pre><p>如何生成不同的产品呢，本例是根据传入的不同的类，来返回不同的实例的。当然了也可以用一个标识符了,如果传入的是“A”那么返回一个ProductA。诸如此类，这就是工厂方法了。<br>具体使用时，是这样的：   </p>\n<pre><code>ProductFactory productFactory = new ProductFactory();\nIProduct productA = productFactory.createProduct(ProductA.class);\nIProduct productB = productFactory.createProduct(ProductB.class);\nproductA.sayName();\nproductB.sayName();\n</code></pre><p>##简单工厂##<br>简单工厂，可以说是工厂方法的一种扩展。上例中，发现在使用<code>ProductFactory</code>的时候，还需要先实例化一个。怎么那么麻烦呢？就像在实际生活中，我想要某个产品，我还需要先建一个工厂是一个道理的。   </p>\n<p>还好，Java提供了这样一个关键字<code>static</code>,简单工厂类就变成这个样子了。</p>\n<pre><code>public class SimpleProductFactory {\n\n    public static &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {\n        // TODO Auto-generated method stub\n        IProduct product = null;\n        try {\n            product = productType.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n}\n</code></pre><p>这样在使用的时间是方便了不少呢？</p>\n<pre><code>IProduct productA = SimpleProductFactory.createProduct(ProductA.class);\nIProduct productB = SimpleProductFactory.createProduct(ProductB.class);\nproductA.sayName();\nproductB.sayName();\n</code></pre><p>##抽象工厂##<br>情况进一步发展，大家对美的追求不断提高。工厂也是需要对自己的产品不断升级的。那就对现有的产品ProductA，ProductB进行升级，各自推出红，蓝两种颜色的产品。那么，我就需要两个工厂了，一个工厂来生产红色产品，一个工厂来生产蓝色产品。<br>下面，先对产品进行改造：  </p>\n<pre><code>public interface IProduct {\n    public void sayName();\n    public void sayColor();\n}\npublic abstract class ProductA implements IProduct {\n    @Override\n    public void sayName() {\n        // TODO Auto-generated method stub\n        System.out.println(&quot;I am ProductA&quot;);\n    }\n}\npublic abstract class ProductB implements IProduct {\n    @Override\n    public void sayName() {\n        System.out.println(&quot;I am productB&quot;);\n    }\n}\n</code></pre><p>哎呀，貌似ProductA，ProductB没什么变化啊！还是有些变化的，都变为<code>abstract</code>了，也就是说他俩都是半成品，还没给上色呢。怎么能实例化，然后往外销售呢，这不坑人，影响工厂形象啊。当然了，没上色，那也没办法<code>sayColor</code>了，鬼知道将会涂成什么颜色。   </p>\n<p>好吧，有了半成品，现在进行上色操作。  </p>\n<pre><code>public class RedProductA extends ProductA {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Red!&quot;);\n    }\n}\npublic class BlueProductA extends ProductA {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Blue!&quot;);\n    }\n}\n\npublic class RedProductB extends ProductB {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Red!&quot;);\n    }\n}\npublic class BlueProductB extends ProductB {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Blue!&quot;);\n    }\n}\n</code></pre><p>到此为止，产品定义完成了。<br>下面就开建工厂了。一个<strong>红色工厂</strong>、一个<strong>蓝色工厂</strong><br>先来个抽象的：   </p>\n<pre><code>public abstract class AbstractProductFactory {\n    public abstract IProduct createProductA();\n\n    public abstract IProduct createProductB();\n}\n</code></pre><p>工厂就是为负责生产两种产品的了。</p>\n<pre><code>public class RedProductFactory extends AbstractProductFactory {\n\n    @Override\n    public IProduct createProductA() {\n        return new RedProductA();\n    }\n\n    @Override\n    public IProduct createProductB() {\n        return new RedProductB();\n    }\n}\n\npublic class BlueProductFactory  extends AbstractProductFactory{\n    @Override\n    public IProduct createProductA() {\n        return new BlueProductA();\n    }\n\n    @Override\n    public IProduct createProductB() {\n        return new BlueProductB();\n    }\n}\n</code></pre><p>那么，通过这两种工厂生产出的产品，不论是A,还是B，颜色铁定是一致的啊。<br>使用场景如下：  </p>\n<pre><code>RedProductFactory redProductFactory = new RedProductFactory();\nSystem.out.println(&quot;red factory is producing&quot;);\nIProduct product1 = redProductFactory.createProductA();\nproduct1.sayName();\nproduct1.sayColor();\nIProduct product2 = redProductFactory.createProductB();\nproduct2.sayName();\nproduct2.sayColor();\n\nBlueProductFactory blueProductFactory = new BlueProductFactory();\nSystem.out.println(&quot;blue factory is producing&quot;);\nIProduct product3 = blueProductFactory.createProductA();\nproduct3.sayName();\nproduct3.sayColor();\nIProduct product4 = blueProductFactory.createProductB();\nproduct4.sayName();\nproduct4.sayColor();\n</code></pre><p>这样两个工厂分别开工了，一个出的产品都是红色的，一个都是蓝色的。这就是<strong>抽象工厂</strong>了。</p>\n<p>##工厂模式 in JDK##</p>\n<pre><code>Class.forName(String className);   \n</code></pre><p>这种应该就是简单工厂的典型了。依据不同的className来生产相应的对象，只不过这里是Class对象了，不要混淆。</p>\n<pre><code>javax.xml.parsers.DocumentBuilderFactory#newInstance()\njavax.xml.transform.TransformerFactory#newInstance()\njavax.xml.xpath.XPathFactory#newInstance()\n</code></pre><p>这几个为什么就是抽象工厂了呢？不理解。高人指点。</p>\n<hr>\n","excerpt":"<p>工厂模式，直接按名字来说，就是负责专门生产产品的。<br>大致分为3类： </p>\n<ul>\n<li>工厂方法</li>\n<li>简单工厂</li>\n<li>抽象工厂</li>\n</ul>\n<p>同时，也有人认为简单工厂只是工厂方法的一种特列，那么就分为两种了。本文就按3种分别进行介绍了。   </p>\n<p>###工厂方法###<br><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。<br>","more":"<br>简单的说，就是有一个抽象类定义了一个方法，而实现类来决定到底初始化那个实例。这些实例，就是一个个产品了。<br>产品接口（主要是考虑面向接口变成吧，个人感觉不要也行，对理解模式没有影响）：   </p>\n<pre><code>public interface IProduct {\n    public void sayName();\n}\n</code></pre><p>下面呢，假设有两种产品：</p>\n<pre><code>public class ProductA implements IProduct {\n    @Override\n    public void sayName() {\n        // TODO Auto-generated method stub\n        System.out.println(&quot;I am ProductA&quot;);\n    }\n}\npublic class ProductB implements IProduct {\n    @Override\n    public void sayName() {\n        System.out.println(&quot;I am productB&quot;);\n    }\n}\n</code></pre><p>有了产品定义，那么下面就要建一个工厂了，怎么建呢？依据定义来说，首先要定义一个接口了：   </p>\n<pre><code>public abstract class AbstractProductFactory {\n    public abstract &lt;T extends IProduct&gt; T createProduct(\n        Class&lt;T&gt; productType);\n}\n</code></pre><p>下面就是一个子类了，也就是具体负责初始化实例的工厂了。</p>\n<pre><code>public class ProductFactory extends AbstractProductFactory {\n\n    @Override\n    public &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {\n        // TODO Auto-generated method stub\n        IProduct product = null;\n        try {\n            product = productType.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n}\n</code></pre><p>如何生成不同的产品呢，本例是根据传入的不同的类，来返回不同的实例的。当然了也可以用一个标识符了,如果传入的是“A”那么返回一个ProductA。诸如此类，这就是工厂方法了。<br>具体使用时，是这样的：   </p>\n<pre><code>ProductFactory productFactory = new ProductFactory();\nIProduct productA = productFactory.createProduct(ProductA.class);\nIProduct productB = productFactory.createProduct(ProductB.class);\nproductA.sayName();\nproductB.sayName();\n</code></pre><p>##简单工厂##<br>简单工厂，可以说是工厂方法的一种扩展。上例中，发现在使用<code>ProductFactory</code>的时候，还需要先实例化一个。怎么那么麻烦呢？就像在实际生活中，我想要某个产品，我还需要先建一个工厂是一个道理的。   </p>\n<p>还好，Java提供了这样一个关键字<code>static</code>,简单工厂类就变成这个样子了。</p>\n<pre><code>public class SimpleProductFactory {\n\n    public static &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {\n        // TODO Auto-generated method stub\n        IProduct product = null;\n        try {\n            product = productType.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n}\n</code></pre><p>这样在使用的时间是方便了不少呢？</p>\n<pre><code>IProduct productA = SimpleProductFactory.createProduct(ProductA.class);\nIProduct productB = SimpleProductFactory.createProduct(ProductB.class);\nproductA.sayName();\nproductB.sayName();\n</code></pre><p>##抽象工厂##<br>情况进一步发展，大家对美的追求不断提高。工厂也是需要对自己的产品不断升级的。那就对现有的产品ProductA，ProductB进行升级，各自推出红，蓝两种颜色的产品。那么，我就需要两个工厂了，一个工厂来生产红色产品，一个工厂来生产蓝色产品。<br>下面，先对产品进行改造：  </p>\n<pre><code>public interface IProduct {\n    public void sayName();\n    public void sayColor();\n}\npublic abstract class ProductA implements IProduct {\n    @Override\n    public void sayName() {\n        // TODO Auto-generated method stub\n        System.out.println(&quot;I am ProductA&quot;);\n    }\n}\npublic abstract class ProductB implements IProduct {\n    @Override\n    public void sayName() {\n        System.out.println(&quot;I am productB&quot;);\n    }\n}\n</code></pre><p>哎呀，貌似ProductA，ProductB没什么变化啊！还是有些变化的，都变为<code>abstract</code>了，也就是说他俩都是半成品，还没给上色呢。怎么能实例化，然后往外销售呢，这不坑人，影响工厂形象啊。当然了，没上色，那也没办法<code>sayColor</code>了，鬼知道将会涂成什么颜色。   </p>\n<p>好吧，有了半成品，现在进行上色操作。  </p>\n<pre><code>public class RedProductA extends ProductA {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Red!&quot;);\n    }\n}\npublic class BlueProductA extends ProductA {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Blue!&quot;);\n    }\n}\n\npublic class RedProductB extends ProductB {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Red!&quot;);\n    }\n}\npublic class BlueProductB extends ProductB {\n    @Override\n    public void sayColor() {\n        System.out.println(&quot;my color is Blue!&quot;);\n    }\n}\n</code></pre><p>到此为止，产品定义完成了。<br>下面就开建工厂了。一个<strong>红色工厂</strong>、一个<strong>蓝色工厂</strong><br>先来个抽象的：   </p>\n<pre><code>public abstract class AbstractProductFactory {\n    public abstract IProduct createProductA();\n\n    public abstract IProduct createProductB();\n}\n</code></pre><p>工厂就是为负责生产两种产品的了。</p>\n<pre><code>public class RedProductFactory extends AbstractProductFactory {\n\n    @Override\n    public IProduct createProductA() {\n        return new RedProductA();\n    }\n\n    @Override\n    public IProduct createProductB() {\n        return new RedProductB();\n    }\n}\n\npublic class BlueProductFactory  extends AbstractProductFactory{\n    @Override\n    public IProduct createProductA() {\n        return new BlueProductA();\n    }\n\n    @Override\n    public IProduct createProductB() {\n        return new BlueProductB();\n    }\n}\n</code></pre><p>那么，通过这两种工厂生产出的产品，不论是A,还是B，颜色铁定是一致的啊。<br>使用场景如下：  </p>\n<pre><code>RedProductFactory redProductFactory = new RedProductFactory();\nSystem.out.println(&quot;red factory is producing&quot;);\nIProduct product1 = redProductFactory.createProductA();\nproduct1.sayName();\nproduct1.sayColor();\nIProduct product2 = redProductFactory.createProductB();\nproduct2.sayName();\nproduct2.sayColor();\n\nBlueProductFactory blueProductFactory = new BlueProductFactory();\nSystem.out.println(&quot;blue factory is producing&quot;);\nIProduct product3 = blueProductFactory.createProductA();\nproduct3.sayName();\nproduct3.sayColor();\nIProduct product4 = blueProductFactory.createProductB();\nproduct4.sayName();\nproduct4.sayColor();\n</code></pre><p>这样两个工厂分别开工了，一个出的产品都是红色的，一个都是蓝色的。这就是<strong>抽象工厂</strong>了。</p>\n<p>##工厂模式 in JDK##</p>\n<pre><code>Class.forName(String className);   \n</code></pre><p>这种应该就是简单工厂的典型了。依据不同的className来生产相应的对象，只不过这里是Class对象了，不要混淆。</p>\n<pre><code>javax.xml.parsers.DocumentBuilderFactory#newInstance()\njavax.xml.transform.TransformerFactory#newInstance()\njavax.xml.xpath.XPathFactory#newInstance()\n</code></pre><p>这几个为什么就是抽象工厂了呢？不理解。高人指点。</p>\n<hr>"},{"layout":"post","title":"设计模式：享元（flyweight） in java","date":"2012-11-02T12:07:00.000Z","comments":1,"_content":"**定义：**享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。    \n\n享元模式提出了2个要求：细粒度的对象和共享对象。    \n要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：    \n\n- 内部状态（intrinsic）    \n内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。    \n- 外部状态（extrinsic）   \n外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。    \n\n<!--more-->\n享元模式有以下几个角色：    \n\n- Flyweight抽象享元角色\n它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。\n- ConcreteFlyweight具体享元角色     \n具体的一个产品类，实现抽象角色定义的业务。\n- unsharedConcreteFlyweight不可共享的享元角色    \n不存在外部状态或者安全要求不能够使用共享技术\n- FlyweightFactory享元工厂    \n职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。    \n\n抽象享元角色：   \n\n    public abstract class Flyweight{\n        //内部状态\n        private String intrinstic;\n        //外部状态\n        protected final String Extrinsic;\n        //要求享元角色必须接受外部状态\n        public Flyweight(String _Extrinsic){\n            this.Extrinsic = _Extrinsic;\n        }\n        //定义业务操作\n        public abstract void operate();\n        \n        //内部状态的getter/setter\n        public String getIntrinsic(){\n            return intrinsic;\n        }\n        public void setIntrinsic(String intrinsic){\n            this.intrinsic = intrinsic\n        }\n    }\n\n具体享元角色：   \n\n    public class ConcreteFlyweight1 extends Flyweight{\n        //接受外部状态\n        public ConcreteFlyweight1(String _Extrinsic){\n            super(_Extrinsic);\n        }\n        //根据外部状态进行逻辑处理\n        public void operate(){\n            //todo\n        }    \n    }\n    \n    public class ConcreteFlyweight2 extends Flyweight{\n        //接受外部状态\n        public ConcreteFlyweight1(String _Extrinsic){\n            super(_Extrinsic);\n        }\n        //根据外部状态进行逻辑处理\n        public void operate(){\n            //todo\n        }    \n    }\n    \n享元工厂：    \n\n    public class FlyweightFactory{\n        //定义一个池容器\n        private static HashMap<String,Flyweight> pool = new HashMap<>(String,Flyweight);\n        //享元工厂\n        public static Flyweight getFlyweight(String Extrinsic){\n            //需要返回的对象\n            Flyweight flyweight = null;\n            //在池中没有该对象\n            if(pool.containsKey(Extrinsic)){\n                flyweight = pool.get(Extrinsic);\n            }else{\n                //根据外部状态创建享元对象\n                flyweight = new ConcreteFlyweight1(Extrinsic);\n                //放置到池中\n                pool.put(Extrinsic,flyweight);\n            }\n            return flyweight;\n        }\n        \n    }\n    \n享元模式的使用场景：   \n（1）系统中存在大量的相似对象     \n（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。       \n（3）需要缓冲池的场景。    ","source":"_posts/2012-11-02-flyweight-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：享元（flyweight） in java\"\ndate: 2012-11-02 20:07\ncomments: true\ncategories: 设计模式\ntags: [ flyweight, pattern, 享元 ]\n---\n**定义：**享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。    \n\n享元模式提出了2个要求：细粒度的对象和共享对象。    \n要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：    \n\n- 内部状态（intrinsic）    \n内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。    \n- 外部状态（extrinsic）   \n外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。    \n\n<!--more-->\n享元模式有以下几个角色：    \n\n- Flyweight抽象享元角色\n它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。\n- ConcreteFlyweight具体享元角色     \n具体的一个产品类，实现抽象角色定义的业务。\n- unsharedConcreteFlyweight不可共享的享元角色    \n不存在外部状态或者安全要求不能够使用共享技术\n- FlyweightFactory享元工厂    \n职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。    \n\n抽象享元角色：   \n\n    public abstract class Flyweight{\n        //内部状态\n        private String intrinstic;\n        //外部状态\n        protected final String Extrinsic;\n        //要求享元角色必须接受外部状态\n        public Flyweight(String _Extrinsic){\n            this.Extrinsic = _Extrinsic;\n        }\n        //定义业务操作\n        public abstract void operate();\n        \n        //内部状态的getter/setter\n        public String getIntrinsic(){\n            return intrinsic;\n        }\n        public void setIntrinsic(String intrinsic){\n            this.intrinsic = intrinsic\n        }\n    }\n\n具体享元角色：   \n\n    public class ConcreteFlyweight1 extends Flyweight{\n        //接受外部状态\n        public ConcreteFlyweight1(String _Extrinsic){\n            super(_Extrinsic);\n        }\n        //根据外部状态进行逻辑处理\n        public void operate(){\n            //todo\n        }    \n    }\n    \n    public class ConcreteFlyweight2 extends Flyweight{\n        //接受外部状态\n        public ConcreteFlyweight1(String _Extrinsic){\n            super(_Extrinsic);\n        }\n        //根据外部状态进行逻辑处理\n        public void operate(){\n            //todo\n        }    \n    }\n    \n享元工厂：    \n\n    public class FlyweightFactory{\n        //定义一个池容器\n        private static HashMap<String,Flyweight> pool = new HashMap<>(String,Flyweight);\n        //享元工厂\n        public static Flyweight getFlyweight(String Extrinsic){\n            //需要返回的对象\n            Flyweight flyweight = null;\n            //在池中没有该对象\n            if(pool.containsKey(Extrinsic)){\n                flyweight = pool.get(Extrinsic);\n            }else{\n                //根据外部状态创建享元对象\n                flyweight = new ConcreteFlyweight1(Extrinsic);\n                //放置到池中\n                pool.put(Extrinsic,flyweight);\n            }\n            return flyweight;\n        }\n        \n    }\n    \n享元模式的使用场景：   \n（1）系统中存在大量的相似对象     \n（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。       \n（3）需要缓冲池的场景。    ","slug":"2012-11-02-flyweight-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3g002nv8fycnx92dm2","content":"<p><strong>定义：</strong>享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。    </p>\n<p>享元模式提出了2个要求：细粒度的对象和共享对象。<br>要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：    </p>\n<ul>\n<li>内部状态（intrinsic）<br>内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。    </li>\n<li>外部状态（extrinsic）<br>外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。    </li>\n</ul>\n<a id=\"more\"></a>\n<p>享元模式有以下几个角色：    </p>\n<ul>\n<li>Flyweight抽象享元角色<br>它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>\n<li>ConcreteFlyweight具体享元角色<br>具体的一个产品类，实现抽象角色定义的业务。</li>\n<li>unsharedConcreteFlyweight不可共享的享元角色<br>不存在外部状态或者安全要求不能够使用共享技术</li>\n<li>FlyweightFactory享元工厂<br>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。    </li>\n</ul>\n<p>抽象享元角色：   </p>\n<pre><code>public abstract class Flyweight{\n    //内部状态\n    private String intrinstic;\n    //外部状态\n    protected final String Extrinsic;\n    //要求享元角色必须接受外部状态\n    public Flyweight(String _Extrinsic){\n        this.Extrinsic = _Extrinsic;\n    }\n    //定义业务操作\n    public abstract void operate();\n\n    //内部状态的getter/setter\n    public String getIntrinsic(){\n        return intrinsic;\n    }\n    public void setIntrinsic(String intrinsic){\n        this.intrinsic = intrinsic\n    }\n}\n</code></pre><p>具体享元角色：   </p>\n<pre><code>public class ConcreteFlyweight1 extends Flyweight{\n    //接受外部状态\n    public ConcreteFlyweight1(String _Extrinsic){\n        super(_Extrinsic);\n    }\n    //根据外部状态进行逻辑处理\n    public void operate(){\n        //todo\n    }    \n}\n\npublic class ConcreteFlyweight2 extends Flyweight{\n    //接受外部状态\n    public ConcreteFlyweight1(String _Extrinsic){\n        super(_Extrinsic);\n    }\n    //根据外部状态进行逻辑处理\n    public void operate(){\n        //todo\n    }    \n}\n</code></pre><p>享元工厂：    </p>\n<pre><code>public class FlyweightFactory{\n    //定义一个池容器\n    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;&gt;(String,Flyweight);\n    //享元工厂\n    public static Flyweight getFlyweight(String Extrinsic){\n        //需要返回的对象\n        Flyweight flyweight = null;\n        //在池中没有该对象\n        if(pool.containsKey(Extrinsic)){\n            flyweight = pool.get(Extrinsic);\n        }else{\n            //根据外部状态创建享元对象\n            flyweight = new ConcreteFlyweight1(Extrinsic);\n            //放置到池中\n            pool.put(Extrinsic,flyweight);\n        }\n        return flyweight;\n    }\n\n}\n</code></pre><p>享元模式的使用场景：<br>（1）系统中存在大量的相似对象<br>（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>（3）需要缓冲池的场景。    </p>\n","excerpt":"<p><strong>定义：</strong>享元模式（Flyweight Pattern）是池技术的重要实现方式。使用共享对象可有效地支持大量的细粒度的对象。    </p>\n<p>享元模式提出了2个要求：细粒度的对象和共享对象。<br>要求细粒度对象，那么不可避免地使用对象数量多且性质相近。可以将这些对象分为2个部分：    </p>\n<ul>\n<li>内部状态（intrinsic）<br>内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。它们可以作为一个对象的动态附加信息，不必直接储存在具体的某个对象中，属于可以共享的部分。    </li>\n<li>外部状态（extrinsic）<br>外部状态是对象得以依赖的一个标记，是随环境改变而改变的，不可以共享的状态。    </li>\n</ul>","more":"<p>享元模式有以下几个角色：    </p>\n<ul>\n<li>Flyweight抽象享元角色<br>它简单说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。</li>\n<li>ConcreteFlyweight具体享元角色<br>具体的一个产品类，实现抽象角色定义的业务。</li>\n<li>unsharedConcreteFlyweight不可共享的享元角色<br>不存在外部状态或者安全要求不能够使用共享技术</li>\n<li>FlyweightFactory享元工厂<br>职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。    </li>\n</ul>\n<p>抽象享元角色：   </p>\n<pre><code>public abstract class Flyweight{\n    //内部状态\n    private String intrinstic;\n    //外部状态\n    protected final String Extrinsic;\n    //要求享元角色必须接受外部状态\n    public Flyweight(String _Extrinsic){\n        this.Extrinsic = _Extrinsic;\n    }\n    //定义业务操作\n    public abstract void operate();\n\n    //内部状态的getter/setter\n    public String getIntrinsic(){\n        return intrinsic;\n    }\n    public void setIntrinsic(String intrinsic){\n        this.intrinsic = intrinsic\n    }\n}\n</code></pre><p>具体享元角色：   </p>\n<pre><code>public class ConcreteFlyweight1 extends Flyweight{\n    //接受外部状态\n    public ConcreteFlyweight1(String _Extrinsic){\n        super(_Extrinsic);\n    }\n    //根据外部状态进行逻辑处理\n    public void operate(){\n        //todo\n    }    \n}\n\npublic class ConcreteFlyweight2 extends Flyweight{\n    //接受外部状态\n    public ConcreteFlyweight1(String _Extrinsic){\n        super(_Extrinsic);\n    }\n    //根据外部状态进行逻辑处理\n    public void operate(){\n        //todo\n    }    \n}\n</code></pre><p>享元工厂：    </p>\n<pre><code>public class FlyweightFactory{\n    //定义一个池容器\n    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;&gt;(String,Flyweight);\n    //享元工厂\n    public static Flyweight getFlyweight(String Extrinsic){\n        //需要返回的对象\n        Flyweight flyweight = null;\n        //在池中没有该对象\n        if(pool.containsKey(Extrinsic)){\n            flyweight = pool.get(Extrinsic);\n        }else{\n            //根据外部状态创建享元对象\n            flyweight = new ConcreteFlyweight1(Extrinsic);\n            //放置到池中\n            pool.put(Extrinsic,flyweight);\n        }\n        return flyweight;\n    }\n\n}\n</code></pre><p>享元模式的使用场景：<br>（1）系统中存在大量的相似对象<br>（2）细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>（3）需要缓冲池的场景。    </p>"},{"layout":"post","title":"Selenium WebDriver 工作原理","date":"2012-11-02T10:26:00.000Z","comments":1,"_content":"WebDriver与之前Selenium的JS注入实现不同，直接利用了浏览器native support来操作浏览器。所以对于不同平台，不同的浏览器，必须依赖一个特定的浏览器的native component来实现把WebDriver API的调用转化为浏览器的native invoke。   \nSelenium采用Javascript的合成事件来处理操作，比如要点击某个元素，JS会定位到这个元素然后触发onclick事件。而WebDriver使用的是系统的原生支持，首先是找到这个元素，然后找到它的location,并在这个座标点触发一个左键点击操作。因此，可以看出WebDriver能更好的模拟真实的环境。也正因为这个区别，有些hidden的元素是可以使用Selenium操作的，但是WebDriver缺不行，会报一个cannot clickable类似的错误。    \n<!--more-->\n\n在我们新建一个WebDriver的过程中，Selenium首先会确认浏览器的native component是否存在可用而且版本匹配。接着就在目标浏览器里启动一整套Web Service，这套Web Service使用了Selenium自己设计定义的协议，名字叫做The WebDriver Wire Protocol。这套协议非常之强大，几乎可以操作浏览器做任何事情，包括打开、关闭、最大化、最小化、元素定位、元素点击、上传文件等等。\n\nWebDriver Wire协议是通用的，也就是说不管是FirefoxDriver还是ChromeDriver，启动之后都会在某一个端口启动基于这套协议的Web Service。例如FirefoxDriver初始化成功之后，默认会从http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP request给监听端口上的Web Service。在我们的HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做社么事情。\n\nWebDriver的工作原理图：\n\n![WebDriver工作原理图](/images/blog/webdriver-works.png)\n\n从上图中我们可以看出，不同浏览器的WebDriver子类，都需要依赖特定的浏览器原生组件，例如Firefox就需要一个add-on名字叫webdriver.xpi，这个是直接集成在jar包内的，我猜想selenium IDE也是需要这个来支持的。而IE的话就需要用到一个dll文件来转化Web Service的命令为浏览器native的调用，以及IEDriver来保证32-64的支持。另外，图中还标明了WebDriver Wire协议是一套基于RESTful的web service。\n\n关于WebDriver Wire协议的细节，比如希望了解这套Web Service能够做哪些事情，可以阅读Selenium官方的协议文档， 在Selenium的源码中，我们可以找到一个HttpCommandExecutor这个类，里面维护了一个Map<String, CommandInfo>，它负责将一个个代表命令的简单字符串key，转化为相应的URL，因为REST的理念是将所有的操作视作一个个状态，每一个状态对应一个URI。所以当我们以特定的URL发送HTTP request给这个RESTful web service之后，它就能解析出需要执行的操作。截取一段源码如下：   \n\n\tnameToUrl = ImmutableMap.<String, CommandInfo>builder()  \n        .put(NEW_SESSION, post(\"/session\"))  \n        .put(QUIT, delete(\"/session/:sessionId\"))  \n        .put(GET_CURRENT_WINDOW_HANDLE, get(\"/session/:sessionId/window_handle\"))  \n        .put(GET_WINDOW_HANDLES, get(\"/session/:sessionId/window_handles\"))  \n        .put(GET, post(\"/session/:sessionId/url\"))  \n  \t\t\t// The Alert API is still experimental and should not be used.  \n        .put(GET_ALERT, get(\"/session/:sessionId/alert\"))  \n        .put(DISMISS_ALERT, post(\"/session/:sessionId/dismiss_alert\"))  \n        .put(ACCEPT_ALERT, post(\"/session/:sessionId/accept_alert\"))  \n        .put(GET_ALERT_TEXT, get(\"/session/:sessionId/alert_text\"))  \n        .put(SET_ALERT_VALUE, post(\"/session/:sessionId/alert_text\"))  \n\n可以看到实际发送的URL都是相对路径，后缀多以/session/:sessionId开头，这也意味着WebDriver每次启动浏览器都会分配一个独立的sessionId，多线程并行的时候彼此之间不会有冲突和干扰。例如我们最常用的一个WebDriver的API，findWebElement在这里就会转化为/session/:sessionId/element这个URL，然后在发出的HTTP request body内再附上具体的参数比如by ID还是CSS还是Xpath，各自的值又是什么。收到并执行了这个操作之后，也会回复一个HTTP response。内容也是JSON，会返回找到的WebElement的各种细节，比如text、CSS selector、tag name、class name等等。以下是解析我们说的HTTP response的代码片段：\n\n\ttry {  \n        response = new JsonToBeanConverter().convert(Response.class, responseAsText);  \n      } catch (ClassCastException e) {  \n        if (responseAsText != null && \"\".equals(responseAsText)) {  \n          // The remote server has died, but has already set some headers.  \n          // Normally this occurs when the final window of the firefox driver  \n          // is closed on OS X. Return null, as the return value _should_ be  \n          // being ignored. This is not an elegant solution.  \n          return null;  \n        }  \n        throw new WebDriverException(\"Cannot convert text to response: \" + responseAsText, e);  \n      } //...  \n\n相信总结到这里，应该对WebDriver的运行原理应该清楚了。Server端就是一个RESTFul的WebService，客户端代码只需调用就可以了。这也解释了为什么WebDriver能支持那么多语言了，只要能发HTTP请求就可以实现，甚至自己封装一套API都是可以的。Github上的WebDriverJS就是一套JS版的WebDriver。    \n\n参考：<http://blog.csdn.net/ant_yan/article/details/7970793>\n","source":"_posts/2012-11-02-how-webdriver-works.markdown","raw":"---\nlayout: post\ntitle: \"Selenium WebDriver 工作原理\"\ndate: 2012-11-02 18:26\ncomments: true\ncategories: selenium\ntags: [ webdriver , selenium  ]\n---\nWebDriver与之前Selenium的JS注入实现不同，直接利用了浏览器native support来操作浏览器。所以对于不同平台，不同的浏览器，必须依赖一个特定的浏览器的native component来实现把WebDriver API的调用转化为浏览器的native invoke。   \nSelenium采用Javascript的合成事件来处理操作，比如要点击某个元素，JS会定位到这个元素然后触发onclick事件。而WebDriver使用的是系统的原生支持，首先是找到这个元素，然后找到它的location,并在这个座标点触发一个左键点击操作。因此，可以看出WebDriver能更好的模拟真实的环境。也正因为这个区别，有些hidden的元素是可以使用Selenium操作的，但是WebDriver缺不行，会报一个cannot clickable类似的错误。    \n<!--more-->\n\n在我们新建一个WebDriver的过程中，Selenium首先会确认浏览器的native component是否存在可用而且版本匹配。接着就在目标浏览器里启动一整套Web Service，这套Web Service使用了Selenium自己设计定义的协议，名字叫做The WebDriver Wire Protocol。这套协议非常之强大，几乎可以操作浏览器做任何事情，包括打开、关闭、最大化、最小化、元素定位、元素点击、上传文件等等。\n\nWebDriver Wire协议是通用的，也就是说不管是FirefoxDriver还是ChromeDriver，启动之后都会在某一个端口启动基于这套协议的Web Service。例如FirefoxDriver初始化成功之后，默认会从http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP request给监听端口上的Web Service。在我们的HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做社么事情。\n\nWebDriver的工作原理图：\n\n![WebDriver工作原理图](/images/blog/webdriver-works.png)\n\n从上图中我们可以看出，不同浏览器的WebDriver子类，都需要依赖特定的浏览器原生组件，例如Firefox就需要一个add-on名字叫webdriver.xpi，这个是直接集成在jar包内的，我猜想selenium IDE也是需要这个来支持的。而IE的话就需要用到一个dll文件来转化Web Service的命令为浏览器native的调用，以及IEDriver来保证32-64的支持。另外，图中还标明了WebDriver Wire协议是一套基于RESTful的web service。\n\n关于WebDriver Wire协议的细节，比如希望了解这套Web Service能够做哪些事情，可以阅读Selenium官方的协议文档， 在Selenium的源码中，我们可以找到一个HttpCommandExecutor这个类，里面维护了一个Map<String, CommandInfo>，它负责将一个个代表命令的简单字符串key，转化为相应的URL，因为REST的理念是将所有的操作视作一个个状态，每一个状态对应一个URI。所以当我们以特定的URL发送HTTP request给这个RESTful web service之后，它就能解析出需要执行的操作。截取一段源码如下：   \n\n\tnameToUrl = ImmutableMap.<String, CommandInfo>builder()  \n        .put(NEW_SESSION, post(\"/session\"))  \n        .put(QUIT, delete(\"/session/:sessionId\"))  \n        .put(GET_CURRENT_WINDOW_HANDLE, get(\"/session/:sessionId/window_handle\"))  \n        .put(GET_WINDOW_HANDLES, get(\"/session/:sessionId/window_handles\"))  \n        .put(GET, post(\"/session/:sessionId/url\"))  \n  \t\t\t// The Alert API is still experimental and should not be used.  \n        .put(GET_ALERT, get(\"/session/:sessionId/alert\"))  \n        .put(DISMISS_ALERT, post(\"/session/:sessionId/dismiss_alert\"))  \n        .put(ACCEPT_ALERT, post(\"/session/:sessionId/accept_alert\"))  \n        .put(GET_ALERT_TEXT, get(\"/session/:sessionId/alert_text\"))  \n        .put(SET_ALERT_VALUE, post(\"/session/:sessionId/alert_text\"))  \n\n可以看到实际发送的URL都是相对路径，后缀多以/session/:sessionId开头，这也意味着WebDriver每次启动浏览器都会分配一个独立的sessionId，多线程并行的时候彼此之间不会有冲突和干扰。例如我们最常用的一个WebDriver的API，findWebElement在这里就会转化为/session/:sessionId/element这个URL，然后在发出的HTTP request body内再附上具体的参数比如by ID还是CSS还是Xpath，各自的值又是什么。收到并执行了这个操作之后，也会回复一个HTTP response。内容也是JSON，会返回找到的WebElement的各种细节，比如text、CSS selector、tag name、class name等等。以下是解析我们说的HTTP response的代码片段：\n\n\ttry {  \n        response = new JsonToBeanConverter().convert(Response.class, responseAsText);  \n      } catch (ClassCastException e) {  \n        if (responseAsText != null && \"\".equals(responseAsText)) {  \n          // The remote server has died, but has already set some headers.  \n          // Normally this occurs when the final window of the firefox driver  \n          // is closed on OS X. Return null, as the return value _should_ be  \n          // being ignored. This is not an elegant solution.  \n          return null;  \n        }  \n        throw new WebDriverException(\"Cannot convert text to response: \" + responseAsText, e);  \n      } //...  \n\n相信总结到这里，应该对WebDriver的运行原理应该清楚了。Server端就是一个RESTFul的WebService，客户端代码只需调用就可以了。这也解释了为什么WebDriver能支持那么多语言了，只要能发HTTP请求就可以实现，甚至自己封装一套API都是可以的。Github上的WebDriverJS就是一套JS版的WebDriver。    \n\n参考：<http://blog.csdn.net/ant_yan/article/details/7970793>\n","slug":"2012-11-02-how-webdriver-works","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3h002qv8fye3fxp4vs","content":"<p>WebDriver与之前Selenium的JS注入实现不同，直接利用了浏览器native support来操作浏览器。所以对于不同平台，不同的浏览器，必须依赖一个特定的浏览器的native component来实现把WebDriver API的调用转化为浏览器的native invoke。<br>Selenium采用Javascript的合成事件来处理操作，比如要点击某个元素，JS会定位到这个元素然后触发onclick事件。而WebDriver使用的是系统的原生支持，首先是找到这个元素，然后找到它的location,并在这个座标点触发一个左键点击操作。因此，可以看出WebDriver能更好的模拟真实的环境。也正因为这个区别，有些hidden的元素是可以使用Selenium操作的，但是WebDriver缺不行，会报一个cannot clickable类似的错误。<br><a id=\"more\"></a></p>\n<p>在我们新建一个WebDriver的过程中，Selenium首先会确认浏览器的native component是否存在可用而且版本匹配。接着就在目标浏览器里启动一整套Web Service，这套Web Service使用了Selenium自己设计定义的协议，名字叫做The WebDriver Wire Protocol。这套协议非常之强大，几乎可以操作浏览器做任何事情，包括打开、关闭、最大化、最小化、元素定位、元素点击、上传文件等等。</p>\n<p>WebDriver Wire协议是通用的，也就是说不管是FirefoxDriver还是ChromeDriver，启动之后都会在某一个端口启动基于这套协议的Web Service。例如FirefoxDriver初始化成功之后，默认会从<a href=\"http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP\" target=\"_blank\" rel=\"external\">http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP</a> request给监听端口上的Web Service。在我们的HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做社么事情。</p>\n<p>WebDriver的工作原理图：</p>\n<p><img src=\"/images/blog/webdriver-works.png\" alt=\"WebDriver工作原理图\"></p>\n<p>从上图中我们可以看出，不同浏览器的WebDriver子类，都需要依赖特定的浏览器原生组件，例如Firefox就需要一个add-on名字叫webdriver.xpi，这个是直接集成在jar包内的，我猜想selenium IDE也是需要这个来支持的。而IE的话就需要用到一个dll文件来转化Web Service的命令为浏览器native的调用，以及IEDriver来保证32-64的支持。另外，图中还标明了WebDriver Wire协议是一套基于RESTful的web service。</p>\n<p>关于WebDriver Wire协议的细节，比如希望了解这套Web Service能够做哪些事情，可以阅读Selenium官方的协议文档， 在Selenium的源码中，我们可以找到一个HttpCommandExecutor这个类，里面维护了一个Map<string, commandinfo=\"\">，它负责将一个个代表命令的简单字符串key，转化为相应的URL，因为REST的理念是将所有的操作视作一个个状态，每一个状态对应一个URI。所以当我们以特定的URL发送HTTP request给这个RESTful web service之后，它就能解析出需要执行的操作。截取一段源码如下：   </string,></p>\n<pre><code>nameToUrl = ImmutableMap.&lt;String, CommandInfo&gt;builder()  \n    .put(NEW_SESSION, post(&quot;/session&quot;))  \n    .put(QUIT, delete(&quot;/session/:sessionId&quot;))  \n    .put(GET_CURRENT_WINDOW_HANDLE, get(&quot;/session/:sessionId/window_handle&quot;))  \n    .put(GET_WINDOW_HANDLES, get(&quot;/session/:sessionId/window_handles&quot;))  \n    .put(GET, post(&quot;/session/:sessionId/url&quot;))  \n          // The Alert API is still experimental and should not be used.  \n    .put(GET_ALERT, get(&quot;/session/:sessionId/alert&quot;))  \n    .put(DISMISS_ALERT, post(&quot;/session/:sessionId/dismiss_alert&quot;))  \n    .put(ACCEPT_ALERT, post(&quot;/session/:sessionId/accept_alert&quot;))  \n    .put(GET_ALERT_TEXT, get(&quot;/session/:sessionId/alert_text&quot;))  \n    .put(SET_ALERT_VALUE, post(&quot;/session/:sessionId/alert_text&quot;))  \n</code></pre><p>可以看到实际发送的URL都是相对路径，后缀多以/session/:sessionId开头，这也意味着WebDriver每次启动浏览器都会分配一个独立的sessionId，多线程并行的时候彼此之间不会有冲突和干扰。例如我们最常用的一个WebDriver的API，findWebElement在这里就会转化为/session/:sessionId/element这个URL，然后在发出的HTTP request body内再附上具体的参数比如by ID还是CSS还是Xpath，各自的值又是什么。收到并执行了这个操作之后，也会回复一个HTTP response。内容也是JSON，会返回找到的WebElement的各种细节，比如text、CSS selector、tag name、class name等等。以下是解析我们说的HTTP response的代码片段：</p>\n<pre><code>try {  \n    response = new JsonToBeanConverter().convert(Response.class, responseAsText);  \n  } catch (ClassCastException e) {  \n    if (responseAsText != null &amp;&amp; &quot;&quot;.equals(responseAsText)) {  \n      // The remote server has died, but has already set some headers.  \n      // Normally this occurs when the final window of the firefox driver  \n      // is closed on OS X. Return null, as the return value _should_ be  \n      // being ignored. This is not an elegant solution.  \n      return null;  \n    }  \n    throw new WebDriverException(&quot;Cannot convert text to response: &quot; + responseAsText, e);  \n  } //...  \n</code></pre><p>相信总结到这里，应该对WebDriver的运行原理应该清楚了。Server端就是一个RESTFul的WebService，客户端代码只需调用就可以了。这也解释了为什么WebDriver能支持那么多语言了，只要能发HTTP请求就可以实现，甚至自己封装一套API都是可以的。Github上的WebDriverJS就是一套JS版的WebDriver。    </p>\n<p>参考：<a href=\"http://blog.csdn.net/ant_yan/article/details/7970793\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ant_yan/article/details/7970793</a></p>\n","excerpt":"<p>WebDriver与之前Selenium的JS注入实现不同，直接利用了浏览器native support来操作浏览器。所以对于不同平台，不同的浏览器，必须依赖一个特定的浏览器的native component来实现把WebDriver API的调用转化为浏览器的native invoke。<br>Selenium采用Javascript的合成事件来处理操作，比如要点击某个元素，JS会定位到这个元素然后触发onclick事件。而WebDriver使用的是系统的原生支持，首先是找到这个元素，然后找到它的location,并在这个座标点触发一个左键点击操作。因此，可以看出WebDriver能更好的模拟真实的环境。也正因为这个区别，有些hidden的元素是可以使用Selenium操作的，但是WebDriver缺不行，会报一个cannot clickable类似的错误。<br>","more":"</p>\n<p>在我们新建一个WebDriver的过程中，Selenium首先会确认浏览器的native component是否存在可用而且版本匹配。接着就在目标浏览器里启动一整套Web Service，这套Web Service使用了Selenium自己设计定义的协议，名字叫做The WebDriver Wire Protocol。这套协议非常之强大，几乎可以操作浏览器做任何事情，包括打开、关闭、最大化、最小化、元素定位、元素点击、上传文件等等。</p>\n<p>WebDriver Wire协议是通用的，也就是说不管是FirefoxDriver还是ChromeDriver，启动之后都会在某一个端口启动基于这套协议的Web Service。例如FirefoxDriver初始化成功之后，默认会从<a href=\"http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP\">http://localhost:7055开始，而ChromeDriver则大概是http://localhost:46350之类的。接下来，我们调用WebDriver的任何API，都需要借助一个ComandExecutor发送一个命令，实际上是一个HTTP</a> request给监听端口上的Web Service。在我们的HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做社么事情。</p>\n<p>WebDriver的工作原理图：</p>\n<p><img src=\"/images/blog/webdriver-works.png\" alt=\"WebDriver工作原理图\"></p>\n<p>从上图中我们可以看出，不同浏览器的WebDriver子类，都需要依赖特定的浏览器原生组件，例如Firefox就需要一个add-on名字叫webdriver.xpi，这个是直接集成在jar包内的，我猜想selenium IDE也是需要这个来支持的。而IE的话就需要用到一个dll文件来转化Web Service的命令为浏览器native的调用，以及IEDriver来保证32-64的支持。另外，图中还标明了WebDriver Wire协议是一套基于RESTful的web service。</p>\n<p>关于WebDriver Wire协议的细节，比如希望了解这套Web Service能够做哪些事情，可以阅读Selenium官方的协议文档， 在Selenium的源码中，我们可以找到一个HttpCommandExecutor这个类，里面维护了一个Map<String, CommandInfo>，它负责将一个个代表命令的简单字符串key，转化为相应的URL，因为REST的理念是将所有的操作视作一个个状态，每一个状态对应一个URI。所以当我们以特定的URL发送HTTP request给这个RESTful web service之后，它就能解析出需要执行的操作。截取一段源码如下：   </p>\n<pre><code>nameToUrl = ImmutableMap.&lt;String, CommandInfo&gt;builder()  \n    .put(NEW_SESSION, post(&quot;/session&quot;))  \n    .put(QUIT, delete(&quot;/session/:sessionId&quot;))  \n    .put(GET_CURRENT_WINDOW_HANDLE, get(&quot;/session/:sessionId/window_handle&quot;))  \n    .put(GET_WINDOW_HANDLES, get(&quot;/session/:sessionId/window_handles&quot;))  \n    .put(GET, post(&quot;/session/:sessionId/url&quot;))  \n          // The Alert API is still experimental and should not be used.  \n    .put(GET_ALERT, get(&quot;/session/:sessionId/alert&quot;))  \n    .put(DISMISS_ALERT, post(&quot;/session/:sessionId/dismiss_alert&quot;))  \n    .put(ACCEPT_ALERT, post(&quot;/session/:sessionId/accept_alert&quot;))  \n    .put(GET_ALERT_TEXT, get(&quot;/session/:sessionId/alert_text&quot;))  \n    .put(SET_ALERT_VALUE, post(&quot;/session/:sessionId/alert_text&quot;))  \n</code></pre><p>可以看到实际发送的URL都是相对路径，后缀多以/session/:sessionId开头，这也意味着WebDriver每次启动浏览器都会分配一个独立的sessionId，多线程并行的时候彼此之间不会有冲突和干扰。例如我们最常用的一个WebDriver的API，findWebElement在这里就会转化为/session/:sessionId/element这个URL，然后在发出的HTTP request body内再附上具体的参数比如by ID还是CSS还是Xpath，各自的值又是什么。收到并执行了这个操作之后，也会回复一个HTTP response。内容也是JSON，会返回找到的WebElement的各种细节，比如text、CSS selector、tag name、class name等等。以下是解析我们说的HTTP response的代码片段：</p>\n<pre><code>try {  \n    response = new JsonToBeanConverter().convert(Response.class, responseAsText);  \n  } catch (ClassCastException e) {  \n    if (responseAsText != null &amp;&amp; &quot;&quot;.equals(responseAsText)) {  \n      // The remote server has died, but has already set some headers.  \n      // Normally this occurs when the final window of the firefox driver  \n      // is closed on OS X. Return null, as the return value _should_ be  \n      // being ignored. This is not an elegant solution.  \n      return null;  \n    }  \n    throw new WebDriverException(&quot;Cannot convert text to response: &quot; + responseAsText, e);  \n  } //...  \n</code></pre><p>相信总结到这里，应该对WebDriver的运行原理应该清楚了。Server端就是一个RESTFul的WebService，客户端代码只需调用就可以了。这也解释了为什么WebDriver能支持那么多语言了，只要能发HTTP请求就可以实现，甚至自己封装一套API都是可以的。Github上的WebDriverJS就是一套JS版的WebDriver。    </p>\n<p>参考：<a href=\"http://blog.csdn.net/ant_yan/article/details/7970793\">http://blog.csdn.net/ant_yan/article/details/7970793</a></p>"},{"layout":"post","title":"设计模式：解释器（interpreter） in java","date":"2012-11-02T12:09:00.000Z","comments":1,"_content":"**定义：**解释器模式是一种按照规定语法进行解析的方案，在现在项目中使用较少。正式定义：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子。    \n\n解释器模式有以下几个角色：    \n\n- AbstractExpression抽象解释器     \n具体的解释任务由各个实现类完成。\n- TerminalExpression终结符表达式    \n实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。\n- NonterminalExpression非终结符表达式     \n文法中的每条规则对应于一个非终结表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。   \n- Context环境角色\n\n","source":"_posts/2012-11-02-interpreter-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：解释器（interpreter） in java\"\ndate: 2012-11-02 20:09\ncomments: true\ncategories: 设计模式\ntags: [ interpreter, pattern, 解释器 ]\n---\n**定义：**解释器模式是一种按照规定语法进行解析的方案，在现在项目中使用较少。正式定义：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子。    \n\n解释器模式有以下几个角色：    \n\n- AbstractExpression抽象解释器     \n具体的解释任务由各个实现类完成。\n- TerminalExpression终结符表达式    \n实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。\n- NonterminalExpression非终结符表达式     \n文法中的每条规则对应于一个非终结表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。   \n- Context环境角色\n\n","slug":"2012-11-02-interpreter-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3k002vv8fyz80wsc8c","content":"<p><strong>定义：</strong>解释器模式是一种按照规定语法进行解析的方案，在现在项目中使用较少。正式定义：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子。    </p>\n<p>解释器模式有以下几个角色：    </p>\n<ul>\n<li>AbstractExpression抽象解释器<br>具体的解释任务由各个实现类完成。</li>\n<li>TerminalExpression终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。</li>\n<li>NonterminalExpression非终结符表达式<br>文法中的每条规则对应于一个非终结表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。   </li>\n<li>Context环境角色</li>\n</ul>\n","excerpt":"","more":"<p><strong>定义：</strong>解释器模式是一种按照规定语法进行解析的方案，在现在项目中使用较少。正式定义：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子。    </p>\n<p>解释器模式有以下几个角色：    </p>\n<ul>\n<li>AbstractExpression抽象解释器<br>具体的解释任务由各个实现类完成。</li>\n<li>TerminalExpression终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。</li>\n<li>NonterminalExpression非终结符表达式<br>文法中的每条规则对应于一个非终结表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。   </li>\n<li>Context环境角色</li>\n</ul>\n"},{"layout":"post","title":"设计模式：迭代器（Iterator） in java","date":"2012-11-08T08:50:00.000Z","comments":1,"_content":"**定义：**迭代器模式提供了一种方法来访问一个容器对象种的各个元素，而又不暴露这个对象的内部细节。   \n>在Java中已经默认提供了Iterator支持，各种容器类都进行了实现，而事实上，迭代器模式就是为了解决如何遍历这些容器里的元素而诞生的。   \n\n**迭代器模式**主要有以下的角色：\n\n* Iterator抽象迭代器：   \n负责定义访问与遍历元素的接口。基本有3个固定的方法`hasNext()`,`next()`,`remove()`;\n* Concrete Iterator具体迭代器：    \n迭代器的实现类，实现接口，完成元素遍历。\n* Aggregate抽象容器：   \n定义创建具体迭代器的接口。在Java种一般是`iterator()`方法。\n* Concrete Aggregate具体容器：  \n实现创建迭代器接口，返回迭代器实例对象。   \n\n<!--more-->\n为了方便，下面就直接以ArrayList为例，来看看迭代器是如何实现的吧。  \n在使用时，通常这样对ArrayList进行遍历：\n\n\t\tList<String> list = new ArrayList<String>();\n\t\tlist.add(\"first\");\n\t\tlist.add(\"second\");\n\t\tIterator<String> itr = list.iterator();\n\t\twhile (itr.hasNext()) {\n\t\t\tString element = itr.next();\n\t\t\tSystem.out.println(element);\n\t\t}\n从这里，我们可以看出来，这就是完全的迭代器模式。  \n首先来看，Iterator接口（java.util.Iterator）：  \n\n\tpublic interface Iterator<E> {\n  \n   \t\tboolean hasNext();\n  \n    \tE next();\n  \n    \tvoid remove();\n\t}\n然后是Iterator的具体实现类(java.util.AbstractList<E>$Itr)：  \n\tprivate class Itr implements Iterator<E> {\n\t\n\t\tint cursor = 0;\n\n\t\tint lastRet = -1;\n\t\n\t\tint expectedModCount = modCount;\n\n\t\tpublic boolean hasNext() {\n            return cursor != size();\n\t\t}\n\n\t\tpublic E next() {\n            checkForComodification();\n\t    \ttry {\n\t\t\tE next = get(cursor);\n\t\t\tlastRet = cursor++;\n\t\t\treturn next;\n\t    \t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tcheckForComodification();\n\t\t\t\tthrow new NoSuchElementException();\n\t    \t}\n\t\t}\n\n\t\tpublic void remove() {\n\t    \tif (lastRet == -1)\n\t\t\tthrow new IllegalStateException();\n            \tcheckForComodification();\n\n\t    \ttry {\n\t\t\t\tAbstractList.this.remove(lastRet);\n\t\t\tif (lastRet < cursor)\n\t\t    \tcursor--;\n\t\t\tlastRet = -1;\n\t\t\texpectedModCount = modCount;\n\t    \t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new ConcurrentModificationException();\n\t    \t}\n\t\t}\n\n\t\tfinal void checkForComodification() {\n\t    \tif (modCount != expectedModCount)\n\t\t\t\tthrow new ConcurrentModificationException();\n\t\t}\n    }\n这个就是具体的Iterator了，当然还有另外一个ListItr extends Itr，这个是专门针对List进行操作的。   \n那么Aggregate接口对应的是哪个呢？就是`java.util.AbstractCollection<E>` ，它里面定义了这样的一个接口：   \n\n\t...\n  \t/**\n     * Returns an iterator over the elements contained in this collection.\n     *\n     * @return an iterator over the elements contained in this collection\n     */\n    public abstract Iterator<E> iterator();\n\t...\n那么具体实现是在哪儿？`java.util.AbstractList<E>`做了实现。\n\n\t    public Iterator<E> iterator() {\n\t\t\treturn new Itr();\n    \t}\n返回了一个具体的迭代器实例。而ArrayList,LinkedList都是继承AbstractList的，因此自动具有了返回迭代器实例的功能。  \n\n因此，Java种的容器类只负责元素的的维护就好了。访问就教给迭代器吧，Java做的如此完善，以至于我们都不必再自己写Iterator了。    ","source":"_posts/2012-11-02-iterator-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：迭代器（Iterator） in java\"\ndate: 2012-11-08 16:50\ncomments: true\ncategories: 设计模式\ntags: [ Java, Iterator ]\n---\n**定义：**迭代器模式提供了一种方法来访问一个容器对象种的各个元素，而又不暴露这个对象的内部细节。   \n>在Java中已经默认提供了Iterator支持，各种容器类都进行了实现，而事实上，迭代器模式就是为了解决如何遍历这些容器里的元素而诞生的。   \n\n**迭代器模式**主要有以下的角色：\n\n* Iterator抽象迭代器：   \n负责定义访问与遍历元素的接口。基本有3个固定的方法`hasNext()`,`next()`,`remove()`;\n* Concrete Iterator具体迭代器：    \n迭代器的实现类，实现接口，完成元素遍历。\n* Aggregate抽象容器：   \n定义创建具体迭代器的接口。在Java种一般是`iterator()`方法。\n* Concrete Aggregate具体容器：  \n实现创建迭代器接口，返回迭代器实例对象。   \n\n<!--more-->\n为了方便，下面就直接以ArrayList为例，来看看迭代器是如何实现的吧。  \n在使用时，通常这样对ArrayList进行遍历：\n\n\t\tList<String> list = new ArrayList<String>();\n\t\tlist.add(\"first\");\n\t\tlist.add(\"second\");\n\t\tIterator<String> itr = list.iterator();\n\t\twhile (itr.hasNext()) {\n\t\t\tString element = itr.next();\n\t\t\tSystem.out.println(element);\n\t\t}\n从这里，我们可以看出来，这就是完全的迭代器模式。  \n首先来看，Iterator接口（java.util.Iterator）：  \n\n\tpublic interface Iterator<E> {\n  \n   \t\tboolean hasNext();\n  \n    \tE next();\n  \n    \tvoid remove();\n\t}\n然后是Iterator的具体实现类(java.util.AbstractList<E>$Itr)：  \n\tprivate class Itr implements Iterator<E> {\n\t\n\t\tint cursor = 0;\n\n\t\tint lastRet = -1;\n\t\n\t\tint expectedModCount = modCount;\n\n\t\tpublic boolean hasNext() {\n            return cursor != size();\n\t\t}\n\n\t\tpublic E next() {\n            checkForComodification();\n\t    \ttry {\n\t\t\tE next = get(cursor);\n\t\t\tlastRet = cursor++;\n\t\t\treturn next;\n\t    \t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tcheckForComodification();\n\t\t\t\tthrow new NoSuchElementException();\n\t    \t}\n\t\t}\n\n\t\tpublic void remove() {\n\t    \tif (lastRet == -1)\n\t\t\tthrow new IllegalStateException();\n            \tcheckForComodification();\n\n\t    \ttry {\n\t\t\t\tAbstractList.this.remove(lastRet);\n\t\t\tif (lastRet < cursor)\n\t\t    \tcursor--;\n\t\t\tlastRet = -1;\n\t\t\texpectedModCount = modCount;\n\t    \t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new ConcurrentModificationException();\n\t    \t}\n\t\t}\n\n\t\tfinal void checkForComodification() {\n\t    \tif (modCount != expectedModCount)\n\t\t\t\tthrow new ConcurrentModificationException();\n\t\t}\n    }\n这个就是具体的Iterator了，当然还有另外一个ListItr extends Itr，这个是专门针对List进行操作的。   \n那么Aggregate接口对应的是哪个呢？就是`java.util.AbstractCollection<E>` ，它里面定义了这样的一个接口：   \n\n\t...\n  \t/**\n     * Returns an iterator over the elements contained in this collection.\n     *\n     * @return an iterator over the elements contained in this collection\n     */\n    public abstract Iterator<E> iterator();\n\t...\n那么具体实现是在哪儿？`java.util.AbstractList<E>`做了实现。\n\n\t    public Iterator<E> iterator() {\n\t\t\treturn new Itr();\n    \t}\n返回了一个具体的迭代器实例。而ArrayList,LinkedList都是继承AbstractList的，因此自动具有了返回迭代器实例的功能。  \n\n因此，Java种的容器类只负责元素的的维护就好了。访问就教给迭代器吧，Java做的如此完善，以至于我们都不必再自己写Iterator了。    ","slug":"2012-11-02-iterator-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3m002yv8fyfwibvobk","content":"<p><strong>定义：</strong>迭代器模式提供了一种方法来访问一个容器对象种的各个元素，而又不暴露这个对象的内部细节。   </p>\n<blockquote>\n<p>在Java中已经默认提供了Iterator支持，各种容器类都进行了实现，而事实上，迭代器模式就是为了解决如何遍历这些容器里的元素而诞生的。   </p>\n</blockquote>\n<p><strong>迭代器模式</strong>主要有以下的角色：</p>\n<ul>\n<li>Iterator抽象迭代器：<br>负责定义访问与遍历元素的接口。基本有3个固定的方法<code>hasNext()</code>,<code>next()</code>,<code>remove()</code>;</li>\n<li>Concrete Iterator具体迭代器：<br>迭代器的实现类，实现接口，完成元素遍历。</li>\n<li>Aggregate抽象容器：<br>定义创建具体迭代器的接口。在Java种一般是<code>iterator()</code>方法。</li>\n<li>Concrete Aggregate具体容器：<br>实现创建迭代器接口，返回迭代器实例对象。   </li>\n</ul>\n<a id=\"more\"></a>\n<p>为了方便，下面就直接以ArrayList为例，来看看迭代器是如何实现的吧。<br>在使用时，通常这样对ArrayList进行遍历：</p>\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist.add(&quot;first&quot;);\nlist.add(&quot;second&quot;);\nIterator&lt;String&gt; itr = list.iterator();\nwhile (itr.hasNext()) {\n    String element = itr.next();\n    System.out.println(element);\n}\n</code></pre><p>从这里，我们可以看出来，这就是完全的迭代器模式。<br>首先来看，Iterator接口（java.util.Iterator）：  </p>\n<pre><code>public interface Iterator&lt;E&gt; {\n\n       boolean hasNext();\n\n    E next();\n\n    void remove();\n}\n</code></pre><p>然后是Iterator的具体实现类(java.util.AbstractList<e>$Itr)：<br>    private class Itr implements Iterator<e> {</e></e></p>\n<pre><code>    int cursor = 0;\n\n    int lastRet = -1;\n\n    int expectedModCount = modCount;\n\n    public boolean hasNext() {\n        return cursor != size();\n    }\n\n    public E next() {\n        checkForComodification();\n        try {\n        E next = get(cursor);\n        lastRet = cursor++;\n        return next;\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\n    public void remove() {\n        if (lastRet == -1)\n        throw new IllegalStateException();\n            checkForComodification();\n\n        try {\n            AbstractList.this.remove(lastRet);\n        if (lastRet &lt; cursor)\n            cursor--;\n        lastRet = -1;\n        expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException e) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n</code></pre><p>这个就是具体的Iterator了，当然还有另外一个ListItr extends Itr，这个是专门针对List进行操作的。<br>那么Aggregate接口对应的是哪个呢？就是<code>java.util.AbstractCollection&lt;E&gt;</code> ，它里面定义了这样的一个接口：   </p>\n<pre><code>...\n  /**\n * Returns an iterator over the elements contained in this collection.\n *\n * @return an iterator over the elements contained in this collection\n */\npublic abstract Iterator&lt;E&gt; iterator();\n...\n</code></pre><p>那么具体实现是在哪儿？<code>java.util.AbstractList&lt;E&gt;</code>做了实现。</p>\n<pre><code>public Iterator&lt;E&gt; iterator() {\n    return new Itr();\n}\n</code></pre><p>返回了一个具体的迭代器实例。而ArrayList,LinkedList都是继承AbstractList的，因此自动具有了返回迭代器实例的功能。  </p>\n<p>因此，Java种的容器类只负责元素的的维护就好了。访问就教给迭代器吧，Java做的如此完善，以至于我们都不必再自己写Iterator了。    </p>\n","excerpt":"<p><strong>定义：</strong>迭代器模式提供了一种方法来访问一个容器对象种的各个元素，而又不暴露这个对象的内部细节。   </p>\n<blockquote>\n<p>在Java中已经默认提供了Iterator支持，各种容器类都进行了实现，而事实上，迭代器模式就是为了解决如何遍历这些容器里的元素而诞生的。   </p>\n</blockquote>\n<p><strong>迭代器模式</strong>主要有以下的角色：</p>\n<ul>\n<li>Iterator抽象迭代器：<br>负责定义访问与遍历元素的接口。基本有3个固定的方法<code>hasNext()</code>,<code>next()</code>,<code>remove()</code>;</li>\n<li>Concrete Iterator具体迭代器：<br>迭代器的实现类，实现接口，完成元素遍历。</li>\n<li>Aggregate抽象容器：<br>定义创建具体迭代器的接口。在Java种一般是<code>iterator()</code>方法。</li>\n<li>Concrete Aggregate具体容器：<br>实现创建迭代器接口，返回迭代器实例对象。   </li>\n</ul>","more":"<p>为了方便，下面就直接以ArrayList为例，来看看迭代器是如何实现的吧。<br>在使用时，通常这样对ArrayList进行遍历：</p>\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist.add(&quot;first&quot;);\nlist.add(&quot;second&quot;);\nIterator&lt;String&gt; itr = list.iterator();\nwhile (itr.hasNext()) {\n    String element = itr.next();\n    System.out.println(element);\n}\n</code></pre><p>从这里，我们可以看出来，这就是完全的迭代器模式。<br>首先来看，Iterator接口（java.util.Iterator）：  </p>\n<pre><code>public interface Iterator&lt;E&gt; {\n\n       boolean hasNext();\n\n    E next();\n\n    void remove();\n}\n</code></pre><p>然后是Iterator的具体实现类(java.util.AbstractList<E>$Itr)：<br>    private class Itr implements Iterator<E> {</p>\n<pre><code>    int cursor = 0;\n\n    int lastRet = -1;\n\n    int expectedModCount = modCount;\n\n    public boolean hasNext() {\n        return cursor != size();\n    }\n\n    public E next() {\n        checkForComodification();\n        try {\n        E next = get(cursor);\n        lastRet = cursor++;\n        return next;\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\n    public void remove() {\n        if (lastRet == -1)\n        throw new IllegalStateException();\n            checkForComodification();\n\n        try {\n            AbstractList.this.remove(lastRet);\n        if (lastRet &lt; cursor)\n            cursor--;\n        lastRet = -1;\n        expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException e) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n</code></pre><p>这个就是具体的Iterator了，当然还有另外一个ListItr extends Itr，这个是专门针对List进行操作的。<br>那么Aggregate接口对应的是哪个呢？就是<code>java.util.AbstractCollection&lt;E&gt;</code> ，它里面定义了这样的一个接口：   </p>\n<pre><code>...\n  /**\n * Returns an iterator over the elements contained in this collection.\n *\n * @return an iterator over the elements contained in this collection\n */\npublic abstract Iterator&lt;E&gt; iterator();\n...\n</code></pre><p>那么具体实现是在哪儿？<code>java.util.AbstractList&lt;E&gt;</code>做了实现。</p>\n<pre><code>public Iterator&lt;E&gt; iterator() {\n    return new Itr();\n}\n</code></pre><p>返回了一个具体的迭代器实例。而ArrayList,LinkedList都是继承AbstractList的，因此自动具有了返回迭代器实例的功能。  </p>\n<p>因此，Java种的容器类只负责元素的的维护就好了。访问就教给迭代器吧，Java做的如此完善，以至于我们都不必再自己写Iterator了。    </p>"},{"layout":"post","title":"设计模式：中介者（mediator） in java","date":"2012-11-02T12:50:00.000Z","comments":1,"_content":"**定义**:中介者模式,用一个中介对象封装一系列的对象交互,中介者使各对象不需要显式的相互作用,从而使其耦合松散,而且可以独立地改变它们之间的交互.     \n\n**相关角色**\n\n- Mediator抽象中介者角色   \n抽象中介者角色定义统一的接口,用于各个角色之间的通信.\n- Concrete Mediator具体中介者   \n具体中介者角色通过协调各同事角色实现协作行为,因此它必须依赖于各个同事角色.\n- Colleague同事角色    \n每一个同事角色都知道中介者角色,而且与其他的同事角色通信的时候,一定要通过中介者角色协作.   \n\n士大夫撒\n","source":"_posts/2012-11-02-mediator-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：中介者（mediator） in java\"\ndate: 2012-11-02 20:50\ncomments: true\ncategories: 设计模式\ntags: [ mediator, java ]\n---\n**定义**:中介者模式,用一个中介对象封装一系列的对象交互,中介者使各对象不需要显式的相互作用,从而使其耦合松散,而且可以独立地改变它们之间的交互.     \n\n**相关角色**\n\n- Mediator抽象中介者角色   \n抽象中介者角色定义统一的接口,用于各个角色之间的通信.\n- Concrete Mediator具体中介者   \n具体中介者角色通过协调各同事角色实现协作行为,因此它必须依赖于各个同事角色.\n- Colleague同事角色    \n每一个同事角色都知道中介者角色,而且与其他的同事角色通信的时候,一定要通过中介者角色协作.   \n\n士大夫撒\n","slug":"2012-11-02-mediator-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3o0033v8fylsi03g9a","content":"<p><strong>定义</strong>:中介者模式,用一个中介对象封装一系列的对象交互,中介者使各对象不需要显式的相互作用,从而使其耦合松散,而且可以独立地改变它们之间的交互.     </p>\n<p><strong>相关角色</strong></p>\n<ul>\n<li>Mediator抽象中介者角色<br>抽象中介者角色定义统一的接口,用于各个角色之间的通信.</li>\n<li>Concrete Mediator具体中介者<br>具体中介者角色通过协调各同事角色实现协作行为,因此它必须依赖于各个同事角色.</li>\n<li>Colleague同事角色<br>每一个同事角色都知道中介者角色,而且与其他的同事角色通信的时候,一定要通过中介者角色协作.   </li>\n</ul>\n<p>士大夫撒</p>\n","excerpt":"","more":"<p><strong>定义</strong>:中介者模式,用一个中介对象封装一系列的对象交互,中介者使各对象不需要显式的相互作用,从而使其耦合松散,而且可以独立地改变它们之间的交互.     </p>\n<p><strong>相关角色</strong></p>\n<ul>\n<li>Mediator抽象中介者角色<br>抽象中介者角色定义统一的接口,用于各个角色之间的通信.</li>\n<li>Concrete Mediator具体中介者<br>具体中介者角色通过协调各同事角色实现协作行为,因此它必须依赖于各个同事角色.</li>\n<li>Colleague同事角色<br>每一个同事角色都知道中介者角色,而且与其他的同事角色通信的时候,一定要通过中介者角色协作.   </li>\n</ul>\n<p>士大夫撒</p>\n"},{"layout":"post","title":"设计模式:备忘录（memento） in java","date":"2012-11-02T12:10:00.000Z","comments":1,"_content":"**定义：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。   \n\n备忘录模式有以下三个角色：   \n\n- Originator发起人角色    \n记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。   \n- Memento备忘录角色     \n负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。   \n- Caretaker备忘录管理员角色    \n对备忘录进行管理、保存和提供备忘录。   \n\n<!--more-->\n发起人角色：    \n\n    public class Originator{\n        //内部状态\n        private String state = \"\";\n        \n        public String getState(){\n            return state;\n        }\n        \n        public void setState(String state){\n            this.state = state;\n        }\n        \n        //创建一个备忘录\n        public Memento createMemento(){\n            return new Memento(this.state);\n        }\n        //恢复一个备忘录\n        public void restoreMemento(Memento _memento){\n            this.setState(_memento.getState());\n        }\n    }\n    \n备忘录角色：    \n\n    public class Memento{\n        //发起人的内部状态\n        private String state = \"\";\n        //构造函数传递参数\n        public Memento(String _state){\n            this.state = _state;\n        }  \n        public String getState(){\n            return state;\n        }\n        \n        public void setState(String state){\n            this.state = state;\n        }\n    }\n    \n备忘录管理员角色：   \n\n    public class Caretaker{\n        //备忘录对象\n        private Memento memento;\n        public Memento getMemento(){\n            return memento;\n        }\n        public void setMemento(Memento memento){\n            this.memento = memento;\n        }\n    }\n    \n现在看看是如何使用的：     \n\n    public class Client{\n        public static void main(String[] args){\n            Originator originator = new Originator();\n            Caretaker caretaker = new Caretaker();\n            caretaker.setMemento(originator.createMemento()); \n            originator.restoreMemento(caretaker.getMemento);\n        }\n    }","source":"_posts/2012-11-02-memento-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式:备忘录（memento） in java\"\ndate: 2012-11-02 20:10\ncomments: true\ncategories: 设计模式\ntags: [ memento, pattern, 备忘录 ]\n---\n**定义：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。   \n\n备忘录模式有以下三个角色：   \n\n- Originator发起人角色    \n记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。   \n- Memento备忘录角色     \n负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。   \n- Caretaker备忘录管理员角色    \n对备忘录进行管理、保存和提供备忘录。   \n\n<!--more-->\n发起人角色：    \n\n    public class Originator{\n        //内部状态\n        private String state = \"\";\n        \n        public String getState(){\n            return state;\n        }\n        \n        public void setState(String state){\n            this.state = state;\n        }\n        \n        //创建一个备忘录\n        public Memento createMemento(){\n            return new Memento(this.state);\n        }\n        //恢复一个备忘录\n        public void restoreMemento(Memento _memento){\n            this.setState(_memento.getState());\n        }\n    }\n    \n备忘录角色：    \n\n    public class Memento{\n        //发起人的内部状态\n        private String state = \"\";\n        //构造函数传递参数\n        public Memento(String _state){\n            this.state = _state;\n        }  \n        public String getState(){\n            return state;\n        }\n        \n        public void setState(String state){\n            this.state = state;\n        }\n    }\n    \n备忘录管理员角色：   \n\n    public class Caretaker{\n        //备忘录对象\n        private Memento memento;\n        public Memento getMemento(){\n            return memento;\n        }\n        public void setMemento(Memento memento){\n            this.memento = memento;\n        }\n    }\n    \n现在看看是如何使用的：     \n\n    public class Client{\n        public static void main(String[] args){\n            Originator originator = new Originator();\n            Caretaker caretaker = new Caretaker();\n            caretaker.setMemento(originator.createMemento()); \n            originator.restoreMemento(caretaker.getMemento);\n        }\n    }","slug":"2012-11-02-memento-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3r0036v8fyqhzn3qra","content":"<p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。   </p>\n<p>备忘录模式有以下三个角色：   </p>\n<ul>\n<li>Originator发起人角色<br>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。   </li>\n<li>Memento备忘录角色<br>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。   </li>\n<li>Caretaker备忘录管理员角色<br>对备忘录进行管理、保存和提供备忘录。   </li>\n</ul>\n<a id=\"more\"></a>\n<p>发起人角色：    </p>\n<pre><code>public class Originator{\n    //内部状态\n    private String state = &quot;&quot;;\n\n    public String getState(){\n        return state;\n    }\n\n    public void setState(String state){\n        this.state = state;\n    }\n\n    //创建一个备忘录\n    public Memento createMemento(){\n        return new Memento(this.state);\n    }\n    //恢复一个备忘录\n    public void restoreMemento(Memento _memento){\n        this.setState(_memento.getState());\n    }\n}\n</code></pre><p>备忘录角色：    </p>\n<pre><code>public class Memento{\n    //发起人的内部状态\n    private String state = &quot;&quot;;\n    //构造函数传递参数\n    public Memento(String _state){\n        this.state = _state;\n    }  \n    public String getState(){\n        return state;\n    }\n\n    public void setState(String state){\n        this.state = state;\n    }\n}\n</code></pre><p>备忘录管理员角色：   </p>\n<pre><code>public class Caretaker{\n    //备忘录对象\n    private Memento memento;\n    public Memento getMemento(){\n        return memento;\n    }\n    public void setMemento(Memento memento){\n        this.memento = memento;\n    }\n}\n</code></pre><p>现在看看是如何使用的：     </p>\n<pre><code>public class Client{\n    public static void main(String[] args){\n        Originator originator = new Originator();\n        Caretaker caretaker = new Caretaker();\n        caretaker.setMemento(originator.createMemento()); \n        originator.restoreMemento(caretaker.getMemento);\n    }\n}\n</code></pre>","excerpt":"<p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。   </p>\n<p>备忘录模式有以下三个角色：   </p>\n<ul>\n<li>Originator发起人角色<br>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。   </li>\n<li>Memento备忘录角色<br>负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。   </li>\n<li>Caretaker备忘录管理员角色<br>对备忘录进行管理、保存和提供备忘录。   </li>\n</ul>","more":"<p>发起人角色：    </p>\n<pre><code>public class Originator{\n    //内部状态\n    private String state = &quot;&quot;;\n\n    public String getState(){\n        return state;\n    }\n\n    public void setState(String state){\n        this.state = state;\n    }\n\n    //创建一个备忘录\n    public Memento createMemento(){\n        return new Memento(this.state);\n    }\n    //恢复一个备忘录\n    public void restoreMemento(Memento _memento){\n        this.setState(_memento.getState());\n    }\n}\n</code></pre><p>备忘录角色：    </p>\n<pre><code>public class Memento{\n    //发起人的内部状态\n    private String state = &quot;&quot;;\n    //构造函数传递参数\n    public Memento(String _state){\n        this.state = _state;\n    }  \n    public String getState(){\n        return state;\n    }\n\n    public void setState(String state){\n        this.state = state;\n    }\n}\n</code></pre><p>备忘录管理员角色：   </p>\n<pre><code>public class Caretaker{\n    //备忘录对象\n    private Memento memento;\n    public Memento getMemento(){\n        return memento;\n    }\n    public void setMemento(Memento memento){\n        this.memento = memento;\n    }\n}\n</code></pre><p>现在看看是如何使用的：     </p>\n<pre><code>public class Client{\n    public static void main(String[] args){\n        Originator originator = new Originator();\n        Caretaker caretaker = new Caretaker();\n        caretaker.setMemento(originator.createMemento()); \n        originator.restoreMemento(caretaker.getMemento);\n    }\n}\n</code></pre>"},{"layout":"post","title":"设计模式：空对象（null object） in java","date":"2012-11-02T12:10:00.000Z","comments":1,"_content":"相信大家一定在开发中见过并且写过类似这样的代码：    \n\n    public Book getBook(int id) {  \n        if (id < 0) {  \n            return null;  \n        }  \n        return new Book(1, \"Design Pattern\", 100);  \n    }  \n    \n    Book book = getBook(-1);  \n    if (book != null) {                   \n    }\n    \n系统在使用对象的相关功能时，总要检查对象是否为null，如果不为null，我们才会调用它的相关方法，完成某种逻辑。这样的检查在一个系统中出现很多次，相信任何一个设计者都不愿意看到这样的情况。为了解决这种问题，我们可以可以引入空对象，这样，我们就可以摆脱大量程式化的代码，对代码的可读性也是一个飞跃。    \n<!--more--> \n\n等等，空对象是什么？它和null什么关系？    \n空对象是一个没有实质性内容的对象，但他并不为null。你可以把空对象理解为一个空箱子，这个物品还是存在的，只不过仅仅是一个壳，没有实质性的东西。    \n我们需要对原有的代码进行重构，把所有返回null的地方都替换成返回一个与之对应的空对象，然后再客户端调用时不再使用book==null这种方式判断是否为空，而是替换成book.isNull()的方式。下面我们就一步一步来实现这种模式。    \n\n首先，我们需要定义一个Nullable接口：   \n\n    public interface Nullable {  \n        /** \n         * 对象是否为空 \n         * @return \n         */  \n        public boolean isNull();  \n    }  \n这个接口定义了一个isNull()的方法，来表示一个对象是否为空。   \n然后我们让Book实现此接口：    \n\n    public class Book implements Nullable {  \n      \n        private int id;  \n        private String name;  \n        private double price;  \n          \n        public Book() {  \n        }  \n          \n        public Book(int id, String name, double price) {  \n            this.id = id;  \n            this.name = name;  \n            this.price = price;  \n        }  \n          \n        @Override  \n        public boolean isNull() {  \n            return false;  \n        }  \n      \n        /** \n         * 创建一个NullBook实例代表空对象 \n         * @return \n         */  \n        public static Book createNullBook() {  \n            return new NullBook();  \n        }  \n          \n        /** \n         * setters & getters \n         */  \n    }\n    \n在Book中实现了isNull()方法，并返回false；另外Book还定义了一个静态的createNullBook方法，返回了一个NullBook的实例，NullBook是什么呢，我们来看一下：   \n\n    public class NullBook extends Book {  \n        @Override  \n        public boolean isNull() {  \n            return true;  \n        }  \n    }  \n    \nNullBook继承了Book，并在isNull()方法中返回true，这个NullBook其实就是我们上面提到的空对象，仅仅是个空箱子而已。    \n然后我们定义一个BookService类，用以模拟获取Book的接口方法：    \n\n    public class BookService {  \n        public Book getBook(int id) {  \n            if (id < 0) {  \n                //返回一个空对象  \n                return Book.createNullBook();             \n            }  \n            return new Book(id, \"Design Pattern\", 100);  \n        }  \n    }  \n    \n在getBook(int id)中，如果`id<0`时，则返回一个NullBook的实例，在客户端调用isNull()方法时则返回true，表示是空对象；如果`id>=0`时，则返回一个Book的实例，在客户端调用isNull()方法时则返回false，表示对象不为空，可以调用相关方法取得数据。对于我们的客户端来讲，返回的都是一个Book类型的对象，我们并不清楚返回的到底是真正的Book实例还是空对象NullBook实例，但是我们并不担心，因为有一点可以肯定的是，我们都可以放心的调用isNull()方法，因为它会根据运行期对象的类型返回一个正确的值。   \n\n多态的最根本好处在于：你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切事情多态机制会为你妥善处理。    \n\n最后再来看一下客户端是如何实现对象为空的判断的：    \n\n    public class Client {  \n        public static void main(String[] args) {  \n            BookService service = new BookService();  \n            Book book = service.getBook(-1);  \n            if (book.isNull()) {  \n                System.out.println(\"not found!\");  \n            } else {  \n                System.out.println(\"name:\" + book.getName());  \n                System.out.println(\"price:\" + book.getPrice());  \n            }  \n        }  \n    }  \n  \n---  \n原文：<http://blog.csdn.net/liuhe688/article/details/6586458>","source":"_posts/2012-11-02-null-object-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：空对象（null object） in java\"\ndate: 2012-11-02 20:10\ncomments: true\ncategories: 设计模式  \ntags: [ null, object ]\n---\n相信大家一定在开发中见过并且写过类似这样的代码：    \n\n    public Book getBook(int id) {  \n        if (id < 0) {  \n            return null;  \n        }  \n        return new Book(1, \"Design Pattern\", 100);  \n    }  \n    \n    Book book = getBook(-1);  \n    if (book != null) {                   \n    }\n    \n系统在使用对象的相关功能时，总要检查对象是否为null，如果不为null，我们才会调用它的相关方法，完成某种逻辑。这样的检查在一个系统中出现很多次，相信任何一个设计者都不愿意看到这样的情况。为了解决这种问题，我们可以可以引入空对象，这样，我们就可以摆脱大量程式化的代码，对代码的可读性也是一个飞跃。    \n<!--more--> \n\n等等，空对象是什么？它和null什么关系？    \n空对象是一个没有实质性内容的对象，但他并不为null。你可以把空对象理解为一个空箱子，这个物品还是存在的，只不过仅仅是一个壳，没有实质性的东西。    \n我们需要对原有的代码进行重构，把所有返回null的地方都替换成返回一个与之对应的空对象，然后再客户端调用时不再使用book==null这种方式判断是否为空，而是替换成book.isNull()的方式。下面我们就一步一步来实现这种模式。    \n\n首先，我们需要定义一个Nullable接口：   \n\n    public interface Nullable {  \n        /** \n         * 对象是否为空 \n         * @return \n         */  \n        public boolean isNull();  \n    }  \n这个接口定义了一个isNull()的方法，来表示一个对象是否为空。   \n然后我们让Book实现此接口：    \n\n    public class Book implements Nullable {  \n      \n        private int id;  \n        private String name;  \n        private double price;  \n          \n        public Book() {  \n        }  \n          \n        public Book(int id, String name, double price) {  \n            this.id = id;  \n            this.name = name;  \n            this.price = price;  \n        }  \n          \n        @Override  \n        public boolean isNull() {  \n            return false;  \n        }  \n      \n        /** \n         * 创建一个NullBook实例代表空对象 \n         * @return \n         */  \n        public static Book createNullBook() {  \n            return new NullBook();  \n        }  \n          \n        /** \n         * setters & getters \n         */  \n    }\n    \n在Book中实现了isNull()方法，并返回false；另外Book还定义了一个静态的createNullBook方法，返回了一个NullBook的实例，NullBook是什么呢，我们来看一下：   \n\n    public class NullBook extends Book {  \n        @Override  \n        public boolean isNull() {  \n            return true;  \n        }  \n    }  \n    \nNullBook继承了Book，并在isNull()方法中返回true，这个NullBook其实就是我们上面提到的空对象，仅仅是个空箱子而已。    \n然后我们定义一个BookService类，用以模拟获取Book的接口方法：    \n\n    public class BookService {  \n        public Book getBook(int id) {  \n            if (id < 0) {  \n                //返回一个空对象  \n                return Book.createNullBook();             \n            }  \n            return new Book(id, \"Design Pattern\", 100);  \n        }  \n    }  \n    \n在getBook(int id)中，如果`id<0`时，则返回一个NullBook的实例，在客户端调用isNull()方法时则返回true，表示是空对象；如果`id>=0`时，则返回一个Book的实例，在客户端调用isNull()方法时则返回false，表示对象不为空，可以调用相关方法取得数据。对于我们的客户端来讲，返回的都是一个Book类型的对象，我们并不清楚返回的到底是真正的Book实例还是空对象NullBook实例，但是我们并不担心，因为有一点可以肯定的是，我们都可以放心的调用isNull()方法，因为它会根据运行期对象的类型返回一个正确的值。   \n\n多态的最根本好处在于：你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切事情多态机制会为你妥善处理。    \n\n最后再来看一下客户端是如何实现对象为空的判断的：    \n\n    public class Client {  \n        public static void main(String[] args) {  \n            BookService service = new BookService();  \n            Book book = service.getBook(-1);  \n            if (book.isNull()) {  \n                System.out.println(\"not found!\");  \n            } else {  \n                System.out.println(\"name:\" + book.getName());  \n                System.out.println(\"price:\" + book.getPrice());  \n            }  \n        }  \n    }  \n  \n---  \n原文：<http://blog.csdn.net/liuhe688/article/details/6586458>","slug":"2012-11-02-null-object-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3t003av8fyfh6hn5ye","content":"<p>相信大家一定在开发中见过并且写过类似这样的代码：    </p>\n<pre><code>public Book getBook(int id) {  \n    if (id &lt; 0) {  \n        return null;  \n    }  \n    return new Book(1, &quot;Design Pattern&quot;, 100);  \n}  \n\nBook book = getBook(-1);  \nif (book != null) {                   \n}\n</code></pre><p>系统在使用对象的相关功能时，总要检查对象是否为null，如果不为null，我们才会调用它的相关方法，完成某种逻辑。这样的检查在一个系统中出现很多次，相信任何一个设计者都不愿意看到这样的情况。为了解决这种问题，我们可以可以引入空对象，这样，我们就可以摆脱大量程式化的代码，对代码的可读性也是一个飞跃。<br><a id=\"more\"></a> </p>\n<p>等等，空对象是什么？它和null什么关系？<br>空对象是一个没有实质性内容的对象，但他并不为null。你可以把空对象理解为一个空箱子，这个物品还是存在的，只不过仅仅是一个壳，没有实质性的东西。<br>我们需要对原有的代码进行重构，把所有返回null的地方都替换成返回一个与之对应的空对象，然后再客户端调用时不再使用book==null这种方式判断是否为空，而是替换成book.isNull()的方式。下面我们就一步一步来实现这种模式。    </p>\n<p>首先，我们需要定义一个Nullable接口：   </p>\n<pre><code>public interface Nullable {  \n    /** \n     * 对象是否为空 \n     * @return \n     */  \n    public boolean isNull();  \n}  \n</code></pre><p>这个接口定义了一个isNull()的方法，来表示一个对象是否为空。<br>然后我们让Book实现此接口：    </p>\n<pre><code>public class Book implements Nullable {  \n\n    private int id;  \n    private String name;  \n    private double price;  \n\n    public Book() {  \n    }  \n\n    public Book(int id, String name, double price) {  \n        this.id = id;  \n        this.name = name;  \n        this.price = price;  \n    }  \n\n    @Override  \n    public boolean isNull() {  \n        return false;  \n    }  \n\n    /** \n     * 创建一个NullBook实例代表空对象 \n     * @return \n     */  \n    public static Book createNullBook() {  \n        return new NullBook();  \n    }  \n\n    /** \n     * setters &amp; getters \n     */  \n}\n</code></pre><p>在Book中实现了isNull()方法，并返回false；另外Book还定义了一个静态的createNullBook方法，返回了一个NullBook的实例，NullBook是什么呢，我们来看一下：   </p>\n<pre><code>public class NullBook extends Book {  \n    @Override  \n    public boolean isNull() {  \n        return true;  \n    }  \n}  \n</code></pre><p>NullBook继承了Book，并在isNull()方法中返回true，这个NullBook其实就是我们上面提到的空对象，仅仅是个空箱子而已。<br>然后我们定义一个BookService类，用以模拟获取Book的接口方法：    </p>\n<pre><code>public class BookService {  \n    public Book getBook(int id) {  \n        if (id &lt; 0) {  \n            //返回一个空对象  \n            return Book.createNullBook();             \n        }  \n        return new Book(id, &quot;Design Pattern&quot;, 100);  \n    }  \n}  \n</code></pre><p>在getBook(int id)中，如果<code>id&lt;0</code>时，则返回一个NullBook的实例，在客户端调用isNull()方法时则返回true，表示是空对象；如果<code>id&gt;=0</code>时，则返回一个Book的实例，在客户端调用isNull()方法时则返回false，表示对象不为空，可以调用相关方法取得数据。对于我们的客户端来讲，返回的都是一个Book类型的对象，我们并不清楚返回的到底是真正的Book实例还是空对象NullBook实例，但是我们并不担心，因为有一点可以肯定的是，我们都可以放心的调用isNull()方法，因为它会根据运行期对象的类型返回一个正确的值。   </p>\n<p>多态的最根本好处在于：你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切事情多态机制会为你妥善处理。    </p>\n<p>最后再来看一下客户端是如何实现对象为空的判断的：    </p>\n<pre><code>public class Client {  \n    public static void main(String[] args) {  \n        BookService service = new BookService();  \n        Book book = service.getBook(-1);  \n        if (book.isNull()) {  \n            System.out.println(&quot;not found!&quot;);  \n        } else {  \n            System.out.println(&quot;name:&quot; + book.getName());  \n            System.out.println(&quot;price:&quot; + book.getPrice());  \n        }  \n    }  \n}  \n</code></pre><hr>\n<p>原文：<a href=\"http://blog.csdn.net/liuhe688/article/details/6586458\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liuhe688/article/details/6586458</a></p>\n","excerpt":"<p>相信大家一定在开发中见过并且写过类似这样的代码：    </p>\n<pre><code>public Book getBook(int id) {  \n    if (id &lt; 0) {  \n        return null;  \n    }  \n    return new Book(1, &quot;Design Pattern&quot;, 100);  \n}  \n\nBook book = getBook(-1);  \nif (book != null) {                   \n}\n</code></pre><p>系统在使用对象的相关功能时，总要检查对象是否为null，如果不为null，我们才会调用它的相关方法，完成某种逻辑。这样的检查在一个系统中出现很多次，相信任何一个设计者都不愿意看到这样的情况。为了解决这种问题，我们可以可以引入空对象，这样，我们就可以摆脱大量程式化的代码，对代码的可读性也是一个飞跃。<br>","more":"</p>\n<p>等等，空对象是什么？它和null什么关系？<br>空对象是一个没有实质性内容的对象，但他并不为null。你可以把空对象理解为一个空箱子，这个物品还是存在的，只不过仅仅是一个壳，没有实质性的东西。<br>我们需要对原有的代码进行重构，把所有返回null的地方都替换成返回一个与之对应的空对象，然后再客户端调用时不再使用book==null这种方式判断是否为空，而是替换成book.isNull()的方式。下面我们就一步一步来实现这种模式。    </p>\n<p>首先，我们需要定义一个Nullable接口：   </p>\n<pre><code>public interface Nullable {  \n    /** \n     * 对象是否为空 \n     * @return \n     */  \n    public boolean isNull();  \n}  \n</code></pre><p>这个接口定义了一个isNull()的方法，来表示一个对象是否为空。<br>然后我们让Book实现此接口：    </p>\n<pre><code>public class Book implements Nullable {  \n\n    private int id;  \n    private String name;  \n    private double price;  \n\n    public Book() {  \n    }  \n\n    public Book(int id, String name, double price) {  \n        this.id = id;  \n        this.name = name;  \n        this.price = price;  \n    }  \n\n    @Override  \n    public boolean isNull() {  \n        return false;  \n    }  \n\n    /** \n     * 创建一个NullBook实例代表空对象 \n     * @return \n     */  \n    public static Book createNullBook() {  \n        return new NullBook();  \n    }  \n\n    /** \n     * setters &amp; getters \n     */  \n}\n</code></pre><p>在Book中实现了isNull()方法，并返回false；另外Book还定义了一个静态的createNullBook方法，返回了一个NullBook的实例，NullBook是什么呢，我们来看一下：   </p>\n<pre><code>public class NullBook extends Book {  \n    @Override  \n    public boolean isNull() {  \n        return true;  \n    }  \n}  \n</code></pre><p>NullBook继承了Book，并在isNull()方法中返回true，这个NullBook其实就是我们上面提到的空对象，仅仅是个空箱子而已。<br>然后我们定义一个BookService类，用以模拟获取Book的接口方法：    </p>\n<pre><code>public class BookService {  \n    public Book getBook(int id) {  \n        if (id &lt; 0) {  \n            //返回一个空对象  \n            return Book.createNullBook();             \n        }  \n        return new Book(id, &quot;Design Pattern&quot;, 100);  \n    }  \n}  \n</code></pre><p>在getBook(int id)中，如果<code>id&lt;0</code>时，则返回一个NullBook的实例，在客户端调用isNull()方法时则返回true，表示是空对象；如果<code>id&gt;=0</code>时，则返回一个Book的实例，在客户端调用isNull()方法时则返回false，表示对象不为空，可以调用相关方法取得数据。对于我们的客户端来讲，返回的都是一个Book类型的对象，我们并不清楚返回的到底是真正的Book实例还是空对象NullBook实例，但是我们并不担心，因为有一点可以肯定的是，我们都可以放心的调用isNull()方法，因为它会根据运行期对象的类型返回一个正确的值。   </p>\n<p>多态的最根本好处在于：你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切事情多态机制会为你妥善处理。    </p>\n<p>最后再来看一下客户端是如何实现对象为空的判断的：    </p>\n<pre><code>public class Client {  \n    public static void main(String[] args) {  \n        BookService service = new BookService();  \n        Book book = service.getBook(-1);  \n        if (book.isNull()) {  \n            System.out.println(&quot;not found!&quot;);  \n        } else {  \n            System.out.println(&quot;name:&quot; + book.getName());  \n            System.out.println(&quot;price:&quot; + book.getPrice());  \n        }  \n    }  \n}  \n</code></pre><hr>\n<p>原文：<a href=\"http://blog.csdn.net/liuhe688/article/details/6586458\">http://blog.csdn.net/liuhe688/article/details/6586458</a></p>"},{"layout":"post","title":"设计模式：观察者（Observer） in java","date":"2012-11-08T10:50:00.000Z","comments":1,"_content":"**定义：**又叫发布订阅模式（Publish/subscribe），它定义了对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。  \n>这个定义还是比较通俗易懂的。我看了一遍，发现这不就是微博吗？我发布一条微博，那么所有关注我的人，都会收到通知，然后在新鲜事里显示出来。没错，就是这样！\n\t\n观察者模式有4个角色：  \n\n* 被观察者(Observable):  \n定义被观察者必须实现的职责，动态的增加、删除观察者以及通知观察者   \n* 观察者（Observer）:   \n接收到消息后，进行更新操作\n* 被观察者(Observable)具体类:  \n定义自己的业务逻辑，并定义哪儿些事件需要通知观察者   \n* 观察者（Observer）具体类：     \n每个观察者在接收到消息后的更新操作是不同的。\n \n\n<!--more-->\n在Java中如何实现观察者模式呢？废话，写代码啊！这个我自然知道，更令人惊喜的是JDK自身就提供了对观察者模式的原生支持，我不得不赞叹Java的强大。  \n\nJava提供了这样的两个东西：  \n\t\n* 类`java.util.Observable`：  \n它内部维护了一个Vector容器，用来放所有的观察者，并且提供了添加、删除观察者的方法。此外，定义了notifyObservers方法，用来通知观察者。  \n* 接口`java.util.Observer`：\n它定义了一个update方法，让Observer具体类来实现各自的操作。\n\n下面，就以微博作为例子吧。  \n先来一个被观察者，也就是我自己了。\n\n\tpublic class ShenYanChao extends Observable {\n\n\t\t//业务逻辑,不通知\n\t\tpublic String getName(){\n\t\t\treturn \"shenyanchao\";\n\t\t}\n\t\t//发微博，通知\n\t\tpublic void publishWeibo(String content){\n\t\t\tSystem.out.println(\"我发布1条微博，內容是：[\"+content+\"]\");\n\t\t\tsetChanged();\n\t\t\tnotifyObservers(content);\n\t\t}\n\t}\n其中，setChanged()用来表明自身的状态变了，否则观察者是不会理的。这个是JDK的限制，其实观察者模式可以不用这个的。  \n\n下面就需要定义观察者了，也就是我的粉丝了。\n\n\tpublic class Fans implements Observer {\n\n\t\t@Override\n\t\tpublic void update(Observable o, Object content) {\n\t\t\tString who = ((ShenYanChao) o).getName();\n\t\t\tSystem.out.println(\"新鲜事:{\" + who + \"发布了一条微博，内容是：[\" + content + \"]}\");\n\t\t}\n\n\t}\n观察者Fans一旦发现我发了1条微博，那么他就会出现一条新鲜事的了。update()的参数，第1个是被观察者，也就是我；第2个就是notifyObservers传过来的参数了，此处是微博内容。\n\n具体场景是这样的：\n\n\tShenYanChao shenyanchao = new ShenYanChao();\n\tfinal int FANS_NUM = 10;//我的粉丝可不止这些呢\n\tfor (int i = 0; i < FANS_NUM; i++) {\n\t\tshenyanchao.addObserver(new Fans());\n\t}\n\tshenyanchao.publishWeibo(\"欢迎登录：www.shenyanchao.cn\");\n\n此处模拟，我有10个粉丝，然后我发了1条微博。结果如下：  \n\n\t我发布1条微博，內容是：[欢迎登录：www.shenyanchao.cn]\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n可见，一旦我发了微博，所有的观察者（Fans）都收到了。\n\n","source":"_posts/2012-11-02-observer-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：观察者（Observer） in java\"\ndate: 2012-11-08 18:50\ncomments: true\ncategories: 设计模式\ntags: [ Java, Observer, Observable ]\n---\n**定义：**又叫发布订阅模式（Publish/subscribe），它定义了对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。  \n>这个定义还是比较通俗易懂的。我看了一遍，发现这不就是微博吗？我发布一条微博，那么所有关注我的人，都会收到通知，然后在新鲜事里显示出来。没错，就是这样！\n\t\n观察者模式有4个角色：  \n\n* 被观察者(Observable):  \n定义被观察者必须实现的职责，动态的增加、删除观察者以及通知观察者   \n* 观察者（Observer）:   \n接收到消息后，进行更新操作\n* 被观察者(Observable)具体类:  \n定义自己的业务逻辑，并定义哪儿些事件需要通知观察者   \n* 观察者（Observer）具体类：     \n每个观察者在接收到消息后的更新操作是不同的。\n \n\n<!--more-->\n在Java中如何实现观察者模式呢？废话，写代码啊！这个我自然知道，更令人惊喜的是JDK自身就提供了对观察者模式的原生支持，我不得不赞叹Java的强大。  \n\nJava提供了这样的两个东西：  \n\t\n* 类`java.util.Observable`：  \n它内部维护了一个Vector容器，用来放所有的观察者，并且提供了添加、删除观察者的方法。此外，定义了notifyObservers方法，用来通知观察者。  \n* 接口`java.util.Observer`：\n它定义了一个update方法，让Observer具体类来实现各自的操作。\n\n下面，就以微博作为例子吧。  \n先来一个被观察者，也就是我自己了。\n\n\tpublic class ShenYanChao extends Observable {\n\n\t\t//业务逻辑,不通知\n\t\tpublic String getName(){\n\t\t\treturn \"shenyanchao\";\n\t\t}\n\t\t//发微博，通知\n\t\tpublic void publishWeibo(String content){\n\t\t\tSystem.out.println(\"我发布1条微博，內容是：[\"+content+\"]\");\n\t\t\tsetChanged();\n\t\t\tnotifyObservers(content);\n\t\t}\n\t}\n其中，setChanged()用来表明自身的状态变了，否则观察者是不会理的。这个是JDK的限制，其实观察者模式可以不用这个的。  \n\n下面就需要定义观察者了，也就是我的粉丝了。\n\n\tpublic class Fans implements Observer {\n\n\t\t@Override\n\t\tpublic void update(Observable o, Object content) {\n\t\t\tString who = ((ShenYanChao) o).getName();\n\t\t\tSystem.out.println(\"新鲜事:{\" + who + \"发布了一条微博，内容是：[\" + content + \"]}\");\n\t\t}\n\n\t}\n观察者Fans一旦发现我发了1条微博，那么他就会出现一条新鲜事的了。update()的参数，第1个是被观察者，也就是我；第2个就是notifyObservers传过来的参数了，此处是微博内容。\n\n具体场景是这样的：\n\n\tShenYanChao shenyanchao = new ShenYanChao();\n\tfinal int FANS_NUM = 10;//我的粉丝可不止这些呢\n\tfor (int i = 0; i < FANS_NUM; i++) {\n\t\tshenyanchao.addObserver(new Fans());\n\t}\n\tshenyanchao.publishWeibo(\"欢迎登录：www.shenyanchao.cn\");\n\n此处模拟，我有10个粉丝，然后我发了1条微博。结果如下：  \n\n\t我发布1条微博，內容是：[欢迎登录：www.shenyanchao.cn]\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n\t新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n可见，一旦我发了微博，所有的观察者（Fans）都收到了。\n\n","slug":"2012-11-02-observer-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3u003cv8fywtg0i3yp","content":"<p><strong>定义：</strong>又叫发布订阅模式（Publish/subscribe），它定义了对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。  </p>\n<blockquote>\n<p>这个定义还是比较通俗易懂的。我看了一遍，发现这不就是微博吗？我发布一条微博，那么所有关注我的人，都会收到通知，然后在新鲜事里显示出来。没错，就是这样！</p>\n</blockquote>\n<p>观察者模式有4个角色：  </p>\n<ul>\n<li>被观察者(Observable):<br>定义被观察者必须实现的职责，动态的增加、删除观察者以及通知观察者   </li>\n<li>观察者（Observer）:<br>接收到消息后，进行更新操作</li>\n<li>被观察者(Observable)具体类:<br>定义自己的业务逻辑，并定义哪儿些事件需要通知观察者   </li>\n<li>观察者（Observer）具体类：<br>每个观察者在接收到消息后的更新操作是不同的。</li>\n</ul>\n<a id=\"more\"></a>\n<p>在Java中如何实现观察者模式呢？废话，写代码啊！这个我自然知道，更令人惊喜的是JDK自身就提供了对观察者模式的原生支持，我不得不赞叹Java的强大。  </p>\n<p>Java提供了这样的两个东西：  </p>\n<ul>\n<li>类<code>java.util.Observable</code>：<br>它内部维护了一个Vector容器，用来放所有的观察者，并且提供了添加、删除观察者的方法。此外，定义了notifyObservers方法，用来通知观察者。  </li>\n<li>接口<code>java.util.Observer</code>：<br>它定义了一个update方法，让Observer具体类来实现各自的操作。</li>\n</ul>\n<p>下面，就以微博作为例子吧。<br>先来一个被观察者，也就是我自己了。</p>\n<pre><code>public class ShenYanChao extends Observable {\n\n    //业务逻辑,不通知\n    public String getName(){\n        return &quot;shenyanchao&quot;;\n    }\n    //发微博，通知\n    public void publishWeibo(String content){\n        System.out.println(&quot;我发布1条微博，內容是：[&quot;+content+&quot;]&quot;);\n        setChanged();\n        notifyObservers(content);\n    }\n}\n</code></pre><p>其中，setChanged()用来表明自身的状态变了，否则观察者是不会理的。这个是JDK的限制，其实观察者模式可以不用这个的。  </p>\n<p>下面就需要定义观察者了，也就是我的粉丝了。</p>\n<pre><code>public class Fans implements Observer {\n\n    @Override\n    public void update(Observable o, Object content) {\n        String who = ((ShenYanChao) o).getName();\n        System.out.println(&quot;新鲜事:{&quot; + who + &quot;发布了一条微博，内容是：[&quot; + content + &quot;]}&quot;);\n    }\n\n}\n</code></pre><p>观察者Fans一旦发现我发了1条微博，那么他就会出现一条新鲜事的了。update()的参数，第1个是被观察者，也就是我；第2个就是notifyObservers传过来的参数了，此处是微博内容。</p>\n<p>具体场景是这样的：</p>\n<pre><code>ShenYanChao shenyanchao = new ShenYanChao();\nfinal int FANS_NUM = 10;//我的粉丝可不止这些呢\nfor (int i = 0; i &lt; FANS_NUM; i++) {\n    shenyanchao.addObserver(new Fans());\n}\nshenyanchao.publishWeibo(&quot;欢迎登录：www.shenyanchao.cn&quot;);\n</code></pre><p>此处模拟，我有10个粉丝，然后我发了1条微博。结果如下：  </p>\n<pre><code>我发布1条微博，內容是：[欢迎登录：www.shenyanchao.cn]\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n</code></pre><p>可见，一旦我发了微博，所有的观察者（Fans）都收到了。</p>\n","excerpt":"<p><strong>定义：</strong>又叫发布订阅模式（Publish/subscribe），它定义了对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。  </p>\n<blockquote>\n<p>这个定义还是比较通俗易懂的。我看了一遍，发现这不就是微博吗？我发布一条微博，那么所有关注我的人，都会收到通知，然后在新鲜事里显示出来。没错，就是这样！</p>\n</blockquote>\n<p>观察者模式有4个角色：  </p>\n<ul>\n<li>被观察者(Observable):<br>定义被观察者必须实现的职责，动态的增加、删除观察者以及通知观察者   </li>\n<li>观察者（Observer）:<br>接收到消息后，进行更新操作</li>\n<li>被观察者(Observable)具体类:<br>定义自己的业务逻辑，并定义哪儿些事件需要通知观察者   </li>\n<li>观察者（Observer）具体类：<br>每个观察者在接收到消息后的更新操作是不同的。</li>\n</ul>","more":"<p>在Java中如何实现观察者模式呢？废话，写代码啊！这个我自然知道，更令人惊喜的是JDK自身就提供了对观察者模式的原生支持，我不得不赞叹Java的强大。  </p>\n<p>Java提供了这样的两个东西：  </p>\n<ul>\n<li>类<code>java.util.Observable</code>：<br>它内部维护了一个Vector容器，用来放所有的观察者，并且提供了添加、删除观察者的方法。此外，定义了notifyObservers方法，用来通知观察者。  </li>\n<li>接口<code>java.util.Observer</code>：<br>它定义了一个update方法，让Observer具体类来实现各自的操作。</li>\n</ul>\n<p>下面，就以微博作为例子吧。<br>先来一个被观察者，也就是我自己了。</p>\n<pre><code>public class ShenYanChao extends Observable {\n\n    //业务逻辑,不通知\n    public String getName(){\n        return &quot;shenyanchao&quot;;\n    }\n    //发微博，通知\n    public void publishWeibo(String content){\n        System.out.println(&quot;我发布1条微博，內容是：[&quot;+content+&quot;]&quot;);\n        setChanged();\n        notifyObservers(content);\n    }\n}\n</code></pre><p>其中，setChanged()用来表明自身的状态变了，否则观察者是不会理的。这个是JDK的限制，其实观察者模式可以不用这个的。  </p>\n<p>下面就需要定义观察者了，也就是我的粉丝了。</p>\n<pre><code>public class Fans implements Observer {\n\n    @Override\n    public void update(Observable o, Object content) {\n        String who = ((ShenYanChao) o).getName();\n        System.out.println(&quot;新鲜事:{&quot; + who + &quot;发布了一条微博，内容是：[&quot; + content + &quot;]}&quot;);\n    }\n\n}\n</code></pre><p>观察者Fans一旦发现我发了1条微博，那么他就会出现一条新鲜事的了。update()的参数，第1个是被观察者，也就是我；第2个就是notifyObservers传过来的参数了，此处是微博内容。</p>\n<p>具体场景是这样的：</p>\n<pre><code>ShenYanChao shenyanchao = new ShenYanChao();\nfinal int FANS_NUM = 10;//我的粉丝可不止这些呢\nfor (int i = 0; i &lt; FANS_NUM; i++) {\n    shenyanchao.addObserver(new Fans());\n}\nshenyanchao.publishWeibo(&quot;欢迎登录：www.shenyanchao.cn&quot;);\n</code></pre><p>此处模拟，我有10个粉丝，然后我发了1条微博。结果如下：  </p>\n<pre><code>我发布1条微博，內容是：[欢迎登录：www.shenyanchao.cn]\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n新鲜事:{shenyanchao发布了一条微博，内容是：[欢迎登录：www.shenyanchao.cn]}\n</code></pre><p>可见，一旦我发了微博，所有的观察者（Fans）都收到了。</p>"},{"layout":"post","title":"设计模式：原型（prototype） in java","date":"2012-11-07T12:41:00.000Z","comments":1,"_content":"**定义：**用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。  \n基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。 \n\nJava中的原型模式：\n\n\tpublic class ProtoTypeClass implements Cloneable {\n\n\t\t@Override\n\t\tpublic ProtoTypeClass clone(){\n\t\t\tProtoTypeClass cloneObject = null;\n\t\t\ttry{\n\t\t\t\tcloneObject = (ProtoTypeClass) super.clone();\n\t\t\t}catch (Exception e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t}\n\t\t\treturn cloneObject;\n\t\t}\n\t}\n上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。\n\n* clone时，构造函数不会执行\n* 浅拷贝与深拷贝\n\n这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。","source":"_posts/2012-11-02-prototype-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：原型（prototype） in java\"\ndate: 2012-11-07 20:41\ncomments: true\ncategories: 设计模式\ntags: [ Java, prototype, Clone ]\n---\n**定义：**用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。  \n基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。 \n\nJava中的原型模式：\n\n\tpublic class ProtoTypeClass implements Cloneable {\n\n\t\t@Override\n\t\tpublic ProtoTypeClass clone(){\n\t\t\tProtoTypeClass cloneObject = null;\n\t\t\ttry{\n\t\t\t\tcloneObject = (ProtoTypeClass) super.clone();\n\t\t\t}catch (Exception e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t}\n\t\t\treturn cloneObject;\n\t\t}\n\t}\n上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。\n\n* clone时，构造函数不会执行\n* 浅拷贝与深拷贝\n\n这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。","slug":"2012-11-02-prototype-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3v003fv8fy3ghlzida","content":"<p><strong>定义：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。 </p>\n<p>Java中的原型模式：</p>\n<pre><code>public class ProtoTypeClass implements Cloneable {\n\n    @Override\n    public ProtoTypeClass clone(){\n        ProtoTypeClass cloneObject = null;\n        try{\n            cloneObject = (ProtoTypeClass) super.clone();\n        }catch (Exception e) {\n            // TODO: handle exception\n        }\n        return cloneObject;\n    }\n}\n</code></pre><p>上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。</p>\n<ul>\n<li>clone时，构造函数不会执行</li>\n<li>浅拷贝与深拷贝</li>\n</ul>\n<p>这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。</p>\n","excerpt":"","more":"<p><strong>定义：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br>基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。 </p>\n<p>Java中的原型模式：</p>\n<pre><code>public class ProtoTypeClass implements Cloneable {\n\n    @Override\n    public ProtoTypeClass clone(){\n        ProtoTypeClass cloneObject = null;\n        try{\n            cloneObject = (ProtoTypeClass) super.clone();\n        }catch (Exception e) {\n            // TODO: handle exception\n        }\n        return cloneObject;\n    }\n}\n</code></pre><p>上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。</p>\n<ul>\n<li>clone时，构造函数不会执行</li>\n<li>浅拷贝与深拷贝</li>\n</ul>\n<p>这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。</p>\n"},{"layout":"post","title":"设计模式：代理（Proxy） in java","date":"2012-11-02T08:21:00.000Z","comments":1,"_content":"##什么是代理？##\n代理是指，本该有A做的工作，现在找一个代理人B，然后由B来进行实际的工作。  \n代理，简单来分，可以分为以下两类：   \n\n* 静态代理\n* 动态代理\n<!--more-->\n\n##静态代理##\n以实现两个数的加法场景为例：   \n\n\tpublic interface IAdd {\n\t\tpublic int add(int a, int b);\n\t}\n实现类：\n\n\tpublic class Add implements IAdd {\n\t\t@Override\n\t\tpublic int add(int a, int b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n直接使用的话：\n\t\n\tAdd add = new Add();\n\tadd.add(3, 14);\n那么我想在执行加运算时，做一些其他操作怎么办，已有的类ADD无法改，没有源码。这时很容易想到的就是扩展：\n\n\tpublic class AddProxy implements IAdd {\n\t\tprivate IAdd add;\n\n\t\tpublic AddProxy(IAdd add) {\n\t\t\tthis.add = add;\n\t\t}\n\t\t@Override\n\t\tpublic int add(int a, int b) {\n\t\t\tSystem.out.println(\"...begin...\");\n\t\t\tint result = add.add(3, 14);\n\t\t\tSystem.out.println(\"...end...\");\n\t\t\treturn result;\n\t\t}\n\t}\n这样做，没有修改已有的类，并且增加了一些操作，此处为一些提示信息。采用了组合的方式，实现了代理模式。具体使用时，直接使用AddProxy即可。   \n\n\tIAdd add = new AddProxy(new Add());\n\tint result = add.add(3, 14);\n此为**静态代理**也。   \n##动态代理##\n动态代理，是指运行时动态的生成代理类，完成功能。静态代理中，显然AddProxy是编译期已知的了。实现方式，主要有两种：   \n\n* JDK Proxy\n* Cglib Proxy    \n\n###JDK Proxy###\nJava自身提供了相关的类，来实现动态代理。    \n首先要定义一个`java.lang.reflect.InvocationHandler`接口实现   \n\n\timport java.lang.reflect.InvocationHandler;\n\timport java.lang.reflect.Method;\n\t/**\n \t* @author shenyanchao\n \t*/\n\tpublic class AddInvocationHandler implements InvocationHandler {\n\t\t\n\t\tprivate Object target;\n\t\t//绑定要代理的目标类\n\t\tpublic void bind(Object target) {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\tSystem.out.println(\"......begin....\");\n\t\t\tObject result = method.invoke(target, args);\n\t\t\tSystem.out.println(\"......end....\");\n\t\t\treturn result;\n\t\t}\n\t}\n那么在具体使用时，代码如下：  \n\t\n\tAddInvocationHandler addHandler = new AddInvocationHandler();\n\tIAdd add = new Add();\n\taddHandler.bind(add);\n\tIAdd addProxy = (IAdd) Proxy.newProxyInstance(\n\t\t\t\tAdd.class.getClassLoader(), Add.class.getInterfaces(),\n\t\t\t\taddHandler);\n\tint jdkResult = addProxy.add(3, 14);\n从代码可见，主要是通过`Proxy.newProxyInstance`来在运行时生成代理类。需要注意的是，第二个参数必须使用具体实现类Add来获得interfaces，也就是说其代理的类必须实现了接口。`addHandler`负责绑定要代理的target类，并调用invoke来增强Add功能。  \n###Cglib Proxy###\nJDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。   \n要使用CgLib，首先要实现一个CallBack接口的类，由于本例是为了实现method的拦截，因此直接实现MethodInterceptor即可：  \n\n\timport java.lang.reflect.Method;\n\timport net.sf.cglib.proxy.MethodInterceptor;\n\timport net.sf.cglib.proxy.MethodProxy;\n\t/**\n \t* @author shenyanchao\n \t*/\n\tpublic class AddInterceptor implements MethodInterceptor {\n\n\t@Override\n\tpublic Object intercept(Object obj, Method method, Object[] args,\n\t\t\tMethodProxy proxy) throws Throwable {\n\t\t\tSystem.out.println(\"....begin....\");\n\t\t\tObject result = proxy.invokeSuper(obj, args);\n\t\t\tSystem.out.println(\"....end....\");\n\t\t\treturn result;\n\t\t}\n\t}\n具体使用时：  \n\n\tEnhancer enhancer = new Enhancer();\n\tenhancer.setSuperclass(Add.class);\n\tenhancer.setCallback(new AddInterceptor());\n\tAdd add  =  (Add) enhancer.create();\n\tint result = add.add(3, 14);\n通过Enhancer制定需要增强的类，并设置CallBack函数来实现代理与功能增强。\n\n","source":"_posts/2012-11-02-proxy-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：代理（Proxy） in java\"\ndate: 2012-11-02 16:21\ncomments: true\ncategories: 设计模式\ntags: [ Java, proxy, JDK, cglib ]\n---\n##什么是代理？##\n代理是指，本该有A做的工作，现在找一个代理人B，然后由B来进行实际的工作。  \n代理，简单来分，可以分为以下两类：   \n\n* 静态代理\n* 动态代理\n<!--more-->\n\n##静态代理##\n以实现两个数的加法场景为例：   \n\n\tpublic interface IAdd {\n\t\tpublic int add(int a, int b);\n\t}\n实现类：\n\n\tpublic class Add implements IAdd {\n\t\t@Override\n\t\tpublic int add(int a, int b) {\n\t\t\treturn a + b;\n\t\t}\n\t}\n直接使用的话：\n\t\n\tAdd add = new Add();\n\tadd.add(3, 14);\n那么我想在执行加运算时，做一些其他操作怎么办，已有的类ADD无法改，没有源码。这时很容易想到的就是扩展：\n\n\tpublic class AddProxy implements IAdd {\n\t\tprivate IAdd add;\n\n\t\tpublic AddProxy(IAdd add) {\n\t\t\tthis.add = add;\n\t\t}\n\t\t@Override\n\t\tpublic int add(int a, int b) {\n\t\t\tSystem.out.println(\"...begin...\");\n\t\t\tint result = add.add(3, 14);\n\t\t\tSystem.out.println(\"...end...\");\n\t\t\treturn result;\n\t\t}\n\t}\n这样做，没有修改已有的类，并且增加了一些操作，此处为一些提示信息。采用了组合的方式，实现了代理模式。具体使用时，直接使用AddProxy即可。   \n\n\tIAdd add = new AddProxy(new Add());\n\tint result = add.add(3, 14);\n此为**静态代理**也。   \n##动态代理##\n动态代理，是指运行时动态的生成代理类，完成功能。静态代理中，显然AddProxy是编译期已知的了。实现方式，主要有两种：   \n\n* JDK Proxy\n* Cglib Proxy    \n\n###JDK Proxy###\nJava自身提供了相关的类，来实现动态代理。    \n首先要定义一个`java.lang.reflect.InvocationHandler`接口实现   \n\n\timport java.lang.reflect.InvocationHandler;\n\timport java.lang.reflect.Method;\n\t/**\n \t* @author shenyanchao\n \t*/\n\tpublic class AddInvocationHandler implements InvocationHandler {\n\t\t\n\t\tprivate Object target;\n\t\t//绑定要代理的目标类\n\t\tpublic void bind(Object target) {\n\t\t\tthis.target = target;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\t\tSystem.out.println(\"......begin....\");\n\t\t\tObject result = method.invoke(target, args);\n\t\t\tSystem.out.println(\"......end....\");\n\t\t\treturn result;\n\t\t}\n\t}\n那么在具体使用时，代码如下：  \n\t\n\tAddInvocationHandler addHandler = new AddInvocationHandler();\n\tIAdd add = new Add();\n\taddHandler.bind(add);\n\tIAdd addProxy = (IAdd) Proxy.newProxyInstance(\n\t\t\t\tAdd.class.getClassLoader(), Add.class.getInterfaces(),\n\t\t\t\taddHandler);\n\tint jdkResult = addProxy.add(3, 14);\n从代码可见，主要是通过`Proxy.newProxyInstance`来在运行时生成代理类。需要注意的是，第二个参数必须使用具体实现类Add来获得interfaces，也就是说其代理的类必须实现了接口。`addHandler`负责绑定要代理的target类，并调用invoke来增强Add功能。  \n###Cglib Proxy###\nJDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。   \n要使用CgLib，首先要实现一个CallBack接口的类，由于本例是为了实现method的拦截，因此直接实现MethodInterceptor即可：  \n\n\timport java.lang.reflect.Method;\n\timport net.sf.cglib.proxy.MethodInterceptor;\n\timport net.sf.cglib.proxy.MethodProxy;\n\t/**\n \t* @author shenyanchao\n \t*/\n\tpublic class AddInterceptor implements MethodInterceptor {\n\n\t@Override\n\tpublic Object intercept(Object obj, Method method, Object[] args,\n\t\t\tMethodProxy proxy) throws Throwable {\n\t\t\tSystem.out.println(\"....begin....\");\n\t\t\tObject result = proxy.invokeSuper(obj, args);\n\t\t\tSystem.out.println(\"....end....\");\n\t\t\treturn result;\n\t\t}\n\t}\n具体使用时：  \n\n\tEnhancer enhancer = new Enhancer();\n\tenhancer.setSuperclass(Add.class);\n\tenhancer.setCallback(new AddInterceptor());\n\tAdd add  =  (Add) enhancer.create();\n\tint result = add.add(3, 14);\n通过Enhancer制定需要增强的类，并设置CallBack函数来实现代理与功能增强。\n\n","slug":"2012-11-02-proxy-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop3y003jv8fyc6faixfu","content":"<p>##什么是代理？##<br>代理是指，本该有A做的工作，现在找一个代理人B，然后由B来进行实际的工作。<br>代理，简单来分，可以分为以下两类：   </p>\n<ul>\n<li>静态代理</li>\n<li>动态代理<a id=\"more\"></a>\n</li>\n</ul>\n<p>##静态代理##<br>以实现两个数的加法场景为例：   </p>\n<pre><code>public interface IAdd {\n    public int add(int a, int b);\n}\n</code></pre><p>实现类：</p>\n<pre><code>public class Add implements IAdd {\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>直接使用的话：</p>\n<pre><code>Add add = new Add();\nadd.add(3, 14);\n</code></pre><p>那么我想在执行加运算时，做一些其他操作怎么办，已有的类ADD无法改，没有源码。这时很容易想到的就是扩展：</p>\n<pre><code>public class AddProxy implements IAdd {\n    private IAdd add;\n\n    public AddProxy(IAdd add) {\n        this.add = add;\n    }\n    @Override\n    public int add(int a, int b) {\n        System.out.println(&quot;...begin...&quot;);\n        int result = add.add(3, 14);\n        System.out.println(&quot;...end...&quot;);\n        return result;\n    }\n}\n</code></pre><p>这样做，没有修改已有的类，并且增加了一些操作，此处为一些提示信息。采用了组合的方式，实现了代理模式。具体使用时，直接使用AddProxy即可。   </p>\n<pre><code>IAdd add = new AddProxy(new Add());\nint result = add.add(3, 14);\n</code></pre><p>此为<strong>静态代理</strong>也。   </p>\n<p>##动态代理##<br>动态代理，是指运行时动态的生成代理类，完成功能。静态代理中，显然AddProxy是编译期已知的了。实现方式，主要有两种：   </p>\n<ul>\n<li>JDK Proxy</li>\n<li>Cglib Proxy    </li>\n</ul>\n<p>###JDK Proxy###<br>Java自身提供了相关的类，来实现动态代理。<br>首先要定义一个<code>java.lang.reflect.InvocationHandler</code>接口实现   </p>\n<pre><code>import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n/**\n * @author shenyanchao\n */\npublic class AddInvocationHandler implements InvocationHandler {\n\n    private Object target;\n    //绑定要代理的目标类\n    public void bind(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable {\n        System.out.println(&quot;......begin....&quot;);\n        Object result = method.invoke(target, args);\n        System.out.println(&quot;......end....&quot;);\n        return result;\n    }\n}\n</code></pre><p>那么在具体使用时，代码如下：  </p>\n<pre><code>AddInvocationHandler addHandler = new AddInvocationHandler();\nIAdd add = new Add();\naddHandler.bind(add);\nIAdd addProxy = (IAdd) Proxy.newProxyInstance(\n            Add.class.getClassLoader(), Add.class.getInterfaces(),\n            addHandler);\nint jdkResult = addProxy.add(3, 14);\n</code></pre><p>从代码可见，主要是通过<code>Proxy.newProxyInstance</code>来在运行时生成代理类。需要注意的是，第二个参数必须使用具体实现类Add来获得interfaces，也就是说其代理的类必须实现了接口。<code>addHandler</code>负责绑定要代理的target类，并调用invoke来增强Add功能。  </p>\n<p>###Cglib Proxy###<br>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。<br>要使用CgLib，首先要实现一个CallBack接口的类，由于本例是为了实现method的拦截，因此直接实现MethodInterceptor即可：  </p>\n<pre><code>import java.lang.reflect.Method;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n/**\n * @author shenyanchao\n */\npublic class AddInterceptor implements MethodInterceptor {\n\n@Override\npublic Object intercept(Object obj, Method method, Object[] args,\n        MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;....begin....&quot;);\n        Object result = proxy.invokeSuper(obj, args);\n        System.out.println(&quot;....end....&quot;);\n        return result;\n    }\n}\n</code></pre><p>具体使用时：  </p>\n<pre><code>Enhancer enhancer = new Enhancer();\nenhancer.setSuperclass(Add.class);\nenhancer.setCallback(new AddInterceptor());\nAdd add  =  (Add) enhancer.create();\nint result = add.add(3, 14);\n</code></pre><p>通过Enhancer制定需要增强的类，并设置CallBack函数来实现代理与功能增强。</p>\n","excerpt":"<p>##什么是代理？##<br>代理是指，本该有A做的工作，现在找一个代理人B，然后由B来进行实际的工作。<br>代理，简单来分，可以分为以下两类：   </p>\n<ul>\n<li>静态代理</li>\n<li>动态代理","more":"</li>\n</ul>\n<p>##静态代理##<br>以实现两个数的加法场景为例：   </p>\n<pre><code>public interface IAdd {\n    public int add(int a, int b);\n}\n</code></pre><p>实现类：</p>\n<pre><code>public class Add implements IAdd {\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>直接使用的话：</p>\n<pre><code>Add add = new Add();\nadd.add(3, 14);\n</code></pre><p>那么我想在执行加运算时，做一些其他操作怎么办，已有的类ADD无法改，没有源码。这时很容易想到的就是扩展：</p>\n<pre><code>public class AddProxy implements IAdd {\n    private IAdd add;\n\n    public AddProxy(IAdd add) {\n        this.add = add;\n    }\n    @Override\n    public int add(int a, int b) {\n        System.out.println(&quot;...begin...&quot;);\n        int result = add.add(3, 14);\n        System.out.println(&quot;...end...&quot;);\n        return result;\n    }\n}\n</code></pre><p>这样做，没有修改已有的类，并且增加了一些操作，此处为一些提示信息。采用了组合的方式，实现了代理模式。具体使用时，直接使用AddProxy即可。   </p>\n<pre><code>IAdd add = new AddProxy(new Add());\nint result = add.add(3, 14);\n</code></pre><p>此为<strong>静态代理</strong>也。   </p>\n<p>##动态代理##<br>动态代理，是指运行时动态的生成代理类，完成功能。静态代理中，显然AddProxy是编译期已知的了。实现方式，主要有两种：   </p>\n<ul>\n<li>JDK Proxy</li>\n<li>Cglib Proxy    </li>\n</ul>\n<p>###JDK Proxy###<br>Java自身提供了相关的类，来实现动态代理。<br>首先要定义一个<code>java.lang.reflect.InvocationHandler</code>接口实现   </p>\n<pre><code>import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n/**\n * @author shenyanchao\n */\npublic class AddInvocationHandler implements InvocationHandler {\n\n    private Object target;\n    //绑定要代理的目标类\n    public void bind(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable {\n        System.out.println(&quot;......begin....&quot;);\n        Object result = method.invoke(target, args);\n        System.out.println(&quot;......end....&quot;);\n        return result;\n    }\n}\n</code></pre><p>那么在具体使用时，代码如下：  </p>\n<pre><code>AddInvocationHandler addHandler = new AddInvocationHandler();\nIAdd add = new Add();\naddHandler.bind(add);\nIAdd addProxy = (IAdd) Proxy.newProxyInstance(\n            Add.class.getClassLoader(), Add.class.getInterfaces(),\n            addHandler);\nint jdkResult = addProxy.add(3, 14);\n</code></pre><p>从代码可见，主要是通过<code>Proxy.newProxyInstance</code>来在运行时生成代理类。需要注意的是，第二个参数必须使用具体实现类Add来获得interfaces，也就是说其代理的类必须实现了接口。<code>addHandler</code>负责绑定要代理的target类，并调用invoke来增强Add功能。  </p>\n<p>###Cglib Proxy###<br>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。<br>要使用CgLib，首先要实现一个CallBack接口的类，由于本例是为了实现method的拦截，因此直接实现MethodInterceptor即可：  </p>\n<pre><code>import java.lang.reflect.Method;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n/**\n * @author shenyanchao\n */\npublic class AddInterceptor implements MethodInterceptor {\n\n@Override\npublic Object intercept(Object obj, Method method, Object[] args,\n        MethodProxy proxy) throws Throwable {\n        System.out.println(&quot;....begin....&quot;);\n        Object result = proxy.invokeSuper(obj, args);\n        System.out.println(&quot;....end....&quot;);\n        return result;\n    }\n}\n</code></pre><p>具体使用时：  </p>\n<pre><code>Enhancer enhancer = new Enhancer();\nenhancer.setSuperclass(Add.class);\nenhancer.setCallback(new AddInterceptor());\nAdd add  =  (Add) enhancer.create();\nint result = add.add(3, 14);\n</code></pre><p>通过Enhancer制定需要增强的类，并设置CallBack函数来实现代理与功能增强。</p>"},{"layout":"post","title":"设计模式：状态（state） in java","date":"2012-11-02T12:11:00.000Z","comments":1,"_content":"**定义：**当一个对象内在状态改变时允许其改变行为，这个对象看起来想改变了其类。    \n状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。    \n\n状态模式有3个角色：    \n\n- State抽象状态角色      \n接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态转换。    \n- ConcreteState具体状态角色    \n每一个具体状态必须完成2个职责：本状态的行为管理以及趋向状态处理。简单说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。       \n- Context环境角色     \n定义客户端需要的接口，并且负责具体状态的切换。    \n\n<!--more-->\n具体看看各个角色的实现.    \n\n抽象状态角色    \n\n    public abstract class State{\n        //定义一个环境角色，提供子类访问\n        protected Context context;\n        //设置环境角色\n        public void setContext(Context _context){\n            this.context = _context;\n        }\n        //行为1\n        public abstract void handle1();\n        //行为2\n        public abstract void handle2();\n    \n    }\n    \n具体状态角色    \n\n    public class ConcreteState1 extends State{\n        @override\n        public void handle1(){\n            //本状态下必须处理的逻辑\n        }\n        @override\n        public void handle2(){\n            //设置当前状态为STATE2\n            super.context.setCurrentState(Context.STATE2);\n            //过渡到STATE2状态，由Context实现\n            super.context.handle2();\n        }\n    }\n    \n    public class ConcreteState2 extends State{\n    \n        @override\n        public void handle1(){\n            //设置当前状态为STATE1\n            super.context.setCurrentState(Context.STATE1);\n            //过渡到STATE1状态，由Context实现\n            super.context.handle1();\n        }\n        @override\n        public void handle2(){\n            //本状态下必须处理的逻辑\n        }\n    }\n\n具体环境角色     \n\n    public class Context{\n        //定义状态\n        public final static State STATE1 = new ConcreteState1();\n        public final static State STATE2 = new ConcreteState2();\n        //当前状态\n        private State CurrentState;\n        //获得当前状态\n        public State getCurrentState(){\n            return CurrentState;\n        }\n        //设置当前状态\n        public void setCurrentState(State currentState){\n            this.CurrentState = currentState;\n            //切换状态\n            this.CurrentState.setContext(this);\n        }\n        //行为委托\n        public void handle1(){\n            this.CurrentState.handle1();\n        }\n        public void handle2(){\n            this.CurrentState.handle2();\n        }\n    }\n环境角色有2个不成文的约束：    \n\n- 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。 \n- 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。   \n\n在具体使用状态模式的时候，直接调用Context就行了。    \n\n    public class Client{\n        public static void main(String[] args){\n            Context context = new Context();\n            context.setCurrentState(new ConcreteState1());\n            context.handle1();\n            context.handle2();\n        }\n    }\n\n\n\n\n\n\n","source":"_posts/2012-11-02-state-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：状态（state） in java\"\ndate: 2012-11-02 20:11\ncomments: true\ncategories: 设计模式\ntags: [ state, pattern, 状态 ]\n---\n**定义：**当一个对象内在状态改变时允许其改变行为，这个对象看起来想改变了其类。    \n状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。    \n\n状态模式有3个角色：    \n\n- State抽象状态角色      \n接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态转换。    \n- ConcreteState具体状态角色    \n每一个具体状态必须完成2个职责：本状态的行为管理以及趋向状态处理。简单说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。       \n- Context环境角色     \n定义客户端需要的接口，并且负责具体状态的切换。    \n\n<!--more-->\n具体看看各个角色的实现.    \n\n抽象状态角色    \n\n    public abstract class State{\n        //定义一个环境角色，提供子类访问\n        protected Context context;\n        //设置环境角色\n        public void setContext(Context _context){\n            this.context = _context;\n        }\n        //行为1\n        public abstract void handle1();\n        //行为2\n        public abstract void handle2();\n    \n    }\n    \n具体状态角色    \n\n    public class ConcreteState1 extends State{\n        @override\n        public void handle1(){\n            //本状态下必须处理的逻辑\n        }\n        @override\n        public void handle2(){\n            //设置当前状态为STATE2\n            super.context.setCurrentState(Context.STATE2);\n            //过渡到STATE2状态，由Context实现\n            super.context.handle2();\n        }\n    }\n    \n    public class ConcreteState2 extends State{\n    \n        @override\n        public void handle1(){\n            //设置当前状态为STATE1\n            super.context.setCurrentState(Context.STATE1);\n            //过渡到STATE1状态，由Context实现\n            super.context.handle1();\n        }\n        @override\n        public void handle2(){\n            //本状态下必须处理的逻辑\n        }\n    }\n\n具体环境角色     \n\n    public class Context{\n        //定义状态\n        public final static State STATE1 = new ConcreteState1();\n        public final static State STATE2 = new ConcreteState2();\n        //当前状态\n        private State CurrentState;\n        //获得当前状态\n        public State getCurrentState(){\n            return CurrentState;\n        }\n        //设置当前状态\n        public void setCurrentState(State currentState){\n            this.CurrentState = currentState;\n            //切换状态\n            this.CurrentState.setContext(this);\n        }\n        //行为委托\n        public void handle1(){\n            this.CurrentState.handle1();\n        }\n        public void handle2(){\n            this.CurrentState.handle2();\n        }\n    }\n环境角色有2个不成文的约束：    \n\n- 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。 \n- 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。   \n\n在具体使用状态模式的时候，直接调用Context就行了。    \n\n    public class Client{\n        public static void main(String[] args){\n            Context context = new Context();\n            context.setCurrentState(new ConcreteState1());\n            context.handle1();\n            context.handle2();\n        }\n    }\n\n\n\n\n\n\n","slug":"2012-11-02-state-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop41003nv8fyzai65iut","content":"<p><strong>定义：</strong>当一个对象内在状态改变时允许其改变行为，这个对象看起来想改变了其类。<br>状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。    </p>\n<p>状态模式有3个角色：    </p>\n<ul>\n<li>State抽象状态角色<br>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态转换。    </li>\n<li>ConcreteState具体状态角色<br>每一个具体状态必须完成2个职责：本状态的行为管理以及趋向状态处理。简单说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。       </li>\n<li>Context环境角色<br>定义客户端需要的接口，并且负责具体状态的切换。    </li>\n</ul>\n<a id=\"more\"></a>\n<p>具体看看各个角色的实现.    </p>\n<p>抽象状态角色    </p>\n<pre><code>public abstract class State{\n    //定义一个环境角色，提供子类访问\n    protected Context context;\n    //设置环境角色\n    public void setContext(Context _context){\n        this.context = _context;\n    }\n    //行为1\n    public abstract void handle1();\n    //行为2\n    public abstract void handle2();\n\n}\n</code></pre><p>具体状态角色    </p>\n<pre><code>public class ConcreteState1 extends State{\n    @override\n    public void handle1(){\n        //本状态下必须处理的逻辑\n    }\n    @override\n    public void handle2(){\n        //设置当前状态为STATE2\n        super.context.setCurrentState(Context.STATE2);\n        //过渡到STATE2状态，由Context实现\n        super.context.handle2();\n    }\n}\n\npublic class ConcreteState2 extends State{\n\n    @override\n    public void handle1(){\n        //设置当前状态为STATE1\n        super.context.setCurrentState(Context.STATE1);\n        //过渡到STATE1状态，由Context实现\n        super.context.handle1();\n    }\n    @override\n    public void handle2(){\n        //本状态下必须处理的逻辑\n    }\n}\n</code></pre><p>具体环境角色     </p>\n<pre><code>public class Context{\n    //定义状态\n    public final static State STATE1 = new ConcreteState1();\n    public final static State STATE2 = new ConcreteState2();\n    //当前状态\n    private State CurrentState;\n    //获得当前状态\n    public State getCurrentState(){\n        return CurrentState;\n    }\n    //设置当前状态\n    public void setCurrentState(State currentState){\n        this.CurrentState = currentState;\n        //切换状态\n        this.CurrentState.setContext(this);\n    }\n    //行为委托\n    public void handle1(){\n        this.CurrentState.handle1();\n    }\n    public void handle2(){\n        this.CurrentState.handle2();\n    }\n}\n</code></pre><p>环境角色有2个不成文的约束：    </p>\n<ul>\n<li>把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。 </li>\n<li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。   </li>\n</ul>\n<p>在具体使用状态模式的时候，直接调用Context就行了。    </p>\n<pre><code>public class Client{\n    public static void main(String[] args){\n        Context context = new Context();\n        context.setCurrentState(new ConcreteState1());\n        context.handle1();\n        context.handle2();\n    }\n}\n</code></pre>","excerpt":"<p><strong>定义：</strong>当一个对象内在状态改变时允许其改变行为，这个对象看起来想改变了其类。<br>状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。    </p>\n<p>状态模式有3个角色：    </p>\n<ul>\n<li>State抽象状态角色<br>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态转换。    </li>\n<li>ConcreteState具体状态角色<br>每一个具体状态必须完成2个职责：本状态的行为管理以及趋向状态处理。简单说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。       </li>\n<li>Context环境角色<br>定义客户端需要的接口，并且负责具体状态的切换。    </li>\n</ul>","more":"<p>具体看看各个角色的实现.    </p>\n<p>抽象状态角色    </p>\n<pre><code>public abstract class State{\n    //定义一个环境角色，提供子类访问\n    protected Context context;\n    //设置环境角色\n    public void setContext(Context _context){\n        this.context = _context;\n    }\n    //行为1\n    public abstract void handle1();\n    //行为2\n    public abstract void handle2();\n\n}\n</code></pre><p>具体状态角色    </p>\n<pre><code>public class ConcreteState1 extends State{\n    @override\n    public void handle1(){\n        //本状态下必须处理的逻辑\n    }\n    @override\n    public void handle2(){\n        //设置当前状态为STATE2\n        super.context.setCurrentState(Context.STATE2);\n        //过渡到STATE2状态，由Context实现\n        super.context.handle2();\n    }\n}\n\npublic class ConcreteState2 extends State{\n\n    @override\n    public void handle1(){\n        //设置当前状态为STATE1\n        super.context.setCurrentState(Context.STATE1);\n        //过渡到STATE1状态，由Context实现\n        super.context.handle1();\n    }\n    @override\n    public void handle2(){\n        //本状态下必须处理的逻辑\n    }\n}\n</code></pre><p>具体环境角色     </p>\n<pre><code>public class Context{\n    //定义状态\n    public final static State STATE1 = new ConcreteState1();\n    public final static State STATE2 = new ConcreteState2();\n    //当前状态\n    private State CurrentState;\n    //获得当前状态\n    public State getCurrentState(){\n        return CurrentState;\n    }\n    //设置当前状态\n    public void setCurrentState(State currentState){\n        this.CurrentState = currentState;\n        //切换状态\n        this.CurrentState.setContext(this);\n    }\n    //行为委托\n    public void handle1(){\n        this.CurrentState.handle1();\n    }\n    public void handle2(){\n        this.CurrentState.handle2();\n    }\n}\n</code></pre><p>环境角色有2个不成文的约束：    </p>\n<ul>\n<li>把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。 </li>\n<li>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。   </li>\n</ul>\n<p>在具体使用状态模式的时候，直接调用Context就行了。    </p>\n<pre><code>public class Client{\n    public static void main(String[] args){\n        Context context = new Context();\n        context.setCurrentState(new ConcreteState1());\n        context.handle1();\n        context.handle2();\n    }\n}\n</code></pre>"},{"layout":"post","title":"设计模式：单例（singleton） in java","date":"2012-11-02T10:47:00.000Z","comments":1,"_content":"###概要###\n单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。    \n\n单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。   \n<!--more-->   \n单例模式的用意在于前一段中所关心的。通过单例模式你可以： \n\n* 确保一个类只有一个实例被建立 \n* 提供了一个对对象的全局访问指针 \n* 在不影响单例类的客户端的情况下允许将来有多个实例 \n\n尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。这篇文章讨论了单例模式并揭示了那些缺陷。  \n\n###单例模式###\n\n在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。\n下图说明了单例模式的类图。    \n![](/images/blog/singleton.jpg)\n \n正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。   \n例1显示了一个经典的单例模式的实现。   \n例1.经典的单例模式  \n \n\tpublic class ClassicSingleton {   \n   \t\tprivate static ClassicSingleton instance = null;   \n    \n   \t\tprotected ClassicSingleton() {   \n      \t\t// Exists only to defeat instantiation.   \n   \t\t}   \n   \t\tpublic static ClassicSingleton getInstance() {   \n      \t\tif(instance == null) {   \n         \t\tinstance = new ClassicSingleton();   \n      \t\t}   \n      \t\treturn instance;   \n   \t\t}   \n\t}   \n\n在例1中的单例模式的实现很容易理解。ClassicSingleton类保持了一个对单独的单例实例的静态引用，并且从静态方法getInstance()中返回那个引用。   \n关于ClassicSingleton类，有几个让我们感兴趣的地方。   \n首先，ClassicSingleton使用了一个众所周知的懒汉式实例化去创建那个单例类的引用;结果，这个单例类的实例直到getInstance()方法被第一次调用时才被创建。这种技巧可以确保单例类的实例只有在需要时才被建立出来。其次，注意ClassicSingleton实现了一个protected的构造方法，这样客户端不能直接实例化一个ClassicSingleton类的实例。然而，你会惊奇的发现下面的代码完全合法：   \n\n\tpublic class SingletonInstantiator {    \n  \t\tpublic SingletonInstantiator() {    \n   \t\t\tClassicSingleton instance = ClassicSingleton.getInstance();   \n\t\t\tClassicSingleton anotherInstance =  new ClassicSingleton();   \n       \t\t...    \n  \t\t\t}    \n\t}   \n前面这个代码片段为何能在没有继承ClassicSingleton并且ClassicSingleton类的构造方法是protected的情况下创建其实例？   \n答案是protected的构造方法可以被其子类以及在同一个包中的其它类调用。因为ClassicSingleton和SingletonInstantiator位于相同的包（缺省的包），所以SingletonInstantiator方法能创建ClasicSingleton的实例。  \n这种情况下有两种解决方案：一是你可以使ClassicSingleton的构造方法变化私有的（private）这样只有ClassicSingleton的方法能调用它;然而这也意味着ClassicSingleton不能有子类。有时这是一种很合意的解决方法，如果确实如此，那声明你的单例类为final是一个好主意，这样意图明确，并且让编译器去使用一些性能优化选项。另一种解决方法是把你的单例类放到一个外在的包中，以便在其它包中的类（包括缺省的包）无法实例化一个单例类。   \n   \n关于ClassicSingleton的第三点感兴趣的地方是，如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。   \n第四点，如果ClasicSingleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。   \n最后也许是最重要的一点，就是例1中的ClassicSingleton类不是线程安全的。如果两个线程，我们称它们为线程1和线程2，在同一时间调用ClassicSingleton.getInstance()方法，如果线程1先进入if块，然后线程2进行控制，那么就会有ClassicSingleton的两个的实例被创建。    \n\n正如你从前面的讨论中所看到的，尽管单例模式是最简单的设计模式之一，在Java中实现它也是决非想象的那么简单。这篇文章接下来会揭示Java规范对单例模式进行的考虑，但是首先让我们近水楼台的看看你如何才能测试你的单例类。    \n\n**测试单例模式**    \n\n接下来，我使用与log4j相对应的JUnit来测试单例类，它会贯穿在这篇文章余下的部分。如果你对JUnit或log4j不很熟悉，请参考相关资源。 \n\n例2是一个用JUnit测试例1的单例模式的案例： \t\n例2.一个单例模式的案例 \n \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate ClassicSingleton sone = null, stwo = null;   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n  \t\t public SingletonTest(String name) {   \n      \t\tsuper(name);   \n   \t\t}   \n   \t\tpublic void setUp() {   \n      \t\tlogger.info(\"getting singleton...\");   \n      \t\tsone = ClassicSingleton.getInstance();   \n      \t\tlogger.info(\"...got singleton: \" + sone);   \n    \n      \t\tlogger.info(\"getting singleton...\");   \n      \t\tstwo = ClassicSingleton.getInstance();   \n      \t\tlogger.info(\"...got singleton: \" + stwo);   \n  \t\t }   \n   \t\tpublic void testUnique() {   \n      \t\tlogger.info(\"checking singletons for equality\");   \n     \t\t Assert.assertEquals(true, sone == stwo);   \n   \t\t}   \n\t}   \n\n\n例2两次调用ClassicSingleton.getInstance()，并且把返回的引用存储在成员变量中。方法testUnique()会检查这些引用看它们是否相同。例3是这个测试案例的输出： \t\n例3.是这个测试案例的输出  \nBuildfile: build.xml   \n    \ninit:   \n     [echo] Build 20030414 (14-04-2003 03:08)   \n    \ncompile:   \n    \nrun-test-text:   \n     [java] .INFO main: [b]getting singleton...[/b]   \n     [java] INFO main: [b]created singleton:[/b] Singleton@e86f41   \n     [java] INFO main: ...got singleton: Singleton@e86f41   \n     [java] INFO main: [b]getting singleton...[/b]   \n     [java] INFO main: ...got singleton: Singleton@e86f41   \n     [java] INFO main: checking singletons for equality   \n    \n     [java] Time: 0.032   \n    \n     [java] OK (1 test)  \n\n\n正如前面的清单所示，例2的简单测试顺利通过----通过ClassicSingleton.getInstance()获得的两个单例类的引用确实相同;然而，你要知道这些引用是在单线程中得到的。下面的部分着重于用多线程测试单例类。 \n\n多线程因素的考虑 \n\n在例1中的ClassicSingleton.getInstance()方法由于下面的代码而不是线程安全的： \n\n\tif(instance == null) {   \n   \t\tinstance = new Singleton();   \n\t }   \n\n如果一个线程在第二行的赋值语句发生之前切换，那么成员变量instance仍然是null，然后另一个线程可能接下来进入到if块中。在这种情况下，两个不同的单例类实例就被创建。不幸的是这种假定很少发生，这样这种假定也很难在测试期间出现（译注：在这可能是作者对很少出现这种情况而导致无法测试从而使人们放松警惕而感到叹惜）。为了演示这个线程轮换，我得重新实现例1中的那个类。例4就是修订后的单例类：   \n例4.人为安排的方式   \n\n\timport org.apache.log4j.Logger;       \n\tpublic class Singleton {   \n\t\tprivate static Singleton singleton = null;   \n\t\tprivate static Logger logger = Logger.getRootLogger();   \n\t\tprivate static boolean firstThread = true;   \n    \n  \t\tprotected Singleton() {   \n   \t\t // Exists only to defeat instantiation.   \n\t\t}   \n\t\tpublic static Singleton getInstance() {   \n\t\t\tif(singleton == null) {   \n        \t\tsimulateRandomActivity();   \n        \t\tsingleton = new Singleton();   \n     \t}   \n     \tlogger.info(\"created singleton: \" + singleton);   \n     \treturn singleton;   \n  \t}   \n\tprivate static void simulateRandomActivity() {   \n     \ttry {   \n        \tif(firstThread) {   \n           \t\tfirstThread = false;   \n          \t\tlogger.info(\"sleeping...\");   \n    \n           \t\t// This nap should give the second thread enough time   \n           \t\t// to get by the first thread.   \n             \tThread.currentThread().sleep(50);   \n       \t\t}   \n     \t\t}   \n     \t\tcatch(InterruptedException ex) {   \n        \t\tlogger.warn(\"Sleep interrupted\");   \n     \t\t}   \n  \t\t}   \n\t}   \n\n除了在这个清单中的单例类强制使用了一个多线程错误处理，例4类似于例1中的单例类。在getInstance()方法第一次被调用时，调用这个方法的线程会休眠50毫秒以便另外的线程也有时间调用getInstance()并创建一个新的单例类实例。当休眠的线程觉醒时，它也会创建一个新的单例类实例，这样我们就有两个单例类实例。尽管例4是人为如此的，但它却模拟了第一个线程调用了getInstance()并在没有完成时被切换的真实情形。   \n例5测试了例4的单例类：   \n例5.失败的测试 \n \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n   \t\tprivate static Singleton singleton = null;   \n    \n   \tpublic SingletonTest(String name) {   \n      \tsuper(name);   \n   \t}   \n   \tpublic void setUp() {   \n      \tsingleton = null;   \n   \t}   \n  \tpublic void testUnique() throws InterruptedException {   \n      // Both threads call Singleton.getInstance().   \n      Thread threadOne = new Thread(new SingletonTestRunnable()),   \n             threadTwo = new Thread(new SingletonTestRunnable());   \n    \n      threadOne.start();   \n      threadTwo.start();   \n    \n      threadOne.join();   \n      threadTwo.join();   \n   \t}   \n   \tprivate static class SingletonTestRunnable implements Runnable {   \n      public void run() {   \n         // Get a reference to the singleton.   \n         Singleton s = Singleton.getInstance();   \n    \n         // Protect singleton member variable from   \n         // multithreaded access.   \n         synchronized(SingletonTest.class) {   \n            if(singleton == null) // If local reference is null...   \n               singleton = s;     // ...set it to the singleton   \n         \t}   \n         // Local reference must be equal to the one and   \n         // only instance of Singleton; otherwise, we have two   \n                  // Singleton instances.   \n         Assert.assertEquals(true, s == singleton);   \n      \t}   \n   \t\t}   \n\t}   \n\n\n例5的测试案例创建两个线程，然后各自启动，等待完成。这个案例保持了一个对单例类的静态引用，每个线程都会调用Singleton.getInstance()。如果这个静态成员变量没有被设置，那么第一个线程就会将它设为通过调用getInstance()而得到的引用，然后这个静态变量会与一个局部变量比较是否相等。\t\t \n在这个测试案例运行时会发生一系列的事情：第一个线程调用getInstance()，进入if块，然后休眠;接着，第二个线程也调用getInstance()并且创建了一个单例类的实例。第二个线程会设置这个静态成员变量为它所创建的引用。第二个线程检查这个静态成员变量与一个局部备份的相等性。然后测试通过。当第一个线程觉醒时，它也会创建一个单例类的实例，并且它不会设置那个静态成员变量（因为第二个线程已经设置过了），所以那个静态变量与那个局部变量脱离同步，相等性测试即告失败。例6列出了例5的输出：\t\t \n例6.例5的输出 \t\n \n\tBuildfile: build.xml   \n\tinit:   \n     \t[echo] Build 20030414 (14-04-2003 03:06)   \n\tcompile:   \n\trun-test-text:   \n\tINFO Thread-1: sleeping...   \n\tINFO Thread-2: created singleton: Singleton@7e5cbd   \n\tINFO Thread-1: created singleton: Singleton@704ebb   \n\tjunit.framework.AssertionFailedError: expected: but was:   \n   \t\tat junit.framework.Assert.fail(Assert.java:47)   \n   \t\tat junit.framework.Assert.failNotEquals(Assert.java:282)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:64)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:149)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:155)   \n   \t\tat SingletonTest$SingletonTestRunnable.run(Unknown Source)   \n   \t\tat java.lang.Thread.run(Thread.java:554)   \n     \t[java] .   \n     \t[java] Time: 0.577   \n    \n     \t[java] OK (1 test)   \n\n\n到现在为止我们已经知道例4不是线程安全的，那就让我们看看如何修正它。 \t\t\t\n\n**同步** \n\n要使例4的单例类为线程安全的很容易----只要像下面一个同步化getInstance()方法：   \n \n\tpublic synchronized static Singleton getInstance() {   \n   \t\tif(singleton == null) {   \n      \t\tsimulateRandomActivity();   \n      \t\tsingleton = new Singleton();   \n   \t\t}   \n   \t\tlogger.info(\"created singleton: \" + singleton);   \n   \t\treturn singleton;   \n\t}   \n\n在同步化getInstance()方法后，我们就可以得到例5的测试案例返回的下面的结果：    \n\n\tBuildfile: build.xml   \n    \n\tinit:   \n     \t[echo] Build 20030414 (14-04-2003 03:15)   \n    \n\tcompile:   \n    \t[javac] Compiling 2 source files   \n    \n\trun-test-text:   \n\tINFO Thread-1: sleeping...   \n\tINFO Thread-1: created singleton: Singleton@ef577d   \n\tINFO Thread-2: created singleton: Singleton@ef577d   \n     \t[java] .   \n     \t[java] Time: 0.513   \n    \n     \t[java] OK (1 test)   \n\n\n这此，这个测试案例工作正常，并且多线程的烦恼也被解决;然而，机敏的读者可能会认识到getInstance()方法只需要在第一次被调用时同步。因为同步的性能开销很昂贵（同步方法比非同步方法能降低到100次左右），或许我们可以引入一种性能改进方法，它只同步单例类的getInstance()方法中的赋值语句。   \n\n**一种性能改进的方法**\n\n寻找一种性能改进方法时，你可能会选择像下面这样重写getInstance()方法：   \n\n\tpublic static Singleton getInstance() {   \n   \t\tif(singleton == null) {   \n      \t\tsynchronized(Singleton.class) {    \n         \t\tsingleton = new Singleton();   \n      \t\t}   \n   \t\t}   \n   \treturn singleton;   \n\t}   \n\n\n这个代码片段只同步了关键的代码，而不是同步整个方法。然而这段代码却不是线程安全的。考虑一下下面的假定：线程1进入同步块，并且在它给singleton成员变量赋值之前线程1被切换。接着另一个线程进入if块。第二个线程将等待直到第一个线程完成，并且仍然会得到两个不同的单例类实例。有修复这个问题的方法吗？请读下去。  \n\n**双重加锁检查**\n\n初看上去，双重加锁检查似乎是一种使懒汉式实例化为线程安全的技术。下面的代码片段展示了这种技术：   \n\n\tpublic static Singleton getInstance() {   \n  \t\tif(singleton == null) {   \n    \t\t synchronized(Singleton.class) {   \n       \t\t\tif(singleton == null) {   \n         \t\t\tsingleton = new Singleton();   \n       \t\t\t}   \n    \t\t}   \n  \t\t}   \n \t\t return singleton;   \n\t}   \n\n如果两个线程同时访问getInstance()方法会发生什么？想像一下线程1进行同步块马上又被切换。接着，第二个线程进入if 块。当线程1退出同步块时，线程2会重新检查看是否singleton实例仍然为null。因为线程1设置了singleton成员变量，所以线程2的第二次检查会失败，第二个单例类实例也就不会被创建。似乎就是如此。  \n不幸的是，双重加锁检查不会保证正常工作，因为编译器会在Singleton的构造方法被调用之前随意给singleton赋一个值。如果在singleton引用被赋值之后而被初始化之前线程1被切换，线程2就会被返回一个对未初始化的单例类实例的引用。   \n\n**一个改进的线程安全的单例模式实现**\n\n例7列出了一个简单、快速而又是线程安全的单例模式实现：   \n例7.一个简单的单例类   \n \n\tpublic class Singleton {   \n   \t\tpublic final static Singleton INSTANCE = new Singleton();   \n   \t\tprivate Singleton() {   \n         \t// Exists only to defeat instantiation.   \n      \t}   \n\t}   \n这段代码是线程安全的是因为静态成员变量一定会在类被第一次访问时被创建。你得到了一个自动使用了懒汉式实例化的线程安全的实现;你应该这样使用它：  \n  \n\tSingleton singleton = Singleton.INSTANCE;   \n\tsingleton.dothis();   \n\tsingleton.dothat();   \n\t...   \n当然万事并不完美，前面的Singleton只是一个折衷的方案;如果你使用那个实现，你就无法改变它以便后来你可能想要允许多个单例类的实例。用一种更折哀的单例模式实现(通过一个getInstance()方法获得实例)你可以改变这个方法以便返回一个唯一的实例或者是数百个实例中的一个．你不能用一个公开且是静态的（public static)成员变量这样做．   \n\n你可以安全的使用例７的单例模式实现或者是例１的带一个同步的getInstance()方法的实现．然而，我们必须要研究另一个问题：你必须在编译期指定这个单例类，这样就不是很灵活．一个单例类的注册表会让我们在运行期指定一个单例类．   \n\n使用注册表   \n使用一个单例类注册表可以：   \n\n**在运行期指定单例类** \n\n防止产生多个单例类子类的实例   \n在例8的单例类中，保持了一个通过类名进行注册的单例类注册表：    \n例8 带注册表的单例类   \n \n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation   \n   \t\t}   \n   \tpublic static synchronized Singleton getInstance(String classname) {   \n      \tif(classname == null) throw new IllegalArgumentException(\"Illegal classname\");   \n         \tSingleton singleton = (Singleton)map.get(classname);   \n    \n      \tif(singleton != null) {   \n         \tlogger.info(\"got singleton from map: \" + singleton);   \n         \treturn singleton;   \n      \t}   \n      \tif(classname.equals(\"SingeltonSubclass_One\"))   \n            singleton = new SingletonSubclass_One();            \n        else if(classname.equals(\"SingeltonSubclass_Two\"))   \n            singleton = new SingletonSubclass_Two();   \n    \n      \tmap.put(classname, singleton);   \n      \tlogger.info(\"created singleton: \" + singleton);   \n      \treturn singleton;   \n   \t\t}   \n  \t\t // Assume functionality follows that's attractive to inherit   \n\t}   \n这段代码的基类首先创建出子类的实例，然后把它们存储在一个Map中。但是基类却得付出很高的代价因为你必须为每一个子类替换它的getInstance()方法。幸运的是我们可以使用反射处理这个问题。   \n\n**使用反射**\n\n在例9的带注册表的单例类中，使用反射来实例化一个特殊的类的对象。与例8相对的是通过这种实现，Singleton.getInstance()方法不需要在每个被实现的子类中重写了。  \n例9 使用反射实例化单例类   \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \tprotected Singleton() {   \n      // Exists only to thwart instantiation   \n   \t}   \n   \tpublic static synchronized Singleton getInstance(String classname) {   \n      \tSingleton singleton = (Singleton)map.get(classname);   \n    \n      \tif(singleton != null) {   \n         \tlogger.info(\"got singleton from map: \" + singleton);   \n         \treturn singleton;   \n      \t}   \n      \ttry {   \n         singleton = (Singleton)Class.forName(classname).newInstance();   \n      \t}   \n      \tcatch(ClassNotFoundException cnf) {   \n         logger.fatal(\"Couldn't find class \" + classname);       \n      \t}   \n      \tcatch(InstantiationException ie) {   \n         \tlogger.fatal(\"Couldn't instantiate an object of type \" + classname);       \n      \t}   \n      \tcatch(IllegalAccessException ia) {   \n         \tlogger.fatal(\"Couldn't access class \" + classname);       \n      \t}   \n      \tmap.put(classname, singleton);   \n      \tlogger.info(\"created singleton: \" + singleton);   \n    \n      \treturn singleton;   \n   \t\t}   \n\t}   \n\n\n关于单例类的注册表应该说明的是：它们应该被封装在它们自己的类中以便最大限度的进行复用。   \n\n\n**封装注册表**\n\n例10列出了一个单例注册表类。  \n例10 一个SingletonRegistry类 \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class SingletonRegistry {   \n   \t\tpublic static SingletonRegistry REGISTRY = new SingletonRegistry();   \n    \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \t\tprotected SingletonRegistry() {   \n      \t\t// Exists to defeat instantiation   \n   \t\t}   \n   \t\tpublic static synchronized Object getInstance(String classname) {   \n      \t\tObject singleton = map.get(classname);   \n    \n      \t\tif(singleton != null) {   \n         \t\treturn singleton;   \n      \t\t}   \n      \ttry {   \n         \tsingleton = Class.forName(classname).newInstance();   \n         \tlogger.info(\"created singleton: \" + singleton);   \n      \t}   \n      \tcatch(ClassNotFoundException cnf) {   \n         \tlogger.fatal(\"Couldn't find class \" + classname);       \n      \t}   \n      \tcatch(InstantiationException ie) {   \n         \tlogger.fatal(\"Couldn't instantiate an object of type \" +    \n                       classname);       \n      \t}   \n      \tcatch(IllegalAccessException ia) {   \n         \tlogger.fatal(\"Couldn't access class \" + classname);       \n      \t}   \n      \tmap.put(classname, singleton);   \n      \treturn singleton;   \n   \t\t}   \n\t}   \n\n注意我是把SingletonRegistry类作为一个单例模式实现的。我也通用化了这个注册表以便它能存储和取回任何类型的对象。例11显示了的Singleton类使用了这个注册表。  \n例11 使用了一个封装的注册表的Singleton类   \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation.   \n   \t\t}   \n   \t\tpublic static Singleton getInstance() {   \n      \t\treturn (Singleton)SingletonRegistry.REGISTRY.getInstance(classname);   \n   \t\t}   \n\t}   \n\n上面的Singleton类使用那个注册表的唯一实例通过类名取得单例对象。  \n现在我们已经知道如何实现线程安全的单例类和如何使用一个注册表去在运行期指定单例类名，接着让我们考查一下如何安排类载入器和处理序列化。  \n\n**Classloaders** \n\n在许多情况下，使用多个类载入器是很普通的--包括servlet容器--所以不管你在实现你的单例类时是多么小心你都最终可以得到多个单例类的实例。如果你想要确保你的单例类只被同一个的类载入器装入，那你就必须自己指定这个类载入器;例如：  \n\n\tprivate static Class getClass(String classname)    \n                                         throws ClassNotFoundException {   \n     \tClassLoader classLoader = Thread.currentThread().getContextClassLoader();   \n    \n      \tif(classLoader == null)   \n         classLoader = Singleton.class.getClassLoader();   \n    \n      \treturn (classLoader.loadClass(classname));   \n   \t\t}   \n\t}   \n\n\n这个方法会尝试把当前的线程与那个类载入器相关联;如果classloader为null，这个方法会使用与装入单例类基类的那个类载入器。这个方法可以用Class.forName()代替。   \n\n**序列化**\n\n如果你序列化一个单例类，然后两次重构它，那么你就会得到那个单例类的两个实例，除非你实现readResolve()方法，像下面这样：  \n例12 一个可序列化的单例类 \n \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton implements java.io.Serializable {   \n   \t\tpublic static Singleton INSTANCE = new Singleton();   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation.   \n   \t\t}   \n   \t\tprivate Object readResolve() {   \n            return INSTANCE;   \n      \t}  \n   \t}   \n\n\n上面的单例类实现从readResolve()方法中返回一个唯一的实例;这样无论Singleton类何时被重构，它都只会返回那个相同的单例类实例。   \n例13测试了例12的单例类：  \n例13 测试一个可序列化的单例类   \n\n\timport java.io.*;   \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate Singleton sone = null, stwo = null;   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n  \t\tpublic SingletonTest(String name) {   \n      \t\tsuper(name);   \n   \t\t}   \n   \t\tpublic void setUp() {   \n      \t\tsone = Singleton.INSTANCE;   \n      \t\tstwo = Singleton.INSTANCE;   \n   \t\t}   \n   \t\tpublic void testSerialize() {   \n      \t\tlogger.info(\"testing singleton serialization...\");   \n\t\t\t[b]      writeSingleton();   \n      \t\tSingleton s1 = readSingleton();   \n      \t\tSingleton s2 = readSingleton();   \n      \t\tAssert.assertEquals(true, s1 == s2);[/b]   }   \n   \t\t\tprivate void writeSingleton() {   \n      \t\ttry {   \n         \t\tFileOutputStream fos = new FileOutputStream(\"serializedSingleton\");   \n         \t\tObjectOutputStream oos = new ObjectOutputStream(fos);   \n         \t\tSingleton s = Singleton.INSTANCE;   \n    \n         \t\toos.writeObject(Singleton.INSTANCE);   \n         \t\toos.flush();   \n      \t\t}   \n      \t\tcatch(NotSerializableException se) {   \n         \t\tlogger.fatal(\"Not Serializable Exception: \" + se.getMessage());   \n      \t\t}   \n      \t\tcatch(IOException iox) {   \n         \t\tlogger.fatal(\"IO Exception: \" + iox.getMessage());   \n      \t\t}   \n   \t\t}   \n   \t\tprivate Singleton readSingleton() {   \n      \t\tSingleton s = null;   \n    \n      \t\ttry {   \n         \t\tFileInputStream fis = new FileInputStream(\"serializedSingleton\");   \n         \t\tObjectInputStream ois = new ObjectInputStream(fis);   \n         \t\ts = (Singleton)ois.readObject();   \n      \t\t}   \n      \t\tcatch(ClassNotFoundException cnf) {   \n         \t\tlogger.fatal(\"Class Not Found Exception: \" + cnf.getMessage());   \n      \t\t}   \n      \t\tcatch(NotSerializableException se) {   \n         \t\tlogger.fatal(\"Not Serializable Exception: \" + se.getMessage());   \n      \t\t}   \n      \t\tcatch(IOException iox) {   \n         \t\tlogger.fatal(\"IO Exception: \" + iox.getMessage());   \n      \t\t}   \n      \t\treturn s;   \n   \t\t}   \n   \t\tpublic void testUnique() {   \n      \t\tlogger.info(\"testing singleton uniqueness...\");   \n      \t\tSingleton another = new Singleton();   \n    \n      \t\tlogger.info(\"checking singletons for equality\");   \n      \t\tAssert.assertEquals(true, sone == stwo);   \n   \t\t}   \n\t}   \n\n前面这个测试案例序列化例12中的单例类，并且两次重构它。然后这个测试案例检查看是否被重构的单例类实例是同一个对象。下面是测试案例的输出：   \n \n\tBuildfile: build.xml   \n    \n\tinit:   \n     \t[echo] Build 20030422 (22-04-2003 11:32)   \n    \n\tcompile:   \n    \n\trun-test-text:   \n     \t[java] .INFO main: testing singleton serialization...   \n     \t[java] .INFO main: testing singleton uniqueness...   \n     \t[java] INFO main: checking singletons for equality   \n    \n     \t[java] Time: 0.1   \n    \n     \t[java] OK (2 tests)   \n\n\n**单例模式结束语**   \n\n单例模式简单却容易让人迷惑，特别是对于Java的开发者来说。在这篇文章中，作者演示了Java开发者在顾及多线程、类载入器和序列化情况如何实现单例模式。作者也展示了你怎样才能实现一个单例类的注册表，以便能够在运行期指定单例类。  \n\n原文：<http://calmness.iteye.com/blog/60179>","source":"_posts/2012-11-02-singleton-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：单例（singleton） in java\"\ndate: 2012-11-02 18:47\ncomments: true\ncategories: 设计模式\ntags: [ Java, singleton ]\n---\n###概要###\n单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。    \n\n单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。   \n<!--more-->   \n单例模式的用意在于前一段中所关心的。通过单例模式你可以： \n\n* 确保一个类只有一个实例被建立 \n* 提供了一个对对象的全局访问指针 \n* 在不影响单例类的客户端的情况下允许将来有多个实例 \n\n尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。这篇文章讨论了单例模式并揭示了那些缺陷。  \n\n###单例模式###\n\n在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。\n下图说明了单例模式的类图。    \n![](/images/blog/singleton.jpg)\n \n正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。   \n例1显示了一个经典的单例模式的实现。   \n例1.经典的单例模式  \n \n\tpublic class ClassicSingleton {   \n   \t\tprivate static ClassicSingleton instance = null;   \n    \n   \t\tprotected ClassicSingleton() {   \n      \t\t// Exists only to defeat instantiation.   \n   \t\t}   \n   \t\tpublic static ClassicSingleton getInstance() {   \n      \t\tif(instance == null) {   \n         \t\tinstance = new ClassicSingleton();   \n      \t\t}   \n      \t\treturn instance;   \n   \t\t}   \n\t}   \n\n在例1中的单例模式的实现很容易理解。ClassicSingleton类保持了一个对单独的单例实例的静态引用，并且从静态方法getInstance()中返回那个引用。   \n关于ClassicSingleton类，有几个让我们感兴趣的地方。   \n首先，ClassicSingleton使用了一个众所周知的懒汉式实例化去创建那个单例类的引用;结果，这个单例类的实例直到getInstance()方法被第一次调用时才被创建。这种技巧可以确保单例类的实例只有在需要时才被建立出来。其次，注意ClassicSingleton实现了一个protected的构造方法，这样客户端不能直接实例化一个ClassicSingleton类的实例。然而，你会惊奇的发现下面的代码完全合法：   \n\n\tpublic class SingletonInstantiator {    \n  \t\tpublic SingletonInstantiator() {    \n   \t\t\tClassicSingleton instance = ClassicSingleton.getInstance();   \n\t\t\tClassicSingleton anotherInstance =  new ClassicSingleton();   \n       \t\t...    \n  \t\t\t}    \n\t}   \n前面这个代码片段为何能在没有继承ClassicSingleton并且ClassicSingleton类的构造方法是protected的情况下创建其实例？   \n答案是protected的构造方法可以被其子类以及在同一个包中的其它类调用。因为ClassicSingleton和SingletonInstantiator位于相同的包（缺省的包），所以SingletonInstantiator方法能创建ClasicSingleton的实例。  \n这种情况下有两种解决方案：一是你可以使ClassicSingleton的构造方法变化私有的（private）这样只有ClassicSingleton的方法能调用它;然而这也意味着ClassicSingleton不能有子类。有时这是一种很合意的解决方法，如果确实如此，那声明你的单例类为final是一个好主意，这样意图明确，并且让编译器去使用一些性能优化选项。另一种解决方法是把你的单例类放到一个外在的包中，以便在其它包中的类（包括缺省的包）无法实例化一个单例类。   \n   \n关于ClassicSingleton的第三点感兴趣的地方是，如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。   \n第四点，如果ClasicSingleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。   \n最后也许是最重要的一点，就是例1中的ClassicSingleton类不是线程安全的。如果两个线程，我们称它们为线程1和线程2，在同一时间调用ClassicSingleton.getInstance()方法，如果线程1先进入if块，然后线程2进行控制，那么就会有ClassicSingleton的两个的实例被创建。    \n\n正如你从前面的讨论中所看到的，尽管单例模式是最简单的设计模式之一，在Java中实现它也是决非想象的那么简单。这篇文章接下来会揭示Java规范对单例模式进行的考虑，但是首先让我们近水楼台的看看你如何才能测试你的单例类。    \n\n**测试单例模式**    \n\n接下来，我使用与log4j相对应的JUnit来测试单例类，它会贯穿在这篇文章余下的部分。如果你对JUnit或log4j不很熟悉，请参考相关资源。 \n\n例2是一个用JUnit测试例1的单例模式的案例： \t\n例2.一个单例模式的案例 \n \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate ClassicSingleton sone = null, stwo = null;   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n  \t\t public SingletonTest(String name) {   \n      \t\tsuper(name);   \n   \t\t}   \n   \t\tpublic void setUp() {   \n      \t\tlogger.info(\"getting singleton...\");   \n      \t\tsone = ClassicSingleton.getInstance();   \n      \t\tlogger.info(\"...got singleton: \" + sone);   \n    \n      \t\tlogger.info(\"getting singleton...\");   \n      \t\tstwo = ClassicSingleton.getInstance();   \n      \t\tlogger.info(\"...got singleton: \" + stwo);   \n  \t\t }   \n   \t\tpublic void testUnique() {   \n      \t\tlogger.info(\"checking singletons for equality\");   \n     \t\t Assert.assertEquals(true, sone == stwo);   \n   \t\t}   \n\t}   \n\n\n例2两次调用ClassicSingleton.getInstance()，并且把返回的引用存储在成员变量中。方法testUnique()会检查这些引用看它们是否相同。例3是这个测试案例的输出： \t\n例3.是这个测试案例的输出  \nBuildfile: build.xml   \n    \ninit:   \n     [echo] Build 20030414 (14-04-2003 03:08)   \n    \ncompile:   \n    \nrun-test-text:   \n     [java] .INFO main: [b]getting singleton...[/b]   \n     [java] INFO main: [b]created singleton:[/b] Singleton@e86f41   \n     [java] INFO main: ...got singleton: Singleton@e86f41   \n     [java] INFO main: [b]getting singleton...[/b]   \n     [java] INFO main: ...got singleton: Singleton@e86f41   \n     [java] INFO main: checking singletons for equality   \n    \n     [java] Time: 0.032   \n    \n     [java] OK (1 test)  \n\n\n正如前面的清单所示，例2的简单测试顺利通过----通过ClassicSingleton.getInstance()获得的两个单例类的引用确实相同;然而，你要知道这些引用是在单线程中得到的。下面的部分着重于用多线程测试单例类。 \n\n多线程因素的考虑 \n\n在例1中的ClassicSingleton.getInstance()方法由于下面的代码而不是线程安全的： \n\n\tif(instance == null) {   \n   \t\tinstance = new Singleton();   \n\t }   \n\n如果一个线程在第二行的赋值语句发生之前切换，那么成员变量instance仍然是null，然后另一个线程可能接下来进入到if块中。在这种情况下，两个不同的单例类实例就被创建。不幸的是这种假定很少发生，这样这种假定也很难在测试期间出现（译注：在这可能是作者对很少出现这种情况而导致无法测试从而使人们放松警惕而感到叹惜）。为了演示这个线程轮换，我得重新实现例1中的那个类。例4就是修订后的单例类：   \n例4.人为安排的方式   \n\n\timport org.apache.log4j.Logger;       \n\tpublic class Singleton {   \n\t\tprivate static Singleton singleton = null;   \n\t\tprivate static Logger logger = Logger.getRootLogger();   \n\t\tprivate static boolean firstThread = true;   \n    \n  \t\tprotected Singleton() {   \n   \t\t // Exists only to defeat instantiation.   \n\t\t}   \n\t\tpublic static Singleton getInstance() {   \n\t\t\tif(singleton == null) {   \n        \t\tsimulateRandomActivity();   \n        \t\tsingleton = new Singleton();   \n     \t}   \n     \tlogger.info(\"created singleton: \" + singleton);   \n     \treturn singleton;   \n  \t}   \n\tprivate static void simulateRandomActivity() {   \n     \ttry {   \n        \tif(firstThread) {   \n           \t\tfirstThread = false;   \n          \t\tlogger.info(\"sleeping...\");   \n    \n           \t\t// This nap should give the second thread enough time   \n           \t\t// to get by the first thread.   \n             \tThread.currentThread().sleep(50);   \n       \t\t}   \n     \t\t}   \n     \t\tcatch(InterruptedException ex) {   \n        \t\tlogger.warn(\"Sleep interrupted\");   \n     \t\t}   \n  \t\t}   \n\t}   \n\n除了在这个清单中的单例类强制使用了一个多线程错误处理，例4类似于例1中的单例类。在getInstance()方法第一次被调用时，调用这个方法的线程会休眠50毫秒以便另外的线程也有时间调用getInstance()并创建一个新的单例类实例。当休眠的线程觉醒时，它也会创建一个新的单例类实例，这样我们就有两个单例类实例。尽管例4是人为如此的，但它却模拟了第一个线程调用了getInstance()并在没有完成时被切换的真实情形。   \n例5测试了例4的单例类：   \n例5.失败的测试 \n \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n   \t\tprivate static Singleton singleton = null;   \n    \n   \tpublic SingletonTest(String name) {   \n      \tsuper(name);   \n   \t}   \n   \tpublic void setUp() {   \n      \tsingleton = null;   \n   \t}   \n  \tpublic void testUnique() throws InterruptedException {   \n      // Both threads call Singleton.getInstance().   \n      Thread threadOne = new Thread(new SingletonTestRunnable()),   \n             threadTwo = new Thread(new SingletonTestRunnable());   \n    \n      threadOne.start();   \n      threadTwo.start();   \n    \n      threadOne.join();   \n      threadTwo.join();   \n   \t}   \n   \tprivate static class SingletonTestRunnable implements Runnable {   \n      public void run() {   \n         // Get a reference to the singleton.   \n         Singleton s = Singleton.getInstance();   \n    \n         // Protect singleton member variable from   \n         // multithreaded access.   \n         synchronized(SingletonTest.class) {   \n            if(singleton == null) // If local reference is null...   \n               singleton = s;     // ...set it to the singleton   \n         \t}   \n         // Local reference must be equal to the one and   \n         // only instance of Singleton; otherwise, we have two   \n                  // Singleton instances.   \n         Assert.assertEquals(true, s == singleton);   \n      \t}   \n   \t\t}   \n\t}   \n\n\n例5的测试案例创建两个线程，然后各自启动，等待完成。这个案例保持了一个对单例类的静态引用，每个线程都会调用Singleton.getInstance()。如果这个静态成员变量没有被设置，那么第一个线程就会将它设为通过调用getInstance()而得到的引用，然后这个静态变量会与一个局部变量比较是否相等。\t\t \n在这个测试案例运行时会发生一系列的事情：第一个线程调用getInstance()，进入if块，然后休眠;接着，第二个线程也调用getInstance()并且创建了一个单例类的实例。第二个线程会设置这个静态成员变量为它所创建的引用。第二个线程检查这个静态成员变量与一个局部备份的相等性。然后测试通过。当第一个线程觉醒时，它也会创建一个单例类的实例，并且它不会设置那个静态成员变量（因为第二个线程已经设置过了），所以那个静态变量与那个局部变量脱离同步，相等性测试即告失败。例6列出了例5的输出：\t\t \n例6.例5的输出 \t\n \n\tBuildfile: build.xml   \n\tinit:   \n     \t[echo] Build 20030414 (14-04-2003 03:06)   \n\tcompile:   \n\trun-test-text:   \n\tINFO Thread-1: sleeping...   \n\tINFO Thread-2: created singleton: Singleton@7e5cbd   \n\tINFO Thread-1: created singleton: Singleton@704ebb   \n\tjunit.framework.AssertionFailedError: expected: but was:   \n   \t\tat junit.framework.Assert.fail(Assert.java:47)   \n   \t\tat junit.framework.Assert.failNotEquals(Assert.java:282)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:64)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:149)   \n   \t\tat junit.framework.Assert.assertEquals(Assert.java:155)   \n   \t\tat SingletonTest$SingletonTestRunnable.run(Unknown Source)   \n   \t\tat java.lang.Thread.run(Thread.java:554)   \n     \t[java] .   \n     \t[java] Time: 0.577   \n    \n     \t[java] OK (1 test)   \n\n\n到现在为止我们已经知道例4不是线程安全的，那就让我们看看如何修正它。 \t\t\t\n\n**同步** \n\n要使例4的单例类为线程安全的很容易----只要像下面一个同步化getInstance()方法：   \n \n\tpublic synchronized static Singleton getInstance() {   \n   \t\tif(singleton == null) {   \n      \t\tsimulateRandomActivity();   \n      \t\tsingleton = new Singleton();   \n   \t\t}   \n   \t\tlogger.info(\"created singleton: \" + singleton);   \n   \t\treturn singleton;   \n\t}   \n\n在同步化getInstance()方法后，我们就可以得到例5的测试案例返回的下面的结果：    \n\n\tBuildfile: build.xml   \n    \n\tinit:   \n     \t[echo] Build 20030414 (14-04-2003 03:15)   \n    \n\tcompile:   \n    \t[javac] Compiling 2 source files   \n    \n\trun-test-text:   \n\tINFO Thread-1: sleeping...   \n\tINFO Thread-1: created singleton: Singleton@ef577d   \n\tINFO Thread-2: created singleton: Singleton@ef577d   \n     \t[java] .   \n     \t[java] Time: 0.513   \n    \n     \t[java] OK (1 test)   \n\n\n这此，这个测试案例工作正常，并且多线程的烦恼也被解决;然而，机敏的读者可能会认识到getInstance()方法只需要在第一次被调用时同步。因为同步的性能开销很昂贵（同步方法比非同步方法能降低到100次左右），或许我们可以引入一种性能改进方法，它只同步单例类的getInstance()方法中的赋值语句。   \n\n**一种性能改进的方法**\n\n寻找一种性能改进方法时，你可能会选择像下面这样重写getInstance()方法：   \n\n\tpublic static Singleton getInstance() {   \n   \t\tif(singleton == null) {   \n      \t\tsynchronized(Singleton.class) {    \n         \t\tsingleton = new Singleton();   \n      \t\t}   \n   \t\t}   \n   \treturn singleton;   \n\t}   \n\n\n这个代码片段只同步了关键的代码，而不是同步整个方法。然而这段代码却不是线程安全的。考虑一下下面的假定：线程1进入同步块，并且在它给singleton成员变量赋值之前线程1被切换。接着另一个线程进入if块。第二个线程将等待直到第一个线程完成，并且仍然会得到两个不同的单例类实例。有修复这个问题的方法吗？请读下去。  \n\n**双重加锁检查**\n\n初看上去，双重加锁检查似乎是一种使懒汉式实例化为线程安全的技术。下面的代码片段展示了这种技术：   \n\n\tpublic static Singleton getInstance() {   \n  \t\tif(singleton == null) {   \n    \t\t synchronized(Singleton.class) {   \n       \t\t\tif(singleton == null) {   \n         \t\t\tsingleton = new Singleton();   \n       \t\t\t}   \n    \t\t}   \n  \t\t}   \n \t\t return singleton;   \n\t}   \n\n如果两个线程同时访问getInstance()方法会发生什么？想像一下线程1进行同步块马上又被切换。接着，第二个线程进入if 块。当线程1退出同步块时，线程2会重新检查看是否singleton实例仍然为null。因为线程1设置了singleton成员变量，所以线程2的第二次检查会失败，第二个单例类实例也就不会被创建。似乎就是如此。  \n不幸的是，双重加锁检查不会保证正常工作，因为编译器会在Singleton的构造方法被调用之前随意给singleton赋一个值。如果在singleton引用被赋值之后而被初始化之前线程1被切换，线程2就会被返回一个对未初始化的单例类实例的引用。   \n\n**一个改进的线程安全的单例模式实现**\n\n例7列出了一个简单、快速而又是线程安全的单例模式实现：   \n例7.一个简单的单例类   \n \n\tpublic class Singleton {   \n   \t\tpublic final static Singleton INSTANCE = new Singleton();   \n   \t\tprivate Singleton() {   \n         \t// Exists only to defeat instantiation.   \n      \t}   \n\t}   \n这段代码是线程安全的是因为静态成员变量一定会在类被第一次访问时被创建。你得到了一个自动使用了懒汉式实例化的线程安全的实现;你应该这样使用它：  \n  \n\tSingleton singleton = Singleton.INSTANCE;   \n\tsingleton.dothis();   \n\tsingleton.dothat();   \n\t...   \n当然万事并不完美，前面的Singleton只是一个折衷的方案;如果你使用那个实现，你就无法改变它以便后来你可能想要允许多个单例类的实例。用一种更折哀的单例模式实现(通过一个getInstance()方法获得实例)你可以改变这个方法以便返回一个唯一的实例或者是数百个实例中的一个．你不能用一个公开且是静态的（public static)成员变量这样做．   \n\n你可以安全的使用例７的单例模式实现或者是例１的带一个同步的getInstance()方法的实现．然而，我们必须要研究另一个问题：你必须在编译期指定这个单例类，这样就不是很灵活．一个单例类的注册表会让我们在运行期指定一个单例类．   \n\n使用注册表   \n使用一个单例类注册表可以：   \n\n**在运行期指定单例类** \n\n防止产生多个单例类子类的实例   \n在例8的单例类中，保持了一个通过类名进行注册的单例类注册表：    \n例8 带注册表的单例类   \n \n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation   \n   \t\t}   \n   \tpublic static synchronized Singleton getInstance(String classname) {   \n      \tif(classname == null) throw new IllegalArgumentException(\"Illegal classname\");   \n         \tSingleton singleton = (Singleton)map.get(classname);   \n    \n      \tif(singleton != null) {   \n         \tlogger.info(\"got singleton from map: \" + singleton);   \n         \treturn singleton;   \n      \t}   \n      \tif(classname.equals(\"SingeltonSubclass_One\"))   \n            singleton = new SingletonSubclass_One();            \n        else if(classname.equals(\"SingeltonSubclass_Two\"))   \n            singleton = new SingletonSubclass_Two();   \n    \n      \tmap.put(classname, singleton);   \n      \tlogger.info(\"created singleton: \" + singleton);   \n      \treturn singleton;   \n   \t\t}   \n  \t\t // Assume functionality follows that's attractive to inherit   \n\t}   \n这段代码的基类首先创建出子类的实例，然后把它们存储在一个Map中。但是基类却得付出很高的代价因为你必须为每一个子类替换它的getInstance()方法。幸运的是我们可以使用反射处理这个问题。   \n\n**使用反射**\n\n在例9的带注册表的单例类中，使用反射来实例化一个特殊的类的对象。与例8相对的是通过这种实现，Singleton.getInstance()方法不需要在每个被实现的子类中重写了。  \n例9 使用反射实例化单例类   \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \tprotected Singleton() {   \n      // Exists only to thwart instantiation   \n   \t}   \n   \tpublic static synchronized Singleton getInstance(String classname) {   \n      \tSingleton singleton = (Singleton)map.get(classname);   \n    \n      \tif(singleton != null) {   \n         \tlogger.info(\"got singleton from map: \" + singleton);   \n         \treturn singleton;   \n      \t}   \n      \ttry {   \n         singleton = (Singleton)Class.forName(classname).newInstance();   \n      \t}   \n      \tcatch(ClassNotFoundException cnf) {   \n         logger.fatal(\"Couldn't find class \" + classname);       \n      \t}   \n      \tcatch(InstantiationException ie) {   \n         \tlogger.fatal(\"Couldn't instantiate an object of type \" + classname);       \n      \t}   \n      \tcatch(IllegalAccessException ia) {   \n         \tlogger.fatal(\"Couldn't access class \" + classname);       \n      \t}   \n      \tmap.put(classname, singleton);   \n      \tlogger.info(\"created singleton: \" + singleton);   \n    \n      \treturn singleton;   \n   \t\t}   \n\t}   \n\n\n关于单例类的注册表应该说明的是：它们应该被封装在它们自己的类中以便最大限度的进行复用。   \n\n\n**封装注册表**\n\n例10列出了一个单例注册表类。  \n例10 一个SingletonRegistry类 \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class SingletonRegistry {   \n   \t\tpublic static SingletonRegistry REGISTRY = new SingletonRegistry();   \n    \n   \t\tprivate static HashMap map = new HashMap();   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n   \t\tprotected SingletonRegistry() {   \n      \t\t// Exists to defeat instantiation   \n   \t\t}   \n   \t\tpublic static synchronized Object getInstance(String classname) {   \n      \t\tObject singleton = map.get(classname);   \n    \n      \t\tif(singleton != null) {   \n         \t\treturn singleton;   \n      \t\t}   \n      \ttry {   \n         \tsingleton = Class.forName(classname).newInstance();   \n         \tlogger.info(\"created singleton: \" + singleton);   \n      \t}   \n      \tcatch(ClassNotFoundException cnf) {   \n         \tlogger.fatal(\"Couldn't find class \" + classname);       \n      \t}   \n      \tcatch(InstantiationException ie) {   \n         \tlogger.fatal(\"Couldn't instantiate an object of type \" +    \n                       classname);       \n      \t}   \n      \tcatch(IllegalAccessException ia) {   \n         \tlogger.fatal(\"Couldn't access class \" + classname);       \n      \t}   \n      \tmap.put(classname, singleton);   \n      \treturn singleton;   \n   \t\t}   \n\t}   \n\n注意我是把SingletonRegistry类作为一个单例模式实现的。我也通用化了这个注册表以便它能存储和取回任何类型的对象。例11显示了的Singleton类使用了这个注册表。  \n例11 使用了一个封装的注册表的Singleton类   \n\n\timport java.util.HashMap;   \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton {   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation.   \n   \t\t}   \n   \t\tpublic static Singleton getInstance() {   \n      \t\treturn (Singleton)SingletonRegistry.REGISTRY.getInstance(classname);   \n   \t\t}   \n\t}   \n\n上面的Singleton类使用那个注册表的唯一实例通过类名取得单例对象。  \n现在我们已经知道如何实现线程安全的单例类和如何使用一个注册表去在运行期指定单例类名，接着让我们考查一下如何安排类载入器和处理序列化。  \n\n**Classloaders** \n\n在许多情况下，使用多个类载入器是很普通的--包括servlet容器--所以不管你在实现你的单例类时是多么小心你都最终可以得到多个单例类的实例。如果你想要确保你的单例类只被同一个的类载入器装入，那你就必须自己指定这个类载入器;例如：  \n\n\tprivate static Class getClass(String classname)    \n                                         throws ClassNotFoundException {   \n     \tClassLoader classLoader = Thread.currentThread().getContextClassLoader();   \n    \n      \tif(classLoader == null)   \n         classLoader = Singleton.class.getClassLoader();   \n    \n      \treturn (classLoader.loadClass(classname));   \n   \t\t}   \n\t}   \n\n\n这个方法会尝试把当前的线程与那个类载入器相关联;如果classloader为null，这个方法会使用与装入单例类基类的那个类载入器。这个方法可以用Class.forName()代替。   \n\n**序列化**\n\n如果你序列化一个单例类，然后两次重构它，那么你就会得到那个单例类的两个实例，除非你实现readResolve()方法，像下面这样：  \n例12 一个可序列化的单例类 \n \n\timport org.apache.log4j.Logger;   \n    \n\tpublic class Singleton implements java.io.Serializable {   \n   \t\tpublic static Singleton INSTANCE = new Singleton();   \n    \n   \t\tprotected Singleton() {   \n      \t\t// Exists only to thwart instantiation.   \n   \t\t}   \n   \t\tprivate Object readResolve() {   \n            return INSTANCE;   \n      \t}  \n   \t}   \n\n\n上面的单例类实现从readResolve()方法中返回一个唯一的实例;这样无论Singleton类何时被重构，它都只会返回那个相同的单例类实例。   \n例13测试了例12的单例类：  \n例13 测试一个可序列化的单例类   \n\n\timport java.io.*;   \n\timport org.apache.log4j.Logger;   \n\timport junit.framework.Assert;   \n\timport junit.framework.TestCase;   \n    \n\tpublic class SingletonTest extends TestCase {   \n   \t\tprivate Singleton sone = null, stwo = null;   \n   \t\tprivate static Logger logger = Logger.getRootLogger();   \n    \n  \t\tpublic SingletonTest(String name) {   \n      \t\tsuper(name);   \n   \t\t}   \n   \t\tpublic void setUp() {   \n      \t\tsone = Singleton.INSTANCE;   \n      \t\tstwo = Singleton.INSTANCE;   \n   \t\t}   \n   \t\tpublic void testSerialize() {   \n      \t\tlogger.info(\"testing singleton serialization...\");   \n\t\t\t[b]      writeSingleton();   \n      \t\tSingleton s1 = readSingleton();   \n      \t\tSingleton s2 = readSingleton();   \n      \t\tAssert.assertEquals(true, s1 == s2);[/b]   }   \n   \t\t\tprivate void writeSingleton() {   \n      \t\ttry {   \n         \t\tFileOutputStream fos = new FileOutputStream(\"serializedSingleton\");   \n         \t\tObjectOutputStream oos = new ObjectOutputStream(fos);   \n         \t\tSingleton s = Singleton.INSTANCE;   \n    \n         \t\toos.writeObject(Singleton.INSTANCE);   \n         \t\toos.flush();   \n      \t\t}   \n      \t\tcatch(NotSerializableException se) {   \n         \t\tlogger.fatal(\"Not Serializable Exception: \" + se.getMessage());   \n      \t\t}   \n      \t\tcatch(IOException iox) {   \n         \t\tlogger.fatal(\"IO Exception: \" + iox.getMessage());   \n      \t\t}   \n   \t\t}   \n   \t\tprivate Singleton readSingleton() {   \n      \t\tSingleton s = null;   \n    \n      \t\ttry {   \n         \t\tFileInputStream fis = new FileInputStream(\"serializedSingleton\");   \n         \t\tObjectInputStream ois = new ObjectInputStream(fis);   \n         \t\ts = (Singleton)ois.readObject();   \n      \t\t}   \n      \t\tcatch(ClassNotFoundException cnf) {   \n         \t\tlogger.fatal(\"Class Not Found Exception: \" + cnf.getMessage());   \n      \t\t}   \n      \t\tcatch(NotSerializableException se) {   \n         \t\tlogger.fatal(\"Not Serializable Exception: \" + se.getMessage());   \n      \t\t}   \n      \t\tcatch(IOException iox) {   \n         \t\tlogger.fatal(\"IO Exception: \" + iox.getMessage());   \n      \t\t}   \n      \t\treturn s;   \n   \t\t}   \n   \t\tpublic void testUnique() {   \n      \t\tlogger.info(\"testing singleton uniqueness...\");   \n      \t\tSingleton another = new Singleton();   \n    \n      \t\tlogger.info(\"checking singletons for equality\");   \n      \t\tAssert.assertEquals(true, sone == stwo);   \n   \t\t}   \n\t}   \n\n前面这个测试案例序列化例12中的单例类，并且两次重构它。然后这个测试案例检查看是否被重构的单例类实例是同一个对象。下面是测试案例的输出：   \n \n\tBuildfile: build.xml   \n    \n\tinit:   \n     \t[echo] Build 20030422 (22-04-2003 11:32)   \n    \n\tcompile:   \n    \n\trun-test-text:   \n     \t[java] .INFO main: testing singleton serialization...   \n     \t[java] .INFO main: testing singleton uniqueness...   \n     \t[java] INFO main: checking singletons for equality   \n    \n     \t[java] Time: 0.1   \n    \n     \t[java] OK (2 tests)   \n\n\n**单例模式结束语**   \n\n单例模式简单却容易让人迷惑，特别是对于Java的开发者来说。在这篇文章中，作者演示了Java开发者在顾及多线程、类载入器和序列化情况如何实现单例模式。作者也展示了你怎样才能实现一个单例类的注册表，以便能够在运行期指定单例类。  \n\n原文：<http://calmness.iteye.com/blog/60179>","slug":"2012-11-02-singleton-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4e003rv8fysl0qvk39","content":"<p>###概要###<br>单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。    </p>\n<p>单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。<br><a id=\"more\"></a><br>单例模式的用意在于前一段中所关心的。通过单例模式你可以： </p>\n<ul>\n<li>确保一个类只有一个实例被建立 </li>\n<li>提供了一个对对象的全局访问指针 </li>\n<li>在不影响单例类的客户端的情况下允许将来有多个实例 </li>\n</ul>\n<p>尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。这篇文章讨论了单例模式并揭示了那些缺陷。  </p>\n<p>###单例模式###</p>\n<p>在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。<br>下图说明了单例模式的类图。<br><img src=\"/images/blog/singleton.jpg\" alt=\"\"></p>\n<p>正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。<br>例1显示了一个经典的单例模式的实现。<br>例1.经典的单例模式  </p>\n<pre><code>public class ClassicSingleton {   \n       private static ClassicSingleton instance = null;   \n\n       protected ClassicSingleton() {   \n          // Exists only to defeat instantiation.   \n       }   \n       public static ClassicSingleton getInstance() {   \n          if(instance == null) {   \n             instance = new ClassicSingleton();   \n          }   \n          return instance;   \n       }   \n}   \n</code></pre><p>在例1中的单例模式的实现很容易理解。ClassicSingleton类保持了一个对单独的单例实例的静态引用，并且从静态方法getInstance()中返回那个引用。<br>关于ClassicSingleton类，有几个让我们感兴趣的地方。<br>首先，ClassicSingleton使用了一个众所周知的懒汉式实例化去创建那个单例类的引用;结果，这个单例类的实例直到getInstance()方法被第一次调用时才被创建。这种技巧可以确保单例类的实例只有在需要时才被建立出来。其次，注意ClassicSingleton实现了一个protected的构造方法，这样客户端不能直接实例化一个ClassicSingleton类的实例。然而，你会惊奇的发现下面的代码完全合法：   </p>\n<pre><code>public class SingletonInstantiator {    \n      public SingletonInstantiator() {    \n           ClassicSingleton instance = ClassicSingleton.getInstance();   \n        ClassicSingleton anotherInstance =  new ClassicSingleton();   \n           ...    \n          }    \n}   \n</code></pre><p>前面这个代码片段为何能在没有继承ClassicSingleton并且ClassicSingleton类的构造方法是protected的情况下创建其实例？<br>答案是protected的构造方法可以被其子类以及在同一个包中的其它类调用。因为ClassicSingleton和SingletonInstantiator位于相同的包（缺省的包），所以SingletonInstantiator方法能创建ClasicSingleton的实例。<br>这种情况下有两种解决方案：一是你可以使ClassicSingleton的构造方法变化私有的（private）这样只有ClassicSingleton的方法能调用它;然而这也意味着ClassicSingleton不能有子类。有时这是一种很合意的解决方法，如果确实如此，那声明你的单例类为final是一个好主意，这样意图明确，并且让编译器去使用一些性能优化选项。另一种解决方法是把你的单例类放到一个外在的包中，以便在其它包中的类（包括缺省的包）无法实例化一个单例类。   </p>\n<p>关于ClassicSingleton的第三点感兴趣的地方是，如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>第四点，如果ClasicSingleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>最后也许是最重要的一点，就是例1中的ClassicSingleton类不是线程安全的。如果两个线程，我们称它们为线程1和线程2，在同一时间调用ClassicSingleton.getInstance()方法，如果线程1先进入if块，然后线程2进行控制，那么就会有ClassicSingleton的两个的实例被创建。    </p>\n<p>正如你从前面的讨论中所看到的，尽管单例模式是最简单的设计模式之一，在Java中实现它也是决非想象的那么简单。这篇文章接下来会揭示Java规范对单例模式进行的考虑，但是首先让我们近水楼台的看看你如何才能测试你的单例类。    </p>\n<p><strong>测试单例模式</strong>    </p>\n<p>接下来，我使用与log4j相对应的JUnit来测试单例类，它会贯穿在这篇文章余下的部分。如果你对JUnit或log4j不很熟悉，请参考相关资源。 </p>\n<p>例2是一个用JUnit测试例1的单例模式的案例：<br>例2.一个单例模式的案例 </p>\n<pre><code>import org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private ClassicSingleton sone = null, stwo = null;   \n       private static Logger logger = Logger.getRootLogger();   \n\n       public SingletonTest(String name) {   \n          super(name);   \n       }   \n       public void setUp() {   \n          logger.info(&quot;getting singleton...&quot;);   \n          sone = ClassicSingleton.getInstance();   \n          logger.info(&quot;...got singleton: &quot; + sone);   \n\n          logger.info(&quot;getting singleton...&quot;);   \n          stwo = ClassicSingleton.getInstance();   \n          logger.info(&quot;...got singleton: &quot; + stwo);   \n       }   \n       public void testUnique() {   \n          logger.info(&quot;checking singletons for equality&quot;);   \n          Assert.assertEquals(true, sone == stwo);   \n       }   \n}   \n</code></pre><p>例2两次调用ClassicSingleton.getInstance()，并且把返回的引用存储在成员变量中。方法testUnique()会检查这些引用看它们是否相同。例3是这个测试案例的输出：<br>例3.是这个测试案例的输出<br>Buildfile: build.xml   </p>\n<p>init:<br>     [echo] Build 20030414 (14-04-2003 03:08)   </p>\n<p>compile:   </p>\n<p>run-test-text:<br>     [java] .INFO main: [b]getting singleton…[/b]<br>     [java] INFO main: [b]created singleton:[/b] Singleton@e86f41<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: [b]getting singleton…[/b]<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: checking singletons for equality   </p>\n<pre><code>[java] Time: 0.032   \n\n[java] OK (1 test)  \n</code></pre><p>正如前面的清单所示，例2的简单测试顺利通过—-通过ClassicSingleton.getInstance()获得的两个单例类的引用确实相同;然而，你要知道这些引用是在单线程中得到的。下面的部分着重于用多线程测试单例类。 </p>\n<p>多线程因素的考虑 </p>\n<p>在例1中的ClassicSingleton.getInstance()方法由于下面的代码而不是线程安全的： </p>\n<pre><code>if(instance == null) {   \n       instance = new Singleton();   \n }   \n</code></pre><p>如果一个线程在第二行的赋值语句发生之前切换，那么成员变量instance仍然是null，然后另一个线程可能接下来进入到if块中。在这种情况下，两个不同的单例类实例就被创建。不幸的是这种假定很少发生，这样这种假定也很难在测试期间出现（译注：在这可能是作者对很少出现这种情况而导致无法测试从而使人们放松警惕而感到叹惜）。为了演示这个线程轮换，我得重新实现例1中的那个类。例4就是修订后的单例类：<br>例4.人为安排的方式   </p>\n<pre><code>import org.apache.log4j.Logger;       \npublic class Singleton {   \n    private static Singleton singleton = null;   \n    private static Logger logger = Logger.getRootLogger();   \n    private static boolean firstThread = true;   \n\n      protected Singleton() {   \n        // Exists only to defeat instantiation.   \n    }   \n    public static Singleton getInstance() {   \n        if(singleton == null) {   \n            simulateRandomActivity();   \n            singleton = new Singleton();   \n     }   \n     logger.info(&quot;created singleton: &quot; + singleton);   \n     return singleton;   \n  }   \nprivate static void simulateRandomActivity() {   \n     try {   \n        if(firstThread) {   \n               firstThread = false;   \n              logger.info(&quot;sleeping...&quot;);   \n\n               // This nap should give the second thread enough time   \n               // to get by the first thread.   \n             Thread.currentThread().sleep(50);   \n           }   \n         }   \n         catch(InterruptedException ex) {   \n            logger.warn(&quot;Sleep interrupted&quot;);   \n         }   \n      }   \n}   \n</code></pre><p>除了在这个清单中的单例类强制使用了一个多线程错误处理，例4类似于例1中的单例类。在getInstance()方法第一次被调用时，调用这个方法的线程会休眠50毫秒以便另外的线程也有时间调用getInstance()并创建一个新的单例类实例。当休眠的线程觉醒时，它也会创建一个新的单例类实例，这样我们就有两个单例类实例。尽管例4是人为如此的，但它却模拟了第一个线程调用了getInstance()并在没有完成时被切换的真实情形。<br>例5测试了例4的单例类：<br>例5.失败的测试 </p>\n<pre><code>import org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private static Logger logger = Logger.getRootLogger();   \n       private static Singleton singleton = null;   \n\n   public SingletonTest(String name) {   \n      super(name);   \n   }   \n   public void setUp() {   \n      singleton = null;   \n   }   \n  public void testUnique() throws InterruptedException {   \n  // Both threads call Singleton.getInstance().   \n  Thread threadOne = new Thread(new SingletonTestRunnable()),   \n         threadTwo = new Thread(new SingletonTestRunnable());   \n\n  threadOne.start();   \n  threadTwo.start();   \n\n  threadOne.join();   \n  threadTwo.join();   \n   }   \n   private static class SingletonTestRunnable implements Runnable {   \n  public void run() {   \n     // Get a reference to the singleton.   \n     Singleton s = Singleton.getInstance();   \n\n     // Protect singleton member variable from   \n     // multithreaded access.   \n     synchronized(SingletonTest.class) {   \n        if(singleton == null) // If local reference is null...   \n           singleton = s;     // ...set it to the singleton   \n         }   \n     // Local reference must be equal to the one and   \n     // only instance of Singleton; otherwise, we have two   \n              // Singleton instances.   \n     Assert.assertEquals(true, s == singleton);   \n      }   \n       }   \n}   \n</code></pre><p>例5的测试案例创建两个线程，然后各自启动，等待完成。这个案例保持了一个对单例类的静态引用，每个线程都会调用Singleton.getInstance()。如果这个静态成员变量没有被设置，那么第一个线程就会将它设为通过调用getInstance()而得到的引用，然后这个静态变量会与一个局部变量比较是否相等。<br>在这个测试案例运行时会发生一系列的事情：第一个线程调用getInstance()，进入if块，然后休眠;接着，第二个线程也调用getInstance()并且创建了一个单例类的实例。第二个线程会设置这个静态成员变量为它所创建的引用。第二个线程检查这个静态成员变量与一个局部备份的相等性。然后测试通过。当第一个线程觉醒时，它也会创建一个单例类的实例，并且它不会设置那个静态成员变量（因为第二个线程已经设置过了），所以那个静态变量与那个局部变量脱离同步，相等性测试即告失败。例6列出了例5的输出：<br>例6.例5的输出     </p>\n<pre><code>Buildfile: build.xml   \ninit:   \n     [echo] Build 20030414 (14-04-2003 03:06)   \ncompile:   \nrun-test-text:   \nINFO Thread-1: sleeping...   \nINFO Thread-2: created singleton: Singleton@7e5cbd   \nINFO Thread-1: created singleton: Singleton@704ebb   \njunit.framework.AssertionFailedError: expected: but was:   \n       at junit.framework.Assert.fail(Assert.java:47)   \n       at junit.framework.Assert.failNotEquals(Assert.java:282)   \n       at junit.framework.Assert.assertEquals(Assert.java:64)   \n       at junit.framework.Assert.assertEquals(Assert.java:149)   \n       at junit.framework.Assert.assertEquals(Assert.java:155)   \n       at SingletonTest$SingletonTestRunnable.run(Unknown Source)   \n       at java.lang.Thread.run(Thread.java:554)   \n     [java] .   \n     [java] Time: 0.577   \n\n     [java] OK (1 test)   \n</code></pre><p>到现在为止我们已经知道例4不是线程安全的，那就让我们看看如何修正它。             </p>\n<p><strong>同步</strong> </p>\n<p>要使例4的单例类为线程安全的很容易—-只要像下面一个同步化getInstance()方法：   </p>\n<pre><code>public synchronized static Singleton getInstance() {   \n       if(singleton == null) {   \n          simulateRandomActivity();   \n          singleton = new Singleton();   \n       }   \n       logger.info(&quot;created singleton: &quot; + singleton);   \n       return singleton;   \n}   \n</code></pre><p>在同步化getInstance()方法后，我们就可以得到例5的测试案例返回的下面的结果：    </p>\n<pre><code>Buildfile: build.xml   \n\ninit:   \n     [echo] Build 20030414 (14-04-2003 03:15)   \n\ncompile:   \n    [javac] Compiling 2 source files   \n\nrun-test-text:   \nINFO Thread-1: sleeping...   \nINFO Thread-1: created singleton: Singleton@ef577d   \nINFO Thread-2: created singleton: Singleton@ef577d   \n     [java] .   \n     [java] Time: 0.513   \n\n     [java] OK (1 test)   \n</code></pre><p>这此，这个测试案例工作正常，并且多线程的烦恼也被解决;然而，机敏的读者可能会认识到getInstance()方法只需要在第一次被调用时同步。因为同步的性能开销很昂贵（同步方法比非同步方法能降低到100次左右），或许我们可以引入一种性能改进方法，它只同步单例类的getInstance()方法中的赋值语句。   </p>\n<p><strong>一种性能改进的方法</strong></p>\n<p>寻找一种性能改进方法时，你可能会选择像下面这样重写getInstance()方法：   </p>\n<pre><code>public static Singleton getInstance() {   \n       if(singleton == null) {   \n          synchronized(Singleton.class) {    \n             singleton = new Singleton();   \n          }   \n       }   \n   return singleton;   \n}   \n</code></pre><p>这个代码片段只同步了关键的代码，而不是同步整个方法。然而这段代码却不是线程安全的。考虑一下下面的假定：线程1进入同步块，并且在它给singleton成员变量赋值之前线程1被切换。接着另一个线程进入if块。第二个线程将等待直到第一个线程完成，并且仍然会得到两个不同的单例类实例。有修复这个问题的方法吗？请读下去。  </p>\n<p><strong>双重加锁检查</strong></p>\n<p>初看上去，双重加锁检查似乎是一种使懒汉式实例化为线程安全的技术。下面的代码片段展示了这种技术：   </p>\n<pre><code>public static Singleton getInstance() {   \n      if(singleton == null) {   \n         synchronized(Singleton.class) {   \n               if(singleton == null) {   \n                 singleton = new Singleton();   \n               }   \n        }   \n      }   \n      return singleton;   \n}   \n</code></pre><p>如果两个线程同时访问getInstance()方法会发生什么？想像一下线程1进行同步块马上又被切换。接着，第二个线程进入if 块。当线程1退出同步块时，线程2会重新检查看是否singleton实例仍然为null。因为线程1设置了singleton成员变量，所以线程2的第二次检查会失败，第二个单例类实例也就不会被创建。似乎就是如此。<br>不幸的是，双重加锁检查不会保证正常工作，因为编译器会在Singleton的构造方法被调用之前随意给singleton赋一个值。如果在singleton引用被赋值之后而被初始化之前线程1被切换，线程2就会被返回一个对未初始化的单例类实例的引用。   </p>\n<p><strong>一个改进的线程安全的单例模式实现</strong></p>\n<p>例7列出了一个简单、快速而又是线程安全的单例模式实现：<br>例7.一个简单的单例类   </p>\n<pre><code>public class Singleton {   \n       public final static Singleton INSTANCE = new Singleton();   \n       private Singleton() {   \n         // Exists only to defeat instantiation.   \n      }   \n}   \n</code></pre><p>这段代码是线程安全的是因为静态成员变量一定会在类被第一次访问时被创建。你得到了一个自动使用了懒汉式实例化的线程安全的实现;你应该这样使用它：  </p>\n<pre><code>Singleton singleton = Singleton.INSTANCE;   \nsingleton.dothis();   \nsingleton.dothat();   \n...   \n</code></pre><p>当然万事并不完美，前面的Singleton只是一个折衷的方案;如果你使用那个实现，你就无法改变它以便后来你可能想要允许多个单例类的实例。用一种更折哀的单例模式实现(通过一个getInstance()方法获得实例)你可以改变这个方法以便返回一个唯一的实例或者是数百个实例中的一个．你不能用一个公开且是静态的（public static)成员变量这样做．   </p>\n<p>你可以安全的使用例７的单例模式实现或者是例１的带一个同步的getInstance()方法的实现．然而，我们必须要研究另一个问题：你必须在编译期指定这个单例类，这样就不是很灵活．一个单例类的注册表会让我们在运行期指定一个单例类．   </p>\n<p>使用注册表<br>使用一个单例类注册表可以：   </p>\n<p><strong>在运行期指定单例类</strong> </p>\n<p>防止产生多个单例类子类的实例<br>在例8的单例类中，保持了一个通过类名进行注册的单例类注册表：<br>例8 带注册表的单例类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation   \n       }   \n   public static synchronized Singleton getInstance(String classname) {   \n      if(classname == null) throw new IllegalArgumentException(&quot;Illegal classname&quot;);   \n         Singleton singleton = (Singleton)map.get(classname);   \n\n      if(singleton != null) {   \n         logger.info(&quot;got singleton from map: &quot; + singleton);   \n         return singleton;   \n      }   \n      if(classname.equals(&quot;SingeltonSubclass_One&quot;))   \n        singleton = new SingletonSubclass_One();            \n    else if(classname.equals(&quot;SingeltonSubclass_Two&quot;))   \n        singleton = new SingletonSubclass_Two();   \n\n      map.put(classname, singleton);   \n      logger.info(&quot;created singleton: &quot; + singleton);   \n      return singleton;   \n       }   \n       // Assume functionality follows that&apos;s attractive to inherit   \n}   \n</code></pre><p>这段代码的基类首先创建出子类的实例，然后把它们存储在一个Map中。但是基类却得付出很高的代价因为你必须为每一个子类替换它的getInstance()方法。幸运的是我们可以使用反射处理这个问题。   </p>\n<p><strong>使用反射</strong></p>\n<p>在例9的带注册表的单例类中，使用反射来实例化一个特殊的类的对象。与例8相对的是通过这种实现，Singleton.getInstance()方法不需要在每个被实现的子类中重写了。<br>例9 使用反射实例化单例类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n   protected Singleton() {   \n  // Exists only to thwart instantiation   \n   }   \n   public static synchronized Singleton getInstance(String classname) {   \n      Singleton singleton = (Singleton)map.get(classname);   \n\n      if(singleton != null) {   \n         logger.info(&quot;got singleton from map: &quot; + singleton);   \n         return singleton;   \n      }   \n      try {   \n     singleton = (Singleton)Class.forName(classname).newInstance();   \n      }   \n      catch(ClassNotFoundException cnf) {   \n     logger.fatal(&quot;Couldn&apos;t find class &quot; + classname);       \n      }   \n      catch(InstantiationException ie) {   \n         logger.fatal(&quot;Couldn&apos;t instantiate an object of type &quot; + classname);       \n      }   \n      catch(IllegalAccessException ia) {   \n         logger.fatal(&quot;Couldn&apos;t access class &quot; + classname);       \n      }   \n      map.put(classname, singleton);   \n      logger.info(&quot;created singleton: &quot; + singleton);   \n\n      return singleton;   \n       }   \n}   \n</code></pre><p>关于单例类的注册表应该说明的是：它们应该被封装在它们自己的类中以便最大限度的进行复用。   </p>\n<p><strong>封装注册表</strong></p>\n<p>例10列出了一个单例注册表类。<br>例10 一个SingletonRegistry类 </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class SingletonRegistry {   \n       public static SingletonRegistry REGISTRY = new SingletonRegistry();   \n\n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n       protected SingletonRegistry() {   \n          // Exists to defeat instantiation   \n       }   \n       public static synchronized Object getInstance(String classname) {   \n          Object singleton = map.get(classname);   \n\n          if(singleton != null) {   \n             return singleton;   \n          }   \n      try {   \n         singleton = Class.forName(classname).newInstance();   \n         logger.info(&quot;created singleton: &quot; + singleton);   \n      }   \n      catch(ClassNotFoundException cnf) {   \n         logger.fatal(&quot;Couldn&apos;t find class &quot; + classname);       \n      }   \n      catch(InstantiationException ie) {   \n         logger.fatal(&quot;Couldn&apos;t instantiate an object of type &quot; +    \n                   classname);       \n      }   \n      catch(IllegalAccessException ia) {   \n         logger.fatal(&quot;Couldn&apos;t access class &quot; + classname);       \n      }   \n      map.put(classname, singleton);   \n      return singleton;   \n       }   \n}   \n</code></pre><p>注意我是把SingletonRegistry类作为一个单例模式实现的。我也通用化了这个注册表以便它能存储和取回任何类型的对象。例11显示了的Singleton类使用了这个注册表。<br>例11 使用了一个封装的注册表的Singleton类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation.   \n       }   \n       public static Singleton getInstance() {   \n          return (Singleton)SingletonRegistry.REGISTRY.getInstance(classname);   \n       }   \n}   \n</code></pre><p>上面的Singleton类使用那个注册表的唯一实例通过类名取得单例对象。<br>现在我们已经知道如何实现线程安全的单例类和如何使用一个注册表去在运行期指定单例类名，接着让我们考查一下如何安排类载入器和处理序列化。  </p>\n<p><strong>Classloaders</strong> </p>\n<p>在许多情况下，使用多个类载入器是很普通的–包括servlet容器–所以不管你在实现你的单例类时是多么小心你都最终可以得到多个单例类的实例。如果你想要确保你的单例类只被同一个的类载入器装入，那你就必须自己指定这个类载入器;例如：  </p>\n<pre><code>private static Class getClass(String classname)    \n                                     throws ClassNotFoundException {   \n     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();   \n\n      if(classLoader == null)   \n     classLoader = Singleton.class.getClassLoader();   \n\n      return (classLoader.loadClass(classname));   \n       }   \n}   \n</code></pre><p>这个方法会尝试把当前的线程与那个类载入器相关联;如果classloader为null，这个方法会使用与装入单例类基类的那个类载入器。这个方法可以用Class.forName()代替。   </p>\n<p><strong>序列化</strong></p>\n<p>如果你序列化一个单例类，然后两次重构它，那么你就会得到那个单例类的两个实例，除非你实现readResolve()方法，像下面这样：<br>例12 一个可序列化的单例类 </p>\n<pre><code>import org.apache.log4j.Logger;   \n\npublic class Singleton implements java.io.Serializable {   \n       public static Singleton INSTANCE = new Singleton();   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation.   \n       }   \n       private Object readResolve() {   \n        return INSTANCE;   \n      }  \n   }   \n</code></pre><p>上面的单例类实现从readResolve()方法中返回一个唯一的实例;这样无论Singleton类何时被重构，它都只会返回那个相同的单例类实例。<br>例13测试了例12的单例类：<br>例13 测试一个可序列化的单例类   </p>\n<pre><code>import java.io.*;   \nimport org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private Singleton sone = null, stwo = null;   \n       private static Logger logger = Logger.getRootLogger();   \n\n      public SingletonTest(String name) {   \n          super(name);   \n       }   \n       public void setUp() {   \n          sone = Singleton.INSTANCE;   \n          stwo = Singleton.INSTANCE;   \n       }   \n       public void testSerialize() {   \n          logger.info(&quot;testing singleton serialization...&quot;);   \n        [b]      writeSingleton();   \n          Singleton s1 = readSingleton();   \n          Singleton s2 = readSingleton();   \n          Assert.assertEquals(true, s1 == s2);[/b]   }   \n           private void writeSingleton() {   \n          try {   \n             FileOutputStream fos = new FileOutputStream(&quot;serializedSingleton&quot;);   \n             ObjectOutputStream oos = new ObjectOutputStream(fos);   \n             Singleton s = Singleton.INSTANCE;   \n\n             oos.writeObject(Singleton.INSTANCE);   \n             oos.flush();   \n          }   \n          catch(NotSerializableException se) {   \n             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());   \n          }   \n          catch(IOException iox) {   \n             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());   \n          }   \n       }   \n       private Singleton readSingleton() {   \n          Singleton s = null;   \n\n          try {   \n             FileInputStream fis = new FileInputStream(&quot;serializedSingleton&quot;);   \n             ObjectInputStream ois = new ObjectInputStream(fis);   \n             s = (Singleton)ois.readObject();   \n          }   \n          catch(ClassNotFoundException cnf) {   \n             logger.fatal(&quot;Class Not Found Exception: &quot; + cnf.getMessage());   \n          }   \n          catch(NotSerializableException se) {   \n             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());   \n          }   \n          catch(IOException iox) {   \n             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());   \n          }   \n          return s;   \n       }   \n       public void testUnique() {   \n          logger.info(&quot;testing singleton uniqueness...&quot;);   \n          Singleton another = new Singleton();   \n\n          logger.info(&quot;checking singletons for equality&quot;);   \n          Assert.assertEquals(true, sone == stwo);   \n       }   \n}   \n</code></pre><p>前面这个测试案例序列化例12中的单例类，并且两次重构它。然后这个测试案例检查看是否被重构的单例类实例是同一个对象。下面是测试案例的输出：   </p>\n<pre><code>Buildfile: build.xml   \n\ninit:   \n     [echo] Build 20030422 (22-04-2003 11:32)   \n\ncompile:   \n\nrun-test-text:   \n     [java] .INFO main: testing singleton serialization...   \n     [java] .INFO main: testing singleton uniqueness...   \n     [java] INFO main: checking singletons for equality   \n\n     [java] Time: 0.1   \n\n     [java] OK (2 tests)   \n</code></pre><p><strong>单例模式结束语</strong>   </p>\n<p>单例模式简单却容易让人迷惑，特别是对于Java的开发者来说。在这篇文章中，作者演示了Java开发者在顾及多线程、类载入器和序列化情况如何实现单例模式。作者也展示了你怎样才能实现一个单例类的注册表，以便能够在运行期指定单例类。  </p>\n<p>原文：<a href=\"http://calmness.iteye.com/blog/60179\" target=\"_blank\" rel=\"external\">http://calmness.iteye.com/blog/60179</a></p>\n","excerpt":"<p>###概要###<br>单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。    </p>\n<p>单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。<br>","more":"<br>单例模式的用意在于前一段中所关心的。通过单例模式你可以： </p>\n<ul>\n<li>确保一个类只有一个实例被建立 </li>\n<li>提供了一个对对象的全局访问指针 </li>\n<li>在不影响单例类的客户端的情况下允许将来有多个实例 </li>\n</ul>\n<p>尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。这篇文章讨论了单例模式并揭示了那些缺陷。  </p>\n<p>###单例模式###</p>\n<p>在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。<br>下图说明了单例模式的类图。<br><img src=\"/images/blog/singleton.jpg\" alt=\"\"></p>\n<p>正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。<br>例1显示了一个经典的单例模式的实现。<br>例1.经典的单例模式  </p>\n<pre><code>public class ClassicSingleton {   \n       private static ClassicSingleton instance = null;   \n\n       protected ClassicSingleton() {   \n          // Exists only to defeat instantiation.   \n       }   \n       public static ClassicSingleton getInstance() {   \n          if(instance == null) {   \n             instance = new ClassicSingleton();   \n          }   \n          return instance;   \n       }   \n}   \n</code></pre><p>在例1中的单例模式的实现很容易理解。ClassicSingleton类保持了一个对单独的单例实例的静态引用，并且从静态方法getInstance()中返回那个引用。<br>关于ClassicSingleton类，有几个让我们感兴趣的地方。<br>首先，ClassicSingleton使用了一个众所周知的懒汉式实例化去创建那个单例类的引用;结果，这个单例类的实例直到getInstance()方法被第一次调用时才被创建。这种技巧可以确保单例类的实例只有在需要时才被建立出来。其次，注意ClassicSingleton实现了一个protected的构造方法，这样客户端不能直接实例化一个ClassicSingleton类的实例。然而，你会惊奇的发现下面的代码完全合法：   </p>\n<pre><code>public class SingletonInstantiator {    \n      public SingletonInstantiator() {    \n           ClassicSingleton instance = ClassicSingleton.getInstance();   \n        ClassicSingleton anotherInstance =  new ClassicSingleton();   \n           ...    \n          }    \n}   \n</code></pre><p>前面这个代码片段为何能在没有继承ClassicSingleton并且ClassicSingleton类的构造方法是protected的情况下创建其实例？<br>答案是protected的构造方法可以被其子类以及在同一个包中的其它类调用。因为ClassicSingleton和SingletonInstantiator位于相同的包（缺省的包），所以SingletonInstantiator方法能创建ClasicSingleton的实例。<br>这种情况下有两种解决方案：一是你可以使ClassicSingleton的构造方法变化私有的（private）这样只有ClassicSingleton的方法能调用它;然而这也意味着ClassicSingleton不能有子类。有时这是一种很合意的解决方法，如果确实如此，那声明你的单例类为final是一个好主意，这样意图明确，并且让编译器去使用一些性能优化选项。另一种解决方法是把你的单例类放到一个外在的包中，以便在其它包中的类（包括缺省的包）无法实例化一个单例类。   </p>\n<p>关于ClassicSingleton的第三点感兴趣的地方是，如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>第四点，如果ClasicSingleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>最后也许是最重要的一点，就是例1中的ClassicSingleton类不是线程安全的。如果两个线程，我们称它们为线程1和线程2，在同一时间调用ClassicSingleton.getInstance()方法，如果线程1先进入if块，然后线程2进行控制，那么就会有ClassicSingleton的两个的实例被创建。    </p>\n<p>正如你从前面的讨论中所看到的，尽管单例模式是最简单的设计模式之一，在Java中实现它也是决非想象的那么简单。这篇文章接下来会揭示Java规范对单例模式进行的考虑，但是首先让我们近水楼台的看看你如何才能测试你的单例类。    </p>\n<p><strong>测试单例模式</strong>    </p>\n<p>接下来，我使用与log4j相对应的JUnit来测试单例类，它会贯穿在这篇文章余下的部分。如果你对JUnit或log4j不很熟悉，请参考相关资源。 </p>\n<p>例2是一个用JUnit测试例1的单例模式的案例：<br>例2.一个单例模式的案例 </p>\n<pre><code>import org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private ClassicSingleton sone = null, stwo = null;   \n       private static Logger logger = Logger.getRootLogger();   \n\n       public SingletonTest(String name) {   \n          super(name);   \n       }   \n       public void setUp() {   \n          logger.info(&quot;getting singleton...&quot;);   \n          sone = ClassicSingleton.getInstance();   \n          logger.info(&quot;...got singleton: &quot; + sone);   \n\n          logger.info(&quot;getting singleton...&quot;);   \n          stwo = ClassicSingleton.getInstance();   \n          logger.info(&quot;...got singleton: &quot; + stwo);   \n       }   \n       public void testUnique() {   \n          logger.info(&quot;checking singletons for equality&quot;);   \n          Assert.assertEquals(true, sone == stwo);   \n       }   \n}   \n</code></pre><p>例2两次调用ClassicSingleton.getInstance()，并且把返回的引用存储在成员变量中。方法testUnique()会检查这些引用看它们是否相同。例3是这个测试案例的输出：<br>例3.是这个测试案例的输出<br>Buildfile: build.xml   </p>\n<p>init:<br>     [echo] Build 20030414 (14-04-2003 03:08)   </p>\n<p>compile:   </p>\n<p>run-test-text:<br>     [java] .INFO main: [b]getting singleton…[/b]<br>     [java] INFO main: [b]created singleton:[/b] Singleton@e86f41<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: [b]getting singleton…[/b]<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: checking singletons for equality   </p>\n<pre><code>[java] Time: 0.032   \n\n[java] OK (1 test)  \n</code></pre><p>正如前面的清单所示，例2的简单测试顺利通过—-通过ClassicSingleton.getInstance()获得的两个单例类的引用确实相同;然而，你要知道这些引用是在单线程中得到的。下面的部分着重于用多线程测试单例类。 </p>\n<p>多线程因素的考虑 </p>\n<p>在例1中的ClassicSingleton.getInstance()方法由于下面的代码而不是线程安全的： </p>\n<pre><code>if(instance == null) {   \n       instance = new Singleton();   \n }   \n</code></pre><p>如果一个线程在第二行的赋值语句发生之前切换，那么成员变量instance仍然是null，然后另一个线程可能接下来进入到if块中。在这种情况下，两个不同的单例类实例就被创建。不幸的是这种假定很少发生，这样这种假定也很难在测试期间出现（译注：在这可能是作者对很少出现这种情况而导致无法测试从而使人们放松警惕而感到叹惜）。为了演示这个线程轮换，我得重新实现例1中的那个类。例4就是修订后的单例类：<br>例4.人为安排的方式   </p>\n<pre><code>import org.apache.log4j.Logger;       \npublic class Singleton {   \n    private static Singleton singleton = null;   \n    private static Logger logger = Logger.getRootLogger();   \n    private static boolean firstThread = true;   \n\n      protected Singleton() {   \n        // Exists only to defeat instantiation.   \n    }   \n    public static Singleton getInstance() {   \n        if(singleton == null) {   \n            simulateRandomActivity();   \n            singleton = new Singleton();   \n     }   \n     logger.info(&quot;created singleton: &quot; + singleton);   \n     return singleton;   \n  }   \nprivate static void simulateRandomActivity() {   \n     try {   \n        if(firstThread) {   \n               firstThread = false;   \n              logger.info(&quot;sleeping...&quot;);   \n\n               // This nap should give the second thread enough time   \n               // to get by the first thread.   \n             Thread.currentThread().sleep(50);   \n           }   \n         }   \n         catch(InterruptedException ex) {   \n            logger.warn(&quot;Sleep interrupted&quot;);   \n         }   \n      }   \n}   \n</code></pre><p>除了在这个清单中的单例类强制使用了一个多线程错误处理，例4类似于例1中的单例类。在getInstance()方法第一次被调用时，调用这个方法的线程会休眠50毫秒以便另外的线程也有时间调用getInstance()并创建一个新的单例类实例。当休眠的线程觉醒时，它也会创建一个新的单例类实例，这样我们就有两个单例类实例。尽管例4是人为如此的，但它却模拟了第一个线程调用了getInstance()并在没有完成时被切换的真实情形。<br>例5测试了例4的单例类：<br>例5.失败的测试 </p>\n<pre><code>import org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private static Logger logger = Logger.getRootLogger();   \n       private static Singleton singleton = null;   \n\n   public SingletonTest(String name) {   \n      super(name);   \n   }   \n   public void setUp() {   \n      singleton = null;   \n   }   \n  public void testUnique() throws InterruptedException {   \n  // Both threads call Singleton.getInstance().   \n  Thread threadOne = new Thread(new SingletonTestRunnable()),   \n         threadTwo = new Thread(new SingletonTestRunnable());   \n\n  threadOne.start();   \n  threadTwo.start();   \n\n  threadOne.join();   \n  threadTwo.join();   \n   }   \n   private static class SingletonTestRunnable implements Runnable {   \n  public void run() {   \n     // Get a reference to the singleton.   \n     Singleton s = Singleton.getInstance();   \n\n     // Protect singleton member variable from   \n     // multithreaded access.   \n     synchronized(SingletonTest.class) {   \n        if(singleton == null) // If local reference is null...   \n           singleton = s;     // ...set it to the singleton   \n         }   \n     // Local reference must be equal to the one and   \n     // only instance of Singleton; otherwise, we have two   \n              // Singleton instances.   \n     Assert.assertEquals(true, s == singleton);   \n      }   \n       }   \n}   \n</code></pre><p>例5的测试案例创建两个线程，然后各自启动，等待完成。这个案例保持了一个对单例类的静态引用，每个线程都会调用Singleton.getInstance()。如果这个静态成员变量没有被设置，那么第一个线程就会将它设为通过调用getInstance()而得到的引用，然后这个静态变量会与一个局部变量比较是否相等。<br>在这个测试案例运行时会发生一系列的事情：第一个线程调用getInstance()，进入if块，然后休眠;接着，第二个线程也调用getInstance()并且创建了一个单例类的实例。第二个线程会设置这个静态成员变量为它所创建的引用。第二个线程检查这个静态成员变量与一个局部备份的相等性。然后测试通过。当第一个线程觉醒时，它也会创建一个单例类的实例，并且它不会设置那个静态成员变量（因为第二个线程已经设置过了），所以那个静态变量与那个局部变量脱离同步，相等性测试即告失败。例6列出了例5的输出：<br>例6.例5的输出     </p>\n<pre><code>Buildfile: build.xml   \ninit:   \n     [echo] Build 20030414 (14-04-2003 03:06)   \ncompile:   \nrun-test-text:   \nINFO Thread-1: sleeping...   \nINFO Thread-2: created singleton: Singleton@7e5cbd   \nINFO Thread-1: created singleton: Singleton@704ebb   \njunit.framework.AssertionFailedError: expected: but was:   \n       at junit.framework.Assert.fail(Assert.java:47)   \n       at junit.framework.Assert.failNotEquals(Assert.java:282)   \n       at junit.framework.Assert.assertEquals(Assert.java:64)   \n       at junit.framework.Assert.assertEquals(Assert.java:149)   \n       at junit.framework.Assert.assertEquals(Assert.java:155)   \n       at SingletonTest$SingletonTestRunnable.run(Unknown Source)   \n       at java.lang.Thread.run(Thread.java:554)   \n     [java] .   \n     [java] Time: 0.577   \n\n     [java] OK (1 test)   \n</code></pre><p>到现在为止我们已经知道例4不是线程安全的，那就让我们看看如何修正它。             </p>\n<p><strong>同步</strong> </p>\n<p>要使例4的单例类为线程安全的很容易—-只要像下面一个同步化getInstance()方法：   </p>\n<pre><code>public synchronized static Singleton getInstance() {   \n       if(singleton == null) {   \n          simulateRandomActivity();   \n          singleton = new Singleton();   \n       }   \n       logger.info(&quot;created singleton: &quot; + singleton);   \n       return singleton;   \n}   \n</code></pre><p>在同步化getInstance()方法后，我们就可以得到例5的测试案例返回的下面的结果：    </p>\n<pre><code>Buildfile: build.xml   \n\ninit:   \n     [echo] Build 20030414 (14-04-2003 03:15)   \n\ncompile:   \n    [javac] Compiling 2 source files   \n\nrun-test-text:   \nINFO Thread-1: sleeping...   \nINFO Thread-1: created singleton: Singleton@ef577d   \nINFO Thread-2: created singleton: Singleton@ef577d   \n     [java] .   \n     [java] Time: 0.513   \n\n     [java] OK (1 test)   \n</code></pre><p>这此，这个测试案例工作正常，并且多线程的烦恼也被解决;然而，机敏的读者可能会认识到getInstance()方法只需要在第一次被调用时同步。因为同步的性能开销很昂贵（同步方法比非同步方法能降低到100次左右），或许我们可以引入一种性能改进方法，它只同步单例类的getInstance()方法中的赋值语句。   </p>\n<p><strong>一种性能改进的方法</strong></p>\n<p>寻找一种性能改进方法时，你可能会选择像下面这样重写getInstance()方法：   </p>\n<pre><code>public static Singleton getInstance() {   \n       if(singleton == null) {   \n          synchronized(Singleton.class) {    \n             singleton = new Singleton();   \n          }   \n       }   \n   return singleton;   \n}   \n</code></pre><p>这个代码片段只同步了关键的代码，而不是同步整个方法。然而这段代码却不是线程安全的。考虑一下下面的假定：线程1进入同步块，并且在它给singleton成员变量赋值之前线程1被切换。接着另一个线程进入if块。第二个线程将等待直到第一个线程完成，并且仍然会得到两个不同的单例类实例。有修复这个问题的方法吗？请读下去。  </p>\n<p><strong>双重加锁检查</strong></p>\n<p>初看上去，双重加锁检查似乎是一种使懒汉式实例化为线程安全的技术。下面的代码片段展示了这种技术：   </p>\n<pre><code>public static Singleton getInstance() {   \n      if(singleton == null) {   \n         synchronized(Singleton.class) {   \n               if(singleton == null) {   \n                 singleton = new Singleton();   \n               }   \n        }   \n      }   \n      return singleton;   \n}   \n</code></pre><p>如果两个线程同时访问getInstance()方法会发生什么？想像一下线程1进行同步块马上又被切换。接着，第二个线程进入if 块。当线程1退出同步块时，线程2会重新检查看是否singleton实例仍然为null。因为线程1设置了singleton成员变量，所以线程2的第二次检查会失败，第二个单例类实例也就不会被创建。似乎就是如此。<br>不幸的是，双重加锁检查不会保证正常工作，因为编译器会在Singleton的构造方法被调用之前随意给singleton赋一个值。如果在singleton引用被赋值之后而被初始化之前线程1被切换，线程2就会被返回一个对未初始化的单例类实例的引用。   </p>\n<p><strong>一个改进的线程安全的单例模式实现</strong></p>\n<p>例7列出了一个简单、快速而又是线程安全的单例模式实现：<br>例7.一个简单的单例类   </p>\n<pre><code>public class Singleton {   \n       public final static Singleton INSTANCE = new Singleton();   \n       private Singleton() {   \n         // Exists only to defeat instantiation.   \n      }   \n}   \n</code></pre><p>这段代码是线程安全的是因为静态成员变量一定会在类被第一次访问时被创建。你得到了一个自动使用了懒汉式实例化的线程安全的实现;你应该这样使用它：  </p>\n<pre><code>Singleton singleton = Singleton.INSTANCE;   \nsingleton.dothis();   \nsingleton.dothat();   \n...   \n</code></pre><p>当然万事并不完美，前面的Singleton只是一个折衷的方案;如果你使用那个实现，你就无法改变它以便后来你可能想要允许多个单例类的实例。用一种更折哀的单例模式实现(通过一个getInstance()方法获得实例)你可以改变这个方法以便返回一个唯一的实例或者是数百个实例中的一个．你不能用一个公开且是静态的（public static)成员变量这样做．   </p>\n<p>你可以安全的使用例７的单例模式实现或者是例１的带一个同步的getInstance()方法的实现．然而，我们必须要研究另一个问题：你必须在编译期指定这个单例类，这样就不是很灵活．一个单例类的注册表会让我们在运行期指定一个单例类．   </p>\n<p>使用注册表<br>使用一个单例类注册表可以：   </p>\n<p><strong>在运行期指定单例类</strong> </p>\n<p>防止产生多个单例类子类的实例<br>在例8的单例类中，保持了一个通过类名进行注册的单例类注册表：<br>例8 带注册表的单例类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation   \n       }   \n   public static synchronized Singleton getInstance(String classname) {   \n      if(classname == null) throw new IllegalArgumentException(&quot;Illegal classname&quot;);   \n         Singleton singleton = (Singleton)map.get(classname);   \n\n      if(singleton != null) {   \n         logger.info(&quot;got singleton from map: &quot; + singleton);   \n         return singleton;   \n      }   \n      if(classname.equals(&quot;SingeltonSubclass_One&quot;))   \n        singleton = new SingletonSubclass_One();            \n    else if(classname.equals(&quot;SingeltonSubclass_Two&quot;))   \n        singleton = new SingletonSubclass_Two();   \n\n      map.put(classname, singleton);   \n      logger.info(&quot;created singleton: &quot; + singleton);   \n      return singleton;   \n       }   \n       // Assume functionality follows that&apos;s attractive to inherit   \n}   \n</code></pre><p>这段代码的基类首先创建出子类的实例，然后把它们存储在一个Map中。但是基类却得付出很高的代价因为你必须为每一个子类替换它的getInstance()方法。幸运的是我们可以使用反射处理这个问题。   </p>\n<p><strong>使用反射</strong></p>\n<p>在例9的带注册表的单例类中，使用反射来实例化一个特殊的类的对象。与例8相对的是通过这种实现，Singleton.getInstance()方法不需要在每个被实现的子类中重写了。<br>例9 使用反射实例化单例类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n   protected Singleton() {   \n  // Exists only to thwart instantiation   \n   }   \n   public static synchronized Singleton getInstance(String classname) {   \n      Singleton singleton = (Singleton)map.get(classname);   \n\n      if(singleton != null) {   \n         logger.info(&quot;got singleton from map: &quot; + singleton);   \n         return singleton;   \n      }   \n      try {   \n     singleton = (Singleton)Class.forName(classname).newInstance();   \n      }   \n      catch(ClassNotFoundException cnf) {   \n     logger.fatal(&quot;Couldn&apos;t find class &quot; + classname);       \n      }   \n      catch(InstantiationException ie) {   \n         logger.fatal(&quot;Couldn&apos;t instantiate an object of type &quot; + classname);       \n      }   \n      catch(IllegalAccessException ia) {   \n         logger.fatal(&quot;Couldn&apos;t access class &quot; + classname);       \n      }   \n      map.put(classname, singleton);   \n      logger.info(&quot;created singleton: &quot; + singleton);   \n\n      return singleton;   \n       }   \n}   \n</code></pre><p>关于单例类的注册表应该说明的是：它们应该被封装在它们自己的类中以便最大限度的进行复用。   </p>\n<p><strong>封装注册表</strong></p>\n<p>例10列出了一个单例注册表类。<br>例10 一个SingletonRegistry类 </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class SingletonRegistry {   \n       public static SingletonRegistry REGISTRY = new SingletonRegistry();   \n\n       private static HashMap map = new HashMap();   \n       private static Logger logger = Logger.getRootLogger();   \n\n       protected SingletonRegistry() {   \n          // Exists to defeat instantiation   \n       }   \n       public static synchronized Object getInstance(String classname) {   \n          Object singleton = map.get(classname);   \n\n          if(singleton != null) {   \n             return singleton;   \n          }   \n      try {   \n         singleton = Class.forName(classname).newInstance();   \n         logger.info(&quot;created singleton: &quot; + singleton);   \n      }   \n      catch(ClassNotFoundException cnf) {   \n         logger.fatal(&quot;Couldn&apos;t find class &quot; + classname);       \n      }   \n      catch(InstantiationException ie) {   \n         logger.fatal(&quot;Couldn&apos;t instantiate an object of type &quot; +    \n                   classname);       \n      }   \n      catch(IllegalAccessException ia) {   \n         logger.fatal(&quot;Couldn&apos;t access class &quot; + classname);       \n      }   \n      map.put(classname, singleton);   \n      return singleton;   \n       }   \n}   \n</code></pre><p>注意我是把SingletonRegistry类作为一个单例模式实现的。我也通用化了这个注册表以便它能存储和取回任何类型的对象。例11显示了的Singleton类使用了这个注册表。<br>例11 使用了一个封装的注册表的Singleton类   </p>\n<pre><code>import java.util.HashMap;   \nimport org.apache.log4j.Logger;   \n\npublic class Singleton {   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation.   \n       }   \n       public static Singleton getInstance() {   \n          return (Singleton)SingletonRegistry.REGISTRY.getInstance(classname);   \n       }   \n}   \n</code></pre><p>上面的Singleton类使用那个注册表的唯一实例通过类名取得单例对象。<br>现在我们已经知道如何实现线程安全的单例类和如何使用一个注册表去在运行期指定单例类名，接着让我们考查一下如何安排类载入器和处理序列化。  </p>\n<p><strong>Classloaders</strong> </p>\n<p>在许多情况下，使用多个类载入器是很普通的–包括servlet容器–所以不管你在实现你的单例类时是多么小心你都最终可以得到多个单例类的实例。如果你想要确保你的单例类只被同一个的类载入器装入，那你就必须自己指定这个类载入器;例如：  </p>\n<pre><code>private static Class getClass(String classname)    \n                                     throws ClassNotFoundException {   \n     ClassLoader classLoader = Thread.currentThread().getContextClassLoader();   \n\n      if(classLoader == null)   \n     classLoader = Singleton.class.getClassLoader();   \n\n      return (classLoader.loadClass(classname));   \n       }   \n}   \n</code></pre><p>这个方法会尝试把当前的线程与那个类载入器相关联;如果classloader为null，这个方法会使用与装入单例类基类的那个类载入器。这个方法可以用Class.forName()代替。   </p>\n<p><strong>序列化</strong></p>\n<p>如果你序列化一个单例类，然后两次重构它，那么你就会得到那个单例类的两个实例，除非你实现readResolve()方法，像下面这样：<br>例12 一个可序列化的单例类 </p>\n<pre><code>import org.apache.log4j.Logger;   \n\npublic class Singleton implements java.io.Serializable {   \n       public static Singleton INSTANCE = new Singleton();   \n\n       protected Singleton() {   \n          // Exists only to thwart instantiation.   \n       }   \n       private Object readResolve() {   \n        return INSTANCE;   \n      }  \n   }   \n</code></pre><p>上面的单例类实现从readResolve()方法中返回一个唯一的实例;这样无论Singleton类何时被重构，它都只会返回那个相同的单例类实例。<br>例13测试了例12的单例类：<br>例13 测试一个可序列化的单例类   </p>\n<pre><code>import java.io.*;   \nimport org.apache.log4j.Logger;   \nimport junit.framework.Assert;   \nimport junit.framework.TestCase;   \n\npublic class SingletonTest extends TestCase {   \n       private Singleton sone = null, stwo = null;   \n       private static Logger logger = Logger.getRootLogger();   \n\n      public SingletonTest(String name) {   \n          super(name);   \n       }   \n       public void setUp() {   \n          sone = Singleton.INSTANCE;   \n          stwo = Singleton.INSTANCE;   \n       }   \n       public void testSerialize() {   \n          logger.info(&quot;testing singleton serialization...&quot;);   \n        [b]      writeSingleton();   \n          Singleton s1 = readSingleton();   \n          Singleton s2 = readSingleton();   \n          Assert.assertEquals(true, s1 == s2);[/b]   }   \n           private void writeSingleton() {   \n          try {   \n             FileOutputStream fos = new FileOutputStream(&quot;serializedSingleton&quot;);   \n             ObjectOutputStream oos = new ObjectOutputStream(fos);   \n             Singleton s = Singleton.INSTANCE;   \n\n             oos.writeObject(Singleton.INSTANCE);   \n             oos.flush();   \n          }   \n          catch(NotSerializableException se) {   \n             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());   \n          }   \n          catch(IOException iox) {   \n             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());   \n          }   \n       }   \n       private Singleton readSingleton() {   \n          Singleton s = null;   \n\n          try {   \n             FileInputStream fis = new FileInputStream(&quot;serializedSingleton&quot;);   \n             ObjectInputStream ois = new ObjectInputStream(fis);   \n             s = (Singleton)ois.readObject();   \n          }   \n          catch(ClassNotFoundException cnf) {   \n             logger.fatal(&quot;Class Not Found Exception: &quot; + cnf.getMessage());   \n          }   \n          catch(NotSerializableException se) {   \n             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());   \n          }   \n          catch(IOException iox) {   \n             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());   \n          }   \n          return s;   \n       }   \n       public void testUnique() {   \n          logger.info(&quot;testing singleton uniqueness...&quot;);   \n          Singleton another = new Singleton();   \n\n          logger.info(&quot;checking singletons for equality&quot;);   \n          Assert.assertEquals(true, sone == stwo);   \n       }   \n}   \n</code></pre><p>前面这个测试案例序列化例12中的单例类，并且两次重构它。然后这个测试案例检查看是否被重构的单例类实例是同一个对象。下面是测试案例的输出：   </p>\n<pre><code>Buildfile: build.xml   \n\ninit:   \n     [echo] Build 20030422 (22-04-2003 11:32)   \n\ncompile:   \n\nrun-test-text:   \n     [java] .INFO main: testing singleton serialization...   \n     [java] .INFO main: testing singleton uniqueness...   \n     [java] INFO main: checking singletons for equality   \n\n     [java] Time: 0.1   \n\n     [java] OK (2 tests)   \n</code></pre><p><strong>单例模式结束语</strong>   </p>\n<p>单例模式简单却容易让人迷惑，特别是对于Java的开发者来说。在这篇文章中，作者演示了Java开发者在顾及多线程、类载入器和序列化情况如何实现单例模式。作者也展示了你怎样才能实现一个单例类的注册表，以便能够在运行期指定单例类。  </p>\n<p>原文：<a href=\"http://calmness.iteye.com/blog/60179\">http://calmness.iteye.com/blog/60179</a></p>"},{"layout":"post","title":"设计模式：模板方法（template method） in java","date":"2012-11-07T11:30:00.000Z","comments":1,"_content":"**定义：**定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义这个算法的某些特定步骤。   \n简单的说，就是你首先定义一下算法的各部分之间的执行顺序或者调用关系，然后在子类中实现具体每一部分是如何实现的。   \n\n采用什么算法作为例子呢？就是用**把动物放进冰箱**这个算法吧。  \n\n<!--more-->\n先定义一个抽象类:  \n\t\n\tpublic abstract class AbstractAlgorithm {\n\n\t\tpublic abstract void openFridgeDoor();\n\n\t\tpublic abstract void putAnimalInFridge();\n\n\t\tpublic abstract void closeFridgeDoor();\n\t\n\t\tpublic void execute(){\n\t\t\tthis.openFridgeDoor();\n\t\t\tthis.putAnimalInFridge();\n\t\t\tthis.closeFridgeDoor();\n\t\t}\n\t}\n\n这个类，定义了3个操作，打开冰箱门、把动物放进冰箱、关闭冰箱门，但并未实现，而留给子类来具体实现。`execute()`用来执行这一算法，它指定了各个操作之间的先后顺序。  \n\n比如：我想把大象放进冰箱里：  \n\n\tpublic class PutElephantInFridge extends AbstractAlgorithm {\n\n\t\t@Override\n\t\tpublic void openFridgeDoor() {\n\t\t\tSystem.out.println(\"open the fridge door lightly\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAnimalInFridge() {\n\t\t\tSystem.out\n\t\t\t\t.println(\"try my best to put elephant in fridge,after 2 hours, I got it.\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void closeFridgeDoor() {\n\t\t\tSystem.out.println(\"close the fridge door...\");\n\t\t}\n\n\t}\n具体使用：\n\n\tPutElephantInFridge algo = new PutElephantInFridge();\n\talgo.execute();\n好吧，执行一下算法就完成了。\n下面吗？我想把猴子放进冰箱，好吧，新建一个类继承AbstractAlgorithm，然后重写相关步骤就可以了。\n\n##模板方法 In JDK##\n\t\n\tjava.io.InputStream, java.io.OutputStream, java.io.Reader，java.io.Writer      \n\n\tjava.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap\n所有非抽象方法。\n\n\tjavax.servlet.http.HttpServlet#doXXX()   \n都默认返回一个`SC_METHOD_NOT_ALLOWED`类似的错误码，或者代码，要想使用，只有继承并且重写这些方法。\n\n\n","source":"_posts/2012-11-02-template-method-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：模板方法（template method） in java\"\ndate: 2012-11-07 19:30\ncomments: true\ncategories: 设计模式\ntags: [ Java, template method ]\n---\n**定义：**定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义这个算法的某些特定步骤。   \n简单的说，就是你首先定义一下算法的各部分之间的执行顺序或者调用关系，然后在子类中实现具体每一部分是如何实现的。   \n\n采用什么算法作为例子呢？就是用**把动物放进冰箱**这个算法吧。  \n\n<!--more-->\n先定义一个抽象类:  \n\t\n\tpublic abstract class AbstractAlgorithm {\n\n\t\tpublic abstract void openFridgeDoor();\n\n\t\tpublic abstract void putAnimalInFridge();\n\n\t\tpublic abstract void closeFridgeDoor();\n\t\n\t\tpublic void execute(){\n\t\t\tthis.openFridgeDoor();\n\t\t\tthis.putAnimalInFridge();\n\t\t\tthis.closeFridgeDoor();\n\t\t}\n\t}\n\n这个类，定义了3个操作，打开冰箱门、把动物放进冰箱、关闭冰箱门，但并未实现，而留给子类来具体实现。`execute()`用来执行这一算法，它指定了各个操作之间的先后顺序。  \n\n比如：我想把大象放进冰箱里：  \n\n\tpublic class PutElephantInFridge extends AbstractAlgorithm {\n\n\t\t@Override\n\t\tpublic void openFridgeDoor() {\n\t\t\tSystem.out.println(\"open the fridge door lightly\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void putAnimalInFridge() {\n\t\t\tSystem.out\n\t\t\t\t.println(\"try my best to put elephant in fridge,after 2 hours, I got it.\");\n\t\t}\n\n\t\t@Override\n\t\tpublic void closeFridgeDoor() {\n\t\t\tSystem.out.println(\"close the fridge door...\");\n\t\t}\n\n\t}\n具体使用：\n\n\tPutElephantInFridge algo = new PutElephantInFridge();\n\talgo.execute();\n好吧，执行一下算法就完成了。\n下面吗？我想把猴子放进冰箱，好吧，新建一个类继承AbstractAlgorithm，然后重写相关步骤就可以了。\n\n##模板方法 In JDK##\n\t\n\tjava.io.InputStream, java.io.OutputStream, java.io.Reader，java.io.Writer      \n\n\tjava.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap\n所有非抽象方法。\n\n\tjavax.servlet.http.HttpServlet#doXXX()   \n都默认返回一个`SC_METHOD_NOT_ALLOWED`类似的错误码，或者代码，要想使用，只有继承并且重写这些方法。\n\n\n","slug":"2012-11-02-template-method-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4i003vv8fyxpebnjwd","content":"<p><strong>定义：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义这个算法的某些特定步骤。<br>简单的说，就是你首先定义一下算法的各部分之间的执行顺序或者调用关系，然后在子类中实现具体每一部分是如何实现的。   </p>\n<p>采用什么算法作为例子呢？就是用<strong>把动物放进冰箱</strong>这个算法吧。  </p>\n<a id=\"more\"></a>\n<p>先定义一个抽象类:  </p>\n<pre><code>public abstract class AbstractAlgorithm {\n\n    public abstract void openFridgeDoor();\n\n    public abstract void putAnimalInFridge();\n\n    public abstract void closeFridgeDoor();\n\n    public void execute(){\n        this.openFridgeDoor();\n        this.putAnimalInFridge();\n        this.closeFridgeDoor();\n    }\n}\n</code></pre><p>这个类，定义了3个操作，打开冰箱门、把动物放进冰箱、关闭冰箱门，但并未实现，而留给子类来具体实现。<code>execute()</code>用来执行这一算法，它指定了各个操作之间的先后顺序。  </p>\n<p>比如：我想把大象放进冰箱里：  </p>\n<pre><code>public class PutElephantInFridge extends AbstractAlgorithm {\n\n    @Override\n    public void openFridgeDoor() {\n        System.out.println(&quot;open the fridge door lightly&quot;);\n    }\n\n    @Override\n    public void putAnimalInFridge() {\n        System.out\n            .println(&quot;try my best to put elephant in fridge,after 2 hours, I got it.&quot;);\n    }\n\n    @Override\n    public void closeFridgeDoor() {\n        System.out.println(&quot;close the fridge door...&quot;);\n    }\n\n}\n</code></pre><p>具体使用：</p>\n<pre><code>PutElephantInFridge algo = new PutElephantInFridge();\nalgo.execute();\n</code></pre><p>好吧，执行一下算法就完成了。<br>下面吗？我想把猴子放进冰箱，好吧，新建一个类继承AbstractAlgorithm，然后重写相关步骤就可以了。</p>\n<p>##模板方法 In JDK##</p>\n<pre><code>java.io.InputStream, java.io.OutputStream, java.io.Reader，java.io.Writer      \n\njava.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap\n</code></pre><p>所有非抽象方法。</p>\n<pre><code>javax.servlet.http.HttpServlet#doXXX()   \n</code></pre><p>都默认返回一个<code>SC_METHOD_NOT_ALLOWED</code>类似的错误码，或者代码，要想使用，只有继承并且重写这些方法。</p>\n","excerpt":"<p><strong>定义：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义这个算法的某些特定步骤。<br>简单的说，就是你首先定义一下算法的各部分之间的执行顺序或者调用关系，然后在子类中实现具体每一部分是如何实现的。   </p>\n<p>采用什么算法作为例子呢？就是用<strong>把动物放进冰箱</strong>这个算法吧。  </p>","more":"<p>先定义一个抽象类:  </p>\n<pre><code>public abstract class AbstractAlgorithm {\n\n    public abstract void openFridgeDoor();\n\n    public abstract void putAnimalInFridge();\n\n    public abstract void closeFridgeDoor();\n\n    public void execute(){\n        this.openFridgeDoor();\n        this.putAnimalInFridge();\n        this.closeFridgeDoor();\n    }\n}\n</code></pre><p>这个类，定义了3个操作，打开冰箱门、把动物放进冰箱、关闭冰箱门，但并未实现，而留给子类来具体实现。<code>execute()</code>用来执行这一算法，它指定了各个操作之间的先后顺序。  </p>\n<p>比如：我想把大象放进冰箱里：  </p>\n<pre><code>public class PutElephantInFridge extends AbstractAlgorithm {\n\n    @Override\n    public void openFridgeDoor() {\n        System.out.println(&quot;open the fridge door lightly&quot;);\n    }\n\n    @Override\n    public void putAnimalInFridge() {\n        System.out\n            .println(&quot;try my best to put elephant in fridge,after 2 hours, I got it.&quot;);\n    }\n\n    @Override\n    public void closeFridgeDoor() {\n        System.out.println(&quot;close the fridge door...&quot;);\n    }\n\n}\n</code></pre><p>具体使用：</p>\n<pre><code>PutElephantInFridge algo = new PutElephantInFridge();\nalgo.execute();\n</code></pre><p>好吧，执行一下算法就完成了。<br>下面吗？我想把猴子放进冰箱，好吧，新建一个类继承AbstractAlgorithm，然后重写相关步骤就可以了。</p>\n<p>##模板方法 In JDK##</p>\n<pre><code>java.io.InputStream, java.io.OutputStream, java.io.Reader，java.io.Writer      \n\njava.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap\n</code></pre><p>所有非抽象方法。</p>\n<pre><code>javax.servlet.http.HttpServlet#doXXX()   \n</code></pre><p>都默认返回一个<code>SC_METHOD_NOT_ALLOWED</code>类似的错误码，或者代码，要想使用，只有继承并且重写这些方法。</p>"},{"layout":"post","title":"设计模式：策略（strategy） in java","date":"2012-11-02T12:11:00.000Z","comments":1,"_content":"**定义：**策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。    \n\n策略模式有3个角色：   \n\n- Context封装角色    \n它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。\n- Strategy抽象策略角色    \n策略、算法的家族的抽象，通常为接口。   \n- ConcreteStrategy具体策略角色    \n实现抽象策略中的操作，该类含有具体的算法。  \n\n下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。    \n<!--more-->\n这3个妙计，分别是：   \n\n- 找乔国老帮忙（走后门）\n- 求吴国太放行（诉苦）\n- 孙尚香断后    \n\n首先，设计一个妙计的策略接口：    \n\n    public interface IStrategy{\n        public void operate();\n    }    \n    \n下面来分别实现这几个妙计。   \n\n    //妙计1\n    public class BackDoor implements IStrategy{    \n        public void operate(){\n            System.out.println(\"找乔国老帮忙，让吴国太给孙权施加压力\");\n        }\n    }\n    //妙计2\n    public class GivenGreenLight implements IStrategy{    \n        public void operate(){\n            System.out.println(\"找吴国太开绿灯，放行！\");\n        }\n    }\n    //妙计3\n    public class BlockEnemy implements IStrategy{    \n        public void operate(){\n            System.out.println(\"孙尚香断口，挡住追兵！\");\n        }\n    }\n    \n这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。    \n\n    public class Context{\n        private IStrategy strategy;\n        public Context(IStrategy strategy){\n            this.strategy = strategy;\n        }\n        \n        public void operate(){\n            this.strategy.operate();\n        }\n    }\n通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。    \n\n下面看下赵云如何使用的。    \n\n    public class ZhaoYun{   \n        Context context;\n        System.out.println(\"---刚到吴国的时候拆第一个---\");\n        context = new Context(new BackDoor());\n        context.operate();\n        System.out.println(\"---刘备乐不思蜀了，拆第二个---\");\n        context = new Context(new GivenGreenLight());\n        context.operate();\n        System.out.println(\"---孙权的小兵过来追，拆第三个---\");\n        context = new Context(new BlockEnemy());\n        context.operate();\n    }\n    \n    \n    \n需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。     \n\n    ","source":"_posts/2012-11-02-strategy-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：策略（strategy） in java\"\ndate: 2012-11-02 20:11\ncomments: true\ncategories: 设计模式\ntags: [ strategy, policy, pattern ]\n---\n**定义：**策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。    \n\n策略模式有3个角色：   \n\n- Context封装角色    \n它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。\n- Strategy抽象策略角色    \n策略、算法的家族的抽象，通常为接口。   \n- ConcreteStrategy具体策略角色    \n实现抽象策略中的操作，该类含有具体的算法。  \n\n下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。    \n<!--more-->\n这3个妙计，分别是：   \n\n- 找乔国老帮忙（走后门）\n- 求吴国太放行（诉苦）\n- 孙尚香断后    \n\n首先，设计一个妙计的策略接口：    \n\n    public interface IStrategy{\n        public void operate();\n    }    \n    \n下面来分别实现这几个妙计。   \n\n    //妙计1\n    public class BackDoor implements IStrategy{    \n        public void operate(){\n            System.out.println(\"找乔国老帮忙，让吴国太给孙权施加压力\");\n        }\n    }\n    //妙计2\n    public class GivenGreenLight implements IStrategy{    \n        public void operate(){\n            System.out.println(\"找吴国太开绿灯，放行！\");\n        }\n    }\n    //妙计3\n    public class BlockEnemy implements IStrategy{    \n        public void operate(){\n            System.out.println(\"孙尚香断口，挡住追兵！\");\n        }\n    }\n    \n这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。    \n\n    public class Context{\n        private IStrategy strategy;\n        public Context(IStrategy strategy){\n            this.strategy = strategy;\n        }\n        \n        public void operate(){\n            this.strategy.operate();\n        }\n    }\n通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。    \n\n下面看下赵云如何使用的。    \n\n    public class ZhaoYun{   \n        Context context;\n        System.out.println(\"---刚到吴国的时候拆第一个---\");\n        context = new Context(new BackDoor());\n        context.operate();\n        System.out.println(\"---刘备乐不思蜀了，拆第二个---\");\n        context = new Context(new GivenGreenLight());\n        context.operate();\n        System.out.println(\"---孙权的小兵过来追，拆第三个---\");\n        context = new Context(new BlockEnemy());\n        context.operate();\n    }\n    \n    \n    \n需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。     \n\n    ","slug":"2012-11-02-strategy-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4k003yv8fyygk8l3oe","content":"<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。    </p>\n<p>策略模式有3个角色：   </p>\n<ul>\n<li>Context封装角色<br>它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>\n<li>Strategy抽象策略角色<br>策略、算法的家族的抽象，通常为接口。   </li>\n<li>ConcreteStrategy具体策略角色<br>实现抽象策略中的操作，该类含有具体的算法。  </li>\n</ul>\n<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。<br><a id=\"more\"></a><br>这3个妙计，分别是：   </p>\n<ul>\n<li>找乔国老帮忙（走后门）</li>\n<li>求吴国太放行（诉苦）</li>\n<li>孙尚香断后    </li>\n</ul>\n<p>首先，设计一个妙计的策略接口：    </p>\n<pre><code>public interface IStrategy{\n    public void operate();\n}    \n</code></pre><p>下面来分别实现这几个妙计。   </p>\n<pre><code>//妙计1\npublic class BackDoor implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;找乔国老帮忙，让吴国太给孙权施加压力&quot;);\n    }\n}\n//妙计2\npublic class GivenGreenLight implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;找吴国太开绿灯，放行！&quot;);\n    }\n}\n//妙计3\npublic class BlockEnemy implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;孙尚香断口，挡住追兵！&quot;);\n    }\n}\n</code></pre><p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。    </p>\n<pre><code>public class Context{\n    private IStrategy strategy;\n    public Context(IStrategy strategy){\n        this.strategy = strategy;\n    }\n\n    public void operate(){\n        this.strategy.operate();\n    }\n}\n</code></pre><p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。    </p>\n<p>下面看下赵云如何使用的。    </p>\n<pre><code>public class ZhaoYun{   \n    Context context;\n    System.out.println(&quot;---刚到吴国的时候拆第一个---&quot;);\n    context = new Context(new BackDoor());\n    context.operate();\n    System.out.println(&quot;---刘备乐不思蜀了，拆第二个---&quot;);\n    context = new Context(new GivenGreenLight());\n    context.operate();\n    System.out.println(&quot;---孙权的小兵过来追，拆第三个---&quot;);\n    context = new Context(new BlockEnemy());\n    context.operate();\n}\n</code></pre><p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。     </p>\n","excerpt":"<p><strong>定义：</strong>策略模式（Strategy Pattern）是一种比较简单的模式，也叫做政策模式（Policy Pattern）。定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。    </p>\n<p>策略模式有3个角色：   </p>\n<ul>\n<li>Context封装角色<br>它叫上下文角色，起承上启下封装的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li>\n<li>Strategy抽象策略角色<br>策略、算法的家族的抽象，通常为接口。   </li>\n<li>ConcreteStrategy具体策略角色<br>实现抽象策略中的操作，该类含有具体的算法。  </li>\n</ul>\n<p>下面借用刘备江东娶亲，诸葛亮给赵云3个妙计的故事来说明这个问题。<br>","more":"<br>这3个妙计，分别是：   </p>\n<ul>\n<li>找乔国老帮忙（走后门）</li>\n<li>求吴国太放行（诉苦）</li>\n<li>孙尚香断后    </li>\n</ul>\n<p>首先，设计一个妙计的策略接口：    </p>\n<pre><code>public interface IStrategy{\n    public void operate();\n}    \n</code></pre><p>下面来分别实现这几个妙计。   </p>\n<pre><code>//妙计1\npublic class BackDoor implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;找乔国老帮忙，让吴国太给孙权施加压力&quot;);\n    }\n}\n//妙计2\npublic class GivenGreenLight implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;找吴国太开绿灯，放行！&quot;);\n    }\n}\n//妙计3\npublic class BlockEnemy implements IStrategy{    \n    public void operate(){\n        System.out.println(&quot;孙尚香断口，挡住追兵！&quot;);\n    }\n}\n</code></pre><p>这几个妙计（算法）都写好了。那么如何使得他们之间可以互换呢。这就需要使用Context进行封装了。在本例子中锦囊就是这个作用，它承载了三种策略妙计。    </p>\n<pre><code>public class Context{\n    private IStrategy strategy;\n    public Context(IStrategy strategy){\n        this.strategy = strategy;\n    }\n\n    public void operate(){\n        this.strategy.operate();\n    }\n}\n</code></pre><p>通过构造函数把策略传递进来，实现了不同策略的互换，同时提供了统一的operate()方法让高层（赵云）使用。    </p>\n<p>下面看下赵云如何使用的。    </p>\n<pre><code>public class ZhaoYun{   \n    Context context;\n    System.out.println(&quot;---刚到吴国的时候拆第一个---&quot;);\n    context = new Context(new BackDoor());\n    context.operate();\n    System.out.println(&quot;---刘备乐不思蜀了，拆第二个---&quot;);\n    context = new Context(new GivenGreenLight());\n    context.operate();\n    System.out.println(&quot;---孙权的小兵过来追，拆第三个---&quot;);\n    context = new Context(new BlockEnemy());\n    context.operate();\n}\n</code></pre><p>需要注意的是，策略方法提供了各种策略的互换，以及高层调用。但是具体什么条件下，使用什么策略是需要外部来判断的。本例子只是按顺序执行了。     </p>"},{"layout":"post","title":"设计模式：访问者（visitor） in java","date":"2012-11-02T12:12:00.000Z","comments":1,"_content":"**定义：**封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。    \n\n访问者模式有以下几个角色：    \n\n- Visitor抽象访问者    \n抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。\n- ConcreteVisitor具体访问者    \n它影响访问者访问到一个类后该怎么办，要做什么事情。\n- Element抽象元素    \n接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。\n- ConcreteElement具体元素    \n实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。\n- ObjectStruture结构对象    \n元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。   \n\n<!--more-->\n下面看看各个部分是如何实现的。    \n抽象元素：    \n\n    public abstract class Element {\n        //业务逻辑\n        public abstract void doSomething();\n        //允许谁来访问\n        public abstract void accept(IVisitor visitor);\n    }\n具体元素：    \n\n    public class ConcreteElement1 extends Element {\n    \n        @Override\n        public void doSomething() {\n            //todo\n        }\n    \n        @Override\n        public void accept(IVisitor visitor) {\n            visitor.visit(this);\n        }\n    }\n    \n    public class ConcreteElement2 extends Element {\n    \n        @Override\n        public void doSomething() {\n            //todo\n        }\n    \n        @Override\n        public void accept(IVisitor visitor) {\n            visitor.visit(this);\n        }\n    }  \n\n抽象访问者：    \n\n    public interface IVisitor {\n    \n        public void visit(ConcreteElement1 el1);\n    \n        public void visit(ConcreteElement2 el2);\n    }\n具体访问者：    \n\n    public class Visitor implements IVisitor {\n    \n        @Override\n        public void visit(ConcreteElement1 el1) {\n            el1.doSomething();\n        }\n    \n        @Override\n        public void visit(ConcreteElement2 el2) {\n            el2.doSomething();\n        }\n    }\n\n结构对象：   \n\n    public class ObjectStruture {\n    \n        public static Element createElment(){\n            Random random = new Random();\n            if (random.nextInt(100) > 50){\n                return new ConcreteElement1();\n            }else{\n                return new ConcreteElement2();\n            }\n        }\n    \n    }\n    \n下面看下具体场景类是怎么使用的：   \n\n    public class Client {\n    \n        public static void main(String[] args) {\n            for (int i = 0; i < 10; i++) {\n                Element el = ObjectStruture.createElment();\n                el.accept(new Visitor());\n            }\n        }\n    }","source":"_posts/2012-11-02-visitor-in-java.markdown","raw":"---\nlayout: post\ntitle: \"设计模式：访问者（visitor） in java\"\ndate: 2012-11-02 20:12\ncomments: true\ncategories: 设计模式\ntags: [ visitor, pattern, 访问者 ]\n---\n**定义：**封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。    \n\n访问者模式有以下几个角色：    \n\n- Visitor抽象访问者    \n抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。\n- ConcreteVisitor具体访问者    \n它影响访问者访问到一个类后该怎么办，要做什么事情。\n- Element抽象元素    \n接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。\n- ConcreteElement具体元素    \n实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。\n- ObjectStruture结构对象    \n元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。   \n\n<!--more-->\n下面看看各个部分是如何实现的。    \n抽象元素：    \n\n    public abstract class Element {\n        //业务逻辑\n        public abstract void doSomething();\n        //允许谁来访问\n        public abstract void accept(IVisitor visitor);\n    }\n具体元素：    \n\n    public class ConcreteElement1 extends Element {\n    \n        @Override\n        public void doSomething() {\n            //todo\n        }\n    \n        @Override\n        public void accept(IVisitor visitor) {\n            visitor.visit(this);\n        }\n    }\n    \n    public class ConcreteElement2 extends Element {\n    \n        @Override\n        public void doSomething() {\n            //todo\n        }\n    \n        @Override\n        public void accept(IVisitor visitor) {\n            visitor.visit(this);\n        }\n    }  \n\n抽象访问者：    \n\n    public interface IVisitor {\n    \n        public void visit(ConcreteElement1 el1);\n    \n        public void visit(ConcreteElement2 el2);\n    }\n具体访问者：    \n\n    public class Visitor implements IVisitor {\n    \n        @Override\n        public void visit(ConcreteElement1 el1) {\n            el1.doSomething();\n        }\n    \n        @Override\n        public void visit(ConcreteElement2 el2) {\n            el2.doSomething();\n        }\n    }\n\n结构对象：   \n\n    public class ObjectStruture {\n    \n        public static Element createElment(){\n            Random random = new Random();\n            if (random.nextInt(100) > 50){\n                return new ConcreteElement1();\n            }else{\n                return new ConcreteElement2();\n            }\n        }\n    \n    }\n    \n下面看下具体场景类是怎么使用的：   \n\n    public class Client {\n    \n        public static void main(String[] args) {\n            for (int i = 0; i < 10; i++) {\n                Element el = ObjectStruture.createElment();\n                el.accept(new Visitor());\n            }\n        }\n    }","slug":"2012-11-02-visitor-in-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4m0041v8fy7hdkd0vb","content":"<p><strong>定义：</strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。    </p>\n<p>访问者模式有以下几个角色：    </p>\n<ul>\n<li>Visitor抽象访问者<br>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。</li>\n<li>ConcreteVisitor具体访问者<br>它影响访问者访问到一个类后该怎么办，要做什么事情。</li>\n<li>Element抽象元素<br>接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。</li>\n<li>ConcreteElement具体元素<br>实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。</li>\n<li>ObjectStruture结构对象<br>元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。   </li>\n</ul>\n<a id=\"more\"></a>\n<p>下面看看各个部分是如何实现的。<br>抽象元素：    </p>\n<pre><code>public abstract class Element {\n    //业务逻辑\n    public abstract void doSomething();\n    //允许谁来访问\n    public abstract void accept(IVisitor visitor);\n}\n</code></pre><p>具体元素：    </p>\n<pre><code>public class ConcreteElement1 extends Element {\n\n    @Override\n    public void doSomething() {\n        //todo\n    }\n\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n\npublic class ConcreteElement2 extends Element {\n\n    @Override\n    public void doSomething() {\n        //todo\n    }\n\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}  \n</code></pre><p>抽象访问者：    </p>\n<pre><code>public interface IVisitor {\n\n    public void visit(ConcreteElement1 el1);\n\n    public void visit(ConcreteElement2 el2);\n}\n</code></pre><p>具体访问者：    </p>\n<pre><code>public class Visitor implements IVisitor {\n\n    @Override\n    public void visit(ConcreteElement1 el1) {\n        el1.doSomething();\n    }\n\n    @Override\n    public void visit(ConcreteElement2 el2) {\n        el2.doSomething();\n    }\n}\n</code></pre><p>结构对象：   </p>\n<pre><code>public class ObjectStruture {\n\n    public static Element createElment(){\n        Random random = new Random();\n        if (random.nextInt(100) &gt; 50){\n            return new ConcreteElement1();\n        }else{\n            return new ConcreteElement2();\n        }\n    }\n\n}\n</code></pre><p>下面看下具体场景类是怎么使用的：   </p>\n<pre><code>public class Client {\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            Element el = ObjectStruture.createElment();\n            el.accept(new Visitor());\n        }\n    }\n}\n</code></pre>","excerpt":"<p><strong>定义：</strong>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。    </p>\n<p>访问者模式有以下几个角色：    </p>\n<ul>\n<li>Visitor抽象访问者<br>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就visit方法的参数定义哪些对象是可以被访问的。</li>\n<li>ConcreteVisitor具体访问者<br>它影响访问者访问到一个类后该怎么办，要做什么事情。</li>\n<li>Element抽象元素<br>接口或者抽象类，声明接受哪一类访问者访问。程序上是通过accept方法中的参数来定义的。</li>\n<li>ConcreteElement具体元素<br>实现accept方法，通常是visitor.visit(this),基本都形成一个模式了。</li>\n<li>ObjectStruture结构对象<br>元素产生者，一般容纳在多个不同类，不同接口的容器。项目中，一般很少抽象这个角色。   </li>\n</ul>","more":"<p>下面看看各个部分是如何实现的。<br>抽象元素：    </p>\n<pre><code>public abstract class Element {\n    //业务逻辑\n    public abstract void doSomething();\n    //允许谁来访问\n    public abstract void accept(IVisitor visitor);\n}\n</code></pre><p>具体元素：    </p>\n<pre><code>public class ConcreteElement1 extends Element {\n\n    @Override\n    public void doSomething() {\n        //todo\n    }\n\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n\npublic class ConcreteElement2 extends Element {\n\n    @Override\n    public void doSomething() {\n        //todo\n    }\n\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.visit(this);\n    }\n}  \n</code></pre><p>抽象访问者：    </p>\n<pre><code>public interface IVisitor {\n\n    public void visit(ConcreteElement1 el1);\n\n    public void visit(ConcreteElement2 el2);\n}\n</code></pre><p>具体访问者：    </p>\n<pre><code>public class Visitor implements IVisitor {\n\n    @Override\n    public void visit(ConcreteElement1 el1) {\n        el1.doSomething();\n    }\n\n    @Override\n    public void visit(ConcreteElement2 el2) {\n        el2.doSomething();\n    }\n}\n</code></pre><p>结构对象：   </p>\n<pre><code>public class ObjectStruture {\n\n    public static Element createElment(){\n        Random random = new Random();\n        if (random.nextInt(100) &gt; 50){\n            return new ConcreteElement1();\n        }else{\n            return new ConcreteElement2();\n        }\n    }\n\n}\n</code></pre><p>下面看下具体场景类是怎么使用的：   </p>\n<pre><code>public class Client {\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            Element el = ObjectStruture.createElment();\n            el.accept(new Visitor());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"mysqldump命令使用","date":"2012-12-04T07:32:00.000Z","comments":1,"_content":"mysqldump命令用来备份数据库，默认会导出一整条insert语句，虽说执行起来会快一些。但是遇到大表，很可能因为缓冲区过载而挂掉。   \n \nmysqldump --skip-opt 加入这个参数，就可以导出多条独立的insert语句。  \n  \n例如：\n \n\tmysqldump --skip-opt -uroot -p database tablename > script.sql","source":"_posts/2012-12-04-mysqldump.markdown","raw":"---\nlayout: post\ntitle: \"mysqldump命令使用\"\ndate: 2012-12-04 15:32\ncomments: true\ncategories: mysql\ntags: [ mysql, dump ]\n---\nmysqldump命令用来备份数据库，默认会导出一整条insert语句，虽说执行起来会快一些。但是遇到大表，很可能因为缓冲区过载而挂掉。   \n \nmysqldump --skip-opt 加入这个参数，就可以导出多条独立的insert语句。  \n  \n例如：\n \n\tmysqldump --skip-opt -uroot -p database tablename > script.sql","slug":"2012-12-04-mysqldump","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4n0044v8fybqcbhtxc","content":"<p>mysqldump命令用来备份数据库，默认会导出一整条insert语句，虽说执行起来会快一些。但是遇到大表，很可能因为缓冲区过载而挂掉。   </p>\n<p>mysqldump –skip-opt 加入这个参数，就可以导出多条独立的insert语句。  </p>\n<p>例如：</p>\n<pre><code>mysqldump --skip-opt -uroot -p database tablename &gt; script.sql\n</code></pre>","excerpt":"","more":"<p>mysqldump命令用来备份数据库，默认会导出一整条insert语句，虽说执行起来会快一些。但是遇到大表，很可能因为缓冲区过载而挂掉。   </p>\n<p>mysqldump –skip-opt 加入这个参数，就可以导出多条独立的insert语句。  </p>\n<p>例如：</p>\n<pre><code>mysqldump --skip-opt -uroot -p database tablename &gt; script.sql\n</code></pre>"},{"layout":"post","title":"jmeter 分布式 step by step","date":"2012-12-07T05:25:00.000Z","comments":1,"_content":"###环境准备###\n\n* Jmeter(本文以2.8为例)   \n* jdk 1.5+   \n* 多台机器  \n(假设3台，IP分别为：10.81.14.170，10.81.14.180，10.81.14.190)    \n\n###工作原理###\n1台机器做为总控机，其他机器作为节点机。总控机器，负责将JMX脚本分发到节点机上，各个节点同时独立运行，向服务发出压力，总控机可以获取并汇总报告。   \n定义：   \n>总控机为**client**，我们（用户）只与这太机器打交道。或者称之为**Master**;   \n节点机器为**server**,它负责真正的向服务发出压力。或者称之为**Slave**;    \n\n<!--more-->\n这个只是角度不一样，就是一个总分结构。  \n###Slave配置###\n假设这3台机器都作为slave，那么分别在各个机器上， \n进入%JMETER HOME%/bin/目录     \n运行:   \njmeter-server.bat（windows）   \njmeter-server.sh (linux)  \n\n###Master配置###\n这里，我们以10.81.14.170作为Master,\n进入%JMETER HOME%/bin/ 目录   \n找到jmeter.properties文件，打开并找到remote_hosts=127.0.0.1这一行，修改为remote_hosts=127.0.0.1,10.81.14.180,10.81.14.190    \n其中，IP部分指向slave,并以逗号分割。由于170这台机器同时也是slave而存在，因此直接写为127.0.0.1了。    \n在目录下执行：   \njmeter.bat (windows)   \njmeter.sh (linux)   \n用来打开GUI界面。  \n点开运行->远程启动，将会看到这样的界面：   \n![Jmeter远程启动](/images/blog/jmeter-remote.png)   \n从这里就可以指定哪台slave来发压力了。当然也可以选择远程全部启动了。\n\n###为什么要分布式发压力？###\n1.单机运行受限，网络、CPU、内存读可能是瓶颈所在；   \n2.Jmeter是纯Java的程序，受JVM的一些限制；    \n一般情况下，依据机器配置，单机的发压量为300～600，如果需要更大的并发，就需要使用分布式的多台机器同时加压。  \n\n###配置注意事项###\n1.尽量保证各台机器之间的jmeter版本一致   \n2.JDK／JRE要正确安装   \n3.启动端口有可能被占用了，这个需要在启动时间指定SERVER_PORT      \n\n---\n参考文献：   \n<http://jmeter.apache.org/usermanual/remote-test.html>   \n<http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf>\n\n\n","source":"_posts/2012-12-07-jmeter-distribution-step-by-step.markdown","raw":"---\nlayout: post\ntitle: \"jmeter 分布式 step by step\"\ndate: 2012-12-07 13:25\ncomments: true\ncategories: jmeter\ntags: [ jmeter, 分布式, 压力测试 ]\n---\n###环境准备###\n\n* Jmeter(本文以2.8为例)   \n* jdk 1.5+   \n* 多台机器  \n(假设3台，IP分别为：10.81.14.170，10.81.14.180，10.81.14.190)    \n\n###工作原理###\n1台机器做为总控机，其他机器作为节点机。总控机器，负责将JMX脚本分发到节点机上，各个节点同时独立运行，向服务发出压力，总控机可以获取并汇总报告。   \n定义：   \n>总控机为**client**，我们（用户）只与这太机器打交道。或者称之为**Master**;   \n节点机器为**server**,它负责真正的向服务发出压力。或者称之为**Slave**;    \n\n<!--more-->\n这个只是角度不一样，就是一个总分结构。  \n###Slave配置###\n假设这3台机器都作为slave，那么分别在各个机器上， \n进入%JMETER HOME%/bin/目录     \n运行:   \njmeter-server.bat（windows）   \njmeter-server.sh (linux)  \n\n###Master配置###\n这里，我们以10.81.14.170作为Master,\n进入%JMETER HOME%/bin/ 目录   \n找到jmeter.properties文件，打开并找到remote_hosts=127.0.0.1这一行，修改为remote_hosts=127.0.0.1,10.81.14.180,10.81.14.190    \n其中，IP部分指向slave,并以逗号分割。由于170这台机器同时也是slave而存在，因此直接写为127.0.0.1了。    \n在目录下执行：   \njmeter.bat (windows)   \njmeter.sh (linux)   \n用来打开GUI界面。  \n点开运行->远程启动，将会看到这样的界面：   \n![Jmeter远程启动](/images/blog/jmeter-remote.png)   \n从这里就可以指定哪台slave来发压力了。当然也可以选择远程全部启动了。\n\n###为什么要分布式发压力？###\n1.单机运行受限，网络、CPU、内存读可能是瓶颈所在；   \n2.Jmeter是纯Java的程序，受JVM的一些限制；    \n一般情况下，依据机器配置，单机的发压量为300～600，如果需要更大的并发，就需要使用分布式的多台机器同时加压。  \n\n###配置注意事项###\n1.尽量保证各台机器之间的jmeter版本一致   \n2.JDK／JRE要正确安装   \n3.启动端口有可能被占用了，这个需要在启动时间指定SERVER_PORT      \n\n---\n参考文献：   \n<http://jmeter.apache.org/usermanual/remote-test.html>   \n<http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf>\n\n\n","slug":"2012-12-07-jmeter-distribution-step-by-step","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4p0046v8fymj21gdzz","content":"<p>###环境准备###</p>\n<ul>\n<li>Jmeter(本文以2.8为例)   </li>\n<li>jdk 1.5+   </li>\n<li>多台机器<br>(假设3台，IP分别为：10.81.14.170，10.81.14.180，10.81.14.190)    </li>\n</ul>\n<p>###工作原理###<br>1台机器做为总控机，其他机器作为节点机。总控机器，负责将JMX脚本分发到节点机上，各个节点同时独立运行，向服务发出压力，总控机可以获取并汇总报告。<br>定义：   </p>\n<blockquote>\n<p>总控机为<strong>client</strong>，我们（用户）只与这太机器打交道。或者称之为<strong>Master</strong>;<br>节点机器为<strong>server</strong>,它负责真正的向服务发出压力。或者称之为<strong>Slave</strong>;    </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>这个只是角度不一样，就是一个总分结构。  </p>\n<p>###Slave配置###<br>假设这3台机器都作为slave，那么分别在各个机器上，<br>进入%JMETER HOME%/bin/目录<br>运行:<br>jmeter-server.bat（windows）<br>jmeter-server.sh (linux)  </p>\n<p>###Master配置###<br>这里，我们以10.81.14.170作为Master,<br>进入%JMETER HOME%/bin/ 目录<br>找到jmeter.properties文件，打开并找到remote_hosts=127.0.0.1这一行，修改为remote_hosts=127.0.0.1,10.81.14.180,10.81.14.190<br>其中，IP部分指向slave,并以逗号分割。由于170这台机器同时也是slave而存在，因此直接写为127.0.0.1了。<br>在目录下执行：<br>jmeter.bat (windows)<br>jmeter.sh (linux)<br>用来打开GUI界面。<br>点开运行-&gt;远程启动，将会看到这样的界面：<br><img src=\"/images/blog/jmeter-remote.png\" alt=\"Jmeter远程启动\"><br>从这里就可以指定哪台slave来发压力了。当然也可以选择远程全部启动了。</p>\n<p>###为什么要分布式发压力？###<br>1.单机运行受限，网络、CPU、内存读可能是瓶颈所在；<br>2.Jmeter是纯Java的程序，受JVM的一些限制；<br>一般情况下，依据机器配置，单机的发压量为300～600，如果需要更大的并发，就需要使用分布式的多台机器同时加压。  </p>\n<p>###配置注意事项###<br>1.尽量保证各台机器之间的jmeter版本一致<br>2.JDK／JRE要正确安装<br>3.启动端口有可能被占用了，这个需要在启动时间指定SERVER_PORT      </p>\n<hr>\n<p>参考文献：<br><a href=\"http://jmeter.apache.org/usermanual/remote-test.html\" target=\"_blank\" rel=\"external\">http://jmeter.apache.org/usermanual/remote-test.html</a><br><a href=\"http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf\" target=\"_blank\" rel=\"external\">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf</a></p>\n","excerpt":"<p>###环境准备###</p>\n<ul>\n<li>Jmeter(本文以2.8为例)   </li>\n<li>jdk 1.5+   </li>\n<li>多台机器<br>(假设3台，IP分别为：10.81.14.170，10.81.14.180，10.81.14.190)    </li>\n</ul>\n<p>###工作原理###<br>1台机器做为总控机，其他机器作为节点机。总控机器，负责将JMX脚本分发到节点机上，各个节点同时独立运行，向服务发出压力，总控机可以获取并汇总报告。<br>定义：   </p>\n<blockquote>\n<p>总控机为<strong>client</strong>，我们（用户）只与这太机器打交道。或者称之为<strong>Master</strong>;<br>节点机器为<strong>server</strong>,它负责真正的向服务发出压力。或者称之为<strong>Slave</strong>;    </p>\n</blockquote>","more":"<p>这个只是角度不一样，就是一个总分结构。  </p>\n<p>###Slave配置###<br>假设这3台机器都作为slave，那么分别在各个机器上，<br>进入%JMETER HOME%/bin/目录<br>运行:<br>jmeter-server.bat（windows）<br>jmeter-server.sh (linux)  </p>\n<p>###Master配置###<br>这里，我们以10.81.14.170作为Master,<br>进入%JMETER HOME%/bin/ 目录<br>找到jmeter.properties文件，打开并找到remote_hosts=127.0.0.1这一行，修改为remote_hosts=127.0.0.1,10.81.14.180,10.81.14.190<br>其中，IP部分指向slave,并以逗号分割。由于170这台机器同时也是slave而存在，因此直接写为127.0.0.1了。<br>在目录下执行：<br>jmeter.bat (windows)<br>jmeter.sh (linux)<br>用来打开GUI界面。<br>点开运行-&gt;远程启动，将会看到这样的界面：<br><img src=\"/images/blog/jmeter-remote.png\" alt=\"Jmeter远程启动\"><br>从这里就可以指定哪台slave来发压力了。当然也可以选择远程全部启动了。</p>\n<p>###为什么要分布式发压力？###<br>1.单机运行受限，网络、CPU、内存读可能是瓶颈所在；<br>2.Jmeter是纯Java的程序，受JVM的一些限制；<br>一般情况下，依据机器配置，单机的发压量为300～600，如果需要更大的并发，就需要使用分布式的多台机器同时加压。  </p>\n<p>###配置注意事项###<br>1.尽量保证各台机器之间的jmeter版本一致<br>2.JDK／JRE要正确安装<br>3.启动端口有可能被占用了，这个需要在启动时间指定SERVER_PORT      </p>\n<hr>\n<p>参考文献：<br><a href=\"http://jmeter.apache.org/usermanual/remote-test.html\">http://jmeter.apache.org/usermanual/remote-test.html</a><br><a href=\"http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf\">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.pdf</a></p>"},{"layout":"post","title":"从源码编译构建Jmeter","date":"2012-12-31T07:48:00.000Z","comments":1,"_content":"###获取Jmeter的源码###\nJmeter源码可以从SVN REPO找到，地址：<http://svn.apache.org/repos/asf/jmeter/trunk/>    \n从GIT上也是可以的。地址：<https://github.com/apache/jmeter>    \nGit clone:   \n\n\tgit clone git://github.com/apache/jmeter.git jmeter\n这样就把Jmeter的源码给放到了本地的jmeter文件夹内。\n\n###配置并编译Jmeter###\n<!--more-->\n进入Jmeter目录，有个build.xml文件，显然是用ant管理的。   \n此时，如果把项目import到eclipse内，会发现缺失很多依赖的jar包。此时不禁感叹，为啥不直接用maven管理呢，这样就不用管这些了。我第一次操作的时候害的我还去下载了一个最新的发行版本，然后从里面找各种依赖的jar包。后来发现，开发者已经为我们想到了这个。执行ant命令就可以直接下载：\n\n\tant download_jars\n\n一段时间的等待后，各种jar包就下载好了。要耐心等待，这个过程要下载很多包的。\n\n接下来吗？直接执行：    \n\n\tant install /ant clean install\n\n提示BUILD SUCCESSFUL,这就表明已经编译成功了。\n\n\n###运行Jmeter###\n进入bin目录，执行jmeter.bat（windows）或者 ./jmeter（linux）,Jmeter的界面打开了，开始体验吧。   \n\n","source":"_posts/2012-12-31-build-jmeter-from-sources.markdown","raw":"---\nlayout: post\ntitle: \"从源码编译构建Jmeter\"\ndate: 2012-12-31 15:48\ncomments: true\ncategories: jmeter\ntags: [ jmeter, ant, source ]\n---\n###获取Jmeter的源码###\nJmeter源码可以从SVN REPO找到，地址：<http://svn.apache.org/repos/asf/jmeter/trunk/>    \n从GIT上也是可以的。地址：<https://github.com/apache/jmeter>    \nGit clone:   \n\n\tgit clone git://github.com/apache/jmeter.git jmeter\n这样就把Jmeter的源码给放到了本地的jmeter文件夹内。\n\n###配置并编译Jmeter###\n<!--more-->\n进入Jmeter目录，有个build.xml文件，显然是用ant管理的。   \n此时，如果把项目import到eclipse内，会发现缺失很多依赖的jar包。此时不禁感叹，为啥不直接用maven管理呢，这样就不用管这些了。我第一次操作的时候害的我还去下载了一个最新的发行版本，然后从里面找各种依赖的jar包。后来发现，开发者已经为我们想到了这个。执行ant命令就可以直接下载：\n\n\tant download_jars\n\n一段时间的等待后，各种jar包就下载好了。要耐心等待，这个过程要下载很多包的。\n\n接下来吗？直接执行：    \n\n\tant install /ant clean install\n\n提示BUILD SUCCESSFUL,这就表明已经编译成功了。\n\n\n###运行Jmeter###\n进入bin目录，执行jmeter.bat（windows）或者 ./jmeter（linux）,Jmeter的界面打开了，开始体验吧。   \n\n","slug":"2012-12-31-build-jmeter-from-sources","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4r0049v8fy0kgkomhl","content":"<p>###获取Jmeter的源码###<br>Jmeter源码可以从SVN REPO找到，地址：<a href=\"http://svn.apache.org/repos/asf/jmeter/trunk/\" target=\"_blank\" rel=\"external\">http://svn.apache.org/repos/asf/jmeter/trunk/</a><br>从GIT上也是可以的。地址：<a href=\"https://github.com/apache/jmeter\" target=\"_blank\" rel=\"external\">https://github.com/apache/jmeter</a><br>Git clone:   </p>\n<pre><code>git clone git://github.com/apache/jmeter.git jmeter\n</code></pre><p>这样就把Jmeter的源码给放到了本地的jmeter文件夹内。</p>\n<p>###配置并编译Jmeter###<br><a id=\"more\"></a><br>进入Jmeter目录，有个build.xml文件，显然是用ant管理的。<br>此时，如果把项目import到eclipse内，会发现缺失很多依赖的jar包。此时不禁感叹，为啥不直接用maven管理呢，这样就不用管这些了。我第一次操作的时候害的我还去下载了一个最新的发行版本，然后从里面找各种依赖的jar包。后来发现，开发者已经为我们想到了这个。执行ant命令就可以直接下载：</p>\n<pre><code>ant download_jars\n</code></pre><p>一段时间的等待后，各种jar包就下载好了。要耐心等待，这个过程要下载很多包的。</p>\n<p>接下来吗？直接执行：    </p>\n<pre><code>ant install /ant clean install\n</code></pre><p>提示BUILD SUCCESSFUL,这就表明已经编译成功了。</p>\n<p>###运行Jmeter###<br>进入bin目录，执行jmeter.bat（windows）或者 ./jmeter（linux）,Jmeter的界面打开了，开始体验吧。   </p>\n","excerpt":"<p>###获取Jmeter的源码###<br>Jmeter源码可以从SVN REPO找到，地址：<a href=\"http://svn.apache.org/repos/asf/jmeter/trunk/\">http://svn.apache.org/repos/asf/jmeter/trunk/</a><br>从GIT上也是可以的。地址：<a href=\"https://github.com/apache/jmeter\">https://github.com/apache/jmeter</a><br>Git clone:   </p>\n<pre><code>git clone git://github.com/apache/jmeter.git jmeter\n</code></pre><p>这样就把Jmeter的源码给放到了本地的jmeter文件夹内。</p>\n<p>###配置并编译Jmeter###<br>","more":"<br>进入Jmeter目录，有个build.xml文件，显然是用ant管理的。<br>此时，如果把项目import到eclipse内，会发现缺失很多依赖的jar包。此时不禁感叹，为啥不直接用maven管理呢，这样就不用管这些了。我第一次操作的时候害的我还去下载了一个最新的发行版本，然后从里面找各种依赖的jar包。后来发现，开发者已经为我们想到了这个。执行ant命令就可以直接下载：</p>\n<pre><code>ant download_jars\n</code></pre><p>一段时间的等待后，各种jar包就下载好了。要耐心等待，这个过程要下载很多包的。</p>\n<p>接下来吗？直接执行：    </p>\n<pre><code>ant install /ant clean install\n</code></pre><p>提示BUILD SUCCESSFUL,这就表明已经编译成功了。</p>\n<p>###运行Jmeter###<br>进入bin目录，执行jmeter.bat（windows）或者 ./jmeter（linux）,Jmeter的界面打开了，开始体验吧。   </p>"},{"layout":"post","title":"MySql性能监控","date":"2013-01-10T11:03:00.000Z","comments":1,"_content":"\n##用mysqldumpslow分析mysql的slow query log   \nmysql有一个功能就是可以log下来运行的比较慢的sql语句，默认是没有这个log的，为了开启这个功能，要修改my.cnf或者在mysql启动的时候加入一些参数。如果在my.cnf里面修改，需增加如下几行   \n\n\tlong_query_time = 1\n\tlog-slow-queries = /var/youpath/slow.log\n\tlog-queries-not-using-indexes[这个在mysql4.10以后才被引入]\n\nlong_query_time 是指执行超过多久的sql会被log下来，这里是1秒。  \nlog-slow-queries 设置把日志写在那里，可以为空，系统会给一个缺省的文件host_name-slow.log，我生成的log就在mysql的data目录   \nlog-queries-not-using-indexes 就是字面意思，log下来没有使用索引的query。   \n把上述参数打开，运行一段时间，就可以关掉了，省得影响生产环境。  \n<!--more-->\n接下来就是分析了，我这里的文件名字叫host-slow.log。     \n先mysqldumpslow –help以下，我主要用的是   \n\n\t-s ORDER what to sort by (t, at, l, al, r, ar etc), ‘at’ is default\n\t-t NUM just show the top n queries\n\t-g PATTERN grep: only consider stmts that include this string\n-s，是order的顺序，说明写的不够详细，俺用下来，包括看了代码，主要有\nc,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒叙    \n-t，是top n的意思，即为返回前面多少条的数据    \n-g，后边可以写一个正则匹配模式，大小写不敏感的   \n\n\tmysqldumpslow -s c -t 20 host-slow.log\n\tmysqldumpslow -s r -t 20 host-slow.log\n上述命令可以看出访问次数最多的20个sql语句和返回记录集最多的20个sql。  \n  \n\tmysqldumpslow -t 10 -s t -g “left join” host-slow.log    \n这个是按照时间返回前10条里面含有左连接的sql语句。   \n用了这个工具就可以查询出来那些sql语句是性能的瓶颈，进行优化，比如加索引，该应用的实现方式等。      \n \n##linux 系统整体性能查看的方法:\nvmstat 10 -----每10秒刷新一次\n \n\tprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------   \n \tr  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st   \n\t0  0      0  56508  10968  68380    0    0   184    40 1021   88  3 14 78  5  0    \n\t0  0      0  56508  10976  68376    0    0     0     3 1251   49  0  0 100  0  0    \n \t0  0      0  56508  10976  68376    0    0     0     0 1250   50  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     4 1251   51  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   48  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   50  0  0 100  0  0   \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   51  0  0 100  0  0      \n \t0  0      0  56508  10992  68376    0    0     0     2 1250   49  0  0 100  0  0    \n \t0  0      0  56508  10992  68376    0    0     0     0 1250   51  0  0 100  0  0   \n \nprocs:   \nr-->;在运行队列中等待的进程数    \nb-->;在等待io的进程数   \nw-->;可以进入运行队列但被替换的进程    \n\nmemory    \nswap-->;现时可用的交换内存（k表示）   \nfree-->;空闲的内存（k表示）   \n\npages   \nre－－》回收的页面   \nmf－－》非严重错误的页面   \npi－－》进入页面数（k表示）   \npo－－》出页面数（k表示）   \nfr－－》空余的页面数（k表示）   \nde－－》提前读入的页面中的未命中数   \nsr－－》通过时钟算法扫描的页面    \n\ndisk 显示每秒的磁盘操作。 s表示scsi盘，0表示盘号    \n\nfault 显示每秒的中断数   \nin－－》设备中断    \nsy－－》系统中断   \ncy－－》cpu交换   \n\ncpu 表示cpu的使用状态   \ncs－－》用户进程使用的时间   \nsy－－》系统进程使用的时间   \nid－－》cpu空闲的时间   \n\n\n其中:   \n如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。   \n如果pi，po 长期不等于0，表示内存不足。   \n如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。   \n \n每100s显示一次mysql 运行的状态:   \n\n\tmysqladmin extended -i 100 –r\n \n显示mysql服务器的线程列表    \n\n\tmysqladmin -u root -p process    \n\tEnter password:\n\t+----+------+-----------+----+---------+------+-------+------------------+\n\t| Id | User | Host      | db | Command | Time | State | Info             |\n\t+----+------+-----------+----+---------+------+-------+------------------+\n\t| 12 | root | localhost |    | Query   | 0    |       | show processlist |\n\t+----+------+-----------+----+---------+------+-------+------------------+\n \n相关命令：\n \n一，获取mysql用户下的进程总数    \n\tps -ef | awk '{print $1}' | grep \"mysql\" | grep -v \"grep\" | wc-1\n二，主机性能状态    \n\t[root@ ~]# uptime\n 13:05:52 up 53 days, 52 min,  1 user,  load average: 0.00, 0.00, 0.00\n \n三，CPU使用率   \ntop 或 vmstat    \n四，磁盘IO量    \nvmstat 或  iostat   \n五，swap进出量[内存]   \nfree    \n六，数据库性能状态   \n(1)QPS(每秒Query量)   \nQPS = Questions(or Queries) / seconds    \nmysql > show status like 'Question';   \n(2)TPS(每秒事务量)   \nTPS = (Com_commit + Com_rollback) / seconds\nmysql > show status like 'Com_commit';    \nmysql > show status like 'Com_rollback';   \n(3)key Buffer 命中率    \nkey_buffer_read_hits = (1-key_reads / key_read_requests) * 100%   \nkey_buffer_write_hits = (1-key_writes / key_write_requests) * 100%    \nmysql> show status like 'Key%';   \n(4)InnoDB Buffer命中率    \ninnodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) * 100%    \nmysql> show status like 'innodb_buffer_pool_read%';     \n(5)Query Cache命中率    \nQuery_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) * 100%;    \nmysql> show status like 'Qcache%';   \n(6)Table Cache状态量    \nmysql> show status like 'open%';    \n(7)Thread Cache 命中率    \nThread_cache_hits = (1 - Threads_created / connections ) * 100%    \nmysql> show status like 'Thread%';    \nmysql> show status like 'Connections';     \n(8)锁定状态     \nmysql> show status like '%lock%';    \n(9)复制延时量    \nmysql > show slave status    \n(10) Tmp Table 状况(临时表状况)   \nmysql > show status like 'Create_tmp%';    \n(11) Binlog Cache 使用状况    \nmysql > show status like 'Binlog_cache%';   \n(12) Innodb_log_waits 量    \nmysql > show status like 'innodb_log_waits';     ","source":"_posts/2013-01-10-mysql-monitor.markdown","raw":"---\nlayout: post\ntitle: \"MySql性能监控\"\ndate: 2013-01-10 19:03\ncomments: true\ncategories: mysql\ntags: [ mysql, monitor, slowquery ]\n---\n\n##用mysqldumpslow分析mysql的slow query log   \nmysql有一个功能就是可以log下来运行的比较慢的sql语句，默认是没有这个log的，为了开启这个功能，要修改my.cnf或者在mysql启动的时候加入一些参数。如果在my.cnf里面修改，需增加如下几行   \n\n\tlong_query_time = 1\n\tlog-slow-queries = /var/youpath/slow.log\n\tlog-queries-not-using-indexes[这个在mysql4.10以后才被引入]\n\nlong_query_time 是指执行超过多久的sql会被log下来，这里是1秒。  \nlog-slow-queries 设置把日志写在那里，可以为空，系统会给一个缺省的文件host_name-slow.log，我生成的log就在mysql的data目录   \nlog-queries-not-using-indexes 就是字面意思，log下来没有使用索引的query。   \n把上述参数打开，运行一段时间，就可以关掉了，省得影响生产环境。  \n<!--more-->\n接下来就是分析了，我这里的文件名字叫host-slow.log。     \n先mysqldumpslow –help以下，我主要用的是   \n\n\t-s ORDER what to sort by (t, at, l, al, r, ar etc), ‘at’ is default\n\t-t NUM just show the top n queries\n\t-g PATTERN grep: only consider stmts that include this string\n-s，是order的顺序，说明写的不够详细，俺用下来，包括看了代码，主要有\nc,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒叙    \n-t，是top n的意思，即为返回前面多少条的数据    \n-g，后边可以写一个正则匹配模式，大小写不敏感的   \n\n\tmysqldumpslow -s c -t 20 host-slow.log\n\tmysqldumpslow -s r -t 20 host-slow.log\n上述命令可以看出访问次数最多的20个sql语句和返回记录集最多的20个sql。  \n  \n\tmysqldumpslow -t 10 -s t -g “left join” host-slow.log    \n这个是按照时间返回前10条里面含有左连接的sql语句。   \n用了这个工具就可以查询出来那些sql语句是性能的瓶颈，进行优化，比如加索引，该应用的实现方式等。      \n \n##linux 系统整体性能查看的方法:\nvmstat 10 -----每10秒刷新一次\n \n\tprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------   \n \tr  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st   \n\t0  0      0  56508  10968  68380    0    0   184    40 1021   88  3 14 78  5  0    \n\t0  0      0  56508  10976  68376    0    0     0     3 1251   49  0  0 100  0  0    \n \t0  0      0  56508  10976  68376    0    0     0     0 1250   50  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     4 1251   51  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   48  0  0 100  0  0    \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   50  0  0 100  0  0   \n \t0  0      0  56508  10984  68376    0    0     0     0 1250   51  0  0 100  0  0      \n \t0  0      0  56508  10992  68376    0    0     0     2 1250   49  0  0 100  0  0    \n \t0  0      0  56508  10992  68376    0    0     0     0 1250   51  0  0 100  0  0   \n \nprocs:   \nr-->;在运行队列中等待的进程数    \nb-->;在等待io的进程数   \nw-->;可以进入运行队列但被替换的进程    \n\nmemory    \nswap-->;现时可用的交换内存（k表示）   \nfree-->;空闲的内存（k表示）   \n\npages   \nre－－》回收的页面   \nmf－－》非严重错误的页面   \npi－－》进入页面数（k表示）   \npo－－》出页面数（k表示）   \nfr－－》空余的页面数（k表示）   \nde－－》提前读入的页面中的未命中数   \nsr－－》通过时钟算法扫描的页面    \n\ndisk 显示每秒的磁盘操作。 s表示scsi盘，0表示盘号    \n\nfault 显示每秒的中断数   \nin－－》设备中断    \nsy－－》系统中断   \ncy－－》cpu交换   \n\ncpu 表示cpu的使用状态   \ncs－－》用户进程使用的时间   \nsy－－》系统进程使用的时间   \nid－－》cpu空闲的时间   \n\n\n其中:   \n如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。   \n如果pi，po 长期不等于0，表示内存不足。   \n如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。   \n \n每100s显示一次mysql 运行的状态:   \n\n\tmysqladmin extended -i 100 –r\n \n显示mysql服务器的线程列表    \n\n\tmysqladmin -u root -p process    \n\tEnter password:\n\t+----+------+-----------+----+---------+------+-------+------------------+\n\t| Id | User | Host      | db | Command | Time | State | Info             |\n\t+----+------+-----------+----+---------+------+-------+------------------+\n\t| 12 | root | localhost |    | Query   | 0    |       | show processlist |\n\t+----+------+-----------+----+---------+------+-------+------------------+\n \n相关命令：\n \n一，获取mysql用户下的进程总数    \n\tps -ef | awk '{print $1}' | grep \"mysql\" | grep -v \"grep\" | wc-1\n二，主机性能状态    \n\t[root@ ~]# uptime\n 13:05:52 up 53 days, 52 min,  1 user,  load average: 0.00, 0.00, 0.00\n \n三，CPU使用率   \ntop 或 vmstat    \n四，磁盘IO量    \nvmstat 或  iostat   \n五，swap进出量[内存]   \nfree    \n六，数据库性能状态   \n(1)QPS(每秒Query量)   \nQPS = Questions(or Queries) / seconds    \nmysql > show status like 'Question';   \n(2)TPS(每秒事务量)   \nTPS = (Com_commit + Com_rollback) / seconds\nmysql > show status like 'Com_commit';    \nmysql > show status like 'Com_rollback';   \n(3)key Buffer 命中率    \nkey_buffer_read_hits = (1-key_reads / key_read_requests) * 100%   \nkey_buffer_write_hits = (1-key_writes / key_write_requests) * 100%    \nmysql> show status like 'Key%';   \n(4)InnoDB Buffer命中率    \ninnodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) * 100%    \nmysql> show status like 'innodb_buffer_pool_read%';     \n(5)Query Cache命中率    \nQuery_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) * 100%;    \nmysql> show status like 'Qcache%';   \n(6)Table Cache状态量    \nmysql> show status like 'open%';    \n(7)Thread Cache 命中率    \nThread_cache_hits = (1 - Threads_created / connections ) * 100%    \nmysql> show status like 'Thread%';    \nmysql> show status like 'Connections';     \n(8)锁定状态     \nmysql> show status like '%lock%';    \n(9)复制延时量    \nmysql > show slave status    \n(10) Tmp Table 状况(临时表状况)   \nmysql > show status like 'Create_tmp%';    \n(11) Binlog Cache 使用状况    \nmysql > show status like 'Binlog_cache%';   \n(12) Innodb_log_waits 量    \nmysql > show status like 'innodb_log_waits';     ","slug":"2013-01-10-mysql-monitor","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4s004dv8fy3abgab17","content":"<p>##用mysqldumpslow分析mysql的slow query log<br>mysql有一个功能就是可以log下来运行的比较慢的sql语句，默认是没有这个log的，为了开启这个功能，要修改my.cnf或者在mysql启动的时候加入一些参数。如果在my.cnf里面修改，需增加如下几行   </p>\n<pre><code>long_query_time = 1\nlog-slow-queries = /var/youpath/slow.log\nlog-queries-not-using-indexes[这个在mysql4.10以后才被引入]\n</code></pre><p>long_query_time 是指执行超过多久的sql会被log下来，这里是1秒。<br>log-slow-queries 设置把日志写在那里，可以为空，系统会给一个缺省的文件host_name-slow.log，我生成的log就在mysql的data目录<br>log-queries-not-using-indexes 就是字面意思，log下来没有使用索引的query。<br>把上述参数打开，运行一段时间，就可以关掉了，省得影响生产环境。<br><a id=\"more\"></a><br>接下来就是分析了，我这里的文件名字叫host-slow.log。<br>先mysqldumpslow –help以下，我主要用的是   </p>\n<pre><code>-s ORDER what to sort by (t, at, l, al, r, ar etc), ‘at’ is default\n-t NUM just show the top n queries\n-g PATTERN grep: only consider stmts that include this string\n</code></pre><p>-s，是order的顺序，说明写的不够详细，俺用下来，包括看了代码，主要有<br>c,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒叙<br>-t，是top n的意思，即为返回前面多少条的数据<br>-g，后边可以写一个正则匹配模式，大小写不敏感的   </p>\n<pre><code>mysqldumpslow -s c -t 20 host-slow.log\nmysqldumpslow -s r -t 20 host-slow.log\n</code></pre><p>上述命令可以看出访问次数最多的20个sql语句和返回记录集最多的20个sql。  </p>\n<pre><code>mysqldumpslow -t 10 -s t -g “left join” host-slow.log    \n</code></pre><p>这个是按照时间返回前10条里面含有左连接的sql语句。<br>用了这个工具就可以查询出来那些sql语句是性能的瓶颈，进行优化，比如加索引，该应用的实现方式等。      </p>\n<p>##linux 系统整体性能查看的方法:<br>vmstat 10 —–每10秒刷新一次</p>\n<pre><code>procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------   \n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st   \n0  0      0  56508  10968  68380    0    0   184    40 1021   88  3 14 78  5  0    \n0  0      0  56508  10976  68376    0    0     0     3 1251   49  0  0 100  0  0    \n 0  0      0  56508  10976  68376    0    0     0     0 1250   50  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     4 1251   51  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     0 1250   48  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     0 1250   50  0  0 100  0  0   \n 0  0      0  56508  10984  68376    0    0     0     0 1250   51  0  0 100  0  0      \n 0  0      0  56508  10992  68376    0    0     0     2 1250   49  0  0 100  0  0    \n 0  0      0  56508  10992  68376    0    0     0     0 1250   51  0  0 100  0  0   \n</code></pre><p>procs:<br>r–&gt;;在运行队列中等待的进程数<br>b–&gt;;在等待io的进程数<br>w–&gt;;可以进入运行队列但被替换的进程    </p>\n<p>memory<br>swap–&gt;;现时可用的交换内存（k表示）<br>free–&gt;;空闲的内存（k表示）   </p>\n<p>pages<br>re－－》回收的页面<br>mf－－》非严重错误的页面<br>pi－－》进入页面数（k表示）<br>po－－》出页面数（k表示）<br>fr－－》空余的页面数（k表示）<br>de－－》提前读入的页面中的未命中数<br>sr－－》通过时钟算法扫描的页面    </p>\n<p>disk 显示每秒的磁盘操作。 s表示scsi盘，0表示盘号    </p>\n<p>fault 显示每秒的中断数<br>in－－》设备中断<br>sy－－》系统中断<br>cy－－》cpu交换   </p>\n<p>cpu 表示cpu的使用状态<br>cs－－》用户进程使用的时间<br>sy－－》系统进程使用的时间<br>id－－》cpu空闲的时间   </p>\n<p>其中:<br>如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。<br>如果pi，po 长期不等于0，表示内存不足。<br>如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。   </p>\n<p>每100s显示一次mysql 运行的状态:   </p>\n<pre><code>mysqladmin extended -i 100 –r\n</code></pre><p>显示mysql服务器的线程列表    </p>\n<pre><code>mysqladmin -u root -p process    \nEnter password:\n+----+------+-----------+----+---------+------+-------+------------------+\n| Id | User | Host      | db | Command | Time | State | Info             |\n+----+------+-----------+----+---------+------+-------+------------------+\n| 12 | root | localhost |    | Query   | 0    |       | show processlist |\n+----+------+-----------+----+---------+------+-------+------------------+\n</code></pre><p>相关命令：</p>\n<p>一，获取mysql用户下的进程总数<br>    ps -ef | awk ‘{print $1}’ | grep “mysql” | grep -v “grep” | wc-1<br>二，主机性能状态<br>    [root@ ~]# uptime<br> 13:05:52 up 53 days, 52 min,  1 user,  load average: 0.00, 0.00, 0.00</p>\n<p>三，CPU使用率<br>top 或 vmstat<br>四，磁盘IO量<br>vmstat 或  iostat<br>五，swap进出量[内存]<br>free<br>六，数据库性能状态<br>(1)QPS(每秒Query量)<br>QPS = Questions(or Queries) / seconds<br>mysql &gt; show status like ‘Question’;<br>(2)TPS(每秒事务量)<br>TPS = (Com_commit + Com_rollback) / seconds<br>mysql &gt; show status like ‘Com_commit’;<br>mysql &gt; show status like ‘Com_rollback’;<br>(3)key Buffer 命中率<br>key_buffer_read_hits = (1-key_reads / key_read_requests) <em> 100%<br>key_buffer_write_hits = (1-key_writes / key_write_requests) </em> 100%<br>mysql&gt; show status like ‘Key%’;<br>(4)InnoDB Buffer命中率<br>innodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) <em> 100%<br>mysql&gt; show status like ‘innodb_buffer_pool_read%’;<br>(5)Query Cache命中率<br>Query_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) </em> 100%;<br>mysql&gt; show status like ‘Qcache%’;<br>(6)Table Cache状态量<br>mysql&gt; show status like ‘open%’;<br>(7)Thread Cache 命中率<br>Thread_cache_hits = (1 - Threads_created / connections ) * 100%<br>mysql&gt; show status like ‘Thread%’;<br>mysql&gt; show status like ‘Connections’;<br>(8)锁定状态<br>mysql&gt; show status like ‘%lock%’;<br>(9)复制延时量<br>mysql &gt; show slave status<br>(10) Tmp Table 状况(临时表状况)<br>mysql &gt; show status like ‘Create_tmp%’;<br>(11) Binlog Cache 使用状况<br>mysql &gt; show status like ‘Binlog_cache%’;<br>(12) Innodb_log_waits 量<br>mysql &gt; show status like ‘innodb_log_waits’;     </p>\n","excerpt":"<p>##用mysqldumpslow分析mysql的slow query log<br>mysql有一个功能就是可以log下来运行的比较慢的sql语句，默认是没有这个log的，为了开启这个功能，要修改my.cnf或者在mysql启动的时候加入一些参数。如果在my.cnf里面修改，需增加如下几行   </p>\n<pre><code>long_query_time = 1\nlog-slow-queries = /var/youpath/slow.log\nlog-queries-not-using-indexes[这个在mysql4.10以后才被引入]\n</code></pre><p>long_query_time 是指执行超过多久的sql会被log下来，这里是1秒。<br>log-slow-queries 设置把日志写在那里，可以为空，系统会给一个缺省的文件host_name-slow.log，我生成的log就在mysql的data目录<br>log-queries-not-using-indexes 就是字面意思，log下来没有使用索引的query。<br>把上述参数打开，运行一段时间，就可以关掉了，省得影响生产环境。<br>","more":"<br>接下来就是分析了，我这里的文件名字叫host-slow.log。<br>先mysqldumpslow –help以下，我主要用的是   </p>\n<pre><code>-s ORDER what to sort by (t, at, l, al, r, ar etc), ‘at’ is default\n-t NUM just show the top n queries\n-g PATTERN grep: only consider stmts that include this string\n</code></pre><p>-s，是order的顺序，说明写的不够详细，俺用下来，包括看了代码，主要有<br>c,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒叙<br>-t，是top n的意思，即为返回前面多少条的数据<br>-g，后边可以写一个正则匹配模式，大小写不敏感的   </p>\n<pre><code>mysqldumpslow -s c -t 20 host-slow.log\nmysqldumpslow -s r -t 20 host-slow.log\n</code></pre><p>上述命令可以看出访问次数最多的20个sql语句和返回记录集最多的20个sql。  </p>\n<pre><code>mysqldumpslow -t 10 -s t -g “left join” host-slow.log    \n</code></pre><p>这个是按照时间返回前10条里面含有左连接的sql语句。<br>用了这个工具就可以查询出来那些sql语句是性能的瓶颈，进行优化，比如加索引，该应用的实现方式等。      </p>\n<p>##linux 系统整体性能查看的方法:<br>vmstat 10 —–每10秒刷新一次</p>\n<pre><code>procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------   \n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st   \n0  0      0  56508  10968  68380    0    0   184    40 1021   88  3 14 78  5  0    \n0  0      0  56508  10976  68376    0    0     0     3 1251   49  0  0 100  0  0    \n 0  0      0  56508  10976  68376    0    0     0     0 1250   50  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     4 1251   51  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     0 1250   48  0  0 100  0  0    \n 0  0      0  56508  10984  68376    0    0     0     0 1250   50  0  0 100  0  0   \n 0  0      0  56508  10984  68376    0    0     0     0 1250   51  0  0 100  0  0      \n 0  0      0  56508  10992  68376    0    0     0     2 1250   49  0  0 100  0  0    \n 0  0      0  56508  10992  68376    0    0     0     0 1250   51  0  0 100  0  0   \n</code></pre><p>procs:<br>r–&gt;;在运行队列中等待的进程数<br>b–&gt;;在等待io的进程数<br>w–&gt;;可以进入运行队列但被替换的进程    </p>\n<p>memory<br>swap–&gt;;现时可用的交换内存（k表示）<br>free–&gt;;空闲的内存（k表示）   </p>\n<p>pages<br>re－－》回收的页面<br>mf－－》非严重错误的页面<br>pi－－》进入页面数（k表示）<br>po－－》出页面数（k表示）<br>fr－－》空余的页面数（k表示）<br>de－－》提前读入的页面中的未命中数<br>sr－－》通过时钟算法扫描的页面    </p>\n<p>disk 显示每秒的磁盘操作。 s表示scsi盘，0表示盘号    </p>\n<p>fault 显示每秒的中断数<br>in－－》设备中断<br>sy－－》系统中断<br>cy－－》cpu交换   </p>\n<p>cpu 表示cpu的使用状态<br>cs－－》用户进程使用的时间<br>sy－－》系统进程使用的时间<br>id－－》cpu空闲的时间   </p>\n<p>其中:<br>如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。<br>如果pi，po 长期不等于0，表示内存不足。<br>如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。   </p>\n<p>每100s显示一次mysql 运行的状态:   </p>\n<pre><code>mysqladmin extended -i 100 –r\n</code></pre><p>显示mysql服务器的线程列表    </p>\n<pre><code>mysqladmin -u root -p process    \nEnter password:\n+----+------+-----------+----+---------+------+-------+------------------+\n| Id | User | Host      | db | Command | Time | State | Info             |\n+----+------+-----------+----+---------+------+-------+------------------+\n| 12 | root | localhost |    | Query   | 0    |       | show processlist |\n+----+------+-----------+----+---------+------+-------+------------------+\n</code></pre><p>相关命令：</p>\n<p>一，获取mysql用户下的进程总数<br>    ps -ef | awk ‘{print $1}’ | grep “mysql” | grep -v “grep” | wc-1<br>二，主机性能状态<br>    [root@ ~]# uptime<br> 13:05:52 up 53 days, 52 min,  1 user,  load average: 0.00, 0.00, 0.00</p>\n<p>三，CPU使用率<br>top 或 vmstat<br>四，磁盘IO量<br>vmstat 或  iostat<br>五，swap进出量[内存]<br>free<br>六，数据库性能状态<br>(1)QPS(每秒Query量)<br>QPS = Questions(or Queries) / seconds<br>mysql &gt; show status like ‘Question’;<br>(2)TPS(每秒事务量)<br>TPS = (Com_commit + Com_rollback) / seconds<br>mysql &gt; show status like ‘Com_commit’;<br>mysql &gt; show status like ‘Com_rollback’;<br>(3)key Buffer 命中率<br>key_buffer_read_hits = (1-key_reads / key_read_requests) <em> 100%<br>key_buffer_write_hits = (1-key_writes / key_write_requests) </em> 100%<br>mysql&gt; show status like ‘Key%’;<br>(4)InnoDB Buffer命中率<br>innodb_buffer_read_hits = (1 - innodb_buffer_pool_reads / innodb_buffer_pool_read_requests) <em> 100%<br>mysql&gt; show status like ‘innodb_buffer_pool_read%’;<br>(5)Query Cache命中率<br>Query_cache_hits = (Qcahce_hits / (Qcache_hits + Qcache_inserts )) </em> 100%;<br>mysql&gt; show status like ‘Qcache%’;<br>(6)Table Cache状态量<br>mysql&gt; show status like ‘open%’;<br>(7)Thread Cache 命中率<br>Thread_cache_hits = (1 - Threads_created / connections ) * 100%<br>mysql&gt; show status like ‘Thread%’;<br>mysql&gt; show status like ‘Connections’;<br>(8)锁定状态<br>mysql&gt; show status like ‘%lock%’;<br>(9)复制延时量<br>mysql &gt; show slave status<br>(10) Tmp Table 状况(临时表状况)<br>mysql &gt; show status like ‘Create_tmp%’;<br>(11) Binlog Cache 使用状况<br>mysql &gt; show status like ‘Binlog_cache%’;<br>(12) Innodb_log_waits 量<br>mysql &gt; show status like ‘innodb_log_waits’;     </p>"},{"layout":"post","title":"Ubuntu软件中心最受欢迎的20个软件","date":"2013-01-17T05:21:00.000Z","comments":1,"_content":"Ubuntu软件中心以下20款软件下载次数很多并且得票很高。 \n\n1.Stellarium 开源的桌面星空软件 \n\n2.Chromium web浏览器\n\n3.SMPlayer 播放器\n\n4.GnuCash 资金管理软件\n\n5.Blender 三维绘图及渲染软件\n\n<!--more-->\n6.Guake GNOME 命令终端\n\n7.Synaptic 包管理器\n\n8.Shutter 截图工具\n\n9.Synapse 启动器\n\n10.Mumble 游戏语音通讯工具\n\n11.XChat IRC 客户端\n\n12.Akregator KDE下不错的feed 聚合器\n\n13.Uget 下载管理器\n\n14.Deluge BT下载客户端\n\n15.GIMP图片编辑器\n\n16.RawTherapee RAW照片处理软件\n\n17.Darktable  数字摄影暗房软件\n\n18.Inskscape 矢量图形编辑器\n\n19.OpenShot 视频编辑器\n\n20.Calibre 电子图书馆\n","source":"_posts/2013-01-17-most-rated-20-software-in-ubuntu-softcenter.markdown","raw":"---\nlayout: post\ntitle: \"Ubuntu软件中心最受欢迎的20个软件\"\ndate: 2013-01-17 13:21\ncomments: true\ncategories: ubuntu\n---\nUbuntu软件中心以下20款软件下载次数很多并且得票很高。 \n\n1.Stellarium 开源的桌面星空软件 \n\n2.Chromium web浏览器\n\n3.SMPlayer 播放器\n\n4.GnuCash 资金管理软件\n\n5.Blender 三维绘图及渲染软件\n\n<!--more-->\n6.Guake GNOME 命令终端\n\n7.Synaptic 包管理器\n\n8.Shutter 截图工具\n\n9.Synapse 启动器\n\n10.Mumble 游戏语音通讯工具\n\n11.XChat IRC 客户端\n\n12.Akregator KDE下不错的feed 聚合器\n\n13.Uget 下载管理器\n\n14.Deluge BT下载客户端\n\n15.GIMP图片编辑器\n\n16.RawTherapee RAW照片处理软件\n\n17.Darktable  数字摄影暗房软件\n\n18.Inskscape 矢量图形编辑器\n\n19.OpenShot 视频编辑器\n\n20.Calibre 电子图书馆\n","slug":"2013-01-17-most-rated-20-software-in-ubuntu-softcenter","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4v004gv8fyxfrhn61a","content":"<p>Ubuntu软件中心以下20款软件下载次数很多并且得票很高。 </p>\n<p>1.Stellarium 开源的桌面星空软件 </p>\n<p>2.Chromium web浏览器</p>\n<p>3.SMPlayer 播放器</p>\n<p>4.GnuCash 资金管理软件</p>\n<p>5.Blender 三维绘图及渲染软件</p>\n<a id=\"more\"></a>\n<p>6.Guake GNOME 命令终端</p>\n<p>7.Synaptic 包管理器</p>\n<p>8.Shutter 截图工具</p>\n<p>9.Synapse 启动器</p>\n<p>10.Mumble 游戏语音通讯工具</p>\n<p>11.XChat IRC 客户端</p>\n<p>12.Akregator KDE下不错的feed 聚合器</p>\n<p>13.Uget 下载管理器</p>\n<p>14.Deluge BT下载客户端</p>\n<p>15.GIMP图片编辑器</p>\n<p>16.RawTherapee RAW照片处理软件</p>\n<p>17.Darktable  数字摄影暗房软件</p>\n<p>18.Inskscape 矢量图形编辑器</p>\n<p>19.OpenShot 视频编辑器</p>\n<p>20.Calibre 电子图书馆</p>\n","excerpt":"<p>Ubuntu软件中心以下20款软件下载次数很多并且得票很高。 </p>\n<p>1.Stellarium 开源的桌面星空软件 </p>\n<p>2.Chromium web浏览器</p>\n<p>3.SMPlayer 播放器</p>\n<p>4.GnuCash 资金管理软件</p>\n<p>5.Blender 三维绘图及渲染软件</p>","more":"<p>6.Guake GNOME 命令终端</p>\n<p>7.Synaptic 包管理器</p>\n<p>8.Shutter 截图工具</p>\n<p>9.Synapse 启动器</p>\n<p>10.Mumble 游戏语音通讯工具</p>\n<p>11.XChat IRC 客户端</p>\n<p>12.Akregator KDE下不错的feed 聚合器</p>\n<p>13.Uget 下载管理器</p>\n<p>14.Deluge BT下载客户端</p>\n<p>15.GIMP图片编辑器</p>\n<p>16.RawTherapee RAW照片处理软件</p>\n<p>17.Darktable  数字摄影暗房软件</p>\n<p>18.Inskscape 矢量图形编辑器</p>\n<p>19.OpenShot 视频编辑器</p>\n<p>20.Calibre 电子图书馆</p>"},{"layout":"post","title":"《探索式软件测试》读书笔记(1)","date":"2013-01-21T11:14:00.000Z","comments":1,"_content":"\n书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。   \n一般情况下，旅游地都会有这样一些区域：   \n\n* **商业区**: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。\n* **历史区**: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。\n* **旅游区**: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。\n* **娱乐区**: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。 \n* **旅馆区**: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。\n* **破旧区**：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。\n\n<!--more-->\n###商业区测试类型###\n商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。  \n>**指南测试法**： 测试人员按照用户手册进行操作。   \n各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。\n\n>**卖点测试法**： 按照销售人员对客户演示的顺序（卖点）进行测试。   \n令旅游者向往的任何一个地方一定有吸引他们的理由。\n\n>**地标测试法**： 选择一个功能点，然后向另外的功能点测试。  \n在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。\n\n>**极限测试法**： 向软件提出很多难以回答的问题。   \n旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。   \n\n>**快递测试法**： 专注与数据，保证数据在任何出现的地方都是同一个。  \n信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A->B->C->A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A->A->A->A，不能开封的说。  \n\n>**深夜／清晨测试法**： 在软件的空闲时段，去测试一些功能。   \n下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。\n\n>**遍历测试法**： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。    \n城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。  \n\n###历史区测试类型###\n主要是针对老功能以及修复代码的测试。\n\n>**恶邻测试法**： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。  \n每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。 \n  \n>**博物馆测试法**： 历史遗留代码值得测试人员多加关注。  \n展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。 \n\n>**上一版测试法**： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。   \n\n###娱乐区测试类型###\n旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。  \n>**配角测试法**：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。   \n导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。   \n\n>**深巷测试法**： 测试那些最不可能被用到或者那些最不吸引用户的特性。   \n高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。  \n\n>**通宵测试法**： 让程序一直运行，而不去关闭他。  \n通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。  \n\n###旅游区测试类型###\n每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。 \n\n>**收藏家测试法**：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。  \n旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。  \n\n>**长路径测试法**： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。  \n在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。  \n\n>**超模测试法**： 关注表面的东西，测试界面。  \n旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。  \n\n>**测一送一法**: 测试同一个应用多个拷贝的情况。  \n旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。   \n\n>**苏格兰酒吧测试法**： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。  \n作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。   \n\n###旅馆区测试类型###\n休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。  \n\n>**取消测试法**： 启动操作然后停止它。学会使用取消按钮。   \n任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。\n\n>**懒汉测试法**： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。   \n一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。   \n\n###破旧区测试类型###\n\n>**破坏测试法**： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。    \n\n>**反叛测试法**： 输入最不可能的数据，或者已知的恶意输入。  \n旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。     \n\n>**强迫症测试法**： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。   \n如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。   \n\n\n\n\n","source":"_posts/2013-01-21-exploratory-software-testing-reading-notes-1.markdown","raw":"---\nlayout: post\ntitle: \"《探索式软件测试》读书笔记(1)\"\ndate: 2013-01-21 19:14\ncomments: true\ncategories: 测试\ntags: [ 漫游, 探索测试, 旅游, 读书笔记 ]\n---\n\n书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。   \n一般情况下，旅游地都会有这样一些区域：   \n\n* **商业区**: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。\n* **历史区**: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。\n* **旅游区**: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。\n* **娱乐区**: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。 \n* **旅馆区**: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。\n* **破旧区**：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。\n\n<!--more-->\n###商业区测试类型###\n商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。  \n>**指南测试法**： 测试人员按照用户手册进行操作。   \n各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。\n\n>**卖点测试法**： 按照销售人员对客户演示的顺序（卖点）进行测试。   \n令旅游者向往的任何一个地方一定有吸引他们的理由。\n\n>**地标测试法**： 选择一个功能点，然后向另外的功能点测试。  \n在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。\n\n>**极限测试法**： 向软件提出很多难以回答的问题。   \n旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。   \n\n>**快递测试法**： 专注与数据，保证数据在任何出现的地方都是同一个。  \n信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A->B->C->A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A->A->A->A，不能开封的说。  \n\n>**深夜／清晨测试法**： 在软件的空闲时段，去测试一些功能。   \n下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。\n\n>**遍历测试法**： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。    \n城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。  \n\n###历史区测试类型###\n主要是针对老功能以及修复代码的测试。\n\n>**恶邻测试法**： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。  \n每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。 \n  \n>**博物馆测试法**： 历史遗留代码值得测试人员多加关注。  \n展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。 \n\n>**上一版测试法**： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。   \n\n###娱乐区测试类型###\n旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。  \n>**配角测试法**：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。   \n导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。   \n\n>**深巷测试法**： 测试那些最不可能被用到或者那些最不吸引用户的特性。   \n高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。  \n\n>**通宵测试法**： 让程序一直运行，而不去关闭他。  \n通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。  \n\n###旅游区测试类型###\n每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。 \n\n>**收藏家测试法**：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。  \n旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。  \n\n>**长路径测试法**： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。  \n在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。  \n\n>**超模测试法**： 关注表面的东西，测试界面。  \n旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。  \n\n>**测一送一法**: 测试同一个应用多个拷贝的情况。  \n旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。   \n\n>**苏格兰酒吧测试法**： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。  \n作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。   \n\n###旅馆区测试类型###\n休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。  \n\n>**取消测试法**： 启动操作然后停止它。学会使用取消按钮。   \n任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。\n\n>**懒汉测试法**： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。   \n一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。   \n\n###破旧区测试类型###\n\n>**破坏测试法**： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。    \n\n>**反叛测试法**： 输入最不可能的数据，或者已知的恶意输入。  \n旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。     \n\n>**强迫症测试法**： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。   \n如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。   \n\n\n\n\n","slug":"2013-01-21-exploratory-software-testing-reading-notes-1","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4x004lv8fytma27g30","content":"<p>书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。<br>一般情况下，旅游地都会有这样一些区域：   </p>\n<ul>\n<li><strong>商业区</strong>: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。</li>\n<li><strong>历史区</strong>: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。</li>\n<li><strong>旅游区</strong>: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。</li>\n<li><strong>娱乐区</strong>: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。 </li>\n<li><strong>旅馆区</strong>: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。</li>\n<li><strong>破旧区</strong>：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。</li>\n</ul>\n<a id=\"more\"></a>\n<p>###商业区测试类型###<br>商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。  </p>\n<blockquote>\n<p><strong>指南测试法</strong>： 测试人员按照用户手册进行操作。<br>各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。</p>\n<p><strong>卖点测试法</strong>： 按照销售人员对客户演示的顺序（卖点）进行测试。<br>令旅游者向往的任何一个地方一定有吸引他们的理由。</p>\n<p><strong>地标测试法</strong>： 选择一个功能点，然后向另外的功能点测试。<br>在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。</p>\n<p><strong>极限测试法</strong>： 向软件提出很多难以回答的问题。<br>旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。   </p>\n<p><strong>快递测试法</strong>： 专注与数据，保证数据在任何出现的地方都是同一个。<br>信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A-&gt;B-&gt;C-&gt;A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A-&gt;A-&gt;A-&gt;A，不能开封的说。  </p>\n<p><strong>深夜／清晨测试法</strong>： 在软件的空闲时段，去测试一些功能。<br>下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。</p>\n<p><strong>遍历测试法</strong>： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。<br>城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。  </p>\n</blockquote>\n<p>###历史区测试类型###<br>主要是针对老功能以及修复代码的测试。</p>\n<blockquote>\n<p><strong>恶邻测试法</strong>： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。<br>每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。 </p>\n<p><strong>博物馆测试法</strong>： 历史遗留代码值得测试人员多加关注。<br>展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。 </p>\n<p><strong>上一版测试法</strong>： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。   </p>\n</blockquote>\n<p>###娱乐区测试类型###<br>旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。  </p>\n<blockquote>\n<p><strong>配角测试法</strong>：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。<br>导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。   </p>\n<p><strong>深巷测试法</strong>： 测试那些最不可能被用到或者那些最不吸引用户的特性。<br>高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。  </p>\n<p><strong>通宵测试法</strong>： 让程序一直运行，而不去关闭他。<br>通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。  </p>\n</blockquote>\n<p>###旅游区测试类型###<br>每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。 </p>\n<blockquote>\n<p><strong>收藏家测试法</strong>：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。<br>旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。  </p>\n<p><strong>长路径测试法</strong>： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。<br>在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。  </p>\n<p><strong>超模测试法</strong>： 关注表面的东西，测试界面。<br>旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。  </p>\n<p><strong>测一送一法</strong>: 测试同一个应用多个拷贝的情况。<br>旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。   </p>\n<p><strong>苏格兰酒吧测试法</strong>： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。<br>作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。   </p>\n</blockquote>\n<p>###旅馆区测试类型###<br>休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。  </p>\n<blockquote>\n<p><strong>取消测试法</strong>： 启动操作然后停止它。学会使用取消按钮。<br>任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。</p>\n<p><strong>懒汉测试法</strong>： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。<br>一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。   </p>\n</blockquote>\n<p>###破旧区测试类型###</p>\n<blockquote>\n<p><strong>破坏测试法</strong>： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。    </p>\n<p><strong>反叛测试法</strong>： 输入最不可能的数据，或者已知的恶意输入。<br>旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。     </p>\n<p><strong>强迫症测试法</strong>： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。<br>如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。   </p>\n</blockquote>\n","excerpt":"<p>书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。<br>一般情况下，旅游地都会有这样一些区域：   </p>\n<ul>\n<li><strong>商业区</strong>: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。</li>\n<li><strong>历史区</strong>: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。</li>\n<li><strong>旅游区</strong>: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。</li>\n<li><strong>娱乐区</strong>: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。 </li>\n<li><strong>旅馆区</strong>: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。</li>\n<li><strong>破旧区</strong>：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。</li>\n</ul>","more":"<p>###商业区测试类型###<br>商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。  </p>\n<blockquote>\n<p><strong>指南测试法</strong>： 测试人员按照用户手册进行操作。<br>各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。</p>\n<p><strong>卖点测试法</strong>： 按照销售人员对客户演示的顺序（卖点）进行测试。<br>令旅游者向往的任何一个地方一定有吸引他们的理由。</p>\n<p><strong>地标测试法</strong>： 选择一个功能点，然后向另外的功能点测试。<br>在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。</p>\n<p><strong>极限测试法</strong>： 向软件提出很多难以回答的问题。<br>旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。   </p>\n<p><strong>快递测试法</strong>： 专注与数据，保证数据在任何出现的地方都是同一个。<br>信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A-&gt;B-&gt;C-&gt;A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A-&gt;A-&gt;A-&gt;A，不能开封的说。  </p>\n<p><strong>深夜／清晨测试法</strong>： 在软件的空闲时段，去测试一些功能。<br>下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。</p>\n<p><strong>遍历测试法</strong>： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。<br>城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。  </p>\n</blockquote>\n<p>###历史区测试类型###<br>主要是针对老功能以及修复代码的测试。</p>\n<blockquote>\n<p><strong>恶邻测试法</strong>： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。<br>每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。 </p>\n<p><strong>博物馆测试法</strong>： 历史遗留代码值得测试人员多加关注。<br>展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。 </p>\n<p><strong>上一版测试法</strong>： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。   </p>\n</blockquote>\n<p>###娱乐区测试类型###<br>旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。  </p>\n<blockquote>\n<p><strong>配角测试法</strong>：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。<br>导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。   </p>\n<p><strong>深巷测试法</strong>： 测试那些最不可能被用到或者那些最不吸引用户的特性。<br>高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。  </p>\n<p><strong>通宵测试法</strong>： 让程序一直运行，而不去关闭他。<br>通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。  </p>\n</blockquote>\n<p>###旅游区测试类型###<br>每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。 </p>\n<blockquote>\n<p><strong>收藏家测试法</strong>：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。<br>旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。  </p>\n<p><strong>长路径测试法</strong>： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。<br>在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。  </p>\n<p><strong>超模测试法</strong>： 关注表面的东西，测试界面。<br>旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。  </p>\n<p><strong>测一送一法</strong>: 测试同一个应用多个拷贝的情况。<br>旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。   </p>\n<p><strong>苏格兰酒吧测试法</strong>： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。<br>作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。   </p>\n</blockquote>\n<p>###旅馆区测试类型###<br>休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。  </p>\n<blockquote>\n<p><strong>取消测试法</strong>： 启动操作然后停止它。学会使用取消按钮。<br>任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。</p>\n<p><strong>懒汉测试法</strong>： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。<br>一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。   </p>\n</blockquote>\n<p>###破旧区测试类型###</p>\n<blockquote>\n<p><strong>破坏测试法</strong>： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。    </p>\n<p><strong>反叛测试法</strong>： 输入最不可能的数据，或者已知的恶意输入。<br>旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。     </p>\n<p><strong>强迫症测试法</strong>： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。<br>如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。   </p>\n</blockquote>"},{"layout":"post","title":"Selenium-Grid2 配置","date":"2013-01-10T11:37:00.000Z","comments":1,"_content":"###为什么要使用Selenium Grid ?###\n* 分布式运行大规模的Test\n* 能够通过一个中央点，很容易的运行不同OS上的不同browser\n* 最小化对Grid的维护时间，并能充分利用虚拟设备\n\n###Selenium Grid 部署与启动###\nHub :总控节点，连接调用Node。   \nNode: 负责执行Tests,调用浏览器。 \n<!--more-->\n下面以selenium-server-standalone-2.27.0.jar版本为例：   \n使用这样3台机器：   \n  \n* 10.81.14.170    \n* 10.81.14.180     \n* 10.81.14.190    \n\n启动Hub（10.81.14.180）:\n\n\tjava  -jar  selenium-server-standalone-2.27.0.jar -role hub \n在浏览器内打开：<http://10.81.14.180:4444/grid/console>可以查看Hub状态。也就是说Grid默认启动端口是4444，如果想切换为其他端口，则加`-port`参数。比如要切换为8888：\n\n\tjava  -jar  selenium-server-standalone-2.27.0.jar -role hub  -port 8888\n\n启动Node（10.81.14.170）: \n\n\tjava -jar selenium-server-standalone-2.27.0.jar -role node -hub http://10.81.14.180:8888/grid/register\n同样的，也可以使用`-port`切换node端口，默认端口是5555.    \n此处的node节点，也可以作为一个单机的远程节点存在，并同时支持RC,WebDriver。浏览器输入<http://10.81.14.180:8877/wd/hub>可以看到session信息。\n\n然后，同样的启动10.81.14.180、10.81.14.190上的Node节点。\n\n打开浏览器<http://10.81.14.180:8888/grid/console>,可以看到如下的界面：   \n\n![](/images/blog/selenium-grid-console.png)    \n \n至此，Selenium Grid2已经配置成功了。\n\n###使用Grid运行Tests###\nSelenium Grid2是向后兼容的，同时支持RC,WebDriver。\n如果使用RC,即Selenium1，使用以下的方法：   \n\n\tSelenium selenium = new DefaultSelenium(“10.81.14.180”, 8888, “*firefox”, “http://www.baidu.com”);\n使用WebDriver的话，使用以下的方法：   \n\n\tDesiredCapabilities capability = DesiredCapabilities.firefox();\n\tWebDriver driver = new RemoteWebDriver(new URL(\"http://10.81.14.180:8888/wd/hub\"), capability);\n\n可以看出所有的请求都发给了Hub,然后由Hub分配给匹配的节点来执行。   \n那么，Hub是如何来分配的呢？往下看   \n###Node配置###\n默认，Node会启动11个浏览器实例:5 Firefox,5 Chrome, 1 Internet Explorer. 从Grid Console界面看出来，为什么每个机器上有22个实例呢？是这样的，Node为了同时支持RC与WebDriver两种协议，所以就是2＊11了。把鼠标放到各个浏览器图标上，就可以看出里面的配置区别了。  \n内容类似：   \n\n\t{\n          \"browserName\": \"*firefox\",\n          \"maxInstances\": 5,\n          \"seleniumProtocol\": \"Selenium\"\n        }\n或者\n\n\t {\n          \"browserName\": \"firefox\",\n          \"maxInstances\": 5,\n          \"seleniumProtocol\": \"WebDriver\"\n        }\n其中，seleniumProtocol就是定义的不同协议了。\n\n如何修改Driver配置呢？可以从启动参数里操作。   \n\n\t-browser browserName=firefox,version=3.6,maxInstances=5,platform=LINUX\n\n那Node默认启动的配置是什么呢？    \n由于如果从启动参数里，配置这个多东西，很难写的。因此，官方很人性化的提供了JSON文件来配置。也就是说默认启动的配置如下：   \n<http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json>   \n \n<http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json>    \n\n如果想自定义配置，直接对json文件修改，启动时，指定配置文件就可以了。   \n\n\tjava -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json \n\n仅仅就这样就行了？从博文<http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/>知道，浏览器的启动是要制定一些driver位置的，否则Node不知道怎么启动浏览器实例。因此需要进行指定：  \n\n\tjava -jar selenium-server-standalone-2.27.0.jar -port 8877 -role node -hub http://10.81.14.180:8888/grid/register  -nodeConfig nodeconfig.json -Dwebdriver.chrome.driver=\"E:/selenium/chromedriver.exe\" -Dwebdriver.ie.driver=\"E:/selenium/IEDriverServer.exe\"\n\n\n参考文档：  \n<http://code.google.com/p/selenium/wiki/Grid2>\n","source":"_posts/2013-01-10-selenium-grid2-config.markdown","raw":"---\nlayout: post\ntitle: \"Selenium-Grid2 配置\"\ndate: 2013-01-10 19:37\ncomments: true\ncategories: selenium\ntags: [ grid, selenium ]\n---\n###为什么要使用Selenium Grid ?###\n* 分布式运行大规模的Test\n* 能够通过一个中央点，很容易的运行不同OS上的不同browser\n* 最小化对Grid的维护时间，并能充分利用虚拟设备\n\n###Selenium Grid 部署与启动###\nHub :总控节点，连接调用Node。   \nNode: 负责执行Tests,调用浏览器。 \n<!--more-->\n下面以selenium-server-standalone-2.27.0.jar版本为例：   \n使用这样3台机器：   \n  \n* 10.81.14.170    \n* 10.81.14.180     \n* 10.81.14.190    \n\n启动Hub（10.81.14.180）:\n\n\tjava  -jar  selenium-server-standalone-2.27.0.jar -role hub \n在浏览器内打开：<http://10.81.14.180:4444/grid/console>可以查看Hub状态。也就是说Grid默认启动端口是4444，如果想切换为其他端口，则加`-port`参数。比如要切换为8888：\n\n\tjava  -jar  selenium-server-standalone-2.27.0.jar -role hub  -port 8888\n\n启动Node（10.81.14.170）: \n\n\tjava -jar selenium-server-standalone-2.27.0.jar -role node -hub http://10.81.14.180:8888/grid/register\n同样的，也可以使用`-port`切换node端口，默认端口是5555.    \n此处的node节点，也可以作为一个单机的远程节点存在，并同时支持RC,WebDriver。浏览器输入<http://10.81.14.180:8877/wd/hub>可以看到session信息。\n\n然后，同样的启动10.81.14.180、10.81.14.190上的Node节点。\n\n打开浏览器<http://10.81.14.180:8888/grid/console>,可以看到如下的界面：   \n\n![](/images/blog/selenium-grid-console.png)    \n \n至此，Selenium Grid2已经配置成功了。\n\n###使用Grid运行Tests###\nSelenium Grid2是向后兼容的，同时支持RC,WebDriver。\n如果使用RC,即Selenium1，使用以下的方法：   \n\n\tSelenium selenium = new DefaultSelenium(“10.81.14.180”, 8888, “*firefox”, “http://www.baidu.com”);\n使用WebDriver的话，使用以下的方法：   \n\n\tDesiredCapabilities capability = DesiredCapabilities.firefox();\n\tWebDriver driver = new RemoteWebDriver(new URL(\"http://10.81.14.180:8888/wd/hub\"), capability);\n\n可以看出所有的请求都发给了Hub,然后由Hub分配给匹配的节点来执行。   \n那么，Hub是如何来分配的呢？往下看   \n###Node配置###\n默认，Node会启动11个浏览器实例:5 Firefox,5 Chrome, 1 Internet Explorer. 从Grid Console界面看出来，为什么每个机器上有22个实例呢？是这样的，Node为了同时支持RC与WebDriver两种协议，所以就是2＊11了。把鼠标放到各个浏览器图标上，就可以看出里面的配置区别了。  \n内容类似：   \n\n\t{\n          \"browserName\": \"*firefox\",\n          \"maxInstances\": 5,\n          \"seleniumProtocol\": \"Selenium\"\n        }\n或者\n\n\t {\n          \"browserName\": \"firefox\",\n          \"maxInstances\": 5,\n          \"seleniumProtocol\": \"WebDriver\"\n        }\n其中，seleniumProtocol就是定义的不同协议了。\n\n如何修改Driver配置呢？可以从启动参数里操作。   \n\n\t-browser browserName=firefox,version=3.6,maxInstances=5,platform=LINUX\n\n那Node默认启动的配置是什么呢？    \n由于如果从启动参数里，配置这个多东西，很难写的。因此，官方很人性化的提供了JSON文件来配置。也就是说默认启动的配置如下：   \n<http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json>   \n \n<http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json>    \n\n如果想自定义配置，直接对json文件修改，启动时，指定配置文件就可以了。   \n\n\tjava -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json \n\n仅仅就这样就行了？从博文<http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/>知道，浏览器的启动是要制定一些driver位置的，否则Node不知道怎么启动浏览器实例。因此需要进行指定：  \n\n\tjava -jar selenium-server-standalone-2.27.0.jar -port 8877 -role node -hub http://10.81.14.180:8888/grid/register  -nodeConfig nodeconfig.json -Dwebdriver.chrome.driver=\"E:/selenium/chromedriver.exe\" -Dwebdriver.ie.driver=\"E:/selenium/IEDriverServer.exe\"\n\n\n参考文档：  \n<http://code.google.com/p/selenium/wiki/Grid2>\n","slug":"2013-01-10-selenium-grid2-config","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop4z004ov8fy5u54knw8","content":"<p>###为什么要使用Selenium Grid ?###</p>\n<ul>\n<li>分布式运行大规模的Test</li>\n<li>能够通过一个中央点，很容易的运行不同OS上的不同browser</li>\n<li>最小化对Grid的维护时间，并能充分利用虚拟设备</li>\n</ul>\n<p>###Selenium Grid 部署与启动###<br>Hub :总控节点，连接调用Node。<br>Node: 负责执行Tests,调用浏览器。<br><a id=\"more\"></a><br>下面以selenium-server-standalone-2.27.0.jar版本为例：<br>使用这样3台机器：   </p>\n<ul>\n<li>10.81.14.170    </li>\n<li>10.81.14.180     </li>\n<li>10.81.14.190    </li>\n</ul>\n<p>启动Hub（10.81.14.180）:</p>\n<pre><code>java  -jar  selenium-server-standalone-2.27.0.jar -role hub \n</code></pre><p>在浏览器内打开：<a href=\"http://10.81.14.180:4444/grid/console\" target=\"_blank\" rel=\"external\">http://10.81.14.180:4444/grid/console</a>可以查看Hub状态。也就是说Grid默认启动端口是4444，如果想切换为其他端口，则加<code>-port</code>参数。比如要切换为8888：</p>\n<pre><code>java  -jar  selenium-server-standalone-2.27.0.jar -role hub  -port 8888\n</code></pre><p>启动Node（10.81.14.170）: </p>\n<pre><code>java -jar selenium-server-standalone-2.27.0.jar -role node -hub http://10.81.14.180:8888/grid/register\n</code></pre><p>同样的，也可以使用<code>-port</code>切换node端口，默认端口是5555.<br>此处的node节点，也可以作为一个单机的远程节点存在，并同时支持RC,WebDriver。浏览器输入<a href=\"http://10.81.14.180:8877/wd/hub\" target=\"_blank\" rel=\"external\">http://10.81.14.180:8877/wd/hub</a>可以看到session信息。</p>\n<p>然后，同样的启动10.81.14.180、10.81.14.190上的Node节点。</p>\n<p>打开浏览器<a href=\"http://10.81.14.180:8888/grid/console\" target=\"_blank\" rel=\"external\">http://10.81.14.180:8888/grid/console</a>,可以看到如下的界面：   </p>\n<p><img src=\"/images/blog/selenium-grid-console.png\" alt=\"\">    </p>\n<p>至此，Selenium Grid2已经配置成功了。</p>\n<p>###使用Grid运行Tests###<br>Selenium Grid2是向后兼容的，同时支持RC,WebDriver。<br>如果使用RC,即Selenium1，使用以下的方法：   </p>\n<pre><code>Selenium selenium = new DefaultSelenium(“10.81.14.180”, 8888, “*firefox”, “http://www.baidu.com”);\n</code></pre><p>使用WebDriver的话，使用以下的方法：   </p>\n<pre><code>DesiredCapabilities capability = DesiredCapabilities.firefox();\nWebDriver driver = new RemoteWebDriver(new URL(&quot;http://10.81.14.180:8888/wd/hub&quot;), capability);\n</code></pre><p>可以看出所有的请求都发给了Hub,然后由Hub分配给匹配的节点来执行。<br>那么，Hub是如何来分配的呢？往下看   </p>\n<p>###Node配置###<br>默认，Node会启动11个浏览器实例:5 Firefox,5 Chrome, 1 Internet Explorer. 从Grid Console界面看出来，为什么每个机器上有22个实例呢？是这样的，Node为了同时支持RC与WebDriver两种协议，所以就是2＊11了。把鼠标放到各个浏览器图标上，就可以看出里面的配置区别了。<br>内容类似：   </p>\n<pre><code>{\n      &quot;browserName&quot;: &quot;*firefox&quot;,\n      &quot;maxInstances&quot;: 5,\n      &quot;seleniumProtocol&quot;: &quot;Selenium&quot;\n    }\n</code></pre><p>或者</p>\n<pre><code>{\n     &quot;browserName&quot;: &quot;firefox&quot;,\n     &quot;maxInstances&quot;: 5,\n     &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;\n   }\n</code></pre><p>其中，seleniumProtocol就是定义的不同协议了。</p>\n<p>如何修改Driver配置呢？可以从启动参数里操作。   </p>\n<pre><code>-browser browserName=firefox,version=3.6,maxInstances=5,platform=LINUX\n</code></pre><p>那Node默认启动的配置是什么呢？<br>由于如果从启动参数里，配置这个多东西，很难写的。因此，官方很人性化的提供了JSON文件来配置。也就是说默认启动的配置如下：<br><a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json</a>   </p>\n<p><a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json</a>    </p>\n<p>如果想自定义配置，直接对json文件修改，启动时，指定配置文件就可以了。   </p>\n<pre><code>java -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json \n</code></pre><p>仅仅就这样就行了？从博文<a href=\"http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/\">http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/</a>知道，浏览器的启动是要制定一些driver位置的，否则Node不知道怎么启动浏览器实例。因此需要进行指定：  </p>\n<pre><code>java -jar selenium-server-standalone-2.27.0.jar -port 8877 -role node -hub http://10.81.14.180:8888/grid/register  -nodeConfig nodeconfig.json -Dwebdriver.chrome.driver=&quot;E:/selenium/chromedriver.exe&quot; -Dwebdriver.ie.driver=&quot;E:/selenium/IEDriverServer.exe&quot;\n</code></pre><p>参考文档：<br><a href=\"http://code.google.com/p/selenium/wiki/Grid2\" target=\"_blank\" rel=\"external\">http://code.google.com/p/selenium/wiki/Grid2</a></p>\n","excerpt":"<p>###为什么要使用Selenium Grid ?###</p>\n<ul>\n<li>分布式运行大规模的Test</li>\n<li>能够通过一个中央点，很容易的运行不同OS上的不同browser</li>\n<li>最小化对Grid的维护时间，并能充分利用虚拟设备</li>\n</ul>\n<p>###Selenium Grid 部署与启动###<br>Hub :总控节点，连接调用Node。<br>Node: 负责执行Tests,调用浏览器。<br>","more":"<br>下面以selenium-server-standalone-2.27.0.jar版本为例：<br>使用这样3台机器：   </p>\n<ul>\n<li>10.81.14.170    </li>\n<li>10.81.14.180     </li>\n<li>10.81.14.190    </li>\n</ul>\n<p>启动Hub（10.81.14.180）:</p>\n<pre><code>java  -jar  selenium-server-standalone-2.27.0.jar -role hub \n</code></pre><p>在浏览器内打开：<a href=\"http://10.81.14.180:4444/grid/console\">http://10.81.14.180:4444/grid/console</a>可以查看Hub状态。也就是说Grid默认启动端口是4444，如果想切换为其他端口，则加<code>-port</code>参数。比如要切换为8888：</p>\n<pre><code>java  -jar  selenium-server-standalone-2.27.0.jar -role hub  -port 8888\n</code></pre><p>启动Node（10.81.14.170）: </p>\n<pre><code>java -jar selenium-server-standalone-2.27.0.jar -role node -hub http://10.81.14.180:8888/grid/register\n</code></pre><p>同样的，也可以使用<code>-port</code>切换node端口，默认端口是5555.<br>此处的node节点，也可以作为一个单机的远程节点存在，并同时支持RC,WebDriver。浏览器输入<a href=\"http://10.81.14.180:8877/wd/hub\">http://10.81.14.180:8877/wd/hub</a>可以看到session信息。</p>\n<p>然后，同样的启动10.81.14.180、10.81.14.190上的Node节点。</p>\n<p>打开浏览器<a href=\"http://10.81.14.180:8888/grid/console\">http://10.81.14.180:8888/grid/console</a>,可以看到如下的界面：   </p>\n<p><img src=\"/images/blog/selenium-grid-console.png\" alt=\"\">    </p>\n<p>至此，Selenium Grid2已经配置成功了。</p>\n<p>###使用Grid运行Tests###<br>Selenium Grid2是向后兼容的，同时支持RC,WebDriver。<br>如果使用RC,即Selenium1，使用以下的方法：   </p>\n<pre><code>Selenium selenium = new DefaultSelenium(“10.81.14.180”, 8888, “*firefox”, “http://www.baidu.com”);\n</code></pre><p>使用WebDriver的话，使用以下的方法：   </p>\n<pre><code>DesiredCapabilities capability = DesiredCapabilities.firefox();\nWebDriver driver = new RemoteWebDriver(new URL(&quot;http://10.81.14.180:8888/wd/hub&quot;), capability);\n</code></pre><p>可以看出所有的请求都发给了Hub,然后由Hub分配给匹配的节点来执行。<br>那么，Hub是如何来分配的呢？往下看   </p>\n<p>###Node配置###<br>默认，Node会启动11个浏览器实例:5 Firefox,5 Chrome, 1 Internet Explorer. 从Grid Console界面看出来，为什么每个机器上有22个实例呢？是这样的，Node为了同时支持RC与WebDriver两种协议，所以就是2＊11了。把鼠标放到各个浏览器图标上，就可以看出里面的配置区别了。<br>内容类似：   </p>\n<pre><code>{\n      &quot;browserName&quot;: &quot;*firefox&quot;,\n      &quot;maxInstances&quot;: 5,\n      &quot;seleniumProtocol&quot;: &quot;Selenium&quot;\n    }\n</code></pre><p>或者</p>\n<pre><code>{\n     &quot;browserName&quot;: &quot;firefox&quot;,\n     &quot;maxInstances&quot;: 5,\n     &quot;seleniumProtocol&quot;: &quot;WebDriver&quot;\n   }\n</code></pre><p>其中，seleniumProtocol就是定义的不同协议了。</p>\n<p>如何修改Driver配置呢？可以从启动参数里操作。   </p>\n<pre><code>-browser browserName=firefox,version=3.6,maxInstances=5,platform=LINUX\n</code></pre><p>那Node默认启动的配置是什么呢？<br>由于如果从启动参数里，配置这个多东西，很难写的。因此，官方很人性化的提供了JSON文件来配置。也就是说默认启动的配置如下：<br><a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json\">http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultNode.json</a>   </p>\n<p><a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json\">http://code.google.com/p/selenium/source/browse/trunk/java/server/src/org/openqa/grid/common/defaults/DefaultHub.json</a>    </p>\n<p>如果想自定义配置，直接对json文件修改，启动时，指定配置文件就可以了。   </p>\n<pre><code>java -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json \n</code></pre><p>仅仅就这样就行了？从博文<a href=\"http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/\">http://www.shenyanchao.cn/blog/2012/10/12/selenium-multiple-browser-support/</a>知道，浏览器的启动是要制定一些driver位置的，否则Node不知道怎么启动浏览器实例。因此需要进行指定：  </p>\n<pre><code>java -jar selenium-server-standalone-2.27.0.jar -port 8877 -role node -hub http://10.81.14.180:8888/grid/register  -nodeConfig nodeconfig.json -Dwebdriver.chrome.driver=&quot;E:/selenium/chromedriver.exe&quot; -Dwebdriver.ie.driver=&quot;E:/selenium/IEDriverServer.exe&quot;\n</code></pre><p>参考文档：<br><a href=\"http://code.google.com/p/selenium/wiki/Grid2\">http://code.google.com/p/selenium/wiki/Grid2</a></p>"},{"layout":"post","title":"《Node.js开发指南》读书笔记","date":"2013-03-11T08:53:00.000Z","comments":1,"_content":"###书籍信息##\nAmazon: [NodeJS开发指南](http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I)\n\nPDF: [免费下载](http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf)\n\n###NodeJS简介###\n是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。  \n由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。\nCommonJS规范包括：  \n\n* 模块（modules）\n* 包（packages）\n* 系统（system）\n* 二进制（binary）\n* 控制台（console）\n* 编码（encodings）\n* 文件系统（filesystems）\n* 套接字（sockets）\n* 单元测试（unit testing）\n<!--more-->\n###NodeJS的模块与包###\n模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。\n####1.什么是模块？\n\n\tvar http = require(\"http\");\n其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。\n\n####2.创建与发布模块\nNodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。\n如创建一个module.js:   \n\n\tvar name;\n\texports.setName=function(thyName){\n\t     name=thyName;\n         }\n         exports.sayHello = function(){\n\t    console.log('Hello '+name);\n\t}\n在同一个目录下，再创建一个getmodule.js: \n\n\tvar mymodule = require('./module');\n\tmyModule.setName('shenyanchao');\n\tmyModule.sayHello();\n运行后的结果：\n\n\tHello shenyanchao\n这就是一个简单的模块发布与调用关系。   \n####3.包（package）\n包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。  \n直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征： \n\n* package.json在包的顶层目录下；\n* 二进制可执行文件在bin目录下；\n* JS代码在lib目录下；\n* 文档在doc目录下；\n* 单元测试在test下；\n这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。  \n\n模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:\n\n\texports.hello = function() {\n\t   console.log('Hello.');\n\t};\n然后在 somepackage 之外建立 getpackage.js,内容如下:   \n\n\tvar somePackage = require('./somepackage');\n\tsomePackage.hello();\n\n运行 node getpackage.js,控制台将输出结果 Hello。   \n我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。   \n**package.json**\n在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:  \n\n\t{\n\t    \"main\" : \"./lib/interface.js\"\n\t}\n然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。   \nNodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。  \npackage.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。   \nname:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。   \ndescription:包的简要说明。   \nversion:符合语义化版本识别 规范的版本字符串。  \nkeywords:关键字数组,通常用于搜索。   \nmaintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。  \ncontributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。   \nbugs:提交bug的地址,可以是网址或者电子邮件地址。   \nlicenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。   \nrepositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。   \n下面是mocha的package.json:  \n\t\n\t{\n \t \"name\": \"mocha\",\n \t \"version\": \"1.8.1\",\n  \t\"description\": \"simple, flexible, fun test framework\",\n \t \"keywords\": [\n   \t \"mocha\",\n    \t\"test\",\n   \t \"bdd\",\n   \t \"tdd\",\n   \t \"tap\"\n  \t],\n \t \"author\": {\n   \t \"name\": \"TJ Holowaychuk\",\n    \t\"email\": \"tj@vision-media.ca\"\n \t },\n  \t\"repository\": {\n    \t\"type\": \"git\",\n    \t\"url\": \"git://github.com/visionmedia/mocha.git\"\n \t },\n  \t\"main\": \"./index\",\n  \t\"bin\": {\n    \t\"mocha\": \"./bin/mocha\",\n    \t\"_mocha\": \"./bin/_mocha\"\n  \t},\n  \t\"engines\": {\n    \t\"node\": \">= 0.4.x\"\n  \t},\n  \t\"scripts\": {\n    \t\"test\": \"make test-all\"\n \t },\n  \t\"dependencies\": {\n    \t\"commander\": \"0.6.1\",\n    \t\"growl\": \"1.7.x\",\n    \t\"jade\": \"0.26.3\",\n    \t\"diff\": \"1.0.2\",\n    \t\"debug\": \"*\",\n    \t\"mkdirp\": \"0.3.3\",\n    \t\"ms\": \"0.3.0\"\n  \t},\n  \t\"devDependencies\": {\n   \t \"should\": \"*\",\n    \t\"coffee-script\": \"1.2\"\n \t },\n  \t\"readme\": \"...\"\n\t}\n也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。   \n如执行：  \n\n\tnpm install -g mocha\n那么，npm将会依据json提供的信息来进行管理。\n####4.npm的本地模式与全局模式\nnpm默认会从http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。  \n\n###模块（modules）的加载机制\n前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。  \n那么，文件模块是如何加载的呢？\n####按路径加载模块####\n1.如果require按“/”开头，那就是绝对路径进行加载。如require('/home/shenyanchao/module'),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。   \n2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。  \n3.对于核心模块,比如require('http')，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？   \n如果，使用require('mymodule'),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。   \n例如： 我们在/home/shenyanchao/develop/app.js中使用require('mymodule')，NodeJS的查找路径如下：  \n\n* /home/shenyanchao/develop/node_modules/mymodule.js\n* /home/shenyanchao/node_modules/mymodule.js\n* /home/node_modules/mymodule.js\n* /node_modules/mymodule.js\n\n这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式`npm install mocha`的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require('mocha')时，能够直接使用。而`npm install -g mocha`相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。\n\n###express: JS的MVC框架###\n这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。   \nexpress将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！    \nexpress主页：<http://expressjs.com/>\n\n\t","source":"_posts/2013-03-11-node-dot-js-develop-guide-reading-note.markdown","raw":"---\nlayout: post\ntitle: \"《Node.js开发指南》读书笔记\"\ndate: 2013-03-11 16:53\ncomments: true\ncategories: javascript\ntags: [ NodeJS, express, 读书笔记 ]\n---\n###书籍信息##\nAmazon: [NodeJS开发指南](http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I)\n\nPDF: [免费下载](http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf)\n\n###NodeJS简介###\n是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。  \n由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。\nCommonJS规范包括：  \n\n* 模块（modules）\n* 包（packages）\n* 系统（system）\n* 二进制（binary）\n* 控制台（console）\n* 编码（encodings）\n* 文件系统（filesystems）\n* 套接字（sockets）\n* 单元测试（unit testing）\n<!--more-->\n###NodeJS的模块与包###\n模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。\n####1.什么是模块？\n\n\tvar http = require(\"http\");\n其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。\n\n####2.创建与发布模块\nNodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。\n如创建一个module.js:   \n\n\tvar name;\n\texports.setName=function(thyName){\n\t     name=thyName;\n         }\n         exports.sayHello = function(){\n\t    console.log('Hello '+name);\n\t}\n在同一个目录下，再创建一个getmodule.js: \n\n\tvar mymodule = require('./module');\n\tmyModule.setName('shenyanchao');\n\tmyModule.sayHello();\n运行后的结果：\n\n\tHello shenyanchao\n这就是一个简单的模块发布与调用关系。   \n####3.包（package）\n包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。  \n直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征： \n\n* package.json在包的顶层目录下；\n* 二进制可执行文件在bin目录下；\n* JS代码在lib目录下；\n* 文档在doc目录下；\n* 单元测试在test下；\n这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。  \n\n模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:\n\n\texports.hello = function() {\n\t   console.log('Hello.');\n\t};\n然后在 somepackage 之外建立 getpackage.js,内容如下:   \n\n\tvar somePackage = require('./somepackage');\n\tsomePackage.hello();\n\n运行 node getpackage.js,控制台将输出结果 Hello。   \n我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。   \n**package.json**\n在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:  \n\n\t{\n\t    \"main\" : \"./lib/interface.js\"\n\t}\n然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。   \nNodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。  \npackage.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。   \nname:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。   \ndescription:包的简要说明。   \nversion:符合语义化版本识别 规范的版本字符串。  \nkeywords:关键字数组,通常用于搜索。   \nmaintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。  \ncontributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。   \nbugs:提交bug的地址,可以是网址或者电子邮件地址。   \nlicenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。   \nrepositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。   \n下面是mocha的package.json:  \n\t\n\t{\n \t \"name\": \"mocha\",\n \t \"version\": \"1.8.1\",\n  \t\"description\": \"simple, flexible, fun test framework\",\n \t \"keywords\": [\n   \t \"mocha\",\n    \t\"test\",\n   \t \"bdd\",\n   \t \"tdd\",\n   \t \"tap\"\n  \t],\n \t \"author\": {\n   \t \"name\": \"TJ Holowaychuk\",\n    \t\"email\": \"tj@vision-media.ca\"\n \t },\n  \t\"repository\": {\n    \t\"type\": \"git\",\n    \t\"url\": \"git://github.com/visionmedia/mocha.git\"\n \t },\n  \t\"main\": \"./index\",\n  \t\"bin\": {\n    \t\"mocha\": \"./bin/mocha\",\n    \t\"_mocha\": \"./bin/_mocha\"\n  \t},\n  \t\"engines\": {\n    \t\"node\": \">= 0.4.x\"\n  \t},\n  \t\"scripts\": {\n    \t\"test\": \"make test-all\"\n \t },\n  \t\"dependencies\": {\n    \t\"commander\": \"0.6.1\",\n    \t\"growl\": \"1.7.x\",\n    \t\"jade\": \"0.26.3\",\n    \t\"diff\": \"1.0.2\",\n    \t\"debug\": \"*\",\n    \t\"mkdirp\": \"0.3.3\",\n    \t\"ms\": \"0.3.0\"\n  \t},\n  \t\"devDependencies\": {\n   \t \"should\": \"*\",\n    \t\"coffee-script\": \"1.2\"\n \t },\n  \t\"readme\": \"...\"\n\t}\n也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。   \n如执行：  \n\n\tnpm install -g mocha\n那么，npm将会依据json提供的信息来进行管理。\n####4.npm的本地模式与全局模式\nnpm默认会从http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。  \n\n###模块（modules）的加载机制\n前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。  \n那么，文件模块是如何加载的呢？\n####按路径加载模块####\n1.如果require按“/”开头，那就是绝对路径进行加载。如require('/home/shenyanchao/module'),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。   \n2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。  \n3.对于核心模块,比如require('http')，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？   \n如果，使用require('mymodule'),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。   \n例如： 我们在/home/shenyanchao/develop/app.js中使用require('mymodule')，NodeJS的查找路径如下：  \n\n* /home/shenyanchao/develop/node_modules/mymodule.js\n* /home/shenyanchao/node_modules/mymodule.js\n* /home/node_modules/mymodule.js\n* /node_modules/mymodule.js\n\n这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式`npm install mocha`的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require('mocha')时，能够直接使用。而`npm install -g mocha`相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。\n\n###express: JS的MVC框架###\n这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。   \nexpress将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！    \nexpress主页：<http://expressjs.com/>\n\n\t","slug":"2013-03-11-node-dot-js-develop-guide-reading-note","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop51004sv8fycp8hzxs2","content":"<p>###书籍信息##<br>Amazon: <a href=\"http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I\" target=\"_blank\" rel=\"external\">NodeJS开发指南</a></p>\n<p>PDF: <a href=\"http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf\" target=\"_blank\" rel=\"external\">免费下载</a></p>\n<p>###NodeJS简介###<br>是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。<br>由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。<br>CommonJS规范包括：  </p>\n<ul>\n<li>模块（modules）</li>\n<li>包（packages）</li>\n<li>系统（system）</li>\n<li>二进制（binary）</li>\n<li>控制台（console）</li>\n<li>编码（encodings）</li>\n<li>文件系统（filesystems）</li>\n<li>套接字（sockets）</li>\n<li><p>单元测试（unit testing）</p>\n<a id=\"more\"></a>\n<p>###NodeJS的模块与包###<br>模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。<br>####1.什么是模块？</p>\n<p>  var http = require(“http”);<br>其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。</p>\n</li>\n</ul>\n<p>####2.创建与发布模块<br>NodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。<br>如创建一个module.js:   </p>\n<pre><code>var name;\nexports.setName=function(thyName){\n     name=thyName;\n     }\n     exports.sayHello = function(){\n    console.log(&apos;Hello &apos;+name);\n}\n</code></pre><p>在同一个目录下，再创建一个getmodule.js: </p>\n<pre><code>var mymodule = require(&apos;./module&apos;);\nmyModule.setName(&apos;shenyanchao&apos;);\nmyModule.sayHello();\n</code></pre><p>运行后的结果：</p>\n<pre><code>Hello shenyanchao\n</code></pre><p>这就是一个简单的模块发布与调用关系。   </p>\n<p>####3.包（package）<br>包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。<br>直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征： </p>\n<ul>\n<li>package.json在包的顶层目录下；</li>\n<li>二进制可执行文件在bin目录下；</li>\n<li>JS代码在lib目录下；</li>\n<li>文档在doc目录下；</li>\n<li>单元测试在test下；<br>这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。  </li>\n</ul>\n<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:</p>\n<pre><code>exports.hello = function() {\n   console.log(&apos;Hello.&apos;);\n};\n</code></pre><p>然后在 somepackage 之外建立 getpackage.js,内容如下:   </p>\n<pre><code>var somePackage = require(&apos;./somepackage&apos;);\nsomePackage.hello();\n</code></pre><p>运行 node getpackage.js,控制台将输出结果 Hello。<br>我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。<br><strong>package.json</strong><br>在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:  </p>\n<pre><code>{\n    &quot;main&quot; : &quot;./lib/interface.js&quot;\n}\n</code></pre><p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。<br>NodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。<br>package.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。<br>name:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。<br>description:包的简要说明。<br>version:符合语义化版本识别 规范的版本字符串。<br>keywords:关键字数组,通常用于搜索。<br>maintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。<br>contributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。<br>bugs:提交bug的地址,可以是网址或者电子邮件地址。<br>licenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。<br>repositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。<br>下面是mocha的package.json:  </p>\n<pre><code>{\n  &quot;name&quot;: &quot;mocha&quot;,\n  &quot;version&quot;: &quot;1.8.1&quot;,\n  &quot;description&quot;: &quot;simple, flexible, fun test framework&quot;,\n  &quot;keywords&quot;: [\n    &quot;mocha&quot;,\n    &quot;test&quot;,\n    &quot;bdd&quot;,\n    &quot;tdd&quot;,\n    &quot;tap&quot;\n  ],\n  &quot;author&quot;: {\n    &quot;name&quot;: &quot;TJ Holowaychuk&quot;,\n    &quot;email&quot;: &quot;tj@vision-media.ca&quot;\n  },\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;git://github.com/visionmedia/mocha.git&quot;\n  },\n  &quot;main&quot;: &quot;./index&quot;,\n  &quot;bin&quot;: {\n    &quot;mocha&quot;: &quot;./bin/mocha&quot;,\n    &quot;_mocha&quot;: &quot;./bin/_mocha&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;= 0.4.x&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;make test-all&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;commander&quot;: &quot;0.6.1&quot;,\n    &quot;growl&quot;: &quot;1.7.x&quot;,\n    &quot;jade&quot;: &quot;0.26.3&quot;,\n    &quot;diff&quot;: &quot;1.0.2&quot;,\n    &quot;debug&quot;: &quot;*&quot;,\n    &quot;mkdirp&quot;: &quot;0.3.3&quot;,\n    &quot;ms&quot;: &quot;0.3.0&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;should&quot;: &quot;*&quot;,\n    &quot;coffee-script&quot;: &quot;1.2&quot;\n  },\n  &quot;readme&quot;: &quot;...&quot;\n}\n</code></pre><p>也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。<br>如执行：  </p>\n<pre><code>npm install -g mocha\n</code></pre><p>那么，npm将会依据json提供的信息来进行管理。</p>\n<p>####4.npm的本地模式与全局模式<br>npm默认会从<a href=\"http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。\" target=\"_blank\" rel=\"external\">http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。</a>  </p>\n<p>###模块（modules）的加载机制<br>前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。<br>那么，文件模块是如何加载的呢？</p>\n<p>####按路径加载模块####<br>1.如果require按“/”开头，那就是绝对路径进行加载。如require(‘/home/shenyanchao/module’),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。<br>2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。<br>3.对于核心模块,比如require(‘http’)，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？<br>如果，使用require(‘mymodule’),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。<br>例如： 我们在/home/shenyanchao/develop/app.js中使用require(‘mymodule’)，NodeJS的查找路径如下：  </p>\n<ul>\n<li>/home/shenyanchao/develop/node_modules/mymodule.js</li>\n<li>/home/shenyanchao/node_modules/mymodule.js</li>\n<li>/home/node_modules/mymodule.js</li>\n<li>/node_modules/mymodule.js</li>\n</ul>\n<p>这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式<code>npm install mocha</code>的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require(‘mocha’)时，能够直接使用。而<code>npm install -g mocha</code>相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。</p>\n<p>###express: JS的MVC框架###<br>这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。<br>express将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！<br>express主页：<a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"external\">http://expressjs.com/</a></p>\n","excerpt":"<p>###书籍信息##<br>Amazon: <a href=\"http://www.amazon.cn/Node-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E9%83%AD%E5%AE%B6%E5%AE%9D/dp/B008HN793I\">NodeJS开发指南</a></p>\n<p>PDF: <a href=\"http://azrael.ihorsley.com/wordpress/wp-content/uploads/2012/11/Node.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_%E4%B8%AD%E6%96%87%E6%AD%A3%E7%89%88.pdf\">免费下载</a></p>\n<p>###NodeJS简介###<br>是NodeJS的出现，让JavaScript在服务器端得以使用，重新焕发了生机。而不仅仅像大家所认为的，只是一个客户端脚本语言。<br>由于JavaScript自身的脚本语言特性，造成开发混乱，难以维护。CommonJS对这个进行了规范。像NodeJS,ringojs都是对这一规范的具体实现。<br>CommonJS规范包括：  </p>\n<ul>\n<li>模块（modules）</li>\n<li>包（packages）</li>\n<li>系统（system）</li>\n<li>二进制（binary）</li>\n<li>控制台（console）</li>\n<li>编码（encodings）</li>\n<li>文件系统（filesystems）</li>\n<li>套接字（sockets）</li>\n<li><p>单元测试（unit testing）</p>","more":"<p>###NodeJS的模块与包###<br>模块（module）和包(package)是NodeJS的基本。并且都是参照CommonJS标准来实现的。如果项目有一定的规模，势必要把各种功能模块进行切分，然后再组装起来。这也正式所有服务器端的通用做法。然而，在NodeJS中怎么实现模块之间的调用呢，这里是使用require函数的。模块和包通常区分不是很明确，可以认为是一致的。<br>####1.什么是模块？</p>\n<p>  var http = require(“http”);<br>其中http就是nodeJs中的一个核心模块. 像Java中的import一样，这里是使用require来引入这个模块。</p>\n</li>\n</ul>\n<p>####2.创建与发布模块<br>NodeJS提供了exports和require两个对象来完成，exports用于公开模块的接口，require用于获取外部模块的接口。<br>如创建一个module.js:   </p>\n<pre><code>var name;\nexports.setName=function(thyName){\n     name=thyName;\n     }\n     exports.sayHello = function(){\n    console.log(&apos;Hello &apos;+name);\n}\n</code></pre><p>在同一个目录下，再创建一个getmodule.js: </p>\n<pre><code>var mymodule = require(&apos;./module&apos;);\nmyModule.setName(&apos;shenyanchao&apos;);\nmyModule.sayHello();\n</code></pre><p>运行后的结果：</p>\n<pre><code>Hello shenyanchao\n</code></pre><p>这就是一个简单的模块发布与调用关系。   </p>\n<p>####3.包（package）<br>包是对模块的更进一步的抽象。类似与Java的类库概念。当包便多，甚至依赖很复杂的时候，就需要一个管理工具，就像是Java的Maven用来管理Jar包一样。NodeJs用NPM（Node Packages Manager）来发布、更新、依赖管理和版本控制。<br>直观上看，NodeJS的包是一个目录，并且包含一个package.json文件。一个符合CommonJS的包应有以下的特征： </p>\n<ul>\n<li>package.json在包的顶层目录下；</li>\n<li>二进制可执行文件在bin目录下；</li>\n<li>JS代码在lib目录下；</li>\n<li>文档在doc目录下；</li>\n<li>单元测试在test下；<br>这就相当于对包的目录结构进行了一个定义，类似于J2EE的规范一样，减少大家的学习成本，什么东西放在哪儿都一清二楚。如果在github或者googlecode上看开源项目，绝对都是这样的结构。  </li>\n</ul>\n<p>模块与文件是一一对应的。文件不仅可以是 JavaScript 代码或二进制代码,还可以是一个文件夹。最简单的包,就是一个作为文件夹的模块。建立一个叫做 somepackage 的文件夹,在其中创建 index.js,内容如下:</p>\n<pre><code>exports.hello = function() {\n   console.log(&apos;Hello.&apos;);\n};\n</code></pre><p>然后在 somepackage 之外建立 getpackage.js,内容如下:   </p>\n<pre><code>var somePackage = require(&apos;./somepackage&apos;);\nsomePackage.hello();\n</code></pre><p>运行 node getpackage.js,控制台将输出结果 Hello。<br>我们使用这种方法可以把文件夹封装为一个模块,即所谓的包。包通常是一些模块的集合,在模块的基础上提供了更高层的抽象,相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。<br><strong>package.json</strong><br>在somepackage 文件夹下,我们创建一个叫做 package.json 的文件,内容如下所示:  </p>\n<pre><code>{\n    &quot;main&quot; : &quot;./lib/interface.js&quot;\n}\n</code></pre><p>然后将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包,依然可以正常使用。<br>NodeJS在调用某个包时,会首先检查包中 package.json 文件的 main 字段,将其作为包的接口模块,如package.json 或 main 字段不存在,会尝试寻找 index.js 或 index.node 作为包的接口。<br>package.json 是 CommonJS 规定的用来描述包的文件,完全符合规范的 package.json 文件应该含有以下字段。<br>name:包的名称,必须是唯一的,由小写英文字母、数字和下划线组成,不能包含空格。<br>description:包的简要说明。<br>version:符合语义化版本识别 规范的版本字符串。<br>keywords:关键字数组,通常用于搜索。<br>maintainers:维护者数组,每个元素要包含 name、email (可选) web (可选)字段。<br>contributors:贡献者数组,格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。<br>bugs:提交bug的地址,可以是网址或者电子邮件地址。<br>licenses:许可证数组,每个元素要包含 type (许可证的名称)和 url (链接到许可证文本的地址)字段。<br>repositories:仓库托管地址数组,每个元素要包含 type(仓库的类型, git )如url (仓库的地址)和 path (相对于仓库的路径,可选)字段。<br>下面是mocha的package.json:  </p>\n<pre><code>{\n  &quot;name&quot;: &quot;mocha&quot;,\n  &quot;version&quot;: &quot;1.8.1&quot;,\n  &quot;description&quot;: &quot;simple, flexible, fun test framework&quot;,\n  &quot;keywords&quot;: [\n    &quot;mocha&quot;,\n    &quot;test&quot;,\n    &quot;bdd&quot;,\n    &quot;tdd&quot;,\n    &quot;tap&quot;\n  ],\n  &quot;author&quot;: {\n    &quot;name&quot;: &quot;TJ Holowaychuk&quot;,\n    &quot;email&quot;: &quot;tj@vision-media.ca&quot;\n  },\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;git://github.com/visionmedia/mocha.git&quot;\n  },\n  &quot;main&quot;: &quot;./index&quot;,\n  &quot;bin&quot;: {\n    &quot;mocha&quot;: &quot;./bin/mocha&quot;,\n    &quot;_mocha&quot;: &quot;./bin/_mocha&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;= 0.4.x&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;make test-all&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;commander&quot;: &quot;0.6.1&quot;,\n    &quot;growl&quot;: &quot;1.7.x&quot;,\n    &quot;jade&quot;: &quot;0.26.3&quot;,\n    &quot;diff&quot;: &quot;1.0.2&quot;,\n    &quot;debug&quot;: &quot;*&quot;,\n    &quot;mkdirp&quot;: &quot;0.3.3&quot;,\n    &quot;ms&quot;: &quot;0.3.0&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;should&quot;: &quot;*&quot;,\n    &quot;coffee-script&quot;: &quot;1.2&quot;\n  },\n  &quot;readme&quot;: &quot;...&quot;\n}\n</code></pre><p>也就是说，这里面提供了完善的信息来告诉npm，怎么样安装、升级、传播。<br>如执行：  </p>\n<pre><code>npm install -g mocha\n</code></pre><p>那么，npm将会依据json提供的信息来进行管理。</p>\n<p>####4.npm的本地模式与全局模式<br>npm默认会从<a href=\"http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。\">http://npmjs.org上搜索并下载包，并将包安装在当前目录的node_modules子目录下。这种就称为本地模式。也就意味着只能在当前目录使用。如果想在全部地方可用，那就用`-g`参数。这样包就会安装到NODE_PATH里了，在任何目录都可以使用了。g应该就是global的缩写，很容易记。</a>  </p>\n<p>###模块（modules）的加载机制<br>前面，已经知道模块加载是通过require来进行的。NodeJS的模块可以分为2大类，一类是核心模块、一类是文件模块。核心模块有最高的优先级，如有模块命名冲突，NodeJS总是优先加载核心模块。<br>那么，文件模块是如何加载的呢？</p>\n<p>####按路径加载模块####<br>1.如果require按“/”开头，那就是绝对路径进行加载。如require(‘/home/shenyanchao/module’),将会按照以下优先级尝试加载 /home/shenyanchao/module.js、/home/shenyanchao/module.json、/home/shenyanchao/module.node。<br>2.如果require按“./”或者“../”开头，则是依相对路径来查找模块，这种较为常见。<br>3.对于核心模块,比如require(‘http’)，nodeJS是怎么找到的呢，自然是通过NODE_PATH目录加载的。那么对于文件模块，如果不用绝对路径已经相对路径，那么该如何查找呢？<br>如果，使用require(‘mymodule’),那么NodeJS将首先在当前目录的node_modules目录内进行尝试加载。如果没有找到，那么将会到当前目录的上一级目录的node_modules继续查找，并反复执行，直到根目录为止。<br>例如： 我们在/home/shenyanchao/develop/app.js中使用require(‘mymodule’)，NodeJS的查找路径如下：  </p>\n<ul>\n<li>/home/shenyanchao/develop/node_modules/mymodule.js</li>\n<li>/home/shenyanchao/node_modules/mymodule.js</li>\n<li>/home/node_modules/mymodule.js</li>\n<li>/node_modules/mymodule.js</li>\n</ul>\n<p>这个时候，明白了加载机制，就可以返回来，看一下模块的本地模式于全局模式来。当以本地模式<code>npm install mocha</code>的时候，会在当前目录建立一个node_modules目录，这就保证了系统内使用require(‘mocha’)时，能够直接使用。而<code>npm install -g mocha</code>相当于把mocha安装到NODE_PATH，这样就使用类似于加载核心模块的形式进行加载了。</p>\n<p>###express: JS的MVC框架###<br>这里介绍来一个强大的Web application Framework for Node。用于进行WEB项目的开发。类似于Java的SpringFramework。很轻量级，简单易用。<br>express将NodeJS的开发，推向了一个新的高度。很有兴趣，待研究！<br>express主页：<a href=\"http://expressjs.com/\">http://expressjs.com/</a></p>"},{"layout":"post","title":"Mocha简介","date":"2013-03-18T12:44:00.000Z","comments":1,"_content":"##Mocha##\nMocha作为一种咖啡名，应该是广为人知的，中文翻译为**摩卡**。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。  \nMocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。   \n项目主页：<http://visionmedia.github.com/mocha/>    \n##安装##\n\tnpm install -g mocha\n\n##一个简单的样例##\n\n\t$ mkdir test\n\t$ cd ..\n\t$ mocha test/test.js\n\n\tvar assert = require(\"assert\")\n\tdescribe('Array', function(){\n  \tdescribe('#indexOf()', function(){\n    \tit('should return -1 when the value is not present', function(){\n      \tassert.equal(-1, [1,2,3].indexOf(5));\n      \tassert.equal(-1, [1,2,3].indexOf(0));\n    \t})\n  \t})\n\t})\n\n\t$  mocha\n\n \t .\n\n \t ✔ 1 test complete (1ms)\n<!--more-->\n##Assertions##\n在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。\n\n* [should.js](http://github.com/visionmedia/should.js)\n* [expect.js](https://github.com/LearnBoost/expect.js)\n* [chai](http://chaijs.com/)\n* [better-assert](https://github.com/visionmedia/better-assert)\n\n##测试同步代码##\n\n\tdescribe('Array', function(){\n  \tdescribe('#indexOf()', function(){\n    \tit('should return -1 when the value is not present', function(){\n      \t[1,2,3].indexOf(5).should.equal(-1);\n      \t[1,2,3].indexOf(0).should.equal(-1);\n    \t})\n  \t})\n\t})\n##测试异步代码##\n添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。\n\n\tdescribe('User', function(){\n  \tdescribe('#save()', function(){\n    \tit('should save without error', function(done){\n      \tvar user = new User('Luna');\n      \tuser.save(done);\n    \t})\n  \t})\n\t})\n\n##类似与JUNIT的函数\n\n* before : 在所有测试执行之前\n* after ： 在所有测试执行之后\n* beforeEach ： 每个测试之前\n* afterEach ：每个测试之后\n\n##mocha指令##\n\n\tUsage: mocha [debug] [options] [files]\n\n\tCommands:\n\n  \tinit <path>\n  \tinitialize a client-side mocha setup at <path>\n\n\tOptions:\n\n  \t-h, --help                      帮助信息\n  \t-V, --version                   版本信息\n  \t-r, --require <name>            依赖的module\n  \t-R, --reporter <name>           使用的报告模式\n  \t-u, --ui <name>                 用什么接口(bdd|tdd|exports)\n  \t-g, --grep <pattern>            执行匹配 <pattern>的测试\n  \t-i, --invert                    --grep 相反的测试\n  \t-t, --timeout <ms>              超时毫秒数 [2000]\n  \t-s, --slow <ms>                 \"slow\" 测试的门槛 [75]\n  \t-w, --watch                     查看文件的变化，如true,则变化后自动运行。\n  \t-c, --colors                    启用colors\n  \t-C, --no-colors                 禁用colors\n  \t-G, --growl                     启用growl notification\n  \t-d, --debug                     启用debug\n  \t-b, --bail                      只对第一个报错的TEST感兴趣\n  \t--recursive                     递归执行\n  \t--debug-brk                     enable node's debugger breaking on the first line\n  \t--globals <names>               allow the given comma-delimited global [names]\n  \t--ignore-leaks                  ignore global variable leaks\n  \t--interfaces                    显示可用的接口\n  \t--reporters                     显示可用的报表列表\n  \t--compilers <ext>:<module>,...  使用指定的module来编译文件\n\n\n##报表##\n\n\tdot - dot matrix\n    \tdoc - html documentation\n    \tspec - hierarchical spec list\n    \tjson - single json object\n    \tprogress - progress bar\n    \tlist - spec-style listing\n    \ttap - test-anything-protocol\n    \tlanding - unicode landing strip\n    \txunit - xunit reportert\n    \tteamcity - teamcity ci support\n    \thtml-cov - HTML test coverage\n    \tjson-cov - JSON test coverage\n    \tmin - minimal reporter (great with --watch)\n    \tjson-stream - newline delimited json events\n    \tmarkdown - markdown documentation (github flavour)\n    \tnyan - nyan cat!\n","source":"_posts/2013-03-18-mocha-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"Mocha简介\"\ndate: 2013-03-18 20:44\ncomments: true\ncategories: nodejs\n---\n##Mocha##\nMocha作为一种咖啡名，应该是广为人知的，中文翻译为**摩卡**。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。  \nMocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。   \n项目主页：<http://visionmedia.github.com/mocha/>    \n##安装##\n\tnpm install -g mocha\n\n##一个简单的样例##\n\n\t$ mkdir test\n\t$ cd ..\n\t$ mocha test/test.js\n\n\tvar assert = require(\"assert\")\n\tdescribe('Array', function(){\n  \tdescribe('#indexOf()', function(){\n    \tit('should return -1 when the value is not present', function(){\n      \tassert.equal(-1, [1,2,3].indexOf(5));\n      \tassert.equal(-1, [1,2,3].indexOf(0));\n    \t})\n  \t})\n\t})\n\n\t$  mocha\n\n \t .\n\n \t ✔ 1 test complete (1ms)\n<!--more-->\n##Assertions##\n在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。\n\n* [should.js](http://github.com/visionmedia/should.js)\n* [expect.js](https://github.com/LearnBoost/expect.js)\n* [chai](http://chaijs.com/)\n* [better-assert](https://github.com/visionmedia/better-assert)\n\n##测试同步代码##\n\n\tdescribe('Array', function(){\n  \tdescribe('#indexOf()', function(){\n    \tit('should return -1 when the value is not present', function(){\n      \t[1,2,3].indexOf(5).should.equal(-1);\n      \t[1,2,3].indexOf(0).should.equal(-1);\n    \t})\n  \t})\n\t})\n##测试异步代码##\n添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。\n\n\tdescribe('User', function(){\n  \tdescribe('#save()', function(){\n    \tit('should save without error', function(done){\n      \tvar user = new User('Luna');\n      \tuser.save(done);\n    \t})\n  \t})\n\t})\n\n##类似与JUNIT的函数\n\n* before : 在所有测试执行之前\n* after ： 在所有测试执行之后\n* beforeEach ： 每个测试之前\n* afterEach ：每个测试之后\n\n##mocha指令##\n\n\tUsage: mocha [debug] [options] [files]\n\n\tCommands:\n\n  \tinit <path>\n  \tinitialize a client-side mocha setup at <path>\n\n\tOptions:\n\n  \t-h, --help                      帮助信息\n  \t-V, --version                   版本信息\n  \t-r, --require <name>            依赖的module\n  \t-R, --reporter <name>           使用的报告模式\n  \t-u, --ui <name>                 用什么接口(bdd|tdd|exports)\n  \t-g, --grep <pattern>            执行匹配 <pattern>的测试\n  \t-i, --invert                    --grep 相反的测试\n  \t-t, --timeout <ms>              超时毫秒数 [2000]\n  \t-s, --slow <ms>                 \"slow\" 测试的门槛 [75]\n  \t-w, --watch                     查看文件的变化，如true,则变化后自动运行。\n  \t-c, --colors                    启用colors\n  \t-C, --no-colors                 禁用colors\n  \t-G, --growl                     启用growl notification\n  \t-d, --debug                     启用debug\n  \t-b, --bail                      只对第一个报错的TEST感兴趣\n  \t--recursive                     递归执行\n  \t--debug-brk                     enable node's debugger breaking on the first line\n  \t--globals <names>               allow the given comma-delimited global [names]\n  \t--ignore-leaks                  ignore global variable leaks\n  \t--interfaces                    显示可用的接口\n  \t--reporters                     显示可用的报表列表\n  \t--compilers <ext>:<module>,...  使用指定的module来编译文件\n\n\n##报表##\n\n\tdot - dot matrix\n    \tdoc - html documentation\n    \tspec - hierarchical spec list\n    \tjson - single json object\n    \tprogress - progress bar\n    \tlist - spec-style listing\n    \ttap - test-anything-protocol\n    \tlanding - unicode landing strip\n    \txunit - xunit reportert\n    \tteamcity - teamcity ci support\n    \thtml-cov - HTML test coverage\n    \tjson-cov - JSON test coverage\n    \tmin - minimal reporter (great with --watch)\n    \tjson-stream - newline delimited json events\n    \tmarkdown - markdown documentation (github flavour)\n    \tnyan - nyan cat!\n","slug":"2013-03-18-mocha-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop52004uv8fykkaj3nv1","content":"<p>##Mocha##<br>Mocha作为一种咖啡名，应该是广为人知的，中文翻译为<strong>摩卡</strong>。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。<br>Mocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。<br>项目主页：<a href=\"http://visionmedia.github.com/mocha/\" target=\"_blank\" rel=\"external\">http://visionmedia.github.com/mocha/</a>    </p>\n<p>##安装##<br>    npm install -g mocha</p>\n<p>##一个简单的样例##</p>\n<pre><code>$ mkdir test\n$ cd ..\n$ mocha test/test.js\n\nvar assert = require(&quot;assert&quot;)\ndescribe(&apos;Array&apos;, function(){\n  describe(&apos;#indexOf()&apos;, function(){\n    it(&apos;should return -1 when the value is not present&apos;, function(){\n      assert.equal(-1, [1,2,3].indexOf(5));\n      assert.equal(-1, [1,2,3].indexOf(0));\n    })\n  })\n})\n\n$  mocha\n\n  .\n\n  ✔ 1 test complete (1ms)\n</code></pre><a id=\"more\"></a>\n<p>##Assertions##<br>在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。</p>\n<ul>\n<li><a href=\"http://github.com/visionmedia/should.js\" target=\"_blank\" rel=\"external\">should.js</a></li>\n<li><a href=\"https://github.com/LearnBoost/expect.js\" target=\"_blank\" rel=\"external\">expect.js</a></li>\n<li><a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"external\">chai</a></li>\n<li><a href=\"https://github.com/visionmedia/better-assert\" target=\"_blank\" rel=\"external\">better-assert</a></li>\n</ul>\n<p>##测试同步代码##</p>\n<pre><code>describe(&apos;Array&apos;, function(){\n  describe(&apos;#indexOf()&apos;, function(){\n    it(&apos;should return -1 when the value is not present&apos;, function(){\n      [1,2,3].indexOf(5).should.equal(-1);\n      [1,2,3].indexOf(0).should.equal(-1);\n    })\n  })\n})\n</code></pre><p>##测试异步代码##<br>添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。</p>\n<pre><code>describe(&apos;User&apos;, function(){\n  describe(&apos;#save()&apos;, function(){\n    it(&apos;should save without error&apos;, function(done){\n      var user = new User(&apos;Luna&apos;);\n      user.save(done);\n    })\n  })\n})\n</code></pre><p>##类似与JUNIT的函数</p>\n<ul>\n<li>before : 在所有测试执行之前</li>\n<li>after ： 在所有测试执行之后</li>\n<li>beforeEach ： 每个测试之前</li>\n<li>afterEach ：每个测试之后</li>\n</ul>\n<p>##mocha指令##</p>\n<pre><code>Usage: mocha [debug] [options] [files]\n\nCommands:\n\n  init &lt;path&gt;\n  initialize a client-side mocha setup at &lt;path&gt;\n\nOptions:\n\n  -h, --help                      帮助信息\n  -V, --version                   版本信息\n  -r, --require &lt;name&gt;            依赖的module\n  -R, --reporter &lt;name&gt;           使用的报告模式\n  -u, --ui &lt;name&gt;                 用什么接口(bdd|tdd|exports)\n  -g, --grep &lt;pattern&gt;            执行匹配 &lt;pattern&gt;的测试\n  -i, --invert                    --grep 相反的测试\n  -t, --timeout &lt;ms&gt;              超时毫秒数 [2000]\n  -s, --slow &lt;ms&gt;                 &quot;slow&quot; 测试的门槛 [75]\n  -w, --watch                     查看文件的变化，如true,则变化后自动运行。\n  -c, --colors                    启用colors\n  -C, --no-colors                 禁用colors\n  -G, --growl                     启用growl notification\n  -d, --debug                     启用debug\n  -b, --bail                      只对第一个报错的TEST感兴趣\n  --recursive                     递归执行\n  --debug-brk                     enable node&apos;s debugger breaking on the first line\n  --globals &lt;names&gt;               allow the given comma-delimited global [names]\n  --ignore-leaks                  ignore global variable leaks\n  --interfaces                    显示可用的接口\n  --reporters                     显示可用的报表列表\n  --compilers &lt;ext&gt;:&lt;module&gt;,...  使用指定的module来编译文件\n</code></pre><p>##报表##</p>\n<pre><code>dot - dot matrix\n    doc - html documentation\n    spec - hierarchical spec list\n    json - single json object\n    progress - progress bar\n    list - spec-style listing\n    tap - test-anything-protocol\n    landing - unicode landing strip\n    xunit - xunit reportert\n    teamcity - teamcity ci support\n    html-cov - HTML test coverage\n    json-cov - JSON test coverage\n    min - minimal reporter (great with --watch)\n    json-stream - newline delimited json events\n    markdown - markdown documentation (github flavour)\n    nyan - nyan cat!\n</code></pre>","excerpt":"<p>##Mocha##<br>Mocha作为一种咖啡名，应该是广为人知的，中文翻译为<strong>摩卡</strong>。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。<br>Mocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。<br>项目主页：<a href=\"http://visionmedia.github.com/mocha/\">http://visionmedia.github.com/mocha/</a>    </p>\n<p>##安装##<br>    npm install -g mocha</p>\n<p>##一个简单的样例##</p>\n<pre><code>$ mkdir test\n$ cd ..\n$ mocha test/test.js\n\nvar assert = require(&quot;assert&quot;)\ndescribe(&apos;Array&apos;, function(){\n  describe(&apos;#indexOf()&apos;, function(){\n    it(&apos;should return -1 when the value is not present&apos;, function(){\n      assert.equal(-1, [1,2,3].indexOf(5));\n      assert.equal(-1, [1,2,3].indexOf(0));\n    })\n  })\n})\n\n$  mocha\n\n  .\n\n  ✔ 1 test complete (1ms)\n</code></pre>","more":"<p>##Assertions##<br>在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。</p>\n<ul>\n<li><a href=\"http://github.com/visionmedia/should.js\">should.js</a></li>\n<li><a href=\"https://github.com/LearnBoost/expect.js\">expect.js</a></li>\n<li><a href=\"http://chaijs.com/\">chai</a></li>\n<li><a href=\"https://github.com/visionmedia/better-assert\">better-assert</a></li>\n</ul>\n<p>##测试同步代码##</p>\n<pre><code>describe(&apos;Array&apos;, function(){\n  describe(&apos;#indexOf()&apos;, function(){\n    it(&apos;should return -1 when the value is not present&apos;, function(){\n      [1,2,3].indexOf(5).should.equal(-1);\n      [1,2,3].indexOf(0).should.equal(-1);\n    })\n  })\n})\n</code></pre><p>##测试异步代码##<br>添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。</p>\n<pre><code>describe(&apos;User&apos;, function(){\n  describe(&apos;#save()&apos;, function(){\n    it(&apos;should save without error&apos;, function(done){\n      var user = new User(&apos;Luna&apos;);\n      user.save(done);\n    })\n  })\n})\n</code></pre><p>##类似与JUNIT的函数</p>\n<ul>\n<li>before : 在所有测试执行之前</li>\n<li>after ： 在所有测试执行之后</li>\n<li>beforeEach ： 每个测试之前</li>\n<li>afterEach ：每个测试之后</li>\n</ul>\n<p>##mocha指令##</p>\n<pre><code>Usage: mocha [debug] [options] [files]\n\nCommands:\n\n  init &lt;path&gt;\n  initialize a client-side mocha setup at &lt;path&gt;\n\nOptions:\n\n  -h, --help                      帮助信息\n  -V, --version                   版本信息\n  -r, --require &lt;name&gt;            依赖的module\n  -R, --reporter &lt;name&gt;           使用的报告模式\n  -u, --ui &lt;name&gt;                 用什么接口(bdd|tdd|exports)\n  -g, --grep &lt;pattern&gt;            执行匹配 &lt;pattern&gt;的测试\n  -i, --invert                    --grep 相反的测试\n  -t, --timeout &lt;ms&gt;              超时毫秒数 [2000]\n  -s, --slow &lt;ms&gt;                 &quot;slow&quot; 测试的门槛 [75]\n  -w, --watch                     查看文件的变化，如true,则变化后自动运行。\n  -c, --colors                    启用colors\n  -C, --no-colors                 禁用colors\n  -G, --growl                     启用growl notification\n  -d, --debug                     启用debug\n  -b, --bail                      只对第一个报错的TEST感兴趣\n  --recursive                     递归执行\n  --debug-brk                     enable node&apos;s debugger breaking on the first line\n  --globals &lt;names&gt;               allow the given comma-delimited global [names]\n  --ignore-leaks                  ignore global variable leaks\n  --interfaces                    显示可用的接口\n  --reporters                     显示可用的报表列表\n  --compilers &lt;ext&gt;:&lt;module&gt;,...  使用指定的module来编译文件\n</code></pre><p>##报表##</p>\n<pre><code>dot - dot matrix\n    doc - html documentation\n    spec - hierarchical spec list\n    json - single json object\n    progress - progress bar\n    list - spec-style listing\n    tap - test-anything-protocol\n    landing - unicode landing strip\n    xunit - xunit reportert\n    teamcity - teamcity ci support\n    html-cov - HTML test coverage\n    json-cov - JSON test coverage\n    min - minimal reporter (great with --watch)\n    json-stream - newline delimited json events\n    markdown - markdown documentation (github flavour)\n    nyan - nyan cat!\n</code></pre>"},{"layout":"post","title":"Karma  or Testacular 简介","date":"2013-03-12T07:12:00.000Z","comments":1,"_content":"##Karma/Testacular是什么？##\n在2012年11月，Google开源了[Testacular](http://testacular.github.com/)，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。   \n\nTestacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与[Jenkins](http://jenkins-ci.org/)或[Travis](https://travis-ci.org/)整合，用于执行持续集成测试。  \n \n<!--more-->\n这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到[WebStorm](http://www.jetbrains.com/webstorm/)中，而WebStorm持错误栈追踪和单元测试调试。  \n\n为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）  \n\n说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。\n\nJína也说到Testacular是受[JS Test Driver(JSTD)](http://code.google.com/p/js-test-driver/)的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。  \n\n##Vojta Jína原版视频##\nyoutube(凸墙):   \n<http://www.youtube.com/watch?v=5mHjJ4xf_K0>    \n<http://www.youtube.com/watch?v=MVw8N3hTfCI>    \nyouku[个人转录]:    \n<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Nzky\" frameborder=0 allowfullscreen></iframe>\n\n<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Mzc2\" frameborder=0 allowfullscreen></iframe>\n##Karma/Testacular 安装##\n首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：   \n\n\tnpm install -g karma/testacular\n安装成功后，可以查看其支持的命令。   \n\n\ttestacular --help\n\tTestacular - Spectacular Test Runner for JavaScript.\n\n\tUsage:\n  \ttestacular <command>\n\n\tCommands:\n  \tstart [<configFile>] [<options>] Start the server / do single run.\n  \tinit [<configFile>] Initialize a config file.\n  \trun [<options>] Trigger a test run.\n\n\tRun --help with particular command to see its description and \tavailable options.\n\n\tOptions:\n  \t--help     Print usage and options.\n  \t--version  Print current version.   \n简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。  \n下面就来看以下，最主要的部分，那就是配置文件了。\n\n##Karma/Testacular配置文件##\n这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。   \n在GitHub上可以看到一个官方提供的默认样例<https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。  \n同样的，使用`karma/testacular init`命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的`karma/testacular start`也会默认搜索当前目录下的karma/testacular.conf.js来启动。    \n下面，我们来生成一个看看：   \n\n\tkarma/testacular init my.conf.js\n\n\tWhich testing framework do you want to use ?\n\tPress tab to list possible options. Enter to move to the next \tquestion.\n\t> mocha\n\n\tDo you want to use Require.js ?\n\tThis will add Require.js adapter into files.\n\tPress tab to list possible options. Enter to move to the next question.\n\t> no\n\n\tDo you want to capture a browser automatically ?\n\tPress tab to list possible options. Enter empty string to move to the next question.\n\t> Firefox\n\t......\n\n\tConfig file generated at \"/home/shenyanchao/tmp/my.conf.js\".\n这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是**Tab**。  \n此时，执行`testacular start my.conf.js`,可以发现，浏览器已经启动了。   \n \n \n![Testacular启动](/images/blog/testacular-run-in-firefox.png)     \n\n\n**配置文件参数：**  \n\tautoWatch\n\n\t类型: Boolean\n\t默认: false\n\t命令行: --auto-watch, --no-auto-watch\n\t详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test\n\n\tbasePath\n\n\t类型: String\n\t默认: ''\n\t详细介绍: 基本路径，用来解决相对路径问题。\n \n\tbrowsers\n\n\t类型: Array\n\t默认: []\n\t命令行: --browsers Chrome,Firefox\n\t取值:\n\tChrome\n\tChromeCanary\n\tFirefox\n\tOpera\n\tSafari\n\tPhantomJS\n\tIE\n\t详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。\n\n\tcaptureTimeout\n\n\t类型: Number\n\t默认: 60000\n\t详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  \n\n\tcolors\n\n\t类型: Boolean\n\t默认: true\n\t命令行: --colors, --no-colors\n\t详细介绍: 在reporters和logs里面是否启用色彩。\n\texclude\n\n\t类型: Array\n\t默认: []\n\t详细介绍: 排除在外的文件列表或者正则表达式\n\n\tfiles\n\n\t类型: Array\n\t默认: []\n\t详细介绍: 要加载的文件列表或者正则表达式\n\n\thostname\n\n\t类型: String\n\t默认: 'localhost'\n\t详细介绍: 启动的浏览器主机名\n\n\tlogLevel\n\n\t类型: Constant\n\t默认: LOG_INFO\n\t命令行: --log-level debug\n\t取值:\n\tLOG_DISABLE\n\tLOG_ERROR\n\tLOG_WARN\n\tLOG_INFO\n\tLOG_DEBUG\n\t详细介绍: 日志级别.\n\n\tloggers\n\n\t类型: Array\n\t默认: [{type: 'console'}]\n\t详细介绍: 定义日志目标。比如log4js\n\n\tport\n\n\t类型: Number\n\t默认: 9876\n\t命令行: --port 9876\n\t详细介绍: web服务的监听端口\n\n\tpreprocessors\n\n\t类型: Object\n\t默认: {'**/*.coffee': 'coffee'}\n\t详细介绍: 前置处理器的MAP\n\n\tproxies\n\n\t类型: Object\n\t默认: {}\n\t详细介绍: 路径代理的映射MAP\n\t例如:\n  \tproxies =  {\n    \t'/static': 'http://gstatic.com',\n    \t'/web': 'http://localhost:9000'\n  \t};\n\n\treportSlowerThan\n\n\t类型: Number\n\t默认: 0\n\t详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 \n\n\treporters\n\n\t类型: Array\n\t默认: ['progress']\n\t命令行: --reporters progress,growl\n\t取值:\n\tdots\n\tprogress\n\tjunit\n\tgrowl\n\tcoverage\n\t详细介绍: 使用的报表列表\n\n\trunnerPort\n\n\t类型: Number\n\t默认: 9100\n\t命令行: --runner-port 9100\n\t详细介绍: 使用testacular run时，服务器的监听端口\n\n\tsingleRun\n\n\t类型: Boolean\n\t默认: false\n\t命令行: --single-run, no-single-run\n\t详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.\n\n\turlRoot\n\n\t类型: String\n\t默认: '/'\n\t详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。\n##browser无法启动？##\n当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。\n如果无法找到，可以通过覆盖`<BROWSER>_BIN`来解决。   \n比如：   \n\n\texport CHROME_BIN=/usr/local/bin/my-chrome-build\n\texport CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build\n \texport PHANTOMJS_BIN=$HOME/local/bin/phantomjs\n就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。   \n##写在Testacular学习之后##\nTestacular应该是Google[AngularJS](http://angularjs.org/)的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。  \n以上，存在一定的个人猜测，但是其产生的过程值得好好学习。   \n##改名为Karma##\n2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为`chore: rename this shit to Karma`。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。    ","source":"_posts/2013-03-12-testacular-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"Karma  or Testacular 简介\"\ndate: 2013-03-12 15:12\ncomments: true\ncategories: nodejs\ntags: [ Testacular, JsTestDriver, nodejs, jenkins ]\n---\n##Karma/Testacular是什么？##\n在2012年11月，Google开源了[Testacular](http://testacular.github.com/)，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。   \n\nTestacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与[Jenkins](http://jenkins-ci.org/)或[Travis](https://travis-ci.org/)整合，用于执行持续集成测试。  \n \n<!--more-->\n这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到[WebStorm](http://www.jetbrains.com/webstorm/)中，而WebStorm持错误栈追踪和单元测试调试。  \n\n为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）  \n\n说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。\n\nJína也说到Testacular是受[JS Test Driver(JSTD)](http://code.google.com/p/js-test-driver/)的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。  \n\n##Vojta Jína原版视频##\nyoutube(凸墙):   \n<http://www.youtube.com/watch?v=5mHjJ4xf_K0>    \n<http://www.youtube.com/watch?v=MVw8N3hTfCI>    \nyouku[个人转录]:    \n<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Nzky\" frameborder=0 allowfullscreen></iframe>\n\n<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Mzc2\" frameborder=0 allowfullscreen></iframe>\n##Karma/Testacular 安装##\n首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：   \n\n\tnpm install -g karma/testacular\n安装成功后，可以查看其支持的命令。   \n\n\ttestacular --help\n\tTestacular - Spectacular Test Runner for JavaScript.\n\n\tUsage:\n  \ttestacular <command>\n\n\tCommands:\n  \tstart [<configFile>] [<options>] Start the server / do single run.\n  \tinit [<configFile>] Initialize a config file.\n  \trun [<options>] Trigger a test run.\n\n\tRun --help with particular command to see its description and \tavailable options.\n\n\tOptions:\n  \t--help     Print usage and options.\n  \t--version  Print current version.   \n简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。  \n下面就来看以下，最主要的部分，那就是配置文件了。\n\n##Karma/Testacular配置文件##\n这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。   \n在GitHub上可以看到一个官方提供的默认样例<https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。  \n同样的，使用`karma/testacular init`命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的`karma/testacular start`也会默认搜索当前目录下的karma/testacular.conf.js来启动。    \n下面，我们来生成一个看看：   \n\n\tkarma/testacular init my.conf.js\n\n\tWhich testing framework do you want to use ?\n\tPress tab to list possible options. Enter to move to the next \tquestion.\n\t> mocha\n\n\tDo you want to use Require.js ?\n\tThis will add Require.js adapter into files.\n\tPress tab to list possible options. Enter to move to the next question.\n\t> no\n\n\tDo you want to capture a browser automatically ?\n\tPress tab to list possible options. Enter empty string to move to the next question.\n\t> Firefox\n\t......\n\n\tConfig file generated at \"/home/shenyanchao/tmp/my.conf.js\".\n这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是**Tab**。  \n此时，执行`testacular start my.conf.js`,可以发现，浏览器已经启动了。   \n \n \n![Testacular启动](/images/blog/testacular-run-in-firefox.png)     \n\n\n**配置文件参数：**  \n\tautoWatch\n\n\t类型: Boolean\n\t默认: false\n\t命令行: --auto-watch, --no-auto-watch\n\t详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test\n\n\tbasePath\n\n\t类型: String\n\t默认: ''\n\t详细介绍: 基本路径，用来解决相对路径问题。\n \n\tbrowsers\n\n\t类型: Array\n\t默认: []\n\t命令行: --browsers Chrome,Firefox\n\t取值:\n\tChrome\n\tChromeCanary\n\tFirefox\n\tOpera\n\tSafari\n\tPhantomJS\n\tIE\n\t详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。\n\n\tcaptureTimeout\n\n\t类型: Number\n\t默认: 60000\n\t详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  \n\n\tcolors\n\n\t类型: Boolean\n\t默认: true\n\t命令行: --colors, --no-colors\n\t详细介绍: 在reporters和logs里面是否启用色彩。\n\texclude\n\n\t类型: Array\n\t默认: []\n\t详细介绍: 排除在外的文件列表或者正则表达式\n\n\tfiles\n\n\t类型: Array\n\t默认: []\n\t详细介绍: 要加载的文件列表或者正则表达式\n\n\thostname\n\n\t类型: String\n\t默认: 'localhost'\n\t详细介绍: 启动的浏览器主机名\n\n\tlogLevel\n\n\t类型: Constant\n\t默认: LOG_INFO\n\t命令行: --log-level debug\n\t取值:\n\tLOG_DISABLE\n\tLOG_ERROR\n\tLOG_WARN\n\tLOG_INFO\n\tLOG_DEBUG\n\t详细介绍: 日志级别.\n\n\tloggers\n\n\t类型: Array\n\t默认: [{type: 'console'}]\n\t详细介绍: 定义日志目标。比如log4js\n\n\tport\n\n\t类型: Number\n\t默认: 9876\n\t命令行: --port 9876\n\t详细介绍: web服务的监听端口\n\n\tpreprocessors\n\n\t类型: Object\n\t默认: {'**/*.coffee': 'coffee'}\n\t详细介绍: 前置处理器的MAP\n\n\tproxies\n\n\t类型: Object\n\t默认: {}\n\t详细介绍: 路径代理的映射MAP\n\t例如:\n  \tproxies =  {\n    \t'/static': 'http://gstatic.com',\n    \t'/web': 'http://localhost:9000'\n  \t};\n\n\treportSlowerThan\n\n\t类型: Number\n\t默认: 0\n\t详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 \n\n\treporters\n\n\t类型: Array\n\t默认: ['progress']\n\t命令行: --reporters progress,growl\n\t取值:\n\tdots\n\tprogress\n\tjunit\n\tgrowl\n\tcoverage\n\t详细介绍: 使用的报表列表\n\n\trunnerPort\n\n\t类型: Number\n\t默认: 9100\n\t命令行: --runner-port 9100\n\t详细介绍: 使用testacular run时，服务器的监听端口\n\n\tsingleRun\n\n\t类型: Boolean\n\t默认: false\n\t命令行: --single-run, no-single-run\n\t详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.\n\n\turlRoot\n\n\t类型: String\n\t默认: '/'\n\t详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。\n##browser无法启动？##\n当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。\n如果无法找到，可以通过覆盖`<BROWSER>_BIN`来解决。   \n比如：   \n\n\texport CHROME_BIN=/usr/local/bin/my-chrome-build\n\texport CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build\n \texport PHANTOMJS_BIN=$HOME/local/bin/phantomjs\n就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。   \n##写在Testacular学习之后##\nTestacular应该是Google[AngularJS](http://angularjs.org/)的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。  \n以上，存在一定的个人猜测，但是其产生的过程值得好好学习。   \n##改名为Karma##\n2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为`chore: rename this shit to Karma`。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。    ","slug":"2013-03-12-testacular-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop54004yv8fyyu4yqaj1","content":"<p>##Karma/Testacular是什么？##<br>在2012年11月，Google开源了<a href=\"http://testacular.github.com/\" target=\"_blank\" rel=\"external\">Testacular</a>，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。   </p>\n<p>Testacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与<a href=\"http://jenkins-ci.org/\" target=\"_blank\" rel=\"external\">Jenkins</a>或<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">Travis</a>整合，用于执行持续集成测试。  </p>\n<a id=\"more\"></a>\n<p>这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到<a href=\"http://www.jetbrains.com/webstorm/\" target=\"_blank\" rel=\"external\">WebStorm</a>中，而WebStorm持错误栈追踪和单元测试调试。  </p>\n<p>为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）  </p>\n<p>说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。</p>\n<p>Jína也说到Testacular是受<a href=\"http://code.google.com/p/js-test-driver/\" target=\"_blank\" rel=\"external\">JS Test Driver(JSTD)</a>的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。  </p>\n<p>##Vojta Jína原版视频##<br>youtube(凸墙):<br><a href=\"http://www.youtube.com/watch?v=5mHjJ4xf_K0\" target=\"_blank\" rel=\"external\">http://www.youtube.com/watch?v=5mHjJ4xf_K0</a><br><a href=\"http://www.youtube.com/watch?v=MVw8N3hTfCI\" target=\"_blank\" rel=\"external\">http://www.youtube.com/watch?v=MVw8N3hTfCI</a><br>youku[个人转录]:    </p>\n<iframe height=\"498\" width=\"510\" src=\"http://player.youku.com/embed/XNTI2NTg0Nzky\" frameborder=\"0\" allowfullscreen></iframe>\n\n<p><iframe height=\"498\" width=\"510\" src=\"http://player.youku.com/embed/XNTI2NTg0Mzc2\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>##Karma/Testacular 安装##<br>首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：   </p>\n<pre><code>npm install -g karma/testacular\n</code></pre><p>安装成功后，可以查看其支持的命令。   </p>\n<pre><code>testacular --help\nTestacular - Spectacular Test Runner for JavaScript.\n\nUsage:\n  testacular &lt;command&gt;\n\nCommands:\n  start [&lt;configFile&gt;] [&lt;options&gt;] Start the server / do single run.\n  init [&lt;configFile&gt;] Initialize a config file.\n  run [&lt;options&gt;] Trigger a test run.\n\nRun --help with particular command to see its description and     available options.\n\nOptions:\n  --help     Print usage and options.\n  --version  Print current version.   \n</code></pre><p>简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。<br>下面就来看以下，最主要的部分，那就是配置文件了。</p>\n<p>##Karma/Testacular配置文件##<br>这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。<br>在GitHub上可以看到一个官方提供的默认样例<a href=\"https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js\" target=\"_blank\" rel=\"external\">https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js</a>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。<br>同样的，使用<code>karma/testacular init</code>命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的<code>karma/testacular start</code>也会默认搜索当前目录下的karma/testacular.conf.js来启动。<br>下面，我们来生成一个看看：   </p>\n<pre><code>karma/testacular init my.conf.js\n\nWhich testing framework do you want to use ?\nPress tab to list possible options. Enter to move to the next     question.\n&gt; mocha\n\nDo you want to use Require.js ?\nThis will add Require.js adapter into files.\nPress tab to list possible options. Enter to move to the next question.\n&gt; no\n\nDo you want to capture a browser automatically ?\nPress tab to list possible options. Enter empty string to move to the next question.\n&gt; Firefox\n......\n\nConfig file generated at &quot;/home/shenyanchao/tmp/my.conf.js&quot;.\n</code></pre><p>这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是<strong>Tab</strong>。<br>此时，执行<code>testacular start my.conf.js</code>,可以发现，浏览器已经启动了。   </p>\n<p><img src=\"/images/blog/testacular-run-in-firefox.png\" alt=\"Testacular启动\">     </p>\n<p><strong>配置文件参数：</strong><br>    autoWatch</p>\n<pre><code>类型: Boolean\n默认: false\n命令行: --auto-watch, --no-auto-watch\n详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test\n\nbasePath\n\n类型: String\n默认: &apos;&apos;\n详细介绍: 基本路径，用来解决相对路径问题。\n\nbrowsers\n\n类型: Array\n默认: []\n命令行: --browsers Chrome,Firefox\n取值:\nChrome\nChromeCanary\nFirefox\nOpera\nSafari\nPhantomJS\nIE\n详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。\n\ncaptureTimeout\n\n类型: Number\n默认: 60000\n详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  \n\ncolors\n\n类型: Boolean\n默认: true\n命令行: --colors, --no-colors\n详细介绍: 在reporters和logs里面是否启用色彩。\nexclude\n\n类型: Array\n默认: []\n详细介绍: 排除在外的文件列表或者正则表达式\n\nfiles\n\n类型: Array\n默认: []\n详细介绍: 要加载的文件列表或者正则表达式\n\nhostname\n\n类型: String\n默认: &apos;localhost&apos;\n详细介绍: 启动的浏览器主机名\n\nlogLevel\n\n类型: Constant\n默认: LOG_INFO\n命令行: --log-level debug\n取值:\nLOG_DISABLE\nLOG_ERROR\nLOG_WARN\nLOG_INFO\nLOG_DEBUG\n详细介绍: 日志级别.\n\nloggers\n\n类型: Array\n默认: [{type: &apos;console&apos;}]\n详细介绍: 定义日志目标。比如log4js\n\nport\n\n类型: Number\n默认: 9876\n命令行: --port 9876\n详细介绍: web服务的监听端口\n\npreprocessors\n\n类型: Object\n默认: {&apos;**/*.coffee&apos;: &apos;coffee&apos;}\n详细介绍: 前置处理器的MAP\n\nproxies\n\n类型: Object\n默认: {}\n详细介绍: 路径代理的映射MAP\n例如:\n  proxies =  {\n    &apos;/static&apos;: &apos;http://gstatic.com&apos;,\n    &apos;/web&apos;: &apos;http://localhost:9000&apos;\n  };\n\nreportSlowerThan\n\n类型: Number\n默认: 0\n详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 \n\nreporters\n\n类型: Array\n默认: [&apos;progress&apos;]\n命令行: --reporters progress,growl\n取值:\ndots\nprogress\njunit\ngrowl\ncoverage\n详细介绍: 使用的报表列表\n\nrunnerPort\n\n类型: Number\n默认: 9100\n命令行: --runner-port 9100\n详细介绍: 使用testacular run时，服务器的监听端口\n\nsingleRun\n\n类型: Boolean\n默认: false\n命令行: --single-run, no-single-run\n详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.\n\nurlRoot\n\n类型: String\n默认: &apos;/&apos;\n详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。\n</code></pre><p>##browser无法启动？##<br>当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。<br>如果无法找到，可以通过覆盖<code>&lt;BROWSER&gt;_BIN</code>来解决。<br>比如：   </p>\n<pre><code>export CHROME_BIN=/usr/local/bin/my-chrome-build\nexport CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build\n export PHANTOMJS_BIN=$HOME/local/bin/phantomjs\n</code></pre><p>就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。   </p>\n<p>##写在Testacular学习之后##<br>Testacular应该是Google<a href=\"http://angularjs.org/\" target=\"_blank\" rel=\"external\">AngularJS</a>的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。<br>以上，存在一定的个人猜测，但是其产生的过程值得好好学习。   </p>\n<p>##改名为Karma##<br>2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为<code>chore: rename this shit to Karma</code>。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。    </p>\n","excerpt":"<p>##Karma/Testacular是什么？##<br>在2012年11月，Google开源了<a href=\"http://testacular.github.com/\">Testacular</a>，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。   </p>\n<p>Testacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与<a href=\"http://jenkins-ci.org/\">Jenkins</a>或<a href=\"https://travis-ci.org/\">Travis</a>整合，用于执行持续集成测试。  </p>","more":"<p>这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到<a href=\"http://www.jetbrains.com/webstorm/\">WebStorm</a>中，而WebStorm持错误栈追踪和单元测试调试。  </p>\n<p>为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）  </p>\n<p>说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。</p>\n<p>Jína也说到Testacular是受<a href=\"http://code.google.com/p/js-test-driver/\">JS Test Driver(JSTD)</a>的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。  </p>\n<p>##Vojta Jína原版视频##<br>youtube(凸墙):<br><a href=\"http://www.youtube.com/watch?v=5mHjJ4xf_K0\">http://www.youtube.com/watch?v=5mHjJ4xf_K0</a><br><a href=\"http://www.youtube.com/watch?v=MVw8N3hTfCI\">http://www.youtube.com/watch?v=MVw8N3hTfCI</a><br>youku[个人转录]:    </p>\n<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Nzky\" frameborder=0 allowfullscreen></iframe>\n\n<p><iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTI2NTg0Mzc2\" frameborder=0 allowfullscreen></iframe></p>\n<p>##Karma/Testacular 安装##<br>首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：   </p>\n<pre><code>npm install -g karma/testacular\n</code></pre><p>安装成功后，可以查看其支持的命令。   </p>\n<pre><code>testacular --help\nTestacular - Spectacular Test Runner for JavaScript.\n\nUsage:\n  testacular &lt;command&gt;\n\nCommands:\n  start [&lt;configFile&gt;] [&lt;options&gt;] Start the server / do single run.\n  init [&lt;configFile&gt;] Initialize a config file.\n  run [&lt;options&gt;] Trigger a test run.\n\nRun --help with particular command to see its description and     available options.\n\nOptions:\n  --help     Print usage and options.\n  --version  Print current version.   \n</code></pre><p>简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。<br>下面就来看以下，最主要的部分，那就是配置文件了。</p>\n<p>##Karma/Testacular配置文件##<br>这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。<br>在GitHub上可以看到一个官方提供的默认样例<a href=\"https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js\">https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js</a>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。<br>同样的，使用<code>karma/testacular init</code>命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是karma/testacular.conf.js。对应的<code>karma/testacular start</code>也会默认搜索当前目录下的karma/testacular.conf.js来启动。<br>下面，我们来生成一个看看：   </p>\n<pre><code>karma/testacular init my.conf.js\n\nWhich testing framework do you want to use ?\nPress tab to list possible options. Enter to move to the next     question.\n&gt; mocha\n\nDo you want to use Require.js ?\nThis will add Require.js adapter into files.\nPress tab to list possible options. Enter to move to the next question.\n&gt; no\n\nDo you want to capture a browser automatically ?\nPress tab to list possible options. Enter empty string to move to the next question.\n&gt; Firefox\n......\n\nConfig file generated at &quot;/home/shenyanchao/tmp/my.conf.js&quot;.\n</code></pre><p>这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是<strong>Tab</strong>。<br>此时，执行<code>testacular start my.conf.js</code>,可以发现，浏览器已经启动了。   </p>\n<p><img src=\"/images/blog/testacular-run-in-firefox.png\" alt=\"Testacular启动\">     </p>\n<p><strong>配置文件参数：</strong><br>    autoWatch</p>\n<pre><code>类型: Boolean\n默认: false\n命令行: --auto-watch, --no-auto-watch\n详细介绍:当检测到文件内容变化的时候，是不是自动的重新运行Test\n\nbasePath\n\n类型: String\n默认: &apos;&apos;\n详细介绍: 基本路径，用来解决相对路径问题。\n\nbrowsers\n\n类型: Array\n默认: []\n命令行: --browsers Chrome,Firefox\n取值:\nChrome\nChromeCanary\nFirefox\nOpera\nSafari\nPhantomJS\nIE\n详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。\n\ncaptureTimeout\n\n类型: Number\n默认: 60000\n详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  \n\ncolors\n\n类型: Boolean\n默认: true\n命令行: --colors, --no-colors\n详细介绍: 在reporters和logs里面是否启用色彩。\nexclude\n\n类型: Array\n默认: []\n详细介绍: 排除在外的文件列表或者正则表达式\n\nfiles\n\n类型: Array\n默认: []\n详细介绍: 要加载的文件列表或者正则表达式\n\nhostname\n\n类型: String\n默认: &apos;localhost&apos;\n详细介绍: 启动的浏览器主机名\n\nlogLevel\n\n类型: Constant\n默认: LOG_INFO\n命令行: --log-level debug\n取值:\nLOG_DISABLE\nLOG_ERROR\nLOG_WARN\nLOG_INFO\nLOG_DEBUG\n详细介绍: 日志级别.\n\nloggers\n\n类型: Array\n默认: [{type: &apos;console&apos;}]\n详细介绍: 定义日志目标。比如log4js\n\nport\n\n类型: Number\n默认: 9876\n命令行: --port 9876\n详细介绍: web服务的监听端口\n\npreprocessors\n\n类型: Object\n默认: {&apos;**/*.coffee&apos;: &apos;coffee&apos;}\n详细介绍: 前置处理器的MAP\n\nproxies\n\n类型: Object\n默认: {}\n详细介绍: 路径代理的映射MAP\n例如:\n  proxies =  {\n    &apos;/static&apos;: &apos;http://gstatic.com&apos;,\n    &apos;/web&apos;: &apos;http://localhost:9000&apos;\n  };\n\nreportSlowerThan\n\n类型: Number\n默认: 0\n详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 \n\nreporters\n\n类型: Array\n默认: [&apos;progress&apos;]\n命令行: --reporters progress,growl\n取值:\ndots\nprogress\njunit\ngrowl\ncoverage\n详细介绍: 使用的报表列表\n\nrunnerPort\n\n类型: Number\n默认: 9100\n命令行: --runner-port 9100\n详细介绍: 使用testacular run时，服务器的监听端口\n\nsingleRun\n\n类型: Boolean\n默认: false\n命令行: --single-run, no-single-run\n详细介绍: CI模式。如为true，就会在所有浏览器运行，运行结束后关闭浏览器，返回码0，失败返回1.\n\nurlRoot\n\n类型: String\n默认: &apos;/&apos;\n详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。\n</code></pre><p>##browser无法启动？##<br>当在karma/testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。<br>如果无法找到，可以通过覆盖<code>&lt;BROWSER&gt;_BIN</code>来解决。<br>比如：   </p>\n<pre><code>export CHROME_BIN=/usr/local/bin/my-chrome-build\nexport CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build\n export PHANTOMJS_BIN=$HOME/local/bin/phantomjs\n</code></pre><p>就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。   </p>\n<p>##写在Testacular学习之后##<br>Testacular应该是Google<a href=\"http://angularjs.org/\">AngularJS</a>的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。<br>以上，存在一定的个人猜测，但是其产生的过程值得好好学习。   </p>\n<p>##改名为Karma##<br>2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为<code>chore: rename this shit to Karma</code>。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。    </p>"},{"layout":"post","title":"Jasmine 简介","date":"2013-03-22T07:47:00.000Z","comments":1,"_content":"##jasmine测试框架简介##\n**jasmine**是一种javascript测试框架，它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。\n###jasmine的简单语法###\n一个基本的jasmine测试用例如下：  \n    describe(\"A suite\", function() {  \n  \t\tit(\"contains spec with an expectation\", function() {  \n    \texpect(true).toBe(true);  \n  \t\t});  \n\t});   \n####describe方法####\ndescribe方法标志着一个测试集(test suite)的开始，这个方法有两个参数，一个字符串String，一个方法function；字符串用来描述我们这个test suite，function里的东西就是测试代码，它们就是suite。  \n<!--more-->\n####it方法####\njasmine中用方法it来开始specs（我理解成测试点，一个测试suite里可以有很多spec）。it方法和describe方法类似，同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。一个测试点(spec)可以包含多个expections（其实是断言的意思）。 \n####expectations####\n断言可以返回为true或者false。全部的断言返回true这个测试点就通过，一个或者多个断言返回false这个测试点就不通过。  \ndescribe和it都是方法，我们可以自定义一些变量，在describe中定义的变量，在it方法中可以直接使用。  \n    describe(\"A suite is just a function\", function() {\n\tvar a;\n\n\tit(\"and so is a spec\", function() {\n    \ta = true;\n\n    \texpect(a).toBe(true);\n\t});\n\t});  \n####Matchers####\n一个一个的测试点们由expect开头，后面跟着一个我们需要测试的变量，如上面的a，然后跟着一个Matcher方法（我理解成校验规则），Matcher方法带着一个期望值，如上面的true。Matchers方法返回true或者false，它决定着测试点（spec）是否通过。所有的Matchers方法都能在mathcer前面加上not来进行否定断言，如`expect(a).not.toBe(true);  \n\njasmine中有很多Matchers方法供我们使用，当然我们也可以定义自己的Matchers方法。\n\tdescribe(\"Included matchers:\", function() {\n\n\t\tit(\"The 'toBe' matcher compares with ===\", function() {\n    \t\tvar a = 12;\n    \t\tvar b = a;\n\n    \t\texpect(a).toBe(b);\n    \t\texpect(a).not.toBe(null);\n  \t\t});  \n\t\t//上面的例子，比较a、b是否相等；验证a是否不是空。 \n\n\t\tit(\"should work for objects\", function() {\n      \t\tvar foo = {\n        \t\ta: 12,\n        \t\tb: 34\n      \t\t};\n      \t\tvar bar = {\n        \t\ta: 12,\n       \t \t\tb: 34\n      \t\t};\n      \t\texpect(foo).toEqual(bar);\n    \t});\n\t\t//上面的例子比较了两个对象是否相等\n\t});\n\n\tit(\"The 'toMatch' matcher is for regular expressions\", function() {\n    \tvar message = 'foo bar baz';\n\n    \texpect(message).toMatch(/bar/);\n    \texpect(message).toMatch('bar');\n    \texpect(message).not.toMatch(/quux/);\n\t});\n\t//也可以使用正则表达式\n\n\tit(\"The 'toBeDefined' matcher compares against `undefined`\", function() {\n    \tvar a = {\n      \t\tfoo: 'foo'\n    \t};\n\n    \texpect(a.foo).toBeDefined();\n    \texpect(a.bar).not.toBeDefined();\n\t});\n\t//验证变量是否被定义\n\n\tit(\"The 'toBeNull' matcher compares against null\", function() {\n    \tvar a = null;\n   \t \tvar foo = 'foo';\n\n    \texpect(null).toBeNull();\n    \texpect(a).toBeNull();\n    \texpect(foo).not.toBeNull();\n\t});\n\t//验证是否为空\n\n\tit(\"The 'toBeTruthy' matcher is for boolean casting testing\", function() {\n    \tvar a, foo = 'foo';\n\n    \texpect(foo).toBeTruthy();\n    \texpect(a).not.toBeTruthy();\n\t});\n\n\tit(\"The 'toBeFalsy' matcher is for boolean casting testing\", function() {\n    \tvar a, foo = 'foo';\n\n    \texpect(a).toBeFalsy();\n    \texpect(foo).not.toBeFalsy();\n\t});\n\t//变量是否能够转化成boolean变量？ 不太确定\n\n\tit(\"The 'toContain' matcher is for finding an item in an Array\", function() {\n    \tvar a = ['foo', 'bar', 'baz'];\n\n    \texpect(a).toContain('bar');\n    \texpect(a).not.toContain('quux');\n\t});\n\t//是否包含\n\tit(\"The 'toBeLessThan' matcher is for mathematical comparisons\", function() {\n    \tvar pi = 3.1415926, e = 2.78;\n\n    \texpect(e).toBeLessThan(pi);\n    \texpect(pi).not.toBeLessThan(e);\n\t});\n\n\tit(\"The 'toBeGreaterThan' is for mathematical comparisons\", function() {\n    \tvar pi = 3.1415926, e = 2.78;\n\n    \texpect(pi).toBeGreaterThan(e);\n    \texpect(e).not.toBeGreaterThan(pi);\n\t});\n\t//数学大小的比较\n\n\tit(\"The 'toBeCloseTo' matcher is for precision math comparison\", function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(pi).not.toBeCloseTo(e, 2);\n    expect(pi).toBeCloseTo(e, 0);\n\t});\n\t//两个数值是否接近，这里接近的意思是将pi和e保留一定小数位数后，是否相等。（一定小数位数：默认为2，也可以手动指定）\n\n\tit(\"The 'toThrow' matcher is for testing if a function throws an exception\", function() {\n    \tvar foo = function() {\n      \treturn 1 + 2;\n    \t};\n    \tvar bar = function() {\n      \t\treturn a + 1;\n    \t};\n\n    \texpect(foo).not.toThrow();\n    \texpect(bar).toThrow();\n\t\t});\n\t}); \n\t//测试一个方法是否抛出异常  \n\n####Setup和Teardown方法####\n为了代码简洁，减少重复性的工作，jasmine提供`beforeEach`和`afterEach`方法。`beforeEach`会在每个spec之前执行，`after`会在每个spec之后执行，类似于selenium中的`beforeMethod`和`afterMethod`方法。  \n    describe(\"A spec (with setup and tear-down)\", function() {\n  \t\tvar foo;\n\n  \t\tbeforeEach(function() {\n    \t\tfoo = 1;\n  \t\t});\n\n  \t\tafterEach(function() {\n    \t\tfoo = 0;\n  \t\t});\n\n  \t\tit(\"is just a function, so it can contain any code\", function() {\n    \t\texpect(foo).toEqual(1);\n  \t\t});\n\n  \t\tit(\"can have more than one expectation\", function() {\n    \t\texpect(foo).toEqual(1);\n    \t\texpect(true).toEqual(true);\n  \t\t});\n\t});  \n另外describe和it作为方法是可以嵌套的，也就是describe中可以出现子describe和it。  \n####禁用某些spec和suites####\n在测试中，我们可能需要禁用一些suites和spec，方法是使用xdescribe和xit方法，这些测试的方法会被忽略，不计入统计结果。  \n####The Runner and Reporter####\nJasmine是用javascript实现的，所以它也必须在javascript的环境中运行，最简单的环境也就是一个web页面。所有的spec都可以在这个页面中运行，这个页面就叫做Runner。  \n\nJasmine通过下面的js代码来展现spec运行结果：  \n\tvar htmlReporter = new jasmine.HtmlReporter(); //创建一个HTMLReporter\n\tjasmineEnv.addReporter(htmlReporter);  \n\n\tjasmineEnv.specFilter = function(spec) {  //一个过滤器，允许我们点击单个的suites，单独运行\n\treturn htmlReporter.specFilter(spec);\n\t};  \n\n\n  \tvar currentWindowOnload = window.onload;   //页面加载完毕后，执行所有的test。\n  \twindow.onload = function() {\n    \tif (currentWindowOnload) {\n      \t\tcurrentWindowOnload();\n    \t}\n\n    \tdocument.querySelector('.version').innerHTML = jasmineEnv.versionString();\n    \texecJasmine();\n  \t};\n\n  \tfunction execJasmine() {\n    \t\tjasmineEnv.execute();\n  \t}\n\t})();\n\n---\n参考文献：<http://pivotal.github.com/jasmine/>   \n感谢：youthflies\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2013-03-22-jasmine-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"Jasmine 简介\"\ndate: 2013-03-22 15:47\ncomments: true\ncategories: nodejs\ntags: [ nodejs, jasmine]\n---\n##jasmine测试框架简介##\n**jasmine**是一种javascript测试框架，它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。\n###jasmine的简单语法###\n一个基本的jasmine测试用例如下：  \n    describe(\"A suite\", function() {  \n  \t\tit(\"contains spec with an expectation\", function() {  \n    \texpect(true).toBe(true);  \n  \t\t});  \n\t});   \n####describe方法####\ndescribe方法标志着一个测试集(test suite)的开始，这个方法有两个参数，一个字符串String，一个方法function；字符串用来描述我们这个test suite，function里的东西就是测试代码，它们就是suite。  \n<!--more-->\n####it方法####\njasmine中用方法it来开始specs（我理解成测试点，一个测试suite里可以有很多spec）。it方法和describe方法类似，同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。一个测试点(spec)可以包含多个expections（其实是断言的意思）。 \n####expectations####\n断言可以返回为true或者false。全部的断言返回true这个测试点就通过，一个或者多个断言返回false这个测试点就不通过。  \ndescribe和it都是方法，我们可以自定义一些变量，在describe中定义的变量，在it方法中可以直接使用。  \n    describe(\"A suite is just a function\", function() {\n\tvar a;\n\n\tit(\"and so is a spec\", function() {\n    \ta = true;\n\n    \texpect(a).toBe(true);\n\t});\n\t});  \n####Matchers####\n一个一个的测试点们由expect开头，后面跟着一个我们需要测试的变量，如上面的a，然后跟着一个Matcher方法（我理解成校验规则），Matcher方法带着一个期望值，如上面的true。Matchers方法返回true或者false，它决定着测试点（spec）是否通过。所有的Matchers方法都能在mathcer前面加上not来进行否定断言，如`expect(a).not.toBe(true);  \n\njasmine中有很多Matchers方法供我们使用，当然我们也可以定义自己的Matchers方法。\n\tdescribe(\"Included matchers:\", function() {\n\n\t\tit(\"The 'toBe' matcher compares with ===\", function() {\n    \t\tvar a = 12;\n    \t\tvar b = a;\n\n    \t\texpect(a).toBe(b);\n    \t\texpect(a).not.toBe(null);\n  \t\t});  \n\t\t//上面的例子，比较a、b是否相等；验证a是否不是空。 \n\n\t\tit(\"should work for objects\", function() {\n      \t\tvar foo = {\n        \t\ta: 12,\n        \t\tb: 34\n      \t\t};\n      \t\tvar bar = {\n        \t\ta: 12,\n       \t \t\tb: 34\n      \t\t};\n      \t\texpect(foo).toEqual(bar);\n    \t});\n\t\t//上面的例子比较了两个对象是否相等\n\t});\n\n\tit(\"The 'toMatch' matcher is for regular expressions\", function() {\n    \tvar message = 'foo bar baz';\n\n    \texpect(message).toMatch(/bar/);\n    \texpect(message).toMatch('bar');\n    \texpect(message).not.toMatch(/quux/);\n\t});\n\t//也可以使用正则表达式\n\n\tit(\"The 'toBeDefined' matcher compares against `undefined`\", function() {\n    \tvar a = {\n      \t\tfoo: 'foo'\n    \t};\n\n    \texpect(a.foo).toBeDefined();\n    \texpect(a.bar).not.toBeDefined();\n\t});\n\t//验证变量是否被定义\n\n\tit(\"The 'toBeNull' matcher compares against null\", function() {\n    \tvar a = null;\n   \t \tvar foo = 'foo';\n\n    \texpect(null).toBeNull();\n    \texpect(a).toBeNull();\n    \texpect(foo).not.toBeNull();\n\t});\n\t//验证是否为空\n\n\tit(\"The 'toBeTruthy' matcher is for boolean casting testing\", function() {\n    \tvar a, foo = 'foo';\n\n    \texpect(foo).toBeTruthy();\n    \texpect(a).not.toBeTruthy();\n\t});\n\n\tit(\"The 'toBeFalsy' matcher is for boolean casting testing\", function() {\n    \tvar a, foo = 'foo';\n\n    \texpect(a).toBeFalsy();\n    \texpect(foo).not.toBeFalsy();\n\t});\n\t//变量是否能够转化成boolean变量？ 不太确定\n\n\tit(\"The 'toContain' matcher is for finding an item in an Array\", function() {\n    \tvar a = ['foo', 'bar', 'baz'];\n\n    \texpect(a).toContain('bar');\n    \texpect(a).not.toContain('quux');\n\t});\n\t//是否包含\n\tit(\"The 'toBeLessThan' matcher is for mathematical comparisons\", function() {\n    \tvar pi = 3.1415926, e = 2.78;\n\n    \texpect(e).toBeLessThan(pi);\n    \texpect(pi).not.toBeLessThan(e);\n\t});\n\n\tit(\"The 'toBeGreaterThan' is for mathematical comparisons\", function() {\n    \tvar pi = 3.1415926, e = 2.78;\n\n    \texpect(pi).toBeGreaterThan(e);\n    \texpect(e).not.toBeGreaterThan(pi);\n\t});\n\t//数学大小的比较\n\n\tit(\"The 'toBeCloseTo' matcher is for precision math comparison\", function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(pi).not.toBeCloseTo(e, 2);\n    expect(pi).toBeCloseTo(e, 0);\n\t});\n\t//两个数值是否接近，这里接近的意思是将pi和e保留一定小数位数后，是否相等。（一定小数位数：默认为2，也可以手动指定）\n\n\tit(\"The 'toThrow' matcher is for testing if a function throws an exception\", function() {\n    \tvar foo = function() {\n      \treturn 1 + 2;\n    \t};\n    \tvar bar = function() {\n      \t\treturn a + 1;\n    \t};\n\n    \texpect(foo).not.toThrow();\n    \texpect(bar).toThrow();\n\t\t});\n\t}); \n\t//测试一个方法是否抛出异常  \n\n####Setup和Teardown方法####\n为了代码简洁，减少重复性的工作，jasmine提供`beforeEach`和`afterEach`方法。`beforeEach`会在每个spec之前执行，`after`会在每个spec之后执行，类似于selenium中的`beforeMethod`和`afterMethod`方法。  \n    describe(\"A spec (with setup and tear-down)\", function() {\n  \t\tvar foo;\n\n  \t\tbeforeEach(function() {\n    \t\tfoo = 1;\n  \t\t});\n\n  \t\tafterEach(function() {\n    \t\tfoo = 0;\n  \t\t});\n\n  \t\tit(\"is just a function, so it can contain any code\", function() {\n    \t\texpect(foo).toEqual(1);\n  \t\t});\n\n  \t\tit(\"can have more than one expectation\", function() {\n    \t\texpect(foo).toEqual(1);\n    \t\texpect(true).toEqual(true);\n  \t\t});\n\t});  \n另外describe和it作为方法是可以嵌套的，也就是describe中可以出现子describe和it。  \n####禁用某些spec和suites####\n在测试中，我们可能需要禁用一些suites和spec，方法是使用xdescribe和xit方法，这些测试的方法会被忽略，不计入统计结果。  \n####The Runner and Reporter####\nJasmine是用javascript实现的，所以它也必须在javascript的环境中运行，最简单的环境也就是一个web页面。所有的spec都可以在这个页面中运行，这个页面就叫做Runner。  \n\nJasmine通过下面的js代码来展现spec运行结果：  \n\tvar htmlReporter = new jasmine.HtmlReporter(); //创建一个HTMLReporter\n\tjasmineEnv.addReporter(htmlReporter);  \n\n\tjasmineEnv.specFilter = function(spec) {  //一个过滤器，允许我们点击单个的suites，单独运行\n\treturn htmlReporter.specFilter(spec);\n\t};  \n\n\n  \tvar currentWindowOnload = window.onload;   //页面加载完毕后，执行所有的test。\n  \twindow.onload = function() {\n    \tif (currentWindowOnload) {\n      \t\tcurrentWindowOnload();\n    \t}\n\n    \tdocument.querySelector('.version').innerHTML = jasmineEnv.versionString();\n    \texecJasmine();\n  \t};\n\n  \tfunction execJasmine() {\n    \t\tjasmineEnv.execute();\n  \t}\n\t})();\n\n---\n参考文献：<http://pivotal.github.com/jasmine/>   \n感谢：youthflies\n\n\n\n\n\n\n\n\n\n\n","slug":"2013-03-22-jasmine-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop550050v8fy7nw5clo1","content":"<p>##jasmine测试框架简介##<br><strong>jasmine</strong>是一种javascript测试框架，它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。</p>\n<p>###jasmine的简单语法###<br>一个基本的jasmine测试用例如下：<br>    describe(“A suite”, function() {<br>          it(“contains spec with an expectation”, function() {<br>        expect(true).toBe(true);<br>          });<br>    });   </p>\n<p>####describe方法####<br>describe方法标志着一个测试集(test suite)的开始，这个方法有两个参数，一个字符串String，一个方法function；字符串用来描述我们这个test suite，function里的东西就是测试代码，它们就是suite。<br><a id=\"more\"></a></p>\n<p>####it方法####<br>jasmine中用方法it来开始specs（我理解成测试点，一个测试suite里可以有很多spec）。it方法和describe方法类似，同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。一个测试点(spec)可以包含多个expections（其实是断言的意思）。 </p>\n<p>####expectations####<br>断言可以返回为true或者false。全部的断言返回true这个测试点就通过，一个或者多个断言返回false这个测试点就不通过。<br>describe和it都是方法，我们可以自定义一些变量，在describe中定义的变量，在it方法中可以直接使用。<br>    describe(“A suite is just a function”, function() {<br>    var a;</p>\n<pre><code>it(&quot;and so is a spec&quot;, function() {\n    a = true;\n\n    expect(a).toBe(true);\n});\n});  \n</code></pre><p>####Matchers####<br>一个一个的测试点们由expect开头，后面跟着一个我们需要测试的变量，如上面的a，然后跟着一个Matcher方法（我理解成校验规则），Matcher方法带着一个期望值，如上面的true。Matchers方法返回true或者false，它决定着测试点（spec）是否通过。所有的Matchers方法都能在mathcer前面加上not来进行否定断言，如`expect(a).not.toBe(true);  </p>\n<p>jasmine中有很多Matchers方法供我们使用，当然我们也可以定义自己的Matchers方法。<br>    describe(“Included matchers:”, function() {</p>\n<pre><code>    it(&quot;The &apos;toBe&apos; matcher compares with ===&quot;, function() {\n        var a = 12;\n        var b = a;\n\n        expect(a).toBe(b);\n        expect(a).not.toBe(null);\n      });  \n    //上面的例子，比较a、b是否相等；验证a是否不是空。 \n\n    it(&quot;should work for objects&quot;, function() {\n          var foo = {\n            a: 12,\n            b: 34\n          };\n          var bar = {\n            a: 12,\n                b: 34\n          };\n          expect(foo).toEqual(bar);\n    });\n    //上面的例子比较了两个对象是否相等\n});\n\nit(&quot;The &apos;toMatch&apos; matcher is for regular expressions&quot;, function() {\n    var message = &apos;foo bar baz&apos;;\n\n    expect(message).toMatch(/bar/);\n    expect(message).toMatch(&apos;bar&apos;);\n    expect(message).not.toMatch(/quux/);\n});\n//也可以使用正则表达式\n\nit(&quot;The &apos;toBeDefined&apos; matcher compares against `undefined`&quot;, function() {\n    var a = {\n          foo: &apos;foo&apos;\n    };\n\n    expect(a.foo).toBeDefined();\n    expect(a.bar).not.toBeDefined();\n});\n//验证变量是否被定义\n\nit(&quot;The &apos;toBeNull&apos; matcher compares against null&quot;, function() {\n    var a = null;\n        var foo = &apos;foo&apos;;\n\n    expect(null).toBeNull();\n    expect(a).toBeNull();\n    expect(foo).not.toBeNull();\n});\n//验证是否为空\n\nit(&quot;The &apos;toBeTruthy&apos; matcher is for boolean casting testing&quot;, function() {\n    var a, foo = &apos;foo&apos;;\n\n    expect(foo).toBeTruthy();\n    expect(a).not.toBeTruthy();\n});\n\nit(&quot;The &apos;toBeFalsy&apos; matcher is for boolean casting testing&quot;, function() {\n    var a, foo = &apos;foo&apos;;\n\n    expect(a).toBeFalsy();\n    expect(foo).not.toBeFalsy();\n});\n//变量是否能够转化成boolean变量？ 不太确定\n\nit(&quot;The &apos;toContain&apos; matcher is for finding an item in an Array&quot;, function() {\n    var a = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];\n\n    expect(a).toContain(&apos;bar&apos;);\n    expect(a).not.toContain(&apos;quux&apos;);\n});\n//是否包含\nit(&quot;The &apos;toBeLessThan&apos; matcher is for mathematical comparisons&quot;, function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(e).toBeLessThan(pi);\n    expect(pi).not.toBeLessThan(e);\n});\n\nit(&quot;The &apos;toBeGreaterThan&apos; is for mathematical comparisons&quot;, function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(pi).toBeGreaterThan(e);\n    expect(e).not.toBeGreaterThan(pi);\n});\n//数学大小的比较\n\nit(&quot;The &apos;toBeCloseTo&apos; matcher is for precision math comparison&quot;, function() {\nvar pi = 3.1415926, e = 2.78;\n\nexpect(pi).not.toBeCloseTo(e, 2);\nexpect(pi).toBeCloseTo(e, 0);\n});\n//两个数值是否接近，这里接近的意思是将pi和e保留一定小数位数后，是否相等。（一定小数位数：默认为2，也可以手动指定）\n\nit(&quot;The &apos;toThrow&apos; matcher is for testing if a function throws an exception&quot;, function() {\n    var foo = function() {\n      return 1 + 2;\n    };\n    var bar = function() {\n          return a + 1;\n    };\n\n    expect(foo).not.toThrow();\n    expect(bar).toThrow();\n    });\n}); \n//测试一个方法是否抛出异常  \n</code></pre><p>####Setup和Teardown方法####<br>为了代码简洁，减少重复性的工作，jasmine提供<code>beforeEach</code>和<code>afterEach</code>方法。<code>beforeEach</code>会在每个spec之前执行，<code>after</code>会在每个spec之后执行，类似于selenium中的<code>beforeMethod</code>和<code>afterMethod</code>方法。<br>    describe(“A spec (with setup and tear-down)”, function() {<br>          var foo;</p>\n<pre><code>      beforeEach(function() {\n        foo = 1;\n      });\n\n      afterEach(function() {\n        foo = 0;\n      });\n\n      it(&quot;is just a function, so it can contain any code&quot;, function() {\n        expect(foo).toEqual(1);\n      });\n\n      it(&quot;can have more than one expectation&quot;, function() {\n        expect(foo).toEqual(1);\n        expect(true).toEqual(true);\n      });\n});  \n</code></pre><p>另外describe和it作为方法是可以嵌套的，也就是describe中可以出现子describe和it。  </p>\n<p>####禁用某些spec和suites####<br>在测试中，我们可能需要禁用一些suites和spec，方法是使用xdescribe和xit方法，这些测试的方法会被忽略，不计入统计结果。  </p>\n<p>####The Runner and Reporter####<br>Jasmine是用javascript实现的，所以它也必须在javascript的环境中运行，最简单的环境也就是一个web页面。所有的spec都可以在这个页面中运行，这个页面就叫做Runner。  </p>\n<p>Jasmine通过下面的js代码来展现spec运行结果：<br>    var htmlReporter = new jasmine.HtmlReporter(); //创建一个HTMLReporter<br>    jasmineEnv.addReporter(htmlReporter);  </p>\n<pre><code>jasmineEnv.specFilter = function(spec) {  //一个过滤器，允许我们点击单个的suites，单独运行\nreturn htmlReporter.specFilter(spec);\n};  \n\n\n  var currentWindowOnload = window.onload;   //页面加载完毕后，执行所有的test。\n  window.onload = function() {\n    if (currentWindowOnload) {\n          currentWindowOnload();\n    }\n\n    document.querySelector(&apos;.version&apos;).innerHTML = jasmineEnv.versionString();\n    execJasmine();\n  };\n\n  function execJasmine() {\n        jasmineEnv.execute();\n  }\n})();\n</code></pre><hr>\n<p>参考文献：<a href=\"http://pivotal.github.com/jasmine/\" target=\"_blank\" rel=\"external\">http://pivotal.github.com/jasmine/</a><br>感谢：youthflies</p>\n","excerpt":"<p>##jasmine测试框架简介##<br><strong>jasmine</strong>是一种javascript测试框架，它既可以在html文件中运行，也可以和jsTestDriver整合，在jsTestDriver中运行。</p>\n<p>###jasmine的简单语法###<br>一个基本的jasmine测试用例如下：<br>    describe(“A suite”, function() {<br>          it(“contains spec with an expectation”, function() {<br>        expect(true).toBe(true);<br>          });<br>    });   </p>\n<p>####describe方法####<br>describe方法标志着一个测试集(test suite)的开始，这个方法有两个参数，一个字符串String，一个方法function；字符串用来描述我们这个test suite，function里的东西就是测试代码，它们就是suite。<br>","more":"</p>\n<p>####it方法####<br>jasmine中用方法it来开始specs（我理解成测试点，一个测试suite里可以有很多spec）。it方法和describe方法类似，同样有两个参数，一个String，一个function；String用来描述测试点（spec），function是具体的测试代码。一个测试点(spec)可以包含多个expections（其实是断言的意思）。 </p>\n<p>####expectations####<br>断言可以返回为true或者false。全部的断言返回true这个测试点就通过，一个或者多个断言返回false这个测试点就不通过。<br>describe和it都是方法，我们可以自定义一些变量，在describe中定义的变量，在it方法中可以直接使用。<br>    describe(“A suite is just a function”, function() {<br>    var a;</p>\n<pre><code>it(&quot;and so is a spec&quot;, function() {\n    a = true;\n\n    expect(a).toBe(true);\n});\n});  \n</code></pre><p>####Matchers####<br>一个一个的测试点们由expect开头，后面跟着一个我们需要测试的变量，如上面的a，然后跟着一个Matcher方法（我理解成校验规则），Matcher方法带着一个期望值，如上面的true。Matchers方法返回true或者false，它决定着测试点（spec）是否通过。所有的Matchers方法都能在mathcer前面加上not来进行否定断言，如`expect(a).not.toBe(true);  </p>\n<p>jasmine中有很多Matchers方法供我们使用，当然我们也可以定义自己的Matchers方法。<br>    describe(“Included matchers:”, function() {</p>\n<pre><code>    it(&quot;The &apos;toBe&apos; matcher compares with ===&quot;, function() {\n        var a = 12;\n        var b = a;\n\n        expect(a).toBe(b);\n        expect(a).not.toBe(null);\n      });  \n    //上面的例子，比较a、b是否相等；验证a是否不是空。 \n\n    it(&quot;should work for objects&quot;, function() {\n          var foo = {\n            a: 12,\n            b: 34\n          };\n          var bar = {\n            a: 12,\n                b: 34\n          };\n          expect(foo).toEqual(bar);\n    });\n    //上面的例子比较了两个对象是否相等\n});\n\nit(&quot;The &apos;toMatch&apos; matcher is for regular expressions&quot;, function() {\n    var message = &apos;foo bar baz&apos;;\n\n    expect(message).toMatch(/bar/);\n    expect(message).toMatch(&apos;bar&apos;);\n    expect(message).not.toMatch(/quux/);\n});\n//也可以使用正则表达式\n\nit(&quot;The &apos;toBeDefined&apos; matcher compares against `undefined`&quot;, function() {\n    var a = {\n          foo: &apos;foo&apos;\n    };\n\n    expect(a.foo).toBeDefined();\n    expect(a.bar).not.toBeDefined();\n});\n//验证变量是否被定义\n\nit(&quot;The &apos;toBeNull&apos; matcher compares against null&quot;, function() {\n    var a = null;\n        var foo = &apos;foo&apos;;\n\n    expect(null).toBeNull();\n    expect(a).toBeNull();\n    expect(foo).not.toBeNull();\n});\n//验证是否为空\n\nit(&quot;The &apos;toBeTruthy&apos; matcher is for boolean casting testing&quot;, function() {\n    var a, foo = &apos;foo&apos;;\n\n    expect(foo).toBeTruthy();\n    expect(a).not.toBeTruthy();\n});\n\nit(&quot;The &apos;toBeFalsy&apos; matcher is for boolean casting testing&quot;, function() {\n    var a, foo = &apos;foo&apos;;\n\n    expect(a).toBeFalsy();\n    expect(foo).not.toBeFalsy();\n});\n//变量是否能够转化成boolean变量？ 不太确定\n\nit(&quot;The &apos;toContain&apos; matcher is for finding an item in an Array&quot;, function() {\n    var a = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;];\n\n    expect(a).toContain(&apos;bar&apos;);\n    expect(a).not.toContain(&apos;quux&apos;);\n});\n//是否包含\nit(&quot;The &apos;toBeLessThan&apos; matcher is for mathematical comparisons&quot;, function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(e).toBeLessThan(pi);\n    expect(pi).not.toBeLessThan(e);\n});\n\nit(&quot;The &apos;toBeGreaterThan&apos; is for mathematical comparisons&quot;, function() {\n    var pi = 3.1415926, e = 2.78;\n\n    expect(pi).toBeGreaterThan(e);\n    expect(e).not.toBeGreaterThan(pi);\n});\n//数学大小的比较\n\nit(&quot;The &apos;toBeCloseTo&apos; matcher is for precision math comparison&quot;, function() {\nvar pi = 3.1415926, e = 2.78;\n\nexpect(pi).not.toBeCloseTo(e, 2);\nexpect(pi).toBeCloseTo(e, 0);\n});\n//两个数值是否接近，这里接近的意思是将pi和e保留一定小数位数后，是否相等。（一定小数位数：默认为2，也可以手动指定）\n\nit(&quot;The &apos;toThrow&apos; matcher is for testing if a function throws an exception&quot;, function() {\n    var foo = function() {\n      return 1 + 2;\n    };\n    var bar = function() {\n          return a + 1;\n    };\n\n    expect(foo).not.toThrow();\n    expect(bar).toThrow();\n    });\n}); \n//测试一个方法是否抛出异常  \n</code></pre><p>####Setup和Teardown方法####<br>为了代码简洁，减少重复性的工作，jasmine提供<code>beforeEach</code>和<code>afterEach</code>方法。<code>beforeEach</code>会在每个spec之前执行，<code>after</code>会在每个spec之后执行，类似于selenium中的<code>beforeMethod</code>和<code>afterMethod</code>方法。<br>    describe(“A spec (with setup and tear-down)”, function() {<br>          var foo;</p>\n<pre><code>      beforeEach(function() {\n        foo = 1;\n      });\n\n      afterEach(function() {\n        foo = 0;\n      });\n\n      it(&quot;is just a function, so it can contain any code&quot;, function() {\n        expect(foo).toEqual(1);\n      });\n\n      it(&quot;can have more than one expectation&quot;, function() {\n        expect(foo).toEqual(1);\n        expect(true).toEqual(true);\n      });\n});  \n</code></pre><p>另外describe和it作为方法是可以嵌套的，也就是describe中可以出现子describe和it。  </p>\n<p>####禁用某些spec和suites####<br>在测试中，我们可能需要禁用一些suites和spec，方法是使用xdescribe和xit方法，这些测试的方法会被忽略，不计入统计结果。  </p>\n<p>####The Runner and Reporter####<br>Jasmine是用javascript实现的，所以它也必须在javascript的环境中运行，最简单的环境也就是一个web页面。所有的spec都可以在这个页面中运行，这个页面就叫做Runner。  </p>\n<p>Jasmine通过下面的js代码来展现spec运行结果：<br>    var htmlReporter = new jasmine.HtmlReporter(); //创建一个HTMLReporter<br>    jasmineEnv.addReporter(htmlReporter);  </p>\n<pre><code>jasmineEnv.specFilter = function(spec) {  //一个过滤器，允许我们点击单个的suites，单独运行\nreturn htmlReporter.specFilter(spec);\n};  \n\n\n  var currentWindowOnload = window.onload;   //页面加载完毕后，执行所有的test。\n  window.onload = function() {\n    if (currentWindowOnload) {\n          currentWindowOnload();\n    }\n\n    document.querySelector(&apos;.version&apos;).innerHTML = jasmineEnv.versionString();\n    execJasmine();\n  };\n\n  function execJasmine() {\n        jasmineEnv.execute();\n  }\n})();\n</code></pre><hr>\n<p>参考文献：<a href=\"http://pivotal.github.com/jasmine/\">http://pivotal.github.com/jasmine/</a><br>感谢：youthflies</p>"},{"layout":"post","title":"开始第一个Jenkins Plugin","date":"2013-03-22T08:48:00.000Z","comments":1,"_content":"##一，Jenkins插件的结构\nJenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：   \n\t\n\txxx.hpi\n\t+- META-INF\n\t|\t+-MANIFEST.MF\n\t+- WEB-INF\n\t|\t+- classes\n\t|\t\t+- index.jelly\n\t|\t\t+- XXXX.class\n\t|\t+- lib\n\t+-\t(static resources)\n说明：   \n   \n+ 1.插件的后缀为\".hpi\",文件名（xxx部分）是插件的简写名字，用来区分插件。\n+ 2.如上图结构所示，它与war包类似，只是缺少web.xml。\n+ 3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。\n+ 4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面\n+ 5.WEB-INF/lib 包含插件中需要的.jar文件\n+ 6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。\n<!--more-->\n##二，Jenkins-Plugins的开发\nJenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。\n###2.1 Jenkins插件开发时的环境配置\nJenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。\n####2.1.1 JDK配置\nJDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：   \n\t\n\tJAVA_HOME = C:\\Program Files (x86)\\Java\\jdk1.6.0_38   \n\tCLASSPATH = ...;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   \n\tPATH = ...;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   \n\n####2.1.2 Maven的配置   \n\n\tM2_HOME =  D:\\maven\n\tM2 = %M2_HOME%\\bin\n\tMAVEN_OPTS  = -Xms256m -Xmx512m\n\n\tCLASSPATH = ...;%M2%   \n\tPATH = ...;%M2%   \n\n可以通过`mvn --version`,查看maven是否配置成功。\n\n####2.1.3 Maven开发环境的配置\n在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：   \n\n\t<settings>\n\t  <pluginGroups>\n\t    <pluginGroup>org.jenkins-ci.tools</pluginGroup>\n\t  </pluginGroups>\n\t\n\t  <profiles>\n\t    <!-- Give access to Jenkins plugins -->\n\t    <profile>\n\t      <id>jenkins</id>\n\t      <activation>\n\t        <activeByDefault>true</activeByDefault> <!-- change this to false, if you don't like to have it on per default -->\n\t      </activation>\n\t      <repositories>\n\t        <repository>\n\t          <id>repo.jenkins-ci.org</id>\n\t          <url>http://repo.jenkins-ci.org/public/</url>\n\t        </repository>\n\t      </repositories>\n\t      <pluginRepositories>\n\t        <pluginRepository>\n\t          <id>repo.jenkins-ci.org</id>\n\t          <url>http://repo.jenkins-ci.org/public/</url>\n\t        </pluginRepository>\n\t      </pluginRepositories>\n\t    </profile>\n\t  </profiles>\n\t  <mirrors>\n\t    <mirror>\n\t      <id>repo.jenkins-ci.org</id>\n\t      <url>http://repo.jenkins-ci.org/public/</url>\n\t      <mirrorOf>m.g.o-public</mirrorOf>\n\t    </mirror>\n\t  </mirrors>\n\t</settings>\n\n###2.2 生成插件的框架程序   \n配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：   \n\n\tmvn hpi:create\n \n\tEnter the groupId of your plugin: com.baidu.ite.hudson\n\tEnter the artifactId of your plugin: samplePlugin\n\n这样会建立一个工程，名字为`samplePlugin`,包路径`com.baidu.ite.hudson`。   \n或者使用如下的命令：   \n   \n\tmvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}\n说明：   \n1，-u代表jenkins需要更新自己所有的插件内容。   \n2，jenkins中提供的archetype-resources，文件的名字为`HelloWorldBuilder.java`。我们需要手工修改成自己需要的内容。\n####2.2.1 代码结构\n使用 hpi:create生成的文件结构如下：   \n\n\t+- src \n\t|\t+- main \n\t|\t|\t+- java\n\t|\t|\t|\t+- groupId.HelloWorldBuilder.java \n\t|\t|\t+- resources \n\t|\t|\t|\t+-  groupId.HelloWorldBuilder\n   \t|\t|\t|\t|\t+- config.jelly\n    |\t|\t|\t|\t+- help-name.html \n\t|\t|\t|\t+- index.jelly \n\nJenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。 \n  \n####2.2.2 代码的解释\n\t数据的绑定：   \n\t\n\t<!--config.jelly-->\n\t<f:entry title=\"Name\" field=\"name\">\n    \t<f:textbox />\n  \t</f:entry>\n\t\n\t//--HelloWorldBuilder.java--\n    @DataBoundConstructor\n    public HelloWorldBuilder(String name) {\n        this.name = name;\n    }\n首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。\n\t\n\tJenkins插件任务的执行\n\n\t@Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n        // This is where you 'build' the project.\n\n        // This also shows how you can consult the global configuration of the builder\n            listener.getLogger().println(\"Hello, \"+name+\"!\");\n        return true;\n    }\n根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。\n\t\n\t传入数据的检查\n\t\t\n\t public FormValidation doCheckName(@QueryParameter String value)\n\t                throws IOException, ServletException {\n\t            if (value.length() == 0)\n\t                return FormValidation.error(\"Please set a name\");\n\t            if (value.length() < 4)\n\t                return FormValidation.warning(\"Isn't the name too short?\");\n\t            return FormValidation.ok();\n\t        }\n\t\n在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。\n###2.3 转换为eclipse工程\n为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：   \n\n\tmvn eclipse:eclipse\n\t或者\n\tmvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse\n第二条较长的命令中，参数是可选的。\n\t\t\n###2.4 生成hpi文件\n使用如下命令可以生成`./target/pluginname.hpi`:   \n\t\n\tmvn install\n\t或者\n\tmvn package \n其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。\n\n###2.5 使用.hpl进行调试\nmaven中使用`.hpl（hudson plugin link）`格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似`META-INF/MANIFEST.MF`的说明文件`../path/to/your/plugin/workspace/manifest-debug.mf`。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。   \n在maven中可以使用命令：    \n\n\tmvn hpi:hpl -DhudsonHome=/...\n\n###2.6 使用.hpi进行测试\n在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：   \n\n\tmvn hpi:run -DhudsonHome=/...\n\n说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。\n\n---\n致谢:lizejun\n\n\n\t","source":"_posts/2013-03-22-jenkins-plugin-start.markdown","raw":"---\nlayout: post\ntitle: \"开始第一个Jenkins Plugin\"\ndate: 2013-03-22 16:48\ncomments: true\ncategories: jenkins\ntags: [ jenkins, hudson, ci, plugins ]\n---\n##一，Jenkins插件的结构\nJenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：   \n\t\n\txxx.hpi\n\t+- META-INF\n\t|\t+-MANIFEST.MF\n\t+- WEB-INF\n\t|\t+- classes\n\t|\t\t+- index.jelly\n\t|\t\t+- XXXX.class\n\t|\t+- lib\n\t+-\t(static resources)\n说明：   \n   \n+ 1.插件的后缀为\".hpi\",文件名（xxx部分）是插件的简写名字，用来区分插件。\n+ 2.如上图结构所示，它与war包类似，只是缺少web.xml。\n+ 3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。\n+ 4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面\n+ 5.WEB-INF/lib 包含插件中需要的.jar文件\n+ 6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。\n<!--more-->\n##二，Jenkins-Plugins的开发\nJenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。\n###2.1 Jenkins插件开发时的环境配置\nJenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。\n####2.1.1 JDK配置\nJDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：   \n\t\n\tJAVA_HOME = C:\\Program Files (x86)\\Java\\jdk1.6.0_38   \n\tCLASSPATH = ...;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   \n\tPATH = ...;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   \n\n####2.1.2 Maven的配置   \n\n\tM2_HOME =  D:\\maven\n\tM2 = %M2_HOME%\\bin\n\tMAVEN_OPTS  = -Xms256m -Xmx512m\n\n\tCLASSPATH = ...;%M2%   \n\tPATH = ...;%M2%   \n\n可以通过`mvn --version`,查看maven是否配置成功。\n\n####2.1.3 Maven开发环境的配置\n在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：   \n\n\t<settings>\n\t  <pluginGroups>\n\t    <pluginGroup>org.jenkins-ci.tools</pluginGroup>\n\t  </pluginGroups>\n\t\n\t  <profiles>\n\t    <!-- Give access to Jenkins plugins -->\n\t    <profile>\n\t      <id>jenkins</id>\n\t      <activation>\n\t        <activeByDefault>true</activeByDefault> <!-- change this to false, if you don't like to have it on per default -->\n\t      </activation>\n\t      <repositories>\n\t        <repository>\n\t          <id>repo.jenkins-ci.org</id>\n\t          <url>http://repo.jenkins-ci.org/public/</url>\n\t        </repository>\n\t      </repositories>\n\t      <pluginRepositories>\n\t        <pluginRepository>\n\t          <id>repo.jenkins-ci.org</id>\n\t          <url>http://repo.jenkins-ci.org/public/</url>\n\t        </pluginRepository>\n\t      </pluginRepositories>\n\t    </profile>\n\t  </profiles>\n\t  <mirrors>\n\t    <mirror>\n\t      <id>repo.jenkins-ci.org</id>\n\t      <url>http://repo.jenkins-ci.org/public/</url>\n\t      <mirrorOf>m.g.o-public</mirrorOf>\n\t    </mirror>\n\t  </mirrors>\n\t</settings>\n\n###2.2 生成插件的框架程序   \n配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：   \n\n\tmvn hpi:create\n \n\tEnter the groupId of your plugin: com.baidu.ite.hudson\n\tEnter the artifactId of your plugin: samplePlugin\n\n这样会建立一个工程，名字为`samplePlugin`,包路径`com.baidu.ite.hudson`。   \n或者使用如下的命令：   \n   \n\tmvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}\n说明：   \n1，-u代表jenkins需要更新自己所有的插件内容。   \n2，jenkins中提供的archetype-resources，文件的名字为`HelloWorldBuilder.java`。我们需要手工修改成自己需要的内容。\n####2.2.1 代码结构\n使用 hpi:create生成的文件结构如下：   \n\n\t+- src \n\t|\t+- main \n\t|\t|\t+- java\n\t|\t|\t|\t+- groupId.HelloWorldBuilder.java \n\t|\t|\t+- resources \n\t|\t|\t|\t+-  groupId.HelloWorldBuilder\n   \t|\t|\t|\t|\t+- config.jelly\n    |\t|\t|\t|\t+- help-name.html \n\t|\t|\t|\t+- index.jelly \n\nJenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。 \n  \n####2.2.2 代码的解释\n\t数据的绑定：   \n\t\n\t<!--config.jelly-->\n\t<f:entry title=\"Name\" field=\"name\">\n    \t<f:textbox />\n  \t</f:entry>\n\t\n\t//--HelloWorldBuilder.java--\n    @DataBoundConstructor\n    public HelloWorldBuilder(String name) {\n        this.name = name;\n    }\n首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。\n\t\n\tJenkins插件任务的执行\n\n\t@Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n        // This is where you 'build' the project.\n\n        // This also shows how you can consult the global configuration of the builder\n            listener.getLogger().println(\"Hello, \"+name+\"!\");\n        return true;\n    }\n根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。\n\t\n\t传入数据的检查\n\t\t\n\t public FormValidation doCheckName(@QueryParameter String value)\n\t                throws IOException, ServletException {\n\t            if (value.length() == 0)\n\t                return FormValidation.error(\"Please set a name\");\n\t            if (value.length() < 4)\n\t                return FormValidation.warning(\"Isn't the name too short?\");\n\t            return FormValidation.ok();\n\t        }\n\t\n在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。\n###2.3 转换为eclipse工程\n为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：   \n\n\tmvn eclipse:eclipse\n\t或者\n\tmvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse\n第二条较长的命令中，参数是可选的。\n\t\t\n###2.4 生成hpi文件\n使用如下命令可以生成`./target/pluginname.hpi`:   \n\t\n\tmvn install\n\t或者\n\tmvn package \n其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。\n\n###2.5 使用.hpl进行调试\nmaven中使用`.hpl（hudson plugin link）`格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似`META-INF/MANIFEST.MF`的说明文件`../path/to/your/plugin/workspace/manifest-debug.mf`。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。   \n在maven中可以使用命令：    \n\n\tmvn hpi:hpl -DhudsonHome=/...\n\n###2.6 使用.hpi进行测试\n在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：   \n\n\tmvn hpi:run -DhudsonHome=/...\n\n说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。\n\n---\n致谢:lizejun\n\n\n\t","slug":"2013-03-22-jenkins-plugin-start","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop570054v8fyaoehwp2h","content":"<p>##一，Jenkins插件的结构<br>Jenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：   </p>\n<pre><code>xxx.hpi\n+- META-INF\n|    +-MANIFEST.MF\n+- WEB-INF\n|    +- classes\n|        +- index.jelly\n|        +- XXXX.class\n|    +- lib\n+-    (static resources)\n</code></pre><p>说明：   </p>\n<ul>\n<li>1.插件的后缀为”.hpi”,文件名（xxx部分）是插件的简写名字，用来区分插件。</li>\n<li>2.如上图结构所示，它与war包类似，只是缺少web.xml。</li>\n<li>3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。</li>\n<li>4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面</li>\n<li>5.WEB-INF/lib 包含插件中需要的.jar文件</li>\n<li><p>6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。</p>\n<a id=\"more\"></a>\n<p>##二，Jenkins-Plugins的开发<br>Jenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。<br>###2.1 Jenkins插件开发时的环境配置<br>Jenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。<br>####2.1.1 JDK配置<br>JDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：   </p>\n<p>  JAVA_HOME = C:\\Program Files (x86)\\Java\\jdk1.6.0_38<br>  CLASSPATH = …;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;<br>  PATH = …;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   </p>\n</li>\n</ul>\n<p>####2.1.2 Maven的配置   </p>\n<pre><code>M2_HOME =  D:\\maven\nM2 = %M2_HOME%\\bin\nMAVEN_OPTS  = -Xms256m -Xmx512m\n\nCLASSPATH = ...;%M2%   \nPATH = ...;%M2%   \n</code></pre><p>可以通过<code>mvn --version</code>,查看maven是否配置成功。</p>\n<p>####2.1.3 Maven开发环境的配置<br>在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：   </p>\n<pre><code>&lt;settings&gt;\n  &lt;pluginGroups&gt;\n    &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;\n  &lt;/pluginGroups&gt;\n\n  &lt;profiles&gt;\n    &lt;!-- Give access to Jenkins plugins --&gt;\n    &lt;profile&gt;\n      &lt;id&gt;jenkins&lt;/id&gt;\n      &lt;activation&gt;\n        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don&apos;t like to have it on per default --&gt;\n      &lt;/activation&gt;\n      &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n        &lt;/repository&gt;\n      &lt;/repositories&gt;\n      &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n        &lt;/pluginRepository&gt;\n      &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt;\n  &lt;mirrors&gt;\n    &lt;mirror&gt;\n      &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n      &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n      &lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;\n    &lt;/mirror&gt;\n  &lt;/mirrors&gt;\n&lt;/settings&gt;\n</code></pre><p>###2.2 生成插件的框架程序<br>配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：   </p>\n<pre><code>mvn hpi:create\n\nEnter the groupId of your plugin: com.baidu.ite.hudson\nEnter the artifactId of your plugin: samplePlugin\n</code></pre><p>这样会建立一个工程，名字为<code>samplePlugin</code>,包路径<code>com.baidu.ite.hudson</code>。<br>或者使用如下的命令：   </p>\n<pre><code>mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}\n</code></pre><p>说明：<br>1，-u代表jenkins需要更新自己所有的插件内容。<br>2，jenkins中提供的archetype-resources，文件的名字为<code>HelloWorldBuilder.java</code>。我们需要手工修改成自己需要的内容。</p>\n<p>####2.2.1 代码结构<br>使用 hpi:create生成的文件结构如下：   </p>\n<pre><code>+- src \n|    +- main \n|    |    +- java\n|    |    |    +- groupId.HelloWorldBuilder.java \n|    |    +- resources \n|    |    |    +-  groupId.HelloWorldBuilder\n   |    |    |    |    +- config.jelly\n|    |    |    |    +- help-name.html \n|    |    |    +- index.jelly \n</code></pre><p>Jenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。 </p>\n<p>####2.2.2 代码的解释<br>    数据的绑定：   </p>\n<pre><code>&lt;!--config.jelly--&gt;\n&lt;f:entry title=&quot;Name&quot; field=&quot;name&quot;&gt;\n    &lt;f:textbox /&gt;\n  &lt;/f:entry&gt;\n\n//--HelloWorldBuilder.java--\n@DataBoundConstructor\npublic HelloWorldBuilder(String name) {\n    this.name = name;\n}\n</code></pre><p>首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。</p>\n<pre><code>Jenkins插件任务的执行\n\n@Override\npublic boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n    // This is where you &apos;build&apos; the project.\n\n    // This also shows how you can consult the global configuration of the builder\n        listener.getLogger().println(&quot;Hello, &quot;+name+&quot;!&quot;);\n    return true;\n}\n</code></pre><p>根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。</p>\n<pre><code>传入数据的检查\n\n public FormValidation doCheckName(@QueryParameter String value)\n                throws IOException, ServletException {\n            if (value.length() == 0)\n                return FormValidation.error(&quot;Please set a name&quot;);\n            if (value.length() &lt; 4)\n                return FormValidation.warning(&quot;Isn&apos;t the name too short?&quot;);\n            return FormValidation.ok();\n        }\n</code></pre><p>在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。</p>\n<p>###2.3 转换为eclipse工程<br>为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：   </p>\n<pre><code>mvn eclipse:eclipse\n或者\nmvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse\n</code></pre><p>第二条较长的命令中，参数是可选的。</p>\n<p>###2.4 生成hpi文件<br>使用如下命令可以生成<code>./target/pluginname.hpi</code>:   </p>\n<pre><code>mvn install\n或者\nmvn package \n</code></pre><p>其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。</p>\n<p>###2.5 使用.hpl进行调试<br>maven中使用<code>.hpl（hudson plugin link）</code>格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似<code>META-INF/MANIFEST.MF</code>的说明文件<code>../path/to/your/plugin/workspace/manifest-debug.mf</code>。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。<br>在maven中可以使用命令：    </p>\n<pre><code>mvn hpi:hpl -DhudsonHome=/...\n</code></pre><p>###2.6 使用.hpi进行测试<br>在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：   </p>\n<pre><code>mvn hpi:run -DhudsonHome=/...\n</code></pre><p>说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。</p>\n<hr>\n<p>致谢:lizejun</p>\n","excerpt":"<p>##一，Jenkins插件的结构<br>Jenkins插件实际上是一个按照一定规则组织的jar包，其结构如下：   </p>\n<pre><code>xxx.hpi\n+- META-INF\n|    +-MANIFEST.MF\n+- WEB-INF\n|    +- classes\n|        +- index.jelly\n|        +- XXXX.class\n|    +- lib\n+-    (static resources)\n</code></pre><p>说明：   </p>\n<ul>\n<li>1.插件的后缀为”.hpi”,文件名（xxx部分）是插件的简写名字，用来区分插件。</li>\n<li>2.如上图结构所示，它与war包类似，只是缺少web.xml。</li>\n<li>3.MANIFEST.MF包含一些入口的配置信息。其中有继承自Jenkins插件的类，用作实例化的入口。类的全名，用作我们去区分其他插件。</li>\n<li>4.WEB-INF/classes 用来包含插件需要的.class，jelly页面等内容。它们可以封装成jar包放到WEB-INF/lib下面</li>\n<li>5.WEB-INF/lib 包含插件中需要的.jar文件</li>\n<li><p>6.插件需要的静态文件如图片，HTML，css样式文件，JS文件等可以放到文件的根目录下面。</p>","more":"<p>##二，Jenkins-Plugins的开发<br>Jenkins插件的开发，使用maven来进行项目的管理和构建。如下罗列了其中需要的步骤。<br>###2.1 Jenkins插件开发时的环境配置<br>Jenkins插件开发，需要JDK和Maven环境。下面以windows下的环境配置为例说明。<br>####2.1.1 JDK配置<br>JDK的版本要求在1.6以上，需要在配置文件中配置JDK的变量：   </p>\n<p>  JAVA_HOME = C:\\Program Files (x86)\\Java\\jdk1.6.0_38<br>  CLASSPATH = …;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;<br>  PATH = …;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;   </p>\n</li>\n</ul>\n<p>####2.1.2 Maven的配置   </p>\n<pre><code>M2_HOME =  D:\\maven\nM2 = %M2_HOME%\\bin\nMAVEN_OPTS  = -Xms256m -Xmx512m\n\nCLASSPATH = ...;%M2%   \nPATH = ...;%M2%   \n</code></pre><p>可以通过<code>mvn --version</code>,查看maven是否配置成功。</p>\n<p>####2.1.3 Maven开发环境的配置<br>在~/.m2/settings.xml中，或者/maven/conf/settings.xml中，配置如下的Jenkins库依赖：   </p>\n<pre><code>&lt;settings&gt;\n  &lt;pluginGroups&gt;\n    &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;\n  &lt;/pluginGroups&gt;\n\n  &lt;profiles&gt;\n    &lt;!-- Give access to Jenkins plugins --&gt;\n    &lt;profile&gt;\n      &lt;id&gt;jenkins&lt;/id&gt;\n      &lt;activation&gt;\n        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don&apos;t like to have it on per default --&gt;\n      &lt;/activation&gt;\n      &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n        &lt;/repository&gt;\n      &lt;/repositories&gt;\n      &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n          &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n          &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n        &lt;/pluginRepository&gt;\n      &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt;\n  &lt;mirrors&gt;\n    &lt;mirror&gt;\n      &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;\n      &lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;\n      &lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;\n    &lt;/mirror&gt;\n  &lt;/mirrors&gt;\n&lt;/settings&gt;\n</code></pre><p>###2.2 生成插件的框架程序<br>配置好maven后，即可使用maven命令建立插件的框架，并且命令行会提示你输入groupId和artifactId：   </p>\n<pre><code>mvn hpi:create\n\nEnter the groupId of your plugin: com.baidu.ite.hudson\nEnter the artifactId of your plugin: samplePlugin\n</code></pre><p>这样会建立一个工程，名字为<code>samplePlugin</code>,包路径<code>com.baidu.ite.hudson</code>。<br>或者使用如下的命令：   </p>\n<pre><code>mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId={your.gound.id} -DartifactId={your.plugin.id}\n</code></pre><p>说明：<br>1，-u代表jenkins需要更新自己所有的插件内容。<br>2，jenkins中提供的archetype-resources，文件的名字为<code>HelloWorldBuilder.java</code>。我们需要手工修改成自己需要的内容。</p>\n<p>####2.2.1 代码结构<br>使用 hpi:create生成的文件结构如下：   </p>\n<pre><code>+- src \n|    +- main \n|    |    +- java\n|    |    |    +- groupId.HelloWorldBuilder.java \n|    |    +- resources \n|    |    |    +-  groupId.HelloWorldBuilder\n   |    |    |    |    +- config.jelly\n|    |    |    |    +- help-name.html \n|    |    |    +- index.jelly \n</code></pre><p>Jenkins定义了一些扩展点（Extension Points）,这些扩展点是接口或者抽象类。你可以根据自己的需要来修改文件的名字和扩展点。我们使用命令生成的框架程序中，HelloWorldBuilder继承了Builder。 </p>\n<p>####2.2.2 代码的解释<br>    数据的绑定：   </p>\n<pre><code>&lt;!--config.jelly--&gt;\n&lt;f:entry title=&quot;Name&quot; field=&quot;name&quot;&gt;\n    &lt;f:textbox /&gt;\n  &lt;/f:entry&gt;\n\n//--HelloWorldBuilder.java--\n@DataBoundConstructor\npublic HelloWorldBuilder(String name) {\n    this.name = name;\n}\n</code></pre><p>首先，在config.jelly中包含需要传入的参数配置信息的文本框，field为name，这样可以在Jenkins中进行配置，然后通过DataBoundConstructor的方式，传到类中。</p>\n<pre><code>Jenkins插件任务的执行\n\n@Override\npublic boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) {\n    // This is where you &apos;build&apos; the project.\n\n    // This also shows how you can consult the global configuration of the builder\n        listener.getLogger().println(&quot;Hello, &quot;+name+&quot;!&quot;);\n    return true;\n}\n</code></pre><p>根据注释可以了解：该处是你在Job进行构建时进行操作的地方，并且这里可以根据你在配置中的设置执行你需要的工作。通常，根据需要修改perform函数即可。</p>\n<pre><code>传入数据的检查\n\n public FormValidation doCheckName(@QueryParameter String value)\n                throws IOException, ServletException {\n            if (value.length() == 0)\n                return FormValidation.error(&quot;Please set a name&quot;);\n            if (value.length() &lt; 4)\n                return FormValidation.warning(&quot;Isn&apos;t the name too short?&quot;);\n            return FormValidation.ok();\n        }\n</code></pre><p>在该函数中，实现在配置页面中填写内容时，进行校验的过程。如函数所述，当填入内容为空时，提示：Please set a name。你可以根据你的需要进行逻辑的控制。</p>\n<p>###2.3 转换为eclipse工程<br>为了便于在编辑器中进行修改，我们需要将生成的maven代码转化为eclipse工程，使用的命令如下：   </p>\n<pre><code>mvn eclipse:eclipse\n或者\nmvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse\n</code></pre><p>第二条较长的命令中，参数是可选的。</p>\n<p>###2.4 生成hpi文件<br>使用如下命令可以生成<code>./target/pluginname.hpi</code>:   </p>\n<pre><code>mvn install\n或者\nmvn package \n</code></pre><p>其中mvn install 生成hpi文件，并放置到本地maven仓库中，mvn package只进行打包操作。</p>\n<p>###2.5 使用.hpl进行调试<br>maven中使用<code>.hpl（hudson plugin link）</code>格式来进行插件的调试。hpl文件中只包含一个链接，链接到类似<code>META-INF/MANIFEST.MF</code>的说明文件<code>../path/to/your/plugin/workspace/manifest-debug.mf</code>。该文件其中额外定义了一些属性来指定文件目录位置,这样资源的修改可以立即生效（需要配置stapler.jelly.noCache=true），不需要重新打包安装。<br>在maven中可以使用命令：    </p>\n<pre><code>mvn hpi:hpl -DhudsonHome=/...\n</code></pre><p>###2.6 使用.hpi进行测试<br>在调试通过后，可以使用.hpi文件来启动jenkins,查看结果，命令如下：   </p>\n<pre><code>mvn hpi:run -DhudsonHome=/...\n</code></pre><p>说明：-DhudsonHome可以不选，默认Jenkins安装到工程的./target目录中。</p>\n<hr>\n<p>致谢:lizejun</p>"},{"layout":"post","title":"Qunit 简介","date":"2013-03-22T07:21:00.000Z","comments":1,"_content":"#QUnit\nQUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。   \n[项目官网](http://qunitjs.com/)   \n[文件下载地址](https://github.com/jquery/qunit)   \n#建立测试程序\n建立html测试页面，引入 `qunit.js` 和 `qunit.css` 这两个必需的文件。其中`qunit.js`是测试套件程序，`qunit.css`用于控制测试套件的结果显示的样式。    \n\t\n\t<!--sample.html:-->\n\t<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t  <title>QUnit basic example</title>\n\t  <link rel=\"stylesheet\" href=\"./resources/qunit.css\">\n\t<script type=\"text/javascript\" src=\"./resources/jquery.js\"></script>\n\t</head>\n\t<body>\n\t  <div id=\"qunit\"></div>\n\t  <div id=\"qunit-fixture\"></div>\n\t  <script src=\"./resources/qunit.js\"></script>\n\t  <script>\n\t    test( \"a basic test example\", function() {\n\t      var value = \"hello\";\n\t      equal( value, \"hello\", \"We expect value to be hello\" );\n\t    });\n\t  </script>\n\t</body>\n\t</html>\n<!--more-->\n其中放置的文件及文件结构如下：     \n  \n\t|-qunit-test   \n\t|  |-sample.html   \n\t|  |-resources   \n\t|  |    |-qunit.js   \n\t|  |    |-qunit.css\n    |  |    |-jquery.js   \n\n测试的结果会由`qunit.js`控制输出到页面代码中的`<div id=\"qunit\"></div>`中。另外一个必不可少的元素是`<div id=\"\"qunit-fixture\"\"></div>`。在每个test执行完毕后，如果改动了该元素，会自动重置。`jquery.js`的引入是为了测试使用jQuery语法写的程序。   \n在浏览器中打开sample1.html可以看到结果显示如下图所示：   \n![qunit的用例运行显示结果](/images/blog/qunit-pic.png)   \n#测试框架使用说明   \n标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。   \n下面是3个checkbox。\"Hide passed tests\"点击后可以过滤掉通过的用例，只显示失败的用例。\"Check for Globals\"，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。\"No try-catch\"用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。   \n#断言   \n- **ok( truthy [, message ] )**   判断是否为true   \n- **equal( actual, expected [, message ] )**    判断actual==expected   \n- **deepEqual( actual, expected [, message ] )**    判断actual===expected\n   \n用例如下：   \n\ttest(\"assertion\",function(){   \n\n\t\tok( true, \"true succeeds\" );\n\t    ok( NaN, \"NaN fails\" );\n\t   \n\t    equal( 0, 0, \"0, 0 : equal succeeds\" );\n\t\tequal( \"\", 0, \"Empty, 0: equal succeeds\" );\n\t    equal( null, \"\", \"null, empty: equal fails\" );\n\t  \n\t    var obj = { foo: \"bar\" };\n\t    deepEqual( obj, { foo: \"bar\" }, \"Two objects can be the same in value\" );\n\t\tequal( \"\", 0, \"Empty, 0: equal succeeds\" );\n\t});    \n\n#测试同步代码   \n在同步代码的测试中，有两种方式：   \n-   test( name, expected, fucntion(){...})：expceted指assertion的数量。   \n-   test( name, function(){expected(amount);...})：在function中增加expected(amount)，amount表示assertiong的数量。   \n\ntest()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。   \n\t\n\ttest( \"a test\", 2, function() {\n\t\tok( true, \"sucess\" );\n\t\tok( false, \"fail\" );\n\t});   \n\n\ttest( \"a test\", function() {\n\t  expect( 2 );\n\t \n\t  function calc( x, operation ) {\n\t    return operation( x );\n\t  }\n\t \n\t  var result = calc( 2, function( x ) {\n\t    ok( true, \"calc() calls operation function\" );\n\t    return x * x;\n\t  });\n\t \n\t  equal( result, 4, \"2 square equals 4\" );\n\t});\n\n\n#测试异步代码\n对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。   \n\n\tasyncTest( \"asynchronous test: one second later!\", function() {\n\t  expect( 1 );\n\t \n\t  setTimeout(function() {\n\t     ok( true, \"Passed and ready to resume!\" );\n\t     start();\n\t  }, 1000);\n\t});      \n\n#用户行为的测试\n测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用`trigger()`或者`triggerHandler()`来实现。\t\n   \n\ttest( \"div click test\", 1, function() {\n\t  var $body = $( \"#qunit-fixture\" );\n\t \n\t  $body.bind( \"click\", function() {\n\t\tok( true, \"body was clicked!\" );\n\t  });\n\t \n\t  $body.trigger( \"click\" );\n\t});\n下面是Qunit中的一个demo例子，其中模拟了一个key的记录器`KeyLogger()`，在test中初始化了一个事件event，并且使触发了两次，：   \n\n\tfunction KeyLogger( target ) {\n\t  if ( !(this instanceof KeyLogger) ) {\n\t\treturn new KeyLogger( target );\n\t  }\n\t  this.target = target;\n\t  this.log = [];\n\t \n\t  var self = this;\n\t \n\t  this.target.bind( \"keydown\", function( event ) {\n\t\tself.log.push( event.keyCode );\n\t  });\n\t}\n\ttest( \"keylogger api behavior\", function() {\n\t \n\t  var event,\n\t\t  $doc = $( document ),\n\t\t  keys = KeyLogger( $doc );\n\t \n\t  // trigger event\n\t  event = $.Event( \"keydown\" );\n\t  \n\t  event.keyCode = 'A';\n\t  $doc.trigger( event );\n\t  $doc.trigger( event );\n\t \n\t  // verify expected behavior\n\t  equal( keys.log.length, 2, \"2 key was logged\" );\n\t  equal( keys.log[ 0 ], 'A', \"correct key was logged\" );\n\t \n\t});   \n#模块化   \n为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。   \n   \n\tmodule( \"group a\" );\n\ttest( \"a basic test example\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\ttest( \"a basic test example 2\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\t \n\tmodule( \"group b\" );\n\ttest( \"a basic test example 3\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\ttest( \"a basic test example 4\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\n除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。   \n   \n\tmodule( \"module\", {\n\t  setup: function() {\n\t    ok( true, \"one extra assert per test\" );\n\t  }, teardown: function() {\n\t    ok( true, \"and one extra assert after each test\" );\n\t  }\n\t});\n\ttest( \"test with setup and teardown\", function() {\n\t  expect( 3 );\n\t  ok( true, \"test\" );\n\t});\n\n#推荐使用的框架程序\t\n最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码`myProject.js`和测试代码`myTests.js`。 \n\n\t<!--sample-framework.html:-->\n\t<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t  <title>QUnit basic example</title>\n\t  <link rel=\"stylesheet\" href=\"./resources/qunit.css\">\n\t</head>\n\t<body>\n\t  <div id=\"qunit\"></div>\n\t  <div id=\"qunit-fixture\"></div>\n\t  <script src=\"./resources/qunit.js\"></script>\n\t  <script type=\"text/javascript\" src=\"./resources/jquery.js\"></script>\n\t    <!-- 项目代码 -->\n\t  <script type=\"text/javascript\" src=\"myProject.js\"></script>\n\t\t<!-- 测试代码 -->\n\t  <script type=\"text/javascript\" src=\"myTests.js\"></script>\n\n\t</body>\n\t</html>\n\n---\n参考文献：<http://qunitjs.com/cookbook/>   \n感谢：lizejun\n\n","source":"_posts/2013-03-22-qunit-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"Qunit 简介\"\ndate: 2013-03-22 15:21\ncomments: true\ncategories: nodejs\ntags: [ qunit, jquery ]\n---\n#QUnit\nQUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。   \n[项目官网](http://qunitjs.com/)   \n[文件下载地址](https://github.com/jquery/qunit)   \n#建立测试程序\n建立html测试页面，引入 `qunit.js` 和 `qunit.css` 这两个必需的文件。其中`qunit.js`是测试套件程序，`qunit.css`用于控制测试套件的结果显示的样式。    \n\t\n\t<!--sample.html:-->\n\t<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t  <title>QUnit basic example</title>\n\t  <link rel=\"stylesheet\" href=\"./resources/qunit.css\">\n\t<script type=\"text/javascript\" src=\"./resources/jquery.js\"></script>\n\t</head>\n\t<body>\n\t  <div id=\"qunit\"></div>\n\t  <div id=\"qunit-fixture\"></div>\n\t  <script src=\"./resources/qunit.js\"></script>\n\t  <script>\n\t    test( \"a basic test example\", function() {\n\t      var value = \"hello\";\n\t      equal( value, \"hello\", \"We expect value to be hello\" );\n\t    });\n\t  </script>\n\t</body>\n\t</html>\n<!--more-->\n其中放置的文件及文件结构如下：     \n  \n\t|-qunit-test   \n\t|  |-sample.html   \n\t|  |-resources   \n\t|  |    |-qunit.js   \n\t|  |    |-qunit.css\n    |  |    |-jquery.js   \n\n测试的结果会由`qunit.js`控制输出到页面代码中的`<div id=\"qunit\"></div>`中。另外一个必不可少的元素是`<div id=\"\"qunit-fixture\"\"></div>`。在每个test执行完毕后，如果改动了该元素，会自动重置。`jquery.js`的引入是为了测试使用jQuery语法写的程序。   \n在浏览器中打开sample1.html可以看到结果显示如下图所示：   \n![qunit的用例运行显示结果](/images/blog/qunit-pic.png)   \n#测试框架使用说明   \n标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。   \n下面是3个checkbox。\"Hide passed tests\"点击后可以过滤掉通过的用例，只显示失败的用例。\"Check for Globals\"，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。\"No try-catch\"用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。   \n#断言   \n- **ok( truthy [, message ] )**   判断是否为true   \n- **equal( actual, expected [, message ] )**    判断actual==expected   \n- **deepEqual( actual, expected [, message ] )**    判断actual===expected\n   \n用例如下：   \n\ttest(\"assertion\",function(){   \n\n\t\tok( true, \"true succeeds\" );\n\t    ok( NaN, \"NaN fails\" );\n\t   \n\t    equal( 0, 0, \"0, 0 : equal succeeds\" );\n\t\tequal( \"\", 0, \"Empty, 0: equal succeeds\" );\n\t    equal( null, \"\", \"null, empty: equal fails\" );\n\t  \n\t    var obj = { foo: \"bar\" };\n\t    deepEqual( obj, { foo: \"bar\" }, \"Two objects can be the same in value\" );\n\t\tequal( \"\", 0, \"Empty, 0: equal succeeds\" );\n\t});    \n\n#测试同步代码   \n在同步代码的测试中，有两种方式：   \n-   test( name, expected, fucntion(){...})：expceted指assertion的数量。   \n-   test( name, function(){expected(amount);...})：在function中增加expected(amount)，amount表示assertiong的数量。   \n\ntest()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。   \n\t\n\ttest( \"a test\", 2, function() {\n\t\tok( true, \"sucess\" );\n\t\tok( false, \"fail\" );\n\t});   \n\n\ttest( \"a test\", function() {\n\t  expect( 2 );\n\t \n\t  function calc( x, operation ) {\n\t    return operation( x );\n\t  }\n\t \n\t  var result = calc( 2, function( x ) {\n\t    ok( true, \"calc() calls operation function\" );\n\t    return x * x;\n\t  });\n\t \n\t  equal( result, 4, \"2 square equals 4\" );\n\t});\n\n\n#测试异步代码\n对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。   \n\n\tasyncTest( \"asynchronous test: one second later!\", function() {\n\t  expect( 1 );\n\t \n\t  setTimeout(function() {\n\t     ok( true, \"Passed and ready to resume!\" );\n\t     start();\n\t  }, 1000);\n\t});      \n\n#用户行为的测试\n测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用`trigger()`或者`triggerHandler()`来实现。\t\n   \n\ttest( \"div click test\", 1, function() {\n\t  var $body = $( \"#qunit-fixture\" );\n\t \n\t  $body.bind( \"click\", function() {\n\t\tok( true, \"body was clicked!\" );\n\t  });\n\t \n\t  $body.trigger( \"click\" );\n\t});\n下面是Qunit中的一个demo例子，其中模拟了一个key的记录器`KeyLogger()`，在test中初始化了一个事件event，并且使触发了两次，：   \n\n\tfunction KeyLogger( target ) {\n\t  if ( !(this instanceof KeyLogger) ) {\n\t\treturn new KeyLogger( target );\n\t  }\n\t  this.target = target;\n\t  this.log = [];\n\t \n\t  var self = this;\n\t \n\t  this.target.bind( \"keydown\", function( event ) {\n\t\tself.log.push( event.keyCode );\n\t  });\n\t}\n\ttest( \"keylogger api behavior\", function() {\n\t \n\t  var event,\n\t\t  $doc = $( document ),\n\t\t  keys = KeyLogger( $doc );\n\t \n\t  // trigger event\n\t  event = $.Event( \"keydown\" );\n\t  \n\t  event.keyCode = 'A';\n\t  $doc.trigger( event );\n\t  $doc.trigger( event );\n\t \n\t  // verify expected behavior\n\t  equal( keys.log.length, 2, \"2 key was logged\" );\n\t  equal( keys.log[ 0 ], 'A', \"correct key was logged\" );\n\t \n\t});   \n#模块化   \n为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。   \n   \n\tmodule( \"group a\" );\n\ttest( \"a basic test example\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\ttest( \"a basic test example 2\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\t \n\tmodule( \"group b\" );\n\ttest( \"a basic test example 3\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\ttest( \"a basic test example 4\", function() {\n\t  ok( true, \"this test is fine\" );\n\t});\n\n除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。   \n   \n\tmodule( \"module\", {\n\t  setup: function() {\n\t    ok( true, \"one extra assert per test\" );\n\t  }, teardown: function() {\n\t    ok( true, \"and one extra assert after each test\" );\n\t  }\n\t});\n\ttest( \"test with setup and teardown\", function() {\n\t  expect( 3 );\n\t  ok( true, \"test\" );\n\t});\n\n#推荐使用的框架程序\t\n最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码`myProject.js`和测试代码`myTests.js`。 \n\n\t<!--sample-framework.html:-->\n\t<html>\n\t<head>\n\t<meta charset=\"utf-8\">\n\t  <title>QUnit basic example</title>\n\t  <link rel=\"stylesheet\" href=\"./resources/qunit.css\">\n\t</head>\n\t<body>\n\t  <div id=\"qunit\"></div>\n\t  <div id=\"qunit-fixture\"></div>\n\t  <script src=\"./resources/qunit.js\"></script>\n\t  <script type=\"text/javascript\" src=\"./resources/jquery.js\"></script>\n\t    <!-- 项目代码 -->\n\t  <script type=\"text/javascript\" src=\"myProject.js\"></script>\n\t\t<!-- 测试代码 -->\n\t  <script type=\"text/javascript\" src=\"myTests.js\"></script>\n\n\t</body>\n\t</html>\n\n---\n参考文献：<http://qunitjs.com/cookbook/>   \n感谢：lizejun\n\n","slug":"2013-03-22-qunit-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5a0057v8fye4h6zlt3","content":"<p>#QUnit<br>QUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。<br><a href=\"http://qunitjs.com/\" target=\"_blank\" rel=\"external\">项目官网</a><br><a href=\"https://github.com/jquery/qunit\" target=\"_blank\" rel=\"external\">文件下载地址</a>   </p>\n<p>#建立测试程序<br>建立html测试页面，引入 <code>qunit.js</code> 和 <code>qunit.css</code> 这两个必需的文件。其中<code>qunit.js</code>是测试套件程序，<code>qunit.css</code>用于控制测试套件的结果显示的样式。    </p>\n<pre><code>&lt;!--sample.html:--&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;QUnit basic example&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/qunit.css&quot;&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;./resources/jquery.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./resources/qunit.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    test( &quot;a basic test example&quot;, function() {\n      var value = &quot;hello&quot;;\n      equal( value, &quot;hello&quot;, &quot;We expect value to be hello&quot; );\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><a id=\"more\"></a>\n<p>其中放置的文件及文件结构如下：     </p>\n<pre><code>|-qunit-test   \n|  |-sample.html   \n|  |-resources   \n|  |    |-qunit.js   \n|  |    |-qunit.css\n|  |    |-jquery.js   \n</code></pre><p>测试的结果会由<code>qunit.js</code>控制输出到页面代码中的<code>&lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;</code>中。另外一个必不可少的元素是<code>&lt;div id=&quot;&quot;qunit-fixture&quot;&quot;&gt;&lt;/div&gt;</code>。在每个test执行完毕后，如果改动了该元素，会自动重置。<code>jquery.js</code>的引入是为了测试使用jQuery语法写的程序。<br>在浏览器中打开sample1.html可以看到结果显示如下图所示：<br><img src=\"/images/blog/qunit-pic.png\" alt=\"qunit的用例运行显示结果\">   </p>\n<p>#测试框架使用说明<br>标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。<br>下面是3个checkbox。”Hide passed tests”点击后可以过滤掉通过的用例，只显示失败的用例。”Check for Globals”，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。”No try-catch”用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。   </p>\n<p>#断言   </p>\n<ul>\n<li><strong>ok( truthy [, message ] )</strong>   判断是否为true   </li>\n<li><strong>equal( actual, expected [, message ] )</strong>    判断actual==expected   </li>\n<li><strong>deepEqual( actual, expected [, message ] )</strong>    判断actual===expected</li>\n</ul>\n<p>用例如下：<br>    test(“assertion”,function(){   </p>\n<pre><code>    ok( true, &quot;true succeeds&quot; );\n    ok( NaN, &quot;NaN fails&quot; );\n\n    equal( 0, 0, &quot;0, 0 : equal succeeds&quot; );\n    equal( &quot;&quot;, 0, &quot;Empty, 0: equal succeeds&quot; );\n    equal( null, &quot;&quot;, &quot;null, empty: equal fails&quot; );\n\n    var obj = { foo: &quot;bar&quot; };\n    deepEqual( obj, { foo: &quot;bar&quot; }, &quot;Two objects can be the same in value&quot; );\n    equal( &quot;&quot;, 0, &quot;Empty, 0: equal succeeds&quot; );\n});    \n</code></pre><p>#测试同步代码<br>在同步代码的测试中，有两种方式：   </p>\n<ul>\n<li>test( name, expected, fucntion(){…})：expceted指assertion的数量。   </li>\n<li>test( name, function(){expected(amount);…})：在function中增加expected(amount)，amount表示assertiong的数量。   </li>\n</ul>\n<p>test()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。   </p>\n<pre><code>test( &quot;a test&quot;, 2, function() {\n    ok( true, &quot;sucess&quot; );\n    ok( false, &quot;fail&quot; );\n});   \n\ntest( &quot;a test&quot;, function() {\n  expect( 2 );\n\n  function calc( x, operation ) {\n    return operation( x );\n  }\n\n  var result = calc( 2, function( x ) {\n    ok( true, &quot;calc() calls operation function&quot; );\n    return x * x;\n  });\n\n  equal( result, 4, &quot;2 square equals 4&quot; );\n});\n</code></pre><p>#测试异步代码<br>对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。   </p>\n<pre><code>asyncTest( &quot;asynchronous test: one second later!&quot;, function() {\n  expect( 1 );\n\n  setTimeout(function() {\n     ok( true, &quot;Passed and ready to resume!&quot; );\n     start();\n  }, 1000);\n});      \n</code></pre><p>#用户行为的测试<br>测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用<code>trigger()</code>或者<code>triggerHandler()</code>来实现。    </p>\n<pre><code>test( &quot;div click test&quot;, 1, function() {\n  var $body = $( &quot;#qunit-fixture&quot; );\n\n  $body.bind( &quot;click&quot;, function() {\n    ok( true, &quot;body was clicked!&quot; );\n  });\n\n  $body.trigger( &quot;click&quot; );\n});\n</code></pre><p>下面是Qunit中的一个demo例子，其中模拟了一个key的记录器<code>KeyLogger()</code>，在test中初始化了一个事件event，并且使触发了两次，：   </p>\n<pre><code>function KeyLogger( target ) {\n  if ( !(this instanceof KeyLogger) ) {\n    return new KeyLogger( target );\n  }\n  this.target = target;\n  this.log = [];\n\n  var self = this;\n\n  this.target.bind( &quot;keydown&quot;, function( event ) {\n    self.log.push( event.keyCode );\n  });\n}\ntest( &quot;keylogger api behavior&quot;, function() {\n\n  var event,\n      $doc = $( document ),\n      keys = KeyLogger( $doc );\n\n  // trigger event\n  event = $.Event( &quot;keydown&quot; );\n\n  event.keyCode = &apos;A&apos;;\n  $doc.trigger( event );\n  $doc.trigger( event );\n\n  // verify expected behavior\n  equal( keys.log.length, 2, &quot;2 key was logged&quot; );\n  equal( keys.log[ 0 ], &apos;A&apos;, &quot;correct key was logged&quot; );\n\n});   \n</code></pre><p>#模块化<br>为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。   </p>\n<pre><code>module( &quot;group a&quot; );\ntest( &quot;a basic test example&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\ntest( &quot;a basic test example 2&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\n\nmodule( &quot;group b&quot; );\ntest( &quot;a basic test example 3&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\ntest( &quot;a basic test example 4&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\n</code></pre><p>除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。   </p>\n<pre><code>module( &quot;module&quot;, {\n  setup: function() {\n    ok( true, &quot;one extra assert per test&quot; );\n  }, teardown: function() {\n    ok( true, &quot;and one extra assert after each test&quot; );\n  }\n});\ntest( &quot;test with setup and teardown&quot;, function() {\n  expect( 3 );\n  ok( true, &quot;test&quot; );\n});\n</code></pre><p>#推荐使用的框架程序<br>最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码<code>myProject.js</code>和测试代码<code>myTests.js</code>。 </p>\n<pre><code>&lt;!--sample-framework.html:--&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;QUnit basic example&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/qunit.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./resources/qunit.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;./resources/jquery.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 项目代码 --&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;myProject.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 测试代码 --&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;myTests.js&quot;&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><hr>\n<p>参考文献：<a href=\"http://qunitjs.com/cookbook/\" target=\"_blank\" rel=\"external\">http://qunitjs.com/cookbook/</a><br>感谢：lizejun</p>\n","excerpt":"<p>#QUnit<br>QUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。<br><a href=\"http://qunitjs.com/\">项目官网</a><br><a href=\"https://github.com/jquery/qunit\">文件下载地址</a>   </p>\n<p>#建立测试程序<br>建立html测试页面，引入 <code>qunit.js</code> 和 <code>qunit.css</code> 这两个必需的文件。其中<code>qunit.js</code>是测试套件程序，<code>qunit.css</code>用于控制测试套件的结果显示的样式。    </p>\n<pre><code>&lt;!--sample.html:--&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;QUnit basic example&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/qunit.css&quot;&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;./resources/jquery.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./resources/qunit.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    test( &quot;a basic test example&quot;, function() {\n      var value = &quot;hello&quot;;\n      equal( value, &quot;hello&quot;, &quot;We expect value to be hello&quot; );\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","more":"<p>其中放置的文件及文件结构如下：     </p>\n<pre><code>|-qunit-test   \n|  |-sample.html   \n|  |-resources   \n|  |    |-qunit.js   \n|  |    |-qunit.css\n|  |    |-jquery.js   \n</code></pre><p>测试的结果会由<code>qunit.js</code>控制输出到页面代码中的<code>&lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;</code>中。另外一个必不可少的元素是<code>&lt;div id=&quot;&quot;qunit-fixture&quot;&quot;&gt;&lt;/div&gt;</code>。在每个test执行完毕后，如果改动了该元素，会自动重置。<code>jquery.js</code>的引入是为了测试使用jQuery语法写的程序。<br>在浏览器中打开sample1.html可以看到结果显示如下图所示：<br><img src=\"/images/blog/qunit-pic.png\" alt=\"qunit的用例运行显示结果\">   </p>\n<p>#测试框架使用说明<br>标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。<br>下面是3个checkbox。”Hide passed tests”点击后可以过滤掉通过的用例，只显示失败的用例。”Check for Globals”，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。”No try-catch”用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。   </p>\n<p>#断言   </p>\n<ul>\n<li><strong>ok( truthy [, message ] )</strong>   判断是否为true   </li>\n<li><strong>equal( actual, expected [, message ] )</strong>    判断actual==expected   </li>\n<li><strong>deepEqual( actual, expected [, message ] )</strong>    判断actual===expected</li>\n</ul>\n<p>用例如下：<br>    test(“assertion”,function(){   </p>\n<pre><code>    ok( true, &quot;true succeeds&quot; );\n    ok( NaN, &quot;NaN fails&quot; );\n\n    equal( 0, 0, &quot;0, 0 : equal succeeds&quot; );\n    equal( &quot;&quot;, 0, &quot;Empty, 0: equal succeeds&quot; );\n    equal( null, &quot;&quot;, &quot;null, empty: equal fails&quot; );\n\n    var obj = { foo: &quot;bar&quot; };\n    deepEqual( obj, { foo: &quot;bar&quot; }, &quot;Two objects can be the same in value&quot; );\n    equal( &quot;&quot;, 0, &quot;Empty, 0: equal succeeds&quot; );\n});    \n</code></pre><p>#测试同步代码<br>在同步代码的测试中，有两种方式：   </p>\n<ul>\n<li>test( name, expected, fucntion(){…})：expceted指assertion的数量。   </li>\n<li>test( name, function(){expected(amount);…})：在function中增加expected(amount)，amount表示assertiong的数量。   </li>\n</ul>\n<p>test()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。   </p>\n<pre><code>test( &quot;a test&quot;, 2, function() {\n    ok( true, &quot;sucess&quot; );\n    ok( false, &quot;fail&quot; );\n});   \n\ntest( &quot;a test&quot;, function() {\n  expect( 2 );\n\n  function calc( x, operation ) {\n    return operation( x );\n  }\n\n  var result = calc( 2, function( x ) {\n    ok( true, &quot;calc() calls operation function&quot; );\n    return x * x;\n  });\n\n  equal( result, 4, &quot;2 square equals 4&quot; );\n});\n</code></pre><p>#测试异步代码<br>对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。   </p>\n<pre><code>asyncTest( &quot;asynchronous test: one second later!&quot;, function() {\n  expect( 1 );\n\n  setTimeout(function() {\n     ok( true, &quot;Passed and ready to resume!&quot; );\n     start();\n  }, 1000);\n});      \n</code></pre><p>#用户行为的测试<br>测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用<code>trigger()</code>或者<code>triggerHandler()</code>来实现。    </p>\n<pre><code>test( &quot;div click test&quot;, 1, function() {\n  var $body = $( &quot;#qunit-fixture&quot; );\n\n  $body.bind( &quot;click&quot;, function() {\n    ok( true, &quot;body was clicked!&quot; );\n  });\n\n  $body.trigger( &quot;click&quot; );\n});\n</code></pre><p>下面是Qunit中的一个demo例子，其中模拟了一个key的记录器<code>KeyLogger()</code>，在test中初始化了一个事件event，并且使触发了两次，：   </p>\n<pre><code>function KeyLogger( target ) {\n  if ( !(this instanceof KeyLogger) ) {\n    return new KeyLogger( target );\n  }\n  this.target = target;\n  this.log = [];\n\n  var self = this;\n\n  this.target.bind( &quot;keydown&quot;, function( event ) {\n    self.log.push( event.keyCode );\n  });\n}\ntest( &quot;keylogger api behavior&quot;, function() {\n\n  var event,\n      $doc = $( document ),\n      keys = KeyLogger( $doc );\n\n  // trigger event\n  event = $.Event( &quot;keydown&quot; );\n\n  event.keyCode = &apos;A&apos;;\n  $doc.trigger( event );\n  $doc.trigger( event );\n\n  // verify expected behavior\n  equal( keys.log.length, 2, &quot;2 key was logged&quot; );\n  equal( keys.log[ 0 ], &apos;A&apos;, &quot;correct key was logged&quot; );\n\n});   \n</code></pre><p>#模块化<br>为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。   </p>\n<pre><code>module( &quot;group a&quot; );\ntest( &quot;a basic test example&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\ntest( &quot;a basic test example 2&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\n\nmodule( &quot;group b&quot; );\ntest( &quot;a basic test example 3&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\ntest( &quot;a basic test example 4&quot;, function() {\n  ok( true, &quot;this test is fine&quot; );\n});\n</code></pre><p>除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。   </p>\n<pre><code>module( &quot;module&quot;, {\n  setup: function() {\n    ok( true, &quot;one extra assert per test&quot; );\n  }, teardown: function() {\n    ok( true, &quot;and one extra assert after each test&quot; );\n  }\n});\ntest( &quot;test with setup and teardown&quot;, function() {\n  expect( 3 );\n  ok( true, &quot;test&quot; );\n});\n</code></pre><p>#推荐使用的框架程序<br>最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码<code>myProject.js</code>和测试代码<code>myTests.js</code>。 </p>\n<pre><code>&lt;!--sample-framework.html:--&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;QUnit basic example&lt;/title&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/qunit.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./resources/qunit.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;./resources/jquery.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 项目代码 --&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;myProject.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- 测试代码 --&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;myTests.js&quot;&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><hr>\n<p>参考文献：<a href=\"http://qunitjs.com/cookbook/\">http://qunitjs.com/cookbook/</a><br>感谢：lizejun</p>"},{"layout":"post","title":"JsTestDriver 简介","date":"2013-03-22T08:11:00.000Z","comments":1,"_content":"#jsTestDriver\njsTestDriver是一个JavaScript单元测试工具，易于与持续构建系统相集成并能够在多个浏览器上执行运行测试，轻松实现TDD（测试驱动开发）风格的开发。当在项目中配置好js-test-driver以后，如同junit测试java文件一般，js-test-driver可以直接通过直接运行js文件，来对js文件单元测试。   \n![alt jsTestDriver框架](/images/blog/jsTestDriver-framework.jpg)\n<!--more-->\n##### 在Intellij IDEA中安装JsTestDriver####\n* 打开IDEA编辑器，点击**File**，点击下拉列表中的**setting**，进入IDEA设置对话框   \n* 在搜索框中键入**plugins**，在搜索结果中选择**plugins**这一项  \n* 点击**Browse Repositories**，在弹出的列表中搜索jsTestDriver。   \n* 右击jsTestDriver插件，选择**Download and Install**.   \n \n![alt jsTestDriver插件安装](/images/blog/idea-install-jstestdriver-plugin-dialog.png)   \n##### 在IDEA中使用jsTestDriver运行js测试代码#####\n* 在IDEA中新建一个空的工程，在工程目录下新建代码包test\n* 在src代码包中新建Greeter.js代码如下：  \n\n    myapp = {};  \n    myapp.Greeter = function() { };  \n    myapp.Greeter.prototype.greet = function(name) {\n    return \"Hello \" + name + \"!\";  \n    };   \n* 在test代码包中新建GreeterTest.js,代码如下\n\n    GGdTestCase(\"GreeterTest\", {\n    \"test greet\": function() {\n        var greeter = new myapp.Greeter();\n        assertEquals(\"Hello World!\", greeter.greet(\"World\"));\n    },\n    \"test greet null\": function() {\n        var greeter = new myapp.Greeter();\n        //assertNull(greeter.greet(null));\n        assertTrue(true);\n    }\n    });  \n* 在项目主文件夹中新建配置文件greeter.jstd,文件内容如下：\n\n    load:  \n  -- src/Greeter.js  \n  --test/GreeterTest.js  \n* 启动jsTestDriver Server  \n  ![alt jsTestDriver server](/images/blog/jsTestDriver-server.jpg)\n* 打开本地浏览器，访问url http://localhost:9876/capture\n* 运行greeter.jstd\n    \n##### 在Eclipse中安装jsTestDriver#####\n* 在**Help**中的**Install new software**中，添加一个update site ：http://js-test-driver.googlecode.com/svn/update/  \n* 安装完毕后，重启Eclipse，新建一个空的java项目\n* 在java项目中添加test代码包，在src中新建src.js,其代码如IDEA中的Greeter.js一样。\n* 在test中添加test.js，其代码和IDEA中GreeterTest.js一样。  \n* 在项目目录中添加配置文件jsTestDriver.conf，其内容为\n\n    load:  \n    -- src/*.js  \n    -- test/*.js  \n目录结构如图：  \n![alt 目录结构](/images/blog/eclipse-jstestDriver.jpg)\n* 配置Run Configuration，新建一个Js Test Driver Test, 选择好项目和相应的配置文件。\n* 启动jsTestDriver服务器，然后用浏览器去访问http://127.0.0.1:4244/capture，这样就可以在\n浏览器中执行我们的js测试脚本了。  \n![alt eclipse执行结果](/images/blog//eclipse-test.jpg)  \n我们可以再eclipse中配置jsTestDriver的相关项，如图：  \n![alt eclipse配置jsTestDriver](/images/blog//eclipse-js-setting.jpg)\n\n---\n参考文献：<http://code.google.com/p/js-test-driver/>   \n感谢：youthflies","source":"_posts/2013-03-22-jstestdriver-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"JsTestDriver 简介\"\ndate: 2013-03-22 16:11\ncomments: true\ncategories: nodejs\ntags: [ jsTestDriver, nodejs, test-runner]\n---\n#jsTestDriver\njsTestDriver是一个JavaScript单元测试工具，易于与持续构建系统相集成并能够在多个浏览器上执行运行测试，轻松实现TDD（测试驱动开发）风格的开发。当在项目中配置好js-test-driver以后，如同junit测试java文件一般，js-test-driver可以直接通过直接运行js文件，来对js文件单元测试。   \n![alt jsTestDriver框架](/images/blog/jsTestDriver-framework.jpg)\n<!--more-->\n##### 在Intellij IDEA中安装JsTestDriver####\n* 打开IDEA编辑器，点击**File**，点击下拉列表中的**setting**，进入IDEA设置对话框   \n* 在搜索框中键入**plugins**，在搜索结果中选择**plugins**这一项  \n* 点击**Browse Repositories**，在弹出的列表中搜索jsTestDriver。   \n* 右击jsTestDriver插件，选择**Download and Install**.   \n \n![alt jsTestDriver插件安装](/images/blog/idea-install-jstestdriver-plugin-dialog.png)   \n##### 在IDEA中使用jsTestDriver运行js测试代码#####\n* 在IDEA中新建一个空的工程，在工程目录下新建代码包test\n* 在src代码包中新建Greeter.js代码如下：  \n\n    myapp = {};  \n    myapp.Greeter = function() { };  \n    myapp.Greeter.prototype.greet = function(name) {\n    return \"Hello \" + name + \"!\";  \n    };   \n* 在test代码包中新建GreeterTest.js,代码如下\n\n    GGdTestCase(\"GreeterTest\", {\n    \"test greet\": function() {\n        var greeter = new myapp.Greeter();\n        assertEquals(\"Hello World!\", greeter.greet(\"World\"));\n    },\n    \"test greet null\": function() {\n        var greeter = new myapp.Greeter();\n        //assertNull(greeter.greet(null));\n        assertTrue(true);\n    }\n    });  \n* 在项目主文件夹中新建配置文件greeter.jstd,文件内容如下：\n\n    load:  \n  -- src/Greeter.js  \n  --test/GreeterTest.js  \n* 启动jsTestDriver Server  \n  ![alt jsTestDriver server](/images/blog/jsTestDriver-server.jpg)\n* 打开本地浏览器，访问url http://localhost:9876/capture\n* 运行greeter.jstd\n    \n##### 在Eclipse中安装jsTestDriver#####\n* 在**Help**中的**Install new software**中，添加一个update site ：http://js-test-driver.googlecode.com/svn/update/  \n* 安装完毕后，重启Eclipse，新建一个空的java项目\n* 在java项目中添加test代码包，在src中新建src.js,其代码如IDEA中的Greeter.js一样。\n* 在test中添加test.js，其代码和IDEA中GreeterTest.js一样。  \n* 在项目目录中添加配置文件jsTestDriver.conf，其内容为\n\n    load:  \n    -- src/*.js  \n    -- test/*.js  \n目录结构如图：  \n![alt 目录结构](/images/blog/eclipse-jstestDriver.jpg)\n* 配置Run Configuration，新建一个Js Test Driver Test, 选择好项目和相应的配置文件。\n* 启动jsTestDriver服务器，然后用浏览器去访问http://127.0.0.1:4244/capture，这样就可以在\n浏览器中执行我们的js测试脚本了。  \n![alt eclipse执行结果](/images/blog//eclipse-test.jpg)  \n我们可以再eclipse中配置jsTestDriver的相关项，如图：  \n![alt eclipse配置jsTestDriver](/images/blog//eclipse-js-setting.jpg)\n\n---\n参考文献：<http://code.google.com/p/js-test-driver/>   \n感谢：youthflies","slug":"2013-03-22-jstestdriver-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5c005cv8fyq0mc639g","content":"<p>#jsTestDriver<br>jsTestDriver是一个JavaScript单元测试工具，易于与持续构建系统相集成并能够在多个浏览器上执行运行测试，轻松实现TDD（测试驱动开发）风格的开发。当在项目中配置好js-test-driver以后，如同junit测试java文件一般，js-test-driver可以直接通过直接运行js文件，来对js文件单元测试。<br><img src=\"/images/blog/jsTestDriver-framework.jpg\" alt=\"alt jsTestDriver框架\"><br><a id=\"more\"></a></p>\n<h5 id=\"在Intellij-IDEA中安装JsTestDriver\"><a href=\"#在Intellij-IDEA中安装JsTestDriver\" class=\"headerlink\" title=\"在Intellij IDEA中安装JsTestDriver\"></a>在Intellij IDEA中安装JsTestDriver</h5><ul>\n<li>打开IDEA编辑器，点击<strong>File</strong>，点击下拉列表中的<strong>setting</strong>，进入IDEA设置对话框   </li>\n<li>在搜索框中键入<strong>plugins</strong>，在搜索结果中选择<strong>plugins</strong>这一项  </li>\n<li>点击<strong>Browse Repositories</strong>，在弹出的列表中搜索jsTestDriver。   </li>\n<li>右击jsTestDriver插件，选择<strong>Download and Install</strong>.   </li>\n</ul>\n<p><img src=\"/images/blog/idea-install-jstestdriver-plugin-dialog.png\" alt=\"alt jsTestDriver插件安装\">   </p>\n<h5 id=\"在IDEA中使用jsTestDriver运行js测试代码\"><a href=\"#在IDEA中使用jsTestDriver运行js测试代码\" class=\"headerlink\" title=\"在IDEA中使用jsTestDriver运行js测试代码\"></a>在IDEA中使用jsTestDriver运行js测试代码</h5><ul>\n<li>在IDEA中新建一个空的工程，在工程目录下新建代码包test</li>\n<li><p>在src代码包中新建Greeter.js代码如下：  </p>\n<p>  myapp = {};<br>  myapp.Greeter = function() { };<br>  myapp.Greeter.prototype.greet = function(name) {<br>  return “Hello “ + name + “!”;<br>  };   </p>\n</li>\n<li><p>在test代码包中新建GreeterTest.js,代码如下</p>\n<p>  GGdTestCase(“GreeterTest”, {<br>  “test greet”: function() {</p>\n<pre><code>var greeter = new myapp.Greeter();\nassertEquals(&quot;Hello World!&quot;, greeter.greet(&quot;World&quot;));\n</code></pre><p>  },<br>  “test greet null”: function() {</p>\n<pre><code>var greeter = new myapp.Greeter();\n//assertNull(greeter.greet(null));\nassertTrue(true);\n</code></pre><p>  }<br>  });  </p>\n</li>\n<li><p>在项目主文件夹中新建配置文件greeter.jstd,文件内容如下：</p>\n<p>  load:<br>– src/Greeter.js<br>–test/GreeterTest.js  </p>\n</li>\n<li>启动jsTestDriver Server<br><img src=\"/images/blog/jsTestDriver-server.jpg\" alt=\"alt jsTestDriver server\"></li>\n<li>打开本地浏览器，访问url <a href=\"http://localhost:9876/capture\" target=\"_blank\" rel=\"external\">http://localhost:9876/capture</a></li>\n<li>运行greeter.jstd</li>\n</ul>\n<h5 id=\"在Eclipse中安装jsTestDriver\"><a href=\"#在Eclipse中安装jsTestDriver\" class=\"headerlink\" title=\"在Eclipse中安装jsTestDriver\"></a>在Eclipse中安装jsTestDriver</h5><ul>\n<li>在<strong>Help</strong>中的<strong>Install new software</strong>中，添加一个update site ：<a href=\"http://js-test-driver.googlecode.com/svn/update/\" target=\"_blank\" rel=\"external\">http://js-test-driver.googlecode.com/svn/update/</a>  </li>\n<li>安装完毕后，重启Eclipse，新建一个空的java项目</li>\n<li>在java项目中添加test代码包，在src中新建src.js,其代码如IDEA中的Greeter.js一样。</li>\n<li>在test中添加test.js，其代码和IDEA中GreeterTest.js一样。  </li>\n<li><p>在项目目录中添加配置文件jsTestDriver.conf，其内容为</p>\n<p>  load:<br>  – src/<em>.js<br>  – test/</em>.js<br>目录结构如图：<br><img src=\"/images/blog/eclipse-jstestDriver.jpg\" alt=\"alt 目录结构\"></p>\n</li>\n<li>配置Run Configuration，新建一个Js Test Driver Test, 选择好项目和相应的配置文件。</li>\n<li>启动jsTestDriver服务器，然后用浏览器去访问<a href=\"http://127.0.0.1:4244/capture，这样就可以在\" target=\"_blank\" rel=\"external\">http://127.0.0.1:4244/capture，这样就可以在</a><br>浏览器中执行我们的js测试脚本了。<br><img src=\"/images/blog//eclipse-test.jpg\" alt=\"alt eclipse执行结果\"><br>我们可以再eclipse中配置jsTestDriver的相关项，如图：<br><img src=\"/images/blog//eclipse-js-setting.jpg\" alt=\"alt eclipse配置jsTestDriver\"></li>\n</ul>\n<hr>\n<p>参考文献：<a href=\"http://code.google.com/p/js-test-driver/\" target=\"_blank\" rel=\"external\">http://code.google.com/p/js-test-driver/</a><br>感谢：youthflies</p>\n","excerpt":"<p>#jsTestDriver<br>jsTestDriver是一个JavaScript单元测试工具，易于与持续构建系统相集成并能够在多个浏览器上执行运行测试，轻松实现TDD（测试驱动开发）风格的开发。当在项目中配置好js-test-driver以后，如同junit测试java文件一般，js-test-driver可以直接通过直接运行js文件，来对js文件单元测试。<br><img src=\"/images/blog/jsTestDriver-framework.jpg\" alt=\"alt jsTestDriver框架\"><br>","more":"</p>\n<h5 id=\"在Intellij-IDEA中安装JsTestDriver\"><a href=\"#在Intellij-IDEA中安装JsTestDriver\" class=\"headerlink\" title=\"在Intellij IDEA中安装JsTestDriver\"></a>在Intellij IDEA中安装JsTestDriver</h5><ul>\n<li>打开IDEA编辑器，点击<strong>File</strong>，点击下拉列表中的<strong>setting</strong>，进入IDEA设置对话框   </li>\n<li>在搜索框中键入<strong>plugins</strong>，在搜索结果中选择<strong>plugins</strong>这一项  </li>\n<li>点击<strong>Browse Repositories</strong>，在弹出的列表中搜索jsTestDriver。   </li>\n<li>右击jsTestDriver插件，选择<strong>Download and Install</strong>.   </li>\n</ul>\n<p><img src=\"/images/blog/idea-install-jstestdriver-plugin-dialog.png\" alt=\"alt jsTestDriver插件安装\">   </p>\n<h5 id=\"在IDEA中使用jsTestDriver运行js测试代码\"><a href=\"#在IDEA中使用jsTestDriver运行js测试代码\" class=\"headerlink\" title=\"在IDEA中使用jsTestDriver运行js测试代码\"></a>在IDEA中使用jsTestDriver运行js测试代码</h5><ul>\n<li>在IDEA中新建一个空的工程，在工程目录下新建代码包test</li>\n<li><p>在src代码包中新建Greeter.js代码如下：  </p>\n<p>  myapp = {};<br>  myapp.Greeter = function() { };<br>  myapp.Greeter.prototype.greet = function(name) {<br>  return “Hello “ + name + “!”;<br>  };   </p>\n</li>\n<li><p>在test代码包中新建GreeterTest.js,代码如下</p>\n<p>  GGdTestCase(“GreeterTest”, {<br>  “test greet”: function() {</p>\n<pre><code>var greeter = new myapp.Greeter();\nassertEquals(&quot;Hello World!&quot;, greeter.greet(&quot;World&quot;));\n</code></pre><p>  },<br>  “test greet null”: function() {</p>\n<pre><code>var greeter = new myapp.Greeter();\n//assertNull(greeter.greet(null));\nassertTrue(true);\n</code></pre><p>  }<br>  });  </p>\n</li>\n<li><p>在项目主文件夹中新建配置文件greeter.jstd,文件内容如下：</p>\n<p>  load:<br>– src/Greeter.js<br>–test/GreeterTest.js  </p>\n</li>\n<li>启动jsTestDriver Server<br><img src=\"/images/blog/jsTestDriver-server.jpg\" alt=\"alt jsTestDriver server\"></li>\n<li>打开本地浏览器，访问url <a href=\"http://localhost:9876/capture\">http://localhost:9876/capture</a></li>\n<li>运行greeter.jstd</li>\n</ul>\n<h5 id=\"在Eclipse中安装jsTestDriver\"><a href=\"#在Eclipse中安装jsTestDriver\" class=\"headerlink\" title=\"在Eclipse中安装jsTestDriver\"></a>在Eclipse中安装jsTestDriver</h5><ul>\n<li>在<strong>Help</strong>中的<strong>Install new software</strong>中，添加一个update site ：<a href=\"http://js-test-driver.googlecode.com/svn/update/\">http://js-test-driver.googlecode.com/svn/update/</a>  </li>\n<li>安装完毕后，重启Eclipse，新建一个空的java项目</li>\n<li>在java项目中添加test代码包，在src中新建src.js,其代码如IDEA中的Greeter.js一样。</li>\n<li>在test中添加test.js，其代码和IDEA中GreeterTest.js一样。  </li>\n<li><p>在项目目录中添加配置文件jsTestDriver.conf，其内容为</p>\n<p>  load:<br>  – src/<em>.js<br>  – test/</em>.js<br>目录结构如图：<br><img src=\"/images/blog/eclipse-jstestDriver.jpg\" alt=\"alt 目录结构\"></p>\n</li>\n<li>配置Run Configuration，新建一个Js Test Driver Test, 选择好项目和相应的配置文件。</li>\n<li>启动jsTestDriver服务器，然后用浏览器去访问<a href=\"http://127.0.0.1:4244/capture，这样就可以在\">http://127.0.0.1:4244/capture，这样就可以在</a><br>浏览器中执行我们的js测试脚本了。<br><img src=\"/images/blog//eclipse-test.jpg\" alt=\"alt eclipse执行结果\"><br>我们可以再eclipse中配置jsTestDriver的相关项，如图：<br><img src=\"/images/blog//eclipse-js-setting.jpg\" alt=\"alt eclipse配置jsTestDriver\"></li>\n</ul>\n<hr>\n<p>参考文献：<a href=\"http://code.google.com/p/js-test-driver/\">http://code.google.com/p/js-test-driver/</a><br>感谢：youthflies</p>"},{"layout":"post","title":"使用Karma来驱动mocha测试","date":"2013-03-27T11:00:00.000Z","comments":1,"_content":"##从Testacular到Karma的变化##\n2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。  \n安装：  \n\tnpm install -g karma\n##什么时候使用Karma？##\n\n* 在真实浏览器里测试。\n* 在多种浏览器里进行测试（包括桌面、移动）。\n* 在本地开发环境执行测试。\n* 想在持续集成CI内运行测试。\n* 想在每次保存代码时，自动执行测试。\n* 热衷于terminal小黑屏。\n* 不想陷入令人厌烦的测试生活。\n* 想使用Istanbul自动生成coverage报告。\n* 想在源码中使用RequireJS。\n\n##Karma不是Testing Framework##\nKarma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。  \n\n* Mocha\n* Jasmine\n* QUnit\n<!--more-->\n##Karma与Test Framework集成##\nKarma对各种Test Framework的支持是以插件的模式进行支持的。  \n只需要在karma.conf.js进行以下配置（mocha为例）：  \n\n    frameworks = ['mocha'];\n\n    plugins = [\n    'karma-mocha'\n    ];\n在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：    \n\n\tnpm install karma-mocha\n其他框架依此类推。\n\n##Karma报告##\nKarma的报告（reporter）也是以插件模式进行的。 \n####JUnit Reporter####\n首先，要定义reporter类型，在karma.conf.js添加：  \n\n\treporters = ['junit'];\n如果想更近一步的话，可以配置一下报告的位置。   \n\n\tjunitReporter = {\n    \toutputFile: 'junit-report/test-results.xml'\n\t};\n报告配置完了，自然要有依赖啊。执行`npm install karma-junit-reporter`来安装。然后在加上这个plugin:   \n\n\tplugins = [\n    \t'karma-junit-reporter'\n\t];\n\n####Coverage Reporter####\n同JUnit Reporter一样，首先添加：  \n\n\treporters = ['coverage'];\n进一步的配置coverage report:   \n\n\tcoverageReporter = {\n    \ttype : 'cobertura',\n    \tdir : 'coverage/'\n\t};\n其中，type用于指出报告类型；dir用于指出生成报告的存放目录。  \ntype包括：  \n\n- html (default)\n- lcov (lcov and html)\n- lcovonly\n- text (standard output)\n- text-summary (standard output)\n- cobertura (xml format supported by Jenkins)\n\n下面，需要安装依赖`npm install karma-coverage`。并在配置文件内添加：  \n\n\tplugins = [\n    \t'karma-coverage'\n\t];\n\n\n##创建一个样例##\n1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。    \n\n2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。\n\n3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：  \n\n\t// Karma configuration\n\t// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)\n\n\t// base path, that will be used to resolve files and exclude\n\tbasePath = './';\n\n\tframeworks = ['mocha'];\n\n\t// list of files / patterns to load in the browser\n\tfiles = [\n    \t{pattern: 'node_modules/chai/chai.js',include: true},\n    \t'src/*.js',\n    \t'test/*.js'\n\t];\n\n\n\t// list of files to exclude\n\texclude = [\n    \t'karma.conf.js'\n\t];\n\n\n\t// use dots reporter, as travis terminal does not support escaping sequences\n\t// possible values: 'dots', 'progress', 'junit', 'teamcity'\n\t// CLI --reporters progress\n\treporters = ['progress','junit','coverage'];\n\n\tjunitReporter = {\n\t    // will be resolved to basePath (in the same way as files/exclude patterns)\n\t    outputFile: 'junit-report/test-results.xml'\n\t};\n\n\tpreprocessors = {\n\t    'src/*.js': 'coverage'\n\t};\n\n\t//Code Coverage options. report type available:\n\t//- html (default)\n\t//- lcov (lcov and html)\n\t//- lcovonly\n\t//- text (standard output)\n\t//- text-summary (standard output)\n\t//- cobertura (xml format supported by Jenkins)\n\tcoverageReporter = {\n\t    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/\n\t    type : 'cobertura',\n\t    dir : 'coverage/'\n\t};\n\n\n\t// web server port\n\tport = 9876;\n\n\n\t// cli runner port\n\trunnerPort = 9100;\n\n\n\t// enable / disable colors in the output (reporters and logs)\n\tcolors = true;\n\n\n\t// level of logging\n\t// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG\n\tlogLevel = LOG_DEBUG;\n\n\n\t// enable / disable watching file and executing tests whenever any file changes\n\tautoWatch = true;\n\n\n\t// Start these browsers, currently available:\n\t// - Chrome\n\t// - ChromeCanary\n\t// - Firefox\n\t// - Opera\n\t// - Safari (only Mac)\n\t// - PhantomJS\n\t// - IE (only Windows)\n\t// CLI --browsers Chrome,Firefox,Safari\n\tbrowsers = ['Chrome'];\n\n\n\t// If browser does not capture in given timeout [ms], kill it\n\tcaptureTimeout = 6000;\n\n\n\t// Continuous Integration mode\n\t// if true, it capture browsers, run tests and exit\n\tsingleRun = true;\n\n\n\tplugins = [\n\t    'karma-mocha',\n\t    'karma-chrome-launcher',\n\t    'karma-firefox-launcher',\n\t    'karma-junit-reporter',\n\t    'karma-coverage'\n\t];\n\n4.放入相应的代码到src以及test目录里。执行'karma start'命令, 浏览器将会被打开，然后执行相应的Test。效果如下图：   \n![Karma in Chrome](/images/blog/karma-chrome.png)\n\n完整样例代码：   \n<https://github.com/blueshen/Karma-mocha-example>\n\n##IntelliJ IDEA集成##\n为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。   \n1.安装NodeJS插件： Settings --> IDE Settings --> Plugins --> Browse repositories --> NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。   \n2.配置Karma Server: 从菜单Run --> Edit Configurations... -->点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：    \n![karma-node-server](/images/blog/karma-node-server.png)\n\n其中：    \nName： 任意，本处为Karma node Server   \nPath to Node: node可执行全路径。$NODE_PATH/bin/node     \nWorking Directory: 当前项目的跟路径   \nPath to Node App JS File: 此处为karma的可执行全路径。   \nApplication Parameters: 要执行的命令，此处为start     \nEnvironment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。  \n\n3.配置Karma run     \n同Karma Server，只是修改Application Parameters为run\n![karma-node-run](/images/blog/karma-node-run.png)\n\n\n配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将`singleRun=false`,也就是说执行完测试之后不退出。只有在CI环境下才用true。   \n  \n在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将`autoWatch=true`,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。   \n   \n\n\n","source":"_posts/2013-03-27-use-karma-to-run-mocha-test.markdown","raw":"---\nlayout: post\ntitle: \"使用Karma来驱动mocha测试\"\ndate: 2013-03-27 19:00\ncomments: true\ncategories: nodejs\ntags: [ karma, testacular, mocha, idea ]\n---\n##从Testacular到Karma的变化##\n2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。  \n安装：  \n\tnpm install -g karma\n##什么时候使用Karma？##\n\n* 在真实浏览器里测试。\n* 在多种浏览器里进行测试（包括桌面、移动）。\n* 在本地开发环境执行测试。\n* 想在持续集成CI内运行测试。\n* 想在每次保存代码时，自动执行测试。\n* 热衷于terminal小黑屏。\n* 不想陷入令人厌烦的测试生活。\n* 想使用Istanbul自动生成coverage报告。\n* 想在源码中使用RequireJS。\n\n##Karma不是Testing Framework##\nKarma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。  \n\n* Mocha\n* Jasmine\n* QUnit\n<!--more-->\n##Karma与Test Framework集成##\nKarma对各种Test Framework的支持是以插件的模式进行支持的。  \n只需要在karma.conf.js进行以下配置（mocha为例）：  \n\n    frameworks = ['mocha'];\n\n    plugins = [\n    'karma-mocha'\n    ];\n在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：    \n\n\tnpm install karma-mocha\n其他框架依此类推。\n\n##Karma报告##\nKarma的报告（reporter）也是以插件模式进行的。 \n####JUnit Reporter####\n首先，要定义reporter类型，在karma.conf.js添加：  \n\n\treporters = ['junit'];\n如果想更近一步的话，可以配置一下报告的位置。   \n\n\tjunitReporter = {\n    \toutputFile: 'junit-report/test-results.xml'\n\t};\n报告配置完了，自然要有依赖啊。执行`npm install karma-junit-reporter`来安装。然后在加上这个plugin:   \n\n\tplugins = [\n    \t'karma-junit-reporter'\n\t];\n\n####Coverage Reporter####\n同JUnit Reporter一样，首先添加：  \n\n\treporters = ['coverage'];\n进一步的配置coverage report:   \n\n\tcoverageReporter = {\n    \ttype : 'cobertura',\n    \tdir : 'coverage/'\n\t};\n其中，type用于指出报告类型；dir用于指出生成报告的存放目录。  \ntype包括：  \n\n- html (default)\n- lcov (lcov and html)\n- lcovonly\n- text (standard output)\n- text-summary (standard output)\n- cobertura (xml format supported by Jenkins)\n\n下面，需要安装依赖`npm install karma-coverage`。并在配置文件内添加：  \n\n\tplugins = [\n    \t'karma-coverage'\n\t];\n\n\n##创建一个样例##\n1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。    \n\n2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。\n\n3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：  \n\n\t// Karma configuration\n\t// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)\n\n\t// base path, that will be used to resolve files and exclude\n\tbasePath = './';\n\n\tframeworks = ['mocha'];\n\n\t// list of files / patterns to load in the browser\n\tfiles = [\n    \t{pattern: 'node_modules/chai/chai.js',include: true},\n    \t'src/*.js',\n    \t'test/*.js'\n\t];\n\n\n\t// list of files to exclude\n\texclude = [\n    \t'karma.conf.js'\n\t];\n\n\n\t// use dots reporter, as travis terminal does not support escaping sequences\n\t// possible values: 'dots', 'progress', 'junit', 'teamcity'\n\t// CLI --reporters progress\n\treporters = ['progress','junit','coverage'];\n\n\tjunitReporter = {\n\t    // will be resolved to basePath (in the same way as files/exclude patterns)\n\t    outputFile: 'junit-report/test-results.xml'\n\t};\n\n\tpreprocessors = {\n\t    'src/*.js': 'coverage'\n\t};\n\n\t//Code Coverage options. report type available:\n\t//- html (default)\n\t//- lcov (lcov and html)\n\t//- lcovonly\n\t//- text (standard output)\n\t//- text-summary (standard output)\n\t//- cobertura (xml format supported by Jenkins)\n\tcoverageReporter = {\n\t    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/\n\t    type : 'cobertura',\n\t    dir : 'coverage/'\n\t};\n\n\n\t// web server port\n\tport = 9876;\n\n\n\t// cli runner port\n\trunnerPort = 9100;\n\n\n\t// enable / disable colors in the output (reporters and logs)\n\tcolors = true;\n\n\n\t// level of logging\n\t// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG\n\tlogLevel = LOG_DEBUG;\n\n\n\t// enable / disable watching file and executing tests whenever any file changes\n\tautoWatch = true;\n\n\n\t// Start these browsers, currently available:\n\t// - Chrome\n\t// - ChromeCanary\n\t// - Firefox\n\t// - Opera\n\t// - Safari (only Mac)\n\t// - PhantomJS\n\t// - IE (only Windows)\n\t// CLI --browsers Chrome,Firefox,Safari\n\tbrowsers = ['Chrome'];\n\n\n\t// If browser does not capture in given timeout [ms], kill it\n\tcaptureTimeout = 6000;\n\n\n\t// Continuous Integration mode\n\t// if true, it capture browsers, run tests and exit\n\tsingleRun = true;\n\n\n\tplugins = [\n\t    'karma-mocha',\n\t    'karma-chrome-launcher',\n\t    'karma-firefox-launcher',\n\t    'karma-junit-reporter',\n\t    'karma-coverage'\n\t];\n\n4.放入相应的代码到src以及test目录里。执行'karma start'命令, 浏览器将会被打开，然后执行相应的Test。效果如下图：   \n![Karma in Chrome](/images/blog/karma-chrome.png)\n\n完整样例代码：   \n<https://github.com/blueshen/Karma-mocha-example>\n\n##IntelliJ IDEA集成##\n为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。   \n1.安装NodeJS插件： Settings --> IDE Settings --> Plugins --> Browse repositories --> NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。   \n2.配置Karma Server: 从菜单Run --> Edit Configurations... -->点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：    \n![karma-node-server](/images/blog/karma-node-server.png)\n\n其中：    \nName： 任意，本处为Karma node Server   \nPath to Node: node可执行全路径。$NODE_PATH/bin/node     \nWorking Directory: 当前项目的跟路径   \nPath to Node App JS File: 此处为karma的可执行全路径。   \nApplication Parameters: 要执行的命令，此处为start     \nEnvironment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。  \n\n3.配置Karma run     \n同Karma Server，只是修改Application Parameters为run\n![karma-node-run](/images/blog/karma-node-run.png)\n\n\n配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将`singleRun=false`,也就是说执行完测试之后不退出。只有在CI环境下才用true。   \n  \n在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将`autoWatch=true`,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。   \n   \n\n\n","slug":"2013-03-27-use-karma-to-run-mocha-test","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5d005fv8fyulqzoj31","content":"<p>##从Testacular到Karma的变化##<br>2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。<br>安装：<br>    npm install -g karma</p>\n<p>##什么时候使用Karma？##</p>\n<ul>\n<li>在真实浏览器里测试。</li>\n<li>在多种浏览器里进行测试（包括桌面、移动）。</li>\n<li>在本地开发环境执行测试。</li>\n<li>想在持续集成CI内运行测试。</li>\n<li>想在每次保存代码时，自动执行测试。</li>\n<li>热衷于terminal小黑屏。</li>\n<li>不想陷入令人厌烦的测试生活。</li>\n<li>想使用Istanbul自动生成coverage报告。</li>\n<li>想在源码中使用RequireJS。</li>\n</ul>\n<p>##Karma不是Testing Framework##<br>Karma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。  </p>\n<ul>\n<li>Mocha</li>\n<li>Jasmine</li>\n<li><p>QUnit</p>\n<a id=\"more\"></a>\n<p>##Karma与Test Framework集成##<br>Karma对各种Test Framework的支持是以插件的模式进行支持的。<br>只需要在karma.conf.js进行以下配置（mocha为例）：  </p>\n<p>  frameworks = [‘mocha’];</p>\n<p>  plugins = [<br>  ‘karma-mocha’<br>  ];<br>在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：    </p>\n<p>  npm install karma-mocha<br>其他框架依此类推。</p>\n</li>\n</ul>\n<p>##Karma报告##<br>Karma的报告（reporter）也是以插件模式进行的。 </p>\n<p>####JUnit Reporter####<br>首先，要定义reporter类型，在karma.conf.js添加：  </p>\n<pre><code>reporters = [&apos;junit&apos;];\n</code></pre><p>如果想更近一步的话，可以配置一下报告的位置。   </p>\n<pre><code>junitReporter = {\n    outputFile: &apos;junit-report/test-results.xml&apos;\n};\n</code></pre><p>报告配置完了，自然要有依赖啊。执行<code>npm install karma-junit-reporter</code>来安装。然后在加上这个plugin:   </p>\n<pre><code>plugins = [\n    &apos;karma-junit-reporter&apos;\n];\n</code></pre><p>####Coverage Reporter####<br>同JUnit Reporter一样，首先添加：  </p>\n<pre><code>reporters = [&apos;coverage&apos;];\n</code></pre><p>进一步的配置coverage report:   </p>\n<pre><code>coverageReporter = {\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n</code></pre><p>其中，type用于指出报告类型；dir用于指出生成报告的存放目录。<br>type包括：  </p>\n<ul>\n<li>html (default)</li>\n<li>lcov (lcov and html)</li>\n<li>lcovonly</li>\n<li>text (standard output)</li>\n<li>text-summary (standard output)</li>\n<li>cobertura (xml format supported by Jenkins)</li>\n</ul>\n<p>下面，需要安装依赖<code>npm install karma-coverage</code>。并在配置文件内添加：  </p>\n<pre><code>plugins = [\n    &apos;karma-coverage&apos;\n];\n</code></pre><p>##创建一个样例##<br>1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。    </p>\n<p>2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。</p>\n<p>3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：  </p>\n<pre><code>// Karma configuration\n// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)\n\n// base path, that will be used to resolve files and exclude\nbasePath = &apos;./&apos;;\n\nframeworks = [&apos;mocha&apos;];\n\n// list of files / patterns to load in the browser\nfiles = [\n    {pattern: &apos;node_modules/chai/chai.js&apos;,include: true},\n    &apos;src/*.js&apos;,\n    &apos;test/*.js&apos;\n];\n\n\n// list of files to exclude\nexclude = [\n    &apos;karma.conf.js&apos;\n];\n\n\n// use dots reporter, as travis terminal does not support escaping sequences\n// possible values: &apos;dots&apos;, &apos;progress&apos;, &apos;junit&apos;, &apos;teamcity&apos;\n// CLI --reporters progress\nreporters = [&apos;progress&apos;,&apos;junit&apos;,&apos;coverage&apos;];\n\njunitReporter = {\n    // will be resolved to basePath (in the same way as files/exclude patterns)\n    outputFile: &apos;junit-report/test-results.xml&apos;\n};\n\npreprocessors = {\n    &apos;src/*.js&apos;: &apos;coverage&apos;\n};\n\n//Code Coverage options. report type available:\n//- html (default)\n//- lcov (lcov and html)\n//- lcovonly\n//- text (standard output)\n//- text-summary (standard output)\n//- cobertura (xml format supported by Jenkins)\ncoverageReporter = {\n    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n\n\n// web server port\nport = 9876;\n\n\n// cli runner port\nrunnerPort = 9100;\n\n\n// enable / disable colors in the output (reporters and logs)\ncolors = true;\n\n\n// level of logging\n// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG\nlogLevel = LOG_DEBUG;\n\n\n// enable / disable watching file and executing tests whenever any file changes\nautoWatch = true;\n\n\n// Start these browsers, currently available:\n// - Chrome\n// - ChromeCanary\n// - Firefox\n// - Opera\n// - Safari (only Mac)\n// - PhantomJS\n// - IE (only Windows)\n// CLI --browsers Chrome,Firefox,Safari\nbrowsers = [&apos;Chrome&apos;];\n\n\n// If browser does not capture in given timeout [ms], kill it\ncaptureTimeout = 6000;\n\n\n// Continuous Integration mode\n// if true, it capture browsers, run tests and exit\nsingleRun = true;\n\n\nplugins = [\n    &apos;karma-mocha&apos;,\n    &apos;karma-chrome-launcher&apos;,\n    &apos;karma-firefox-launcher&apos;,\n    &apos;karma-junit-reporter&apos;,\n    &apos;karma-coverage&apos;\n];\n</code></pre><p>4.放入相应的代码到src以及test目录里。执行’karma start’命令, 浏览器将会被打开，然后执行相应的Test。效果如下图：<br><img src=\"/images/blog/karma-chrome.png\" alt=\"Karma in Chrome\"></p>\n<p>完整样例代码：<br><a href=\"https://github.com/blueshen/Karma-mocha-example\" target=\"_blank\" rel=\"external\">https://github.com/blueshen/Karma-mocha-example</a></p>\n<p>##IntelliJ IDEA集成##<br>为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。<br>1.安装NodeJS插件： Settings –&gt; IDE Settings –&gt; Plugins –&gt; Browse repositories –&gt; NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。<br>2.配置Karma Server: 从菜单Run –&gt; Edit Configurations… –&gt;点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：<br><img src=\"/images/blog/karma-node-server.png\" alt=\"karma-node-server\"></p>\n<p>其中：<br>Name： 任意，本处为Karma node Server<br>Path to Node: node可执行全路径。$NODE_PATH/bin/node<br>Working Directory: 当前项目的跟路径<br>Path to Node App JS File: 此处为karma的可执行全路径。<br>Application Parameters: 要执行的命令，此处为start<br>Environment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。  </p>\n<p>3.配置Karma run<br>同Karma Server，只是修改Application Parameters为run<br><img src=\"/images/blog/karma-node-run.png\" alt=\"karma-node-run\"></p>\n<p>配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将<code>singleRun=false</code>,也就是说执行完测试之后不退出。只有在CI环境下才用true。   </p>\n<p>在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将<code>autoWatch=true</code>,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。   </p>\n","excerpt":"<p>##从Testacular到Karma的变化##<br>2013年03月18日，Testacular正式被重命名为Karma。具体原因，讲起来缺也很滑稽。这里面不含有任何的商业成分，只是因为Testacular与Testicular很相似，因此令人感觉尴尬。仅仅此而已，谁让JsTestDriver已经被别人给拿走了。<br>安装：<br>    npm install -g karma</p>\n<p>##什么时候使用Karma？##</p>\n<ul>\n<li>在真实浏览器里测试。</li>\n<li>在多种浏览器里进行测试（包括桌面、移动）。</li>\n<li>在本地开发环境执行测试。</li>\n<li>想在持续集成CI内运行测试。</li>\n<li>想在每次保存代码时，自动执行测试。</li>\n<li>热衷于terminal小黑屏。</li>\n<li>不想陷入令人厌烦的测试生活。</li>\n<li>想使用Istanbul自动生成coverage报告。</li>\n<li>想在源码中使用RequireJS。</li>\n</ul>\n<p>##Karma不是Testing Framework##<br>Karma自从出现，就是一直作为一个Test Runner而存在的，只是用来驱动测试的框架。不过到目前为止，它支持以下流行的测试框架。  </p>\n<ul>\n<li>Mocha</li>\n<li>Jasmine</li>\n<li><p>QUnit</p>","more":"<p>##Karma与Test Framework集成##<br>Karma对各种Test Framework的支持是以插件的模式进行支持的。<br>只需要在karma.conf.js进行以下配置（mocha为例）：  </p>\n<p>  frameworks = [‘mocha’];</p>\n<p>  plugins = [<br>  ‘karma-mocha’<br>  ];<br>在此处只是配置了一下，具体支持的plugin要在当前目录下进行安装：    </p>\n<p>  npm install karma-mocha<br>其他框架依此类推。</p>\n</li>\n</ul>\n<p>##Karma报告##<br>Karma的报告（reporter）也是以插件模式进行的。 </p>\n<p>####JUnit Reporter####<br>首先，要定义reporter类型，在karma.conf.js添加：  </p>\n<pre><code>reporters = [&apos;junit&apos;];\n</code></pre><p>如果想更近一步的话，可以配置一下报告的位置。   </p>\n<pre><code>junitReporter = {\n    outputFile: &apos;junit-report/test-results.xml&apos;\n};\n</code></pre><p>报告配置完了，自然要有依赖啊。执行<code>npm install karma-junit-reporter</code>来安装。然后在加上这个plugin:   </p>\n<pre><code>plugins = [\n    &apos;karma-junit-reporter&apos;\n];\n</code></pre><p>####Coverage Reporter####<br>同JUnit Reporter一样，首先添加：  </p>\n<pre><code>reporters = [&apos;coverage&apos;];\n</code></pre><p>进一步的配置coverage report:   </p>\n<pre><code>coverageReporter = {\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n</code></pre><p>其中，type用于指出报告类型；dir用于指出生成报告的存放目录。<br>type包括：  </p>\n<ul>\n<li>html (default)</li>\n<li>lcov (lcov and html)</li>\n<li>lcovonly</li>\n<li>text (standard output)</li>\n<li>text-summary (standard output)</li>\n<li>cobertura (xml format supported by Jenkins)</li>\n</ul>\n<p>下面，需要安装依赖<code>npm install karma-coverage</code>。并在配置文件内添加：  </p>\n<pre><code>plugins = [\n    &apos;karma-coverage&apos;\n];\n</code></pre><p>##创建一个样例##<br>1.执行‘karma init’,然后根据提示按Tab键进行相关选择。先生成一个默认的配置文件，这个是可以再修改的。    </p>\n<p>2.创建一个src文件夹，用于存放待测试的JS代码。然后在创建一个test文件夹，用于存放自己写的单元测试代码。</p>\n<p>3.以mocha为例，将mocha集成到karma中，使用karma来驱动测试。这需要在karma.conf.js里进行如下配置：  </p>\n<pre><code>// Karma configuration\n// Generated on Tue Mar 19 2013 20:46:08 GMT+0800 (CST)\n\n// base path, that will be used to resolve files and exclude\nbasePath = &apos;./&apos;;\n\nframeworks = [&apos;mocha&apos;];\n\n// list of files / patterns to load in the browser\nfiles = [\n    {pattern: &apos;node_modules/chai/chai.js&apos;,include: true},\n    &apos;src/*.js&apos;,\n    &apos;test/*.js&apos;\n];\n\n\n// list of files to exclude\nexclude = [\n    &apos;karma.conf.js&apos;\n];\n\n\n// use dots reporter, as travis terminal does not support escaping sequences\n// possible values: &apos;dots&apos;, &apos;progress&apos;, &apos;junit&apos;, &apos;teamcity&apos;\n// CLI --reporters progress\nreporters = [&apos;progress&apos;,&apos;junit&apos;,&apos;coverage&apos;];\n\njunitReporter = {\n    // will be resolved to basePath (in the same way as files/exclude patterns)\n    outputFile: &apos;junit-report/test-results.xml&apos;\n};\n\npreprocessors = {\n    &apos;src/*.js&apos;: &apos;coverage&apos;\n};\n\n//Code Coverage options. report type available:\n//- html (default)\n//- lcov (lcov and html)\n//- lcovonly\n//- text (standard output)\n//- text-summary (standard output)\n//- cobertura (xml format supported by Jenkins)\ncoverageReporter = {\n    // cf. http://gotwarlost.github.com/istanbul/public/apidocs/\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n\n\n// web server port\nport = 9876;\n\n\n// cli runner port\nrunnerPort = 9100;\n\n\n// enable / disable colors in the output (reporters and logs)\ncolors = true;\n\n\n// level of logging\n// possible values: LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG\nlogLevel = LOG_DEBUG;\n\n\n// enable / disable watching file and executing tests whenever any file changes\nautoWatch = true;\n\n\n// Start these browsers, currently available:\n// - Chrome\n// - ChromeCanary\n// - Firefox\n// - Opera\n// - Safari (only Mac)\n// - PhantomJS\n// - IE (only Windows)\n// CLI --browsers Chrome,Firefox,Safari\nbrowsers = [&apos;Chrome&apos;];\n\n\n// If browser does not capture in given timeout [ms], kill it\ncaptureTimeout = 6000;\n\n\n// Continuous Integration mode\n// if true, it capture browsers, run tests and exit\nsingleRun = true;\n\n\nplugins = [\n    &apos;karma-mocha&apos;,\n    &apos;karma-chrome-launcher&apos;,\n    &apos;karma-firefox-launcher&apos;,\n    &apos;karma-junit-reporter&apos;,\n    &apos;karma-coverage&apos;\n];\n</code></pre><p>4.放入相应的代码到src以及test目录里。执行’karma start’命令, 浏览器将会被打开，然后执行相应的Test。效果如下图：<br><img src=\"/images/blog/karma-chrome.png\" alt=\"Karma in Chrome\"></p>\n<p>完整样例代码：<br><a href=\"https://github.com/blueshen/Karma-mocha-example\">https://github.com/blueshen/Karma-mocha-example</a></p>\n<p>##IntelliJ IDEA集成##<br>为了在项目中开发方便，那么在开发中集成到IDE中，会节省N多时间的。下面就先来说说于IDEA的集成。<br>1.安装NodeJS插件： Settings –&gt; IDE Settings –&gt; Plugins –&gt; Browse repositories –&gt; NodeJS  选中，然后右键Download and Install进行安装。重启后成功安装。<br>2.配置Karma Server: 从菜单Run –&gt; Edit Configurations… –&gt;点击 ‘+’新建一个Node.js类型的配置。出现以下的界面：<br><img src=\"/images/blog/karma-node-server.png\" alt=\"karma-node-server\"></p>\n<p>其中：<br>Name： 任意，本处为Karma node Server<br>Path to Node: node可执行全路径。$NODE_PATH/bin/node<br>Working Directory: 当前项目的跟路径<br>Path to Node App JS File: 此处为karma的可执行全路径。<br>Application Parameters: 要执行的命令，此处为start<br>Environment variables: 就是环境变量了。此处我定义了CHROME_BIN来指出CHROME浏览器路径。  </p>\n<p>3.配置Karma run<br>同Karma Server，只是修改Application Parameters为run<br><img src=\"/images/blog/karma-node-run.png\" alt=\"karma-node-run\"></p>\n<p>配置成功后，运行Karma node Server可以看到浏览器就可以正常启动了。console也正确的输出。如同在terminal里执行一般。需要注意的是，本地开发时，需要将<code>singleRun=false</code>,也就是说执行完测试之后不退出。只有在CI环境下才用true。   </p>\n<p>在浏览器启动之后，如果修改了源代码，Test能否自动执行呢？可以将<code>autoWatch=true</code>,这样当你修改代码后，保存后能自动执行，方便开发了。如果‘autoWatch=false’了，那么这时间就要执行Karma run了，用于在Karma Server上重新执行。   </p>"},{"layout":"post","title":"Karma与Jenkins-CI集成","date":"2013-04-01T11:38:00.000Z","comments":1,"_content":"Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？\n\n###前提条件###\nJenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：   \n\n* Node\n* Karma\n\n###配置Karma.conf.js文件###\n必须保证：\n\n\tsingleRun = true;\n只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。    \n在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。\n\n\treporters = ['junit'];\n\tjunitReporter = {\n  \t\toutputFile: 'test-results.xml'\n\t};\n那么，Junit格式的测试结果就存到了test-results.xml中。    \n\n另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：   \n\n\treporters = ['coverage'];\n\n\tpreprocessors = {\n    \t'src/*.js': 'coverage'\n\t};\n\n\tcoverageReporter = {\n    \ttype : 'cobertura',\n    \tdir : 'coverage/'\n\t};\n这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。   \n<!--more-->\n###一个Jenkins Job###\n1.新建一个自由风格（freestyle）的Job即可。   \n2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。   \n3.源码管理部分，填写repository url。    \n4.在构建里，直接填写`karma start`即可。   \n5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：   \n   \n![karma-jenkins-cobertura](/images/blog/karma-jenkins-cobertura.png)\n\n6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：   \n  \n![karma-jenkins-junit](/images/blog/karma-jenkins-junit.png)  \n\n###Jenkins运行结果###\nCode Coverage结果：   \n![](/images/blog/karma-jenkins-codecoverage.png)\n\n点击进入后，可以看到具体的覆盖率情况：   \n![](/images/blog/karma-jenkins-codecoverage-detail.png)\n\nJUnit结果：   \n![](/images/blog/karma-jenkins-junit-report.png)  \n\n点进去后可以查看详细信息：  \n![](/images/blog/karma-jenkins-junit-report-detail.png)\n\n###关于Coverage###\ncoverageReporter的类型有以下几种：   \n\n- html (default)\n- lcov (lcov and html)\n- lcovonly\n- text (standard output)\n- text-summary (standard output)\n- cobertura (xml format supported by Jenkins)   \n\nKarma是使用[istanbul](http://gotwarlost.github.com/istanbul/)来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。   \n以下是lcov类型的Coverage结果： \n\n![](/images/blog/karma-lcov-1.png)\n\n而下面的结果，则指明了哪行源码被覆盖了。   \n![](/images/blog/karma-lcov-2.png)\n","source":"_posts/2013-04-01-run-karma-in-jenkins-ci.markdown","raw":"---\nlayout: post\ntitle: \"Karma与Jenkins-CI集成\"\ndate: 2013-04-01 19:38\ncomments: true\ncategories: nodejs\ntags: [ karma, testacular, jenkins, junit, coverage, cobertura ]\n---\nJenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？\n\n###前提条件###\nJenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：   \n\n* Node\n* Karma\n\n###配置Karma.conf.js文件###\n必须保证：\n\n\tsingleRun = true;\n只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。    \n在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。\n\n\treporters = ['junit'];\n\tjunitReporter = {\n  \t\toutputFile: 'test-results.xml'\n\t};\n那么，Junit格式的测试结果就存到了test-results.xml中。    \n\n另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：   \n\n\treporters = ['coverage'];\n\n\tpreprocessors = {\n    \t'src/*.js': 'coverage'\n\t};\n\n\tcoverageReporter = {\n    \ttype : 'cobertura',\n    \tdir : 'coverage/'\n\t};\n这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。   \n<!--more-->\n###一个Jenkins Job###\n1.新建一个自由风格（freestyle）的Job即可。   \n2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。   \n3.源码管理部分，填写repository url。    \n4.在构建里，直接填写`karma start`即可。   \n5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：   \n   \n![karma-jenkins-cobertura](/images/blog/karma-jenkins-cobertura.png)\n\n6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：   \n  \n![karma-jenkins-junit](/images/blog/karma-jenkins-junit.png)  \n\n###Jenkins运行结果###\nCode Coverage结果：   \n![](/images/blog/karma-jenkins-codecoverage.png)\n\n点击进入后，可以看到具体的覆盖率情况：   \n![](/images/blog/karma-jenkins-codecoverage-detail.png)\n\nJUnit结果：   \n![](/images/blog/karma-jenkins-junit-report.png)  \n\n点进去后可以查看详细信息：  \n![](/images/blog/karma-jenkins-junit-report-detail.png)\n\n###关于Coverage###\ncoverageReporter的类型有以下几种：   \n\n- html (default)\n- lcov (lcov and html)\n- lcovonly\n- text (standard output)\n- text-summary (standard output)\n- cobertura (xml format supported by Jenkins)   \n\nKarma是使用[istanbul](http://gotwarlost.github.com/istanbul/)来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。   \n以下是lcov类型的Coverage结果： \n\n![](/images/blog/karma-lcov-1.png)\n\n而下面的结果，则指明了哪行源码被覆盖了。   \n![](/images/blog/karma-lcov-2.png)\n","slug":"2013-04-01-run-karma-in-jenkins-ci","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5f005jv8fydwh5rtro","content":"<p>Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？</p>\n<p>###前提条件###<br>Jenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：   </p>\n<ul>\n<li>Node</li>\n<li>Karma</li>\n</ul>\n<p>###配置Karma.conf.js文件###<br>必须保证：</p>\n<pre><code>singleRun = true;\n</code></pre><p>只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。<br>在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。</p>\n<pre><code>reporters = [&apos;junit&apos;];\njunitReporter = {\n      outputFile: &apos;test-results.xml&apos;\n};\n</code></pre><p>那么，Junit格式的测试结果就存到了test-results.xml中。    </p>\n<p>另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：   </p>\n<pre><code>reporters = [&apos;coverage&apos;];\n\npreprocessors = {\n    &apos;src/*.js&apos;: &apos;coverage&apos;\n};\n\ncoverageReporter = {\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n</code></pre><p>这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。<br><a id=\"more\"></a></p>\n<p>###一个Jenkins Job###<br>1.新建一个自由风格（freestyle）的Job即可。<br>2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。<br>3.源码管理部分，填写repository url。<br>4.在构建里，直接填写<code>karma start</code>即可。<br>5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：   </p>\n<p><img src=\"/images/blog/karma-jenkins-cobertura.png\" alt=\"karma-jenkins-cobertura\"></p>\n<p>6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：   </p>\n<p><img src=\"/images/blog/karma-jenkins-junit.png\" alt=\"karma-jenkins-junit\">  </p>\n<p>###Jenkins运行结果###<br>Code Coverage结果：<br><img src=\"/images/blog/karma-jenkins-codecoverage.png\" alt=\"\"></p>\n<p>点击进入后，可以看到具体的覆盖率情况：<br><img src=\"/images/blog/karma-jenkins-codecoverage-detail.png\" alt=\"\"></p>\n<p>JUnit结果：<br><img src=\"/images/blog/karma-jenkins-junit-report.png\" alt=\"\">  </p>\n<p>点进去后可以查看详细信息：<br><img src=\"/images/blog/karma-jenkins-junit-report-detail.png\" alt=\"\"></p>\n<p>###关于Coverage###<br>coverageReporter的类型有以下几种：   </p>\n<ul>\n<li>html (default)</li>\n<li>lcov (lcov and html)</li>\n<li>lcovonly</li>\n<li>text (standard output)</li>\n<li>text-summary (standard output)</li>\n<li>cobertura (xml format supported by Jenkins)   </li>\n</ul>\n<p>Karma是使用<a href=\"http://gotwarlost.github.com/istanbul/\" target=\"_blank\" rel=\"external\">istanbul</a>来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。<br>以下是lcov类型的Coverage结果： </p>\n<p><img src=\"/images/blog/karma-lcov-1.png\" alt=\"\"></p>\n<p>而下面的结果，则指明了哪行源码被覆盖了。<br><img src=\"/images/blog/karma-lcov-2.png\" alt=\"\"></p>\n","excerpt":"<p>Jenkins是一款目前最为流行的持续集成工具，那么，如何让Karma的能集成到Jenkins，并自动执行呢？</p>\n<p>###前提条件###<br>Jenkins Server上（可以是Master，也许是Slave结点，总之在那个Server上跑，就需要安装），安装：   </p>\n<ul>\n<li>Node</li>\n<li>Karma</li>\n</ul>\n<p>###配置Karma.conf.js文件###<br>必须保证：</p>\n<pre><code>singleRun = true;\n</code></pre><p>只有这样，才能保证运行Test后，浏览器自动退出，不影响下次执行。<br>在Jenkins中，也许你想查看测试结果，这个时候可以借助junit reporter。</p>\n<pre><code>reporters = [&apos;junit&apos;];\njunitReporter = {\n      outputFile: &apos;test-results.xml&apos;\n};\n</code></pre><p>那么，Junit格式的测试结果就存到了test-results.xml中。    </p>\n<p>另外一种情况，我可能还想查看一下代码覆盖率。Karma也是支持的，要进行以下的配置：   </p>\n<pre><code>reporters = [&apos;coverage&apos;];\n\npreprocessors = {\n    &apos;src/*.js&apos;: &apos;coverage&apos;\n};\n\ncoverageReporter = {\n    type : &apos;cobertura&apos;,\n    dir : &apos;coverage/&apos;\n};\n</code></pre><p>这里，reporters指出了要生成coverage报告。preprocessors指明了要统计覆盖率的源码。coverageReporter里，指明type为cobertura，dir则是报告路径。type用多种选择，其中cobertura为Jenkins专属的。<br>","more":"</p>\n<p>###一个Jenkins Job###<br>1.新建一个自由风格（freestyle）的Job即可。<br>2.Restrict where this project can be run 里面填好前提条件中的机器名。当然如果直接是在Master结点，这个可以忽略。<br>3.源码管理部分，填写repository url。<br>4.在构建里，直接填写<code>karma start</code>即可。<br>5.在构建后操作里。选择Publish Cobertura Coverage Report,并指定生成的XML地址。如下图：   </p>\n<p><img src=\"/images/blog/karma-jenkins-cobertura.png\" alt=\"karma-jenkins-cobertura\"></p>\n<p>6.在构建后操作里。选择Publish JUnit test result report,同样指定report的XML路径。如图：   </p>\n<p><img src=\"/images/blog/karma-jenkins-junit.png\" alt=\"karma-jenkins-junit\">  </p>\n<p>###Jenkins运行结果###<br>Code Coverage结果：<br><img src=\"/images/blog/karma-jenkins-codecoverage.png\" alt=\"\"></p>\n<p>点击进入后，可以看到具体的覆盖率情况：<br><img src=\"/images/blog/karma-jenkins-codecoverage-detail.png\" alt=\"\"></p>\n<p>JUnit结果：<br><img src=\"/images/blog/karma-jenkins-junit-report.png\" alt=\"\">  </p>\n<p>点进去后可以查看详细信息：<br><img src=\"/images/blog/karma-jenkins-junit-report-detail.png\" alt=\"\"></p>\n<p>###关于Coverage###<br>coverageReporter的类型有以下几种：   </p>\n<ul>\n<li>html (default)</li>\n<li>lcov (lcov and html)</li>\n<li>lcovonly</li>\n<li>text (standard output)</li>\n<li>text-summary (standard output)</li>\n<li>cobertura (xml format supported by Jenkins)   </li>\n</ul>\n<p>Karma是使用<a href=\"http://gotwarlost.github.com/istanbul/\">istanbul</a>来生成报告的，上面在Jenkins种使用的cobertura类型。如果不在CI环境中，那么可以考虑使用lcon或者html类型，report也是相当好看呢。<br>以下是lcov类型的Coverage结果： </p>\n<p><img src=\"/images/blog/karma-lcov-1.png\" alt=\"\"></p>\n<p>而下面的结果，则指明了哪行源码被覆盖了。<br><img src=\"/images/blog/karma-lcov-2.png\" alt=\"\"></p>"},{"layout":"post","title":"从windows到linux","date":"2013-05-02T08:37:00.000Z","comments":1,"_content":"从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.   \n\n高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.    \n\n大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.    \n\n研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.    \n\n工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.    \n\n大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.\n\n个人常用软件推荐:   \n\n* office: wps for linux  or libreoffice\n* 输入法:  sogou for linux\n* 开发IDE: Intellij IDEA or Eclipse\n* 编辑器: sublime,retext\n* 浏览器: chrome,firefox\n* 邮件客户端: thunderbird","source":"_posts/2013-05-02-my-linux-dream.markdown","raw":"---\nlayout: post\ntitle: \"从windows到linux\"\ndate: 2013-05-02 16:37\ncomments: true\ncategories: linux\n---\n从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.   \n\n高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.    \n\n大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.    \n\n研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.    \n\n工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.    \n\n大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.\n\n个人常用软件推荐:   \n\n* office: wps for linux  or libreoffice\n* 输入法:  sogou for linux\n* 开发IDE: Intellij IDEA or Eclipse\n* 编辑器: sublime,retext\n* 浏览器: chrome,firefox\n* 邮件客户端: thunderbird","slug":"2013-05-02-my-linux-dream","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5g005mv8fy0y4omzdk","content":"<p>从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.   </p>\n<p>高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.    </p>\n<p>大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.    </p>\n<p>研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.    </p>\n<p>工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.    </p>\n<p>大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.</p>\n<p>个人常用软件推荐:   </p>\n<ul>\n<li>office: wps for linux  or libreoffice</li>\n<li>输入法:  sogou for linux</li>\n<li>开发IDE: Intellij IDEA or Eclipse</li>\n<li>编辑器: sublime,retext</li>\n<li>浏览器: chrome,firefox</li>\n<li>邮件客户端: thunderbird</li>\n</ul>\n","excerpt":"","more":"<p>从高中时代最早接触计算机,当初什么都不懂,能会用下email就绝对是达人了啊.最早见到OS应该是windows 95,那时候虽然已经出了windows 98,不过学校仍预装的是windows 95.   </p>\n<p>高中时期,就感觉计算机挺新奇,很感兴趣,至于具体会发展到什么样也不清楚.大学报考时间果断选择了计算机科学与技术这一专业.从此就走上了这一不归路.    </p>\n<p>大学时期对计算机有了更深刻的认识,也知道除了windows之外还有一个linux的东西所在.这期间先后给自己的机器安装过红帽,安装过国产的红旗.不过这些东西也都没有什么深入,安装后发现也很不好用,不得已而放弃掉.    </p>\n<p>研究生期间有更多的linux伙伴,有人在用也有人给推荐.那个时候选择了ubuntu作为自己首选,因为大家推荐说资源多,新人入手容易.那个时候应该是9.04左右的版本.    </p>\n<p>工作后,接触到了更多的服务器,也经历了各种在windows下的程序无法很好在linux运行的情况,因此下决心学习.私人的笔记本装上了ubuntu 10.04,不过公司的工作电脑还是没敢做成ubuntu系统,只是弄了一个虚拟机.    </p>\n<p>大概在大半年以前,我下定了决心,把系统给完全换成了ubuntu,版本也升到了12.04.这时的系统已经足够成熟,几乎可以满足工作的需要.而最近发布的ubuntu 13.04则更加的完善,各种替代软件都可以找到.</p>\n<p>个人常用软件推荐:   </p>\n<ul>\n<li>office: wps for linux  or libreoffice</li>\n<li>输入法:  sogou for linux</li>\n<li>开发IDE: Intellij IDEA or Eclipse</li>\n<li>编辑器: sublime,retext</li>\n<li>浏览器: chrome,firefox</li>\n<li>邮件客户端: thunderbird</li>\n</ul>\n"},{"layout":"post","title":"《HTTP权威指南》读书笔记1","date":"2013-05-15T08:53:00.000Z","comments":1,"_content":"###URL语法###\n完整的URL是建立在由以下9个部分构成的通用格式上的。  \n\n    <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>   \n其中各个部分代表：   \n\n- scheme(方案)：使用的哪种协议;默认无\n- user（用户）：用户名；默认匿名\n- password(密码)：密码\n- host(主机)：服务器主机名或点分IP地址\n- port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80\n- path(路径)：/分割的资源路径\n- params(参数)：名/值对，使用；分割。\n- query（查询）：名=值对，用&分割多个\n- frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。\n<!--more-->\n###HTTP报文格式###\n####1.请求报文（request message）####\n\n    <method> <request-URL> <version>\n    <headers>\n    \n    <entity-body>\n例如：\n\n    GET /images/blog/qunit-pic.png HTTP/1.0\n    Host: www.shenyanchao.cn\n    \n####2.响应报文（request message）####\n\n    <version> <status-code> <reason-phrase>\n    <headers>\n    \n    <entity-body>\n例如：   \n\n    HTTP/1.1 200 OK\n    Content-Type: image/png\n    Content-Length: 18107\n    \n以上报文格式中，各个部分的描述如下：   \n\n- method（方法）：希望服务器对资源执行的动作。如GET，POST等。\n- request-URL（请求的URL）：要请求的资源。\n- version（版本）：报文使用的HTTP协议版本。\n- status-code(状态码)：描述了请求过程中的状态。\n- reason-phrase（原因短语）：状态码的可读版本。 \n- header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。\n- entity-body（实体的主题部分）：任意数据组成的数据块。\n\n###HTTP方法###\n####1.GET####\n请求服务器发送某个资源。请求无主体部分。\n####2.HEAD####\n与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：   \n\n- 在不获取资源的情况下了解资源的情况（比如其类型）;\n- 通过查看响应中的状态码，判断某个对象是否存在。\n- 通过查看header，测试资源是否被修改了。\n\n####3.PUT####\nPUT方法用于向服务器写入文档。请求有主体部分。   \n####4.POST####\nPOST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。\n####5.TRACE####\n客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。\n####6.OPTIONS####\nOPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。  \n####7.DELETE####\nDELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。\n\n###HTTP连接###\nHTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。   \nHTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：   \n  \n- 客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。\n- 客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。\n- 连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。\n- 服务器回送响应也花费时间。\n\n####1.TCP连接握手时延\n由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。\n####2.延迟确认\n网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。   \n由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。     \n####3.TCP慢启动\nTCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。\n####4.Nagle算法与TCP_NODELAY\n一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。   \n####5.TIME_WAIT累积与端口耗尽\n在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。   \n\n###HTTP状态码\n\n+------------+---------------+---------+  \n|  整体范围   |   已定义范围     |   分类   |    \n+------------+----------------+---------+   \n| 100～199   | 100～101        | 信息提示 |   \n+------------+----------------+---------+   \n| 200～299   | 200～206        | 成功    |    \n+------------+----------------+---------+   \n| 300~399    | 300~305        | 重定向   |    \n+------------+----------------+---------+   \n| 400～499   | 400～415       |客户端错误|   \n+------------+----------------+---------+   \n| 500~599    | 500~505        | 服务器错误|     \n+------------+----------------+---------+    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2013-05-15-http-the-definitive-guide-reading-notes.markdown","raw":"---\nlayout: post\ntitle: \"《HTTP权威指南》读书笔记1\"\ndate: 2013-05-15 16:53\ncomments: true\ncategories: HTTP\ntags: [ HTTP, 读书笔记 ]\n---\n###URL语法###\n完整的URL是建立在由以下9个部分构成的通用格式上的。  \n\n    <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>   \n其中各个部分代表：   \n\n- scheme(方案)：使用的哪种协议;默认无\n- user（用户）：用户名；默认匿名\n- password(密码)：密码\n- host(主机)：服务器主机名或点分IP地址\n- port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80\n- path(路径)：/分割的资源路径\n- params(参数)：名/值对，使用；分割。\n- query（查询）：名=值对，用&分割多个\n- frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。\n<!--more-->\n###HTTP报文格式###\n####1.请求报文（request message）####\n\n    <method> <request-URL> <version>\n    <headers>\n    \n    <entity-body>\n例如：\n\n    GET /images/blog/qunit-pic.png HTTP/1.0\n    Host: www.shenyanchao.cn\n    \n####2.响应报文（request message）####\n\n    <version> <status-code> <reason-phrase>\n    <headers>\n    \n    <entity-body>\n例如：   \n\n    HTTP/1.1 200 OK\n    Content-Type: image/png\n    Content-Length: 18107\n    \n以上报文格式中，各个部分的描述如下：   \n\n- method（方法）：希望服务器对资源执行的动作。如GET，POST等。\n- request-URL（请求的URL）：要请求的资源。\n- version（版本）：报文使用的HTTP协议版本。\n- status-code(状态码)：描述了请求过程中的状态。\n- reason-phrase（原因短语）：状态码的可读版本。 \n- header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。\n- entity-body（实体的主题部分）：任意数据组成的数据块。\n\n###HTTP方法###\n####1.GET####\n请求服务器发送某个资源。请求无主体部分。\n####2.HEAD####\n与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：   \n\n- 在不获取资源的情况下了解资源的情况（比如其类型）;\n- 通过查看响应中的状态码，判断某个对象是否存在。\n- 通过查看header，测试资源是否被修改了。\n\n####3.PUT####\nPUT方法用于向服务器写入文档。请求有主体部分。   \n####4.POST####\nPOST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。\n####5.TRACE####\n客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。\n####6.OPTIONS####\nOPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。  \n####7.DELETE####\nDELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。\n\n###HTTP连接###\nHTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。   \nHTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：   \n  \n- 客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。\n- 客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。\n- 连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。\n- 服务器回送响应也花费时间。\n\n####1.TCP连接握手时延\n由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。\n####2.延迟确认\n网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。   \n由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。     \n####3.TCP慢启动\nTCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。\n####4.Nagle算法与TCP_NODELAY\n一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。   \n####5.TIME_WAIT累积与端口耗尽\n在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。   \n\n###HTTP状态码\n\n+------------+---------------+---------+  \n|  整体范围   |   已定义范围     |   分类   |    \n+------------+----------------+---------+   \n| 100～199   | 100～101        | 信息提示 |   \n+------------+----------------+---------+   \n| 200～299   | 200～206        | 成功    |    \n+------------+----------------+---------+   \n| 300~399    | 300~305        | 重定向   |    \n+------------+----------------+---------+   \n| 400～499   | 400～415       |客户端错误|   \n+------------+----------------+---------+   \n| 500~599    | 500~505        | 服务器错误|     \n+------------+----------------+---------+    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2013-05-15-http-the-definitive-guide-reading-notes","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5i005pv8fy7wbgi7yf","content":"<p>###URL语法###<br>完整的URL是建立在由以下9个部分构成的通用格式上的。  </p>\n<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;   \n</code></pre><p>其中各个部分代表：   </p>\n<ul>\n<li>scheme(方案)：使用的哪种协议;默认无</li>\n<li>user（用户）：用户名；默认匿名</li>\n<li>password(密码)：密码</li>\n<li>host(主机)：服务器主机名或点分IP地址</li>\n<li>port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80</li>\n<li>path(路径)：/分割的资源路径</li>\n<li>params(参数)：名/值对，使用；分割。</li>\n<li>query（查询）：名=值对，用&amp;分割多个</li>\n<li><p>frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。</p>\n<a id=\"more\"></a>\n<p>###HTTP报文格式###<br>####1.请求报文（request message）####</p>\n<p>  <method> <request-url> <version></version></request-url></method></p>\n  <headers>\n\n<p>  <entity-body><br>例如：</entity-body></p>\n<p>  GET /images/blog/qunit-pic.png HTTP/1.0<br>  Host: www.shenyanchao.cn</p>\n</headers></li>\n</ul>\n<p>####2.响应报文（request message）####</p>\n<pre><code>&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;\n&lt;headers&gt;\n\n&lt;entity-body&gt;\n</code></pre><p>例如：   </p>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: image/png\nContent-Length: 18107\n</code></pre><p>以上报文格式中，各个部分的描述如下：   </p>\n<ul>\n<li>method（方法）：希望服务器对资源执行的动作。如GET，POST等。</li>\n<li>request-URL（请求的URL）：要请求的资源。</li>\n<li>version（版本）：报文使用的HTTP协议版本。</li>\n<li>status-code(状态码)：描述了请求过程中的状态。</li>\n<li>reason-phrase（原因短语）：状态码的可读版本。 </li>\n<li>header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。</li>\n<li>entity-body（实体的主题部分）：任意数据组成的数据块。</li>\n</ul>\n<p>###HTTP方法###</p>\n<p>####1.GET####<br>请求服务器发送某个资源。请求无主体部分。</p>\n<p>####2.HEAD####<br>与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：   </p>\n<ul>\n<li>在不获取资源的情况下了解资源的情况（比如其类型）;</li>\n<li>通过查看响应中的状态码，判断某个对象是否存在。</li>\n<li>通过查看header，测试资源是否被修改了。</li>\n</ul>\n<p>####3.PUT####<br>PUT方法用于向服务器写入文档。请求有主体部分。   </p>\n<p>####4.POST####<br>POST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。</p>\n<p>####5.TRACE####<br>客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。</p>\n<p>####6.OPTIONS####<br>OPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。  </p>\n<p>####7.DELETE####<br>DELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。</p>\n<p>###HTTP连接###<br>HTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。<br>HTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：   </p>\n<ul>\n<li>客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。</li>\n<li>客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。</li>\n<li>连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。</li>\n<li>服务器回送响应也花费时间。</li>\n</ul>\n<p>####1.TCP连接握手时延<br>由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。</p>\n<p>####2.延迟确认<br>网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。<br>由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。     </p>\n<p>####3.TCP慢启动<br>TCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。</p>\n<p>####4.Nagle算法与TCP_NODELAY<br>一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。   </p>\n<p>####5.TIME_WAIT累积与端口耗尽<br>在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。   </p>\n<p>###HTTP状态码</p>\n<p>+————+—————+———+<br>|  整体范围   |   已定义范围     |   分类   |<br>+————+—————-+———+<br>| 100～199   | 100～101        | 信息提示 |<br>+————+—————-+———+<br>| 200～299   | 200～206        | 成功    |<br>+————+—————-+———+<br>| 300~399    | 300~305        | 重定向   |<br>+————+—————-+———+<br>| 400～499   | 400～415       |客户端错误|<br>+————+—————-+———+<br>| 500~599    | 500~505        | 服务器错误|<br>+————+—————-+———+    </p>\n","excerpt":"<p>###URL语法###<br>完整的URL是建立在由以下9个部分构成的通用格式上的。  </p>\n<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;   \n</code></pre><p>其中各个部分代表：   </p>\n<ul>\n<li>scheme(方案)：使用的哪种协议;默认无</li>\n<li>user（用户）：用户名；默认匿名</li>\n<li>password(密码)：密码</li>\n<li>host(主机)：服务器主机名或点分IP地址</li>\n<li>port(端口)：服务器监听端口。不同协议，默认值不一样，HTTP默认80</li>\n<li>path(路径)：/分割的资源路径</li>\n<li>params(参数)：名/值对，使用；分割。</li>\n<li>query（查询）：名=值对，用&amp;分割多个</li>\n<li><p>frag（片段）：小片资源的名字。在html就是一个锚点名了。自动从锚点开始显示。</p>","more":"<p>###HTTP报文格式###<br>####1.请求报文（request message）####</p>\n<p>  <method> <request-URL> <version></p>\n  <headers>\n\n<p>  <entity-body><br>例如：</p>\n<p>  GET /images/blog/qunit-pic.png HTTP/1.0<br>  Host: www.shenyanchao.cn</p>\n</li>\n</ul>\n<p>####2.响应报文（request message）####</p>\n<pre><code>&lt;version&gt; &lt;status-code&gt; &lt;reason-phrase&gt;\n&lt;headers&gt;\n\n&lt;entity-body&gt;\n</code></pre><p>例如：   </p>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: image/png\nContent-Length: 18107\n</code></pre><p>以上报文格式中，各个部分的描述如下：   </p>\n<ul>\n<li>method（方法）：希望服务器对资源执行的动作。如GET，POST等。</li>\n<li>request-URL（请求的URL）：要请求的资源。</li>\n<li>version（版本）：报文使用的HTTP协议版本。</li>\n<li>status-code(状态码)：描述了请求过程中的状态。</li>\n<li>reason-phrase（原因短语）：状态码的可读版本。 </li>\n<li>header(首部)：可以有0或多个首部。每个首部，名字跟着一个冒号，紧接着是空格，然后是一个值，最后是一个CRLF。</li>\n<li>entity-body（实体的主题部分）：任意数据组成的数据块。</li>\n</ul>\n<p>###HTTP方法###</p>\n<p>####1.GET####<br>请求服务器发送某个资源。请求无主体部分。</p>\n<p>####2.HEAD####<br>与GET方法类似，但服务器在响应中只返回header。请求无主体部分，同时服务器也不会返回主体部分。使用HEAD方法，主要用于以下：   </p>\n<ul>\n<li>在不获取资源的情况下了解资源的情况（比如其类型）;</li>\n<li>通过查看响应中的状态码，判断某个对象是否存在。</li>\n<li>通过查看header，测试资源是否被修改了。</li>\n</ul>\n<p>####3.PUT####<br>PUT方法用于向服务器写入文档。请求有主体部分。   </p>\n<p>####4.POST####<br>POST方法用于向服务器输入数据。经常用于表单提交。请求有主体部分。</p>\n<p>####5.TRACE####<br>客户端发起一个请求时，这个请求可能要船防火墙、代理、网关或其他一些应用程序。每个中间点都可能修改原始HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。简单说，就是TRACE方式会把服务器接受到的请求，返回给客户端。请求无主体部分。</p>\n<p>####6.OPTIONS####<br>OPTIONS方法请求WEB服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法。这位客户端提供了一种手段，使其不用访问那些资源就能判定访问各资源的最优方式。请求无主体部分。  </p>\n<p>####7.DELETE####<br>DELETE方法，请求服务器删除请求URL所指定的资源。请求无主体部分。</p>\n<p>###HTTP连接###<br>HTTP通信都是由TCP/IP所承载的。HTTP连接实际上就是TCP连接及其使用规则，TCP连接是因特网上的可靠连接。TCP有著名的“三次握手”以及“四次挥手”来保证有效可靠的连接。<br>HTTP性能在很大程度上取决于底层TCP通道的性能。影响TCP性能主要有以下几个方面：   </p>\n<ul>\n<li>客户端需要根据URI确定WEB服务器的IP和端口号。这依赖于DNS解析速度，有可能很慢。</li>\n<li>客户端与服务器端建立TCP连接有时延。如果并发大的话，时延更长。</li>\n<li>连接建立后，通过TCP管道发送HTTP请求，然后服务器读取报文并处理都耗费时间。</li>\n<li>服务器回送响应也花费时间。</li>\n</ul>\n<p>####1.TCP连接握手时延<br>由于3次握手的存在，很可能造成：小的HTTP事务可能在TCP建立上花费50%乃至更多的时间。这样很不划算了。</p>\n<p>####2.延迟确认<br>网络无法确保可靠的分组传输，因此TCP实现了自己的确认机制来确保数据的成功传输。每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者认为没发送成功，并重发数据。<br>由于确认报文很小，所以TCP允许在发往同方向的输出数据分组中对其进行“捎带”。TCP中称之为“延迟确认”。延迟确认算法在一个特定的窗口时间（100～200ms）内将输出确认放在缓冲区内，以寻找能够捎带它的数据分组。如果那段时间没没有，就单独发送。延迟确认算法会引入相当大的时延。     </p>\n<p>####3.TCP慢启动<br>TCP数据传输的性能取决于TCP连接的使用时间。TCP连接随着时间进行自我调谐，防止因特网的突然过载和拥塞。因此新连接的传输速度会比已经调谐的连接慢一些。</p>\n<p>####4.Nagle算法与TCP_NODELAY<br>一个TCP段都至少装载了40个字节的标记和首部，如果TCP发送大量只包含少量的分组（一个字节），网络的性能就会严重下降。Nagle算法试图在发送一个分组前，将大量TCP数据绑定在一起来提高网络效率。但是这样也造成了不少时延，HTTP应用程序常常在自己的栈中设置参数TCP_NODELAY来禁用Nagle算法。   </p>\n<p>####5.TIME_WAIT累积与端口耗尽<br>在四次挥手中，客户端关闭TCP连接时，会在内存维护一个小的控制块，用来记录最近所关闭的连接的IP地址和端口号。此时客户端处于TIME_WAIT状态，并维持2MSL（2分钟）的时间，确保这段时间内不会创建具有相同地址和端口号的新连接。这个时候问题就来了，在做性能测试的时候，很容易造成大量TIME_WAIT的连接，同时也不能新建新的连接了，因为无端口可用了。这也是增加时延的因素。可以考虑改小MSL。   </p>\n<p>###HTTP状态码</p>\n<p>+————+—————+———+<br>|  整体范围   |   已定义范围     |   分类   |<br>+————+—————-+———+<br>| 100～199   | 100～101        | 信息提示 |<br>+————+—————-+———+<br>| 200～299   | 200～206        | 成功    |<br>+————+—————-+———+<br>| 300~399    | 300~305        | 重定向   |<br>+————+—————-+———+<br>| 400～499   | 400～415       |客户端错误|<br>+————+—————-+———+<br>| 500~599    | 500~505        | 服务器错误|<br>+————+—————-+———+    </p>"},{"layout":"post","title":"使用Maven Archetype来生成项目框架","date":"2013-05-21T08:36:00.000Z","comments":1,"_content":"###Maven in 5 Minutes\n[maven官方文档](http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html)的入门章节就介绍了如何创建一个maven项目。大致如下：   \n\n    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     \n我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？    \n其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。\n<!--more-->\n###Maven Archetype Plugin\n我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。    \nMaven Archetype Plugin有4个Goal:    \n\n- archetype:create 已过时，用于从archetype创建maven project\n- archetype:generate  替代create,并且可以用交互的模式\n- archetype:create-from-project 依据存在的project 创建archetype\n- archetype:crawl 查找repo里存在的archetypes并更新目录。\n\n###实战演练一把\n假设我们已经有了一个项目名叫seleniumframework-start:   \n进入到这个工程的根目录，首先执行：   \n\n    mvn clean archetype:create-from-project\n这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：   \n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n      <modelVersion>4.0.0</modelVersion>\n    \n      <groupId>com.baidu.selenium.archetypes</groupId>\n      <artifactId>seleniumframework-start-archetype</artifactId>\n      <version>1.0.0</version>\n      <packaging>maven-archetype</packaging>\n    \n      <name>seleniumframework-start-archetype</name>\n    \n      <build>\n        <extensions>\n          <extension>\n            <groupId>org.apache.maven.archetype</groupId>\n            <artifactId>archetype-packaging</artifactId>\n            <version>2.2</version>\n          </extension>\n        </extensions>\n    \n        <pluginManagement>\n          <plugins>\n            <plugin>\n              <artifactId>maven-archetype-plugin</artifactId>\n              <version>2.2</version>\n            </plugin>\n          </plugins>\n        </pluginManagement>\n      </build>\n    </project>\n这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：  \n\n- ${groupId}\n- ${artifactId}\n- ${version}\n- ${package}\n\n找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`转为了`<?xml version=\"${version}\" encoding=\"UTF-8\"?>^`。这并不是我们想要的，`${version}`是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：   \n    \n    mvn clean install\n这样，这个archetype就安装到了local repository。\n如何使用呢？咱们试试。   \n\n    mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes \\\n    -DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0\n其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。  \n此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。  \n\n    ","source":"_posts/2013-05-21-use-maven-archetype-to-generate-project-architecture.markdown","raw":"---\nlayout: post\ntitle: \"使用Maven Archetype来生成项目框架\"\ndate: 2013-05-21 16:36\ncomments: true\ncategories: maven\ntags: [ maven, archetype, generate, selenium ]\n---\n###Maven in 5 Minutes\n[maven官方文档](http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html)的入门章节就介绍了如何创建一个maven项目。大致如下：   \n\n    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     \n我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？    \n其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。\n<!--more-->\n###Maven Archetype Plugin\n我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。    \nMaven Archetype Plugin有4个Goal:    \n\n- archetype:create 已过时，用于从archetype创建maven project\n- archetype:generate  替代create,并且可以用交互的模式\n- archetype:create-from-project 依据存在的project 创建archetype\n- archetype:crawl 查找repo里存在的archetypes并更新目录。\n\n###实战演练一把\n假设我们已经有了一个项目名叫seleniumframework-start:   \n进入到这个工程的根目录，首先执行：   \n\n    mvn clean archetype:create-from-project\n这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：   \n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n      <modelVersion>4.0.0</modelVersion>\n    \n      <groupId>com.baidu.selenium.archetypes</groupId>\n      <artifactId>seleniumframework-start-archetype</artifactId>\n      <version>1.0.0</version>\n      <packaging>maven-archetype</packaging>\n    \n      <name>seleniumframework-start-archetype</name>\n    \n      <build>\n        <extensions>\n          <extension>\n            <groupId>org.apache.maven.archetype</groupId>\n            <artifactId>archetype-packaging</artifactId>\n            <version>2.2</version>\n          </extension>\n        </extensions>\n    \n        <pluginManagement>\n          <plugins>\n            <plugin>\n              <artifactId>maven-archetype-plugin</artifactId>\n              <version>2.2</version>\n            </plugin>\n          </plugins>\n        </pluginManagement>\n      </build>\n    </project>\n这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：  \n\n- ${groupId}\n- ${artifactId}\n- ${version}\n- ${package}\n\n找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`转为了`<?xml version=\"${version}\" encoding=\"UTF-8\"?>^`。这并不是我们想要的，`${version}`是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：   \n    \n    mvn clean install\n这样，这个archetype就安装到了local repository。\n如何使用呢？咱们试试。   \n\n    mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes \\\n    -DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0\n其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。  \n此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。  \n\n    ","slug":"2013-05-21-use-maven-archetype-to-generate-project-architecture","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5o005tv8fyr4xq7jts","content":"<p>###Maven in 5 Minutes<br><a href=\"http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html\" target=\"_blank\" rel=\"external\">maven官方文档</a>的入门章节就介绍了如何创建一个maven项目。大致如下：   </p>\n<pre><code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     \n</code></pre><p>我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？<br>其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。<br><a id=\"more\"></a></p>\n<p>###Maven Archetype Plugin<br>我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。<br>Maven Archetype Plugin有4个Goal:    </p>\n<ul>\n<li>archetype:create 已过时，用于从archetype创建maven project</li>\n<li>archetype:generate  替代create,并且可以用交互的模式</li>\n<li>archetype:create-from-project 依据存在的project 创建archetype</li>\n<li>archetype:crawl 查找repo里存在的archetypes并更新目录。</li>\n</ul>\n<p>###实战演练一把<br>假设我们已经有了一个项目名叫seleniumframework-start:<br>进入到这个工程的根目录，首先执行：   </p>\n<pre><code>mvn clean archetype:create-from-project\n</code></pre><p>这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：   </p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.baidu.selenium.archetypes&lt;/groupId&gt;\n  &lt;artifactId&gt;seleniumframework-start-archetype&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;packaging&gt;maven-archetype&lt;/packaging&gt;\n\n  &lt;name&gt;seleniumframework-start-archetype&lt;/name&gt;\n\n  &lt;build&gt;\n    &lt;extensions&gt;\n      &lt;extension&gt;\n        &lt;groupId&gt;org.apache.maven.archetype&lt;/groupId&gt;\n        &lt;artifactId&gt;archetype-packaging&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n      &lt;/extension&gt;\n    &lt;/extensions&gt;\n\n    &lt;pluginManagement&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.2&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre><p>这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：  </p>\n<ul>\n<li>${groupId}</li>\n<li>${artifactId}</li>\n<li>${version}</li>\n<li>${package}</li>\n</ul>\n<p>找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>转为了<code>&lt;?xml version=&quot;${version}&quot; encoding=&quot;UTF-8&quot;?&gt;^</code>。这并不是我们想要的，<code>${version}</code>是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：   </p>\n<pre><code>mvn clean install\n</code></pre><p>这样，这个archetype就安装到了local repository。<br>如何使用呢？咱们试试。   </p>\n<pre><code>mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes \\\n-DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0\n</code></pre><p>其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。<br>此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。  </p>\n","excerpt":"<p>###Maven in 5 Minutes<br><a href=\"http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html\">maven官方文档</a>的入门章节就介绍了如何创建一个maven项目。大致如下：   </p>\n<pre><code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false     \n</code></pre><p>我相信，很多人都是从这里开始的。但是为什么是这样呢？这里面都是怎么实现的？<br>其实，这里面是maven archetype的作用。它可以根据模板为你生成样例项目。<br>","more":"</p>\n<p>###Maven Archetype Plugin<br>我们使用这个插件可以依据已经存在的项目来生成一个架构。这样其他人就可以使用这个架构来快速生成自己的项目了。<br>Maven Archetype Plugin有4个Goal:    </p>\n<ul>\n<li>archetype:create 已过时，用于从archetype创建maven project</li>\n<li>archetype:generate  替代create,并且可以用交互的模式</li>\n<li>archetype:create-from-project 依据存在的project 创建archetype</li>\n<li>archetype:crawl 查找repo里存在的archetypes并更新目录。</li>\n</ul>\n<p>###实战演练一把<br>假设我们已经有了一个项目名叫seleniumframework-start:<br>进入到这个工程的根目录，首先执行：   </p>\n<pre><code>mvn clean archetype:create-from-project\n</code></pre><p>这样就生成了一个archetype的代码。其路径位于./target/generated-sources/archetype目录内。其中pom.xml类似：   </p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.baidu.selenium.archetypes&lt;/groupId&gt;\n  &lt;artifactId&gt;seleniumframework-start-archetype&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;packaging&gt;maven-archetype&lt;/packaging&gt;\n\n  &lt;name&gt;seleniumframework-start-archetype&lt;/name&gt;\n\n  &lt;build&gt;\n    &lt;extensions&gt;\n      &lt;extension&gt;\n        &lt;groupId&gt;org.apache.maven.archetype&lt;/groupId&gt;\n        &lt;artifactId&gt;archetype-packaging&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n      &lt;/extension&gt;\n    &lt;/extensions&gt;\n\n    &lt;pluginManagement&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;\n          &lt;version&gt;2.2&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre><p>这个就是要生成的seleniumframework-start-archetype的pom.xml了。一般情况下生成的代码是不能直接使用的，需要做一些修改。这其中主要有以下几个变量需要替换：  </p>\n<ul>\n<li>${groupId}</li>\n<li>${artifactId}</li>\n<li>${version}</li>\n<li>${package}</li>\n</ul>\n<p>找到./target/generated-sources/archetype/src/main/resources/archetype-resources目录，这里面就是要生成的文件模板了，这个时候需要注意以上几个占位符出现的地方是否正确，可以按照需要进行修改。常见的情况是把XML文件里的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>转为了<code>&lt;?xml version=&quot;${version}&quot; encoding=&quot;UTF-8&quot;?&gt;^</code>。这并不是我们想要的，<code>${version}</code>是用来指项目的版本号，因此此处去掉占位符。有的其他地方，应该要使用占位符的可以根据需要修改。修改完毕，那么返回./target/generated-sources/archetype目录，install之：   </p>\n<pre><code>mvn clean install\n</code></pre><p>这样，这个archetype就安装到了local repository。<br>如何使用呢？咱们试试。   </p>\n<pre><code>mvn archetype:generate -DarchetypeGroupId=com.baidu.selenium.archetypes \\\n-DarchetypeArtifactId=seleniumframework-start-archetype -DarchetypeVersion=1.0.0\n</code></pre><p>其中，有一些交互信息需要确认。依次是groupId,artifactId,version,package。按照要求输入后，这些信息就是用来分别替代上面说的几个变量了，项目就顺利生成了。<br>此时，seleniumframework-start-archetype还只能自己使用，因为它只存在于local repository内。为了让大家共享成果，将这个包deploy到伺服器就OK了。  </p>"},{"layout":"post","title":"selenium 文档:入门介绍","date":"2013-05-30T11:54:00.000Z","comments":1,"_content":"# 介绍\n\n## 用于网站应用的测试自动化\n\n如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。\n\n测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。\n\n本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。\n\n对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：\n\n- 频繁的回归测试\n- 快速反馈\n- 几乎无限制的测试用例迭代执行\n- 支持敏捷和极限编程\n- 遵循测试用例的文档\n- 自定义缺陷报告\n- 能找出手工测试中没发现的缺陷\n<!--more-->\n## 自动化？或不自动化？\n\n自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？\n\n自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。\n\n## 介绍 Selenium\n\nSelenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。\n\n## Selenium 项目简史\n\nSelenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。\n\nSelenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。\n\n在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。\n\n跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：\n\n> 为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。\n\n## Selenium 工具集\n\nSelenium 由多个软件工具组成，每个具备特定的功能。\n\n### Selenium 2 (又叫 Selenium Webdriver)\n\nSelenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。\n\n正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。\n\nSelenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。 \n\n### Selenium 1 (又叫 Selenium RC 或 Remote Control)\n\n正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.\n\nSeleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。\n\n### Selenium IDE\n\nSelenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。\n\n**注意** \n\n虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.\n\n### Selenium-Grid\n\nSelenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。\n\n## 选择合适你的 Selenium 工具\n\n很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。\n\n但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。\n\n在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。\n\n我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。\n\n## 支持的浏览器和平台\n\n在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。\n\n### Selenium-WebDriver\n\nSelenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。\n\n- Google Chrome 12.0.712.0+\n- Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable\n- Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7\n- Opera 11.5+\n- HtmlUnit 2.9\n- Android – 2.3+ for phones and tablets (devices & emulators)\n- iOS 3+ for phones (devices & emulators) and 3.2+ for tablets (devices & emulators)\n\n**注意：** \n\n在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。\n\n### Selenium 1.0 and Selenium-RC\n\n这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。\n\n<table border=\"1\">\n    <tbody>\n    <tr>\n        <td><strong>Browser</strong></td>\n        <td><strong>Selenium IDE</strong></td>\n        <td><strong>Selenium 1 (RC)</strong></td>\n        <td><strong>Operating Systems</strong></td>\n    </tr>\n    <tr>\n        <td>Firefox 3.x</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Firefox 3</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Firefox 2</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>IE 8</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>IE 7</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>IE 6</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>Safari 4</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Safari 3</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Safari 2</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 10</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 9</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 8</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Google Chrome</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Others</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Partial support possible**</td>\n        <td>As applicable</td>\n    </tr>\n    </tbody>\n</table>\n\n\\* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。\n\n\\*\\* Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。\n\n## 灵活性和可扩展性\n\n你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。\n\n## 本文档包含哪些内容？\n\n本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。\n\n剩下的章节将讲述以下内容:\n\n### Selenium IDE\n\n介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。\n\n### Selenium 2\n\n解释如何通过 Selenium 2 创建自动化测试项目。\n\n### Selenium 1\n\n解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。\n\n### 测试设计\n\n这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。\n\n### Selenium-Grid\n\n这部分内容未完成。\n\n### User extensions\n\n讲述如何修改、扩展和定制 Selenium。\n\n\n\n\n\n\n","source":"_posts/2013-05-30-selenium-doc-introduction.markdown","raw":"---\nlayout: post\ntitle: \"selenium 文档:入门介绍\"\ndate: 2013-05-30 19:54\ncomments: true\ncategories: selenium官方文档\ntags: [ selenium ]\n---\n# 介绍\n\n## 用于网站应用的测试自动化\n\n如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。\n\n测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。\n\n本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。\n\n对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：\n\n- 频繁的回归测试\n- 快速反馈\n- 几乎无限制的测试用例迭代执行\n- 支持敏捷和极限编程\n- 遵循测试用例的文档\n- 自定义缺陷报告\n- 能找出手工测试中没发现的缺陷\n<!--more-->\n## 自动化？或不自动化？\n\n自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？\n\n自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。\n\n## 介绍 Selenium\n\nSelenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。\n\n## Selenium 项目简史\n\nSelenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。\n\nSelenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。\n\n在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。\n\n跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：\n\n> 为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。\n\n## Selenium 工具集\n\nSelenium 由多个软件工具组成，每个具备特定的功能。\n\n### Selenium 2 (又叫 Selenium Webdriver)\n\nSelenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。\n\n正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。\n\nSelenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。 \n\n### Selenium 1 (又叫 Selenium RC 或 Remote Control)\n\n正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.\n\nSeleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。\n\n### Selenium IDE\n\nSelenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。\n\n**注意** \n\n虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.\n\n### Selenium-Grid\n\nSelenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。\n\n## 选择合适你的 Selenium 工具\n\n很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。\n\n但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。\n\n在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。\n\n我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。\n\n## 支持的浏览器和平台\n\n在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。\n\n### Selenium-WebDriver\n\nSelenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。\n\n- Google Chrome 12.0.712.0+\n- Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable\n- Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7\n- Opera 11.5+\n- HtmlUnit 2.9\n- Android – 2.3+ for phones and tablets (devices & emulators)\n- iOS 3+ for phones (devices & emulators) and 3.2+ for tablets (devices & emulators)\n\n**注意：** \n\n在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。\n\n### Selenium 1.0 and Selenium-RC\n\n这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。\n\n<table border=\"1\">\n    <tbody>\n    <tr>\n        <td><strong>Browser</strong></td>\n        <td><strong>Selenium IDE</strong></td>\n        <td><strong>Selenium 1 (RC)</strong></td>\n        <td><strong>Operating Systems</strong></td>\n    </tr>\n    <tr>\n        <td>Firefox 3.x</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Firefox 3</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Firefox 2</td>\n        <td>Record and playback tests</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>IE 8</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>IE 7</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>IE 6</td>\n        <td>Test execution only via Selenium RC*</td>\n        <td>Start browser, run tests</td>\n        <td>Windows</td>\n    </tr>\n    <tr>\n        <td>Safari 4</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Safari 3</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Safari 2</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 10</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 9</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Opera 8</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Google Chrome</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Start browser, run tests</td>\n        <td>Windows, Linux, Mac</td>\n    </tr>\n    <tr>\n        <td>Others</td>\n        <td>Test execution only via Selenium RC</td>\n        <td>Partial support possible**</td>\n        <td>As applicable</td>\n    </tr>\n    </tbody>\n</table>\n\n\\* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。\n\n\\*\\* Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。\n\n## 灵活性和可扩展性\n\n你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。\n\n## 本文档包含哪些内容？\n\n本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。\n\n剩下的章节将讲述以下内容:\n\n### Selenium IDE\n\n介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。\n\n### Selenium 2\n\n解释如何通过 Selenium 2 创建自动化测试项目。\n\n### Selenium 1\n\n解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。\n\n### 测试设计\n\n这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。\n\n### Selenium-Grid\n\n这部分内容未完成。\n\n### User extensions\n\n讲述如何修改、扩展和定制 Selenium。\n\n\n\n\n\n\n","slug":"2013-05-30-selenium-doc-introduction","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5q005xv8fypyyi40s3","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"用于网站应用的测试自动化\"><a href=\"#用于网站应用的测试自动化\" class=\"headerlink\" title=\"用于网站应用的测试自动化\"></a>用于网站应用的测试自动化</h2><p>如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。</p>\n<p>测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。</p>\n<p>本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。</p>\n<p>对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：</p>\n<ul>\n<li>频繁的回归测试</li>\n<li>快速反馈</li>\n<li>几乎无限制的测试用例迭代执行</li>\n<li>支持敏捷和极限编程</li>\n<li>遵循测试用例的文档</li>\n<li>自定义缺陷报告</li>\n<li>能找出手工测试中没发现的缺陷<a id=\"more\"></a>\n<h2 id=\"自动化？或不自动化？\"><a href=\"#自动化？或不自动化？\" class=\"headerlink\" title=\"自动化？或不自动化？\"></a>自动化？或不自动化？</h2></li>\n</ul>\n<p>自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？</p>\n<p>自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。</p>\n<h2 id=\"介绍-Selenium\"><a href=\"#介绍-Selenium\" class=\"headerlink\" title=\"介绍 Selenium\"></a>介绍 Selenium</h2><p>Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。</p>\n<h2 id=\"Selenium-项目简史\"><a href=\"#Selenium-项目简史\" class=\"headerlink\" title=\"Selenium 项目简史\"></a>Selenium 项目简史</h2><p>Selenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。</p>\n<p>Selenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。</p>\n<p>在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。</p>\n<p>跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：</p>\n<blockquote>\n<p>为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。</p>\n</blockquote>\n<h2 id=\"Selenium-工具集\"><a href=\"#Selenium-工具集\" class=\"headerlink\" title=\"Selenium 工具集\"></a>Selenium 工具集</h2><p>Selenium 由多个软件工具组成，每个具备特定的功能。</p>\n<h3 id=\"Selenium-2-又叫-Selenium-Webdriver\"><a href=\"#Selenium-2-又叫-Selenium-Webdriver\" class=\"headerlink\" title=\"Selenium 2 (又叫 Selenium Webdriver)\"></a>Selenium 2 (又叫 Selenium Webdriver)</h3><p>Selenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。</p>\n<p>正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。</p>\n<p>Selenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。 </p>\n<h3 id=\"Selenium-1-又叫-Selenium-RC-或-Remote-Control\"><a href=\"#Selenium-1-又叫-Selenium-RC-或-Remote-Control\" class=\"headerlink\" title=\"Selenium 1 (又叫 Selenium RC 或 Remote Control)\"></a>Selenium 1 (又叫 Selenium RC 或 Remote Control)</h3><p>正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.</p>\n<p>Seleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。</p>\n<h3 id=\"Selenium-IDE\"><a href=\"#Selenium-IDE\" class=\"headerlink\" title=\"Selenium IDE\"></a>Selenium IDE</h3><p>Selenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。</p>\n<p><strong>注意</strong> </p>\n<p>虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.</p>\n<h3 id=\"Selenium-Grid\"><a href=\"#Selenium-Grid\" class=\"headerlink\" title=\"Selenium-Grid\"></a>Selenium-Grid</h3><p>Selenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。</p>\n<h2 id=\"选择合适你的-Selenium-工具\"><a href=\"#选择合适你的-Selenium-工具\" class=\"headerlink\" title=\"选择合适你的 Selenium 工具\"></a>选择合适你的 Selenium 工具</h2><p>很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。</p>\n<p>但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。</p>\n<p>在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。</p>\n<p>我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。</p>\n<h2 id=\"支持的浏览器和平台\"><a href=\"#支持的浏览器和平台\" class=\"headerlink\" title=\"支持的浏览器和平台\"></a>支持的浏览器和平台</h2><p>在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。</p>\n<h3 id=\"Selenium-WebDriver\"><a href=\"#Selenium-WebDriver\" class=\"headerlink\" title=\"Selenium-WebDriver\"></a>Selenium-WebDriver</h3><p>Selenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。</p>\n<ul>\n<li>Google Chrome 12.0.712.0+</li>\n<li>Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable</li>\n<li>Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7</li>\n<li>Opera 11.5+</li>\n<li>HtmlUnit 2.9</li>\n<li>Android – 2.3+ for phones and tablets (devices &amp; emulators)</li>\n<li>iOS 3+ for phones (devices &amp; emulators) and 3.2+ for tablets (devices &amp; emulators)</li>\n</ul>\n<p><strong>注意：</strong> </p>\n<p>在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。</p>\n<h3 id=\"Selenium-1-0-and-Selenium-RC\"><a href=\"#Selenium-1-0-and-Selenium-RC\" class=\"headerlink\" title=\"Selenium 1.0 and Selenium-RC\"></a>Selenium 1.0 and Selenium-RC</h3><p>这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。</p>\n<table border=\"1\"><br>    <tbody><br>    <tr><br>        <td><strong>Browser</strong></td><br>        <td><strong>Selenium IDE</strong></td><br>        <td><strong>Selenium 1 (RC)</strong></td><br>        <td><strong>Operating Systems</strong></td><br>    </tr><br>    <tr><br>        <td>Firefox 3.x</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Firefox 3</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Firefox 2</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>IE 8</td><br>        <td>Test execution only via Selenium RC<em></em></td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>IE 7</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>IE 6</td><br>        <td>Test execution only via Selenium RC<em></em></td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>Safari 4</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Safari 3</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Safari 2</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 10</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 9</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 8</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Google Chrome</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Others</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Partial support possible*</td><br>        <td>As applicable</td><br>    </tr><br>    </tbody><br></table>\n\n<p>* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。</p>\n<p>** Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。</p>\n<h2 id=\"灵活性和可扩展性\"><a href=\"#灵活性和可扩展性\" class=\"headerlink\" title=\"灵活性和可扩展性\"></a>灵活性和可扩展性</h2><p>你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。</p>\n<h2 id=\"本文档包含哪些内容？\"><a href=\"#本文档包含哪些内容？\" class=\"headerlink\" title=\"本文档包含哪些内容？\"></a>本文档包含哪些内容？</h2><p>本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。</p>\n<p>剩下的章节将讲述以下内容:</p>\n<h3 id=\"Selenium-IDE-1\"><a href=\"#Selenium-IDE-1\" class=\"headerlink\" title=\"Selenium IDE\"></a>Selenium IDE</h3><p>介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。</p>\n<h3 id=\"Selenium-2\"><a href=\"#Selenium-2\" class=\"headerlink\" title=\"Selenium 2\"></a>Selenium 2</h3><p>解释如何通过 Selenium 2 创建自动化测试项目。</p>\n<h3 id=\"Selenium-1\"><a href=\"#Selenium-1\" class=\"headerlink\" title=\"Selenium 1\"></a>Selenium 1</h3><p>解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。</p>\n<h3 id=\"测试设计\"><a href=\"#测试设计\" class=\"headerlink\" title=\"测试设计\"></a>测试设计</h3><p>这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。</p>\n<h3 id=\"Selenium-Grid-1\"><a href=\"#Selenium-Grid-1\" class=\"headerlink\" title=\"Selenium-Grid\"></a>Selenium-Grid</h3><p>这部分内容未完成。</p>\n<h3 id=\"User-extensions\"><a href=\"#User-extensions\" class=\"headerlink\" title=\"User extensions\"></a>User extensions</h3><p>讲述如何修改、扩展和定制 Selenium。</p>\n","excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"用于网站应用的测试自动化\"><a href=\"#用于网站应用的测试自动化\" class=\"headerlink\" title=\"用于网站应用的测试自动化\"></a>用于网站应用的测试自动化</h2><p>如今，大多数软件应用都是跑在浏览器中的网站应用。不同公司和组织之间的测试效率迥异。在这个富交互和响应式处理随处可见的时代，很多组织都使用敏捷的方式来开发，因此测试自动化也成为软件项目的必备部分。测试自动化意味着使用软件工具来反复运行项目中的测试，并为回归测试提供反馈。</p>\n<p>测试自动化有很多优点。大多数都和测试的可重复性和高执行效率这两点相关。市面上有一些商业或开源的同居来辅助测试自动化开发。Selenium 应该是最广泛使用的开源方案。本文档将帮助新手和有经验的使用者学习为网站应用创建测试自动化的有效技术。</p>\n<p>本文档介绍了 Selenium，其细节和从社区中积累的最佳实践。其中包含很多范例。同时，也将提及 Selenium 的一些技术细节和推荐用法。</p>\n<p>对于一个软件团队的测试过程来说，测试自动化具有提高长期效率的优势。测试自动化包括：</p>\n<ul>\n<li>频繁的回归测试</li>\n<li>快速反馈</li>\n<li>几乎无限制的测试用例迭代执行</li>\n<li>支持敏捷和极限编程</li>\n<li>遵循测试用例的文档</li>\n<li>自定义缺陷报告</li>\n<li>能找出手工测试中没发现的缺陷","more":"<h2 id=\"自动化？或不自动化？\"><a href=\"#自动化？或不自动化？\" class=\"headerlink\" title=\"自动化？或不自动化？\"></a>自动化？或不自动化？</h2></li>\n</ul>\n<p>自动化是否总是好的？什么时候我们应该使用自动化的方式来测试？</p>\n<p>自动化测试不总是有优势的。这里有一些场景就更适合手工测试。例如，如果一个应用的接口在不久的将来会发生变化，那时所有的测试用例都需要重写。有时仅仅是因为没有足够的时间来实现测试自动化。短期来说，手工测试更快捷。如果一个应用的发布日是掐死的，而又没有可用的自动化测试，而测试工作又必须在指定时间内完成，那么此时手工测试也是最佳选择。</p>\n<h2 id=\"介绍-Selenium\"><a href=\"#介绍-Selenium\" class=\"headerlink\" title=\"介绍 Selenium\"></a>介绍 Selenium</h2><p>Selenium 是一组软件工具集,每一个都有不同的方法来支持测试自动化。大多数使用 Selenium 的QA工程师只关注一两个最能满足他们的项目需求的工具上。然而，学习所有的工具你将有更多选择来解决不同类型的测试自动化问题。这一整套工具具备丰富的测试功能，很好的契合了测试各种类型的网站应用的需要。这些操作非常灵活，有多种选择来定位 UI 元素，同时将预期的测试结果和实际的行为进行比较。Selenium 一个最关键的特性是支持在多浏览器平台上进行测试。</p>\n<h2 id=\"Selenium-项目简史\"><a href=\"#Selenium-项目简史\" class=\"headerlink\" title=\"Selenium 项目简史\"></a>Selenium 项目简史</h2><p>Selenium 诞生于 2004 年，当在 ThoughtWorks 工作的 Jason Huggins 在测试一个内部应用时。作为一个聪明的家伙，他意识到相对于每次改动都需要手工进行测试，他的时间应该用得更有价值。他开发了一个可以驱动页面进行交互的 Javascript 库，能让多浏览器自动返回测试结果。那个库最终变成了 Selenium 的核心，它是 Selenium RC（远程控制）和 Selenium IDE 所有功能的基础。Selenium RC 是开拓性的，因为没有其他产品能让你使用自己喜欢的语言来控制浏览器。</p>\n<p>Selenium 是一个庞大的工具，所以它也有自己的缺点。由于它使用了基于 Javascript 的自动化引擎，而浏览器对 Javascript 又有很多安全限制，有些事情就难以实现。更糟糕的是，网站应用正变得越来越强大，它们使用了新浏览器提供的各种特性，都使得这些限制让人痛苦不堪。</p>\n<p>在 2006 年，一名 Google 的工程师， Simon Stewart 开始基于这个项目进行开发，这个项目被命名为 WebDriver。此时，Google 早已是 Selenium 的重度用户，但是测试工程师们不得不绕过它的限制进行工具。Simon 需要一款能通过浏览器和操作系统的本地方法直接和浏览器进行通话的测试工具，来解决Javascript 环境沙箱的问题。WebDriver 项目的目标就是要解决 Selenium 的痛点。</p>\n<p>跳到 2008 年。北京奥运会的召开显示了中国在全球的实力，大规模的次贷危机引发了“大萧条”以来美国最大的经济危机。但是当年最重要的故事是 Selenium 和WebDriver 的合并。Selenium 有着丰富的社区和商业支持，但 WebDriver 显然代表着未来的趋势。两者的合并为所有用户提供了一组通用功能，并且借鉴了一些测试自动化领域最闪光的思想。或许，关于两者合并的最好解释，是由 WebDriver 的开发者，在 2009 年 8 月 6 日发出的一封给社区的联合邮件中提到的：</p>\n<blockquote>\n<p>为什么这两个项目要合并？一部分是因为 WebDriver 弥补了 Selenium 的一些短处（例如提供了一组很棒的 API，绕开浏览器的限制），一部分是因为 Selenium 弥补了 WebDriver 的一些短处（例如对浏览器更广泛的支持），还有一部分是因为 Selenium 的主要贡献者和我都认为这样能为用户提供最优秀的框架。</p>\n</blockquote>\n<h2 id=\"Selenium-工具集\"><a href=\"#Selenium-工具集\" class=\"headerlink\" title=\"Selenium 工具集\"></a>Selenium 工具集</h2><p>Selenium 由多个软件工具组成，每个具备特定的功能。</p>\n<h3 id=\"Selenium-2-又叫-Selenium-Webdriver\"><a href=\"#Selenium-2-又叫-Selenium-Webdriver\" class=\"headerlink\" title=\"Selenium 2 (又叫 Selenium Webdriver)\"></a>Selenium 2 (又叫 Selenium Webdriver)</h3><p>Selenium 2 代表了这个项目未来的方向，也是最新被添加到 Selenium 工具集中的。这个全新的自动化工具提供了很多了不起的特性，包括更内聚和面向对象的 API，并且解决了旧版本限制。</p>\n<p>正如简史中提到的，Selenium 和 WebDriver 的作者都赞同两者各具优势，而两者的合并使得这个自动化工具更加强健。</p>\n<p>Selenium 2.0正是于此的产品。它支持WebDriver API及其底层技术，同时也在WebDriver API底下通过Selenium 1技术为移植测试代码提供极大的灵活性。此外，为了向后兼容，Selenium 2 仍然使用 Selenium 1 的 Selenium RC 接口。 </p>\n<h3 id=\"Selenium-1-又叫-Selenium-RC-或-Remote-Control\"><a href=\"#Selenium-1-又叫-Selenium-RC-或-Remote-Control\" class=\"headerlink\" title=\"Selenium 1 (又叫 Selenium RC 或 Remote Control)\"></a>Selenium 1 (又叫 Selenium RC 或 Remote Control)</h3><p>正如你在简史中读到的，在很长一段时间内，Selenium RC 都是最主要的 Selenium 项目，直到 WebDriver 和 Selenium 合并而产生了最新且最强大的 Selenium 2.</p>\n<p>Seleinum 1 仍然被活跃的支持着（更多是维护），并且提供一些 Selenium 2 短时间内可能不会支持的特性，包括对多种语言的支持(Java, Javascript, Ruby, PHP, Python, Perl and C#) 和对大多数浏览器的支持。</p>\n<h3 id=\"Selenium-IDE\"><a href=\"#Selenium-IDE\" class=\"headerlink\" title=\"Selenium IDE\"></a>Selenium IDE</h3><p>Selenium IDE (集成开发环境) 是一个创建测试脚本的原型工具。它是一个 Firefox 插件，提供创建自动化测试的建议接口。Selenium IDE 有一个记录功能，能记录用户的操作，并且能选择多种语言把它们导出到一个可重用的脚本中用于后续执行。</p>\n<p><strong>注意</strong> </p>\n<p>虽然 Selenium IDE 有保存功能，能让用户以表格的形式保存测试，以供后续的导入和执行，但它不是用于执行你的测试是否通过，也不能创建所有你需要的自动化测试。需要注意的是，Selenium IDE 不能生成含有迭代和条件语句的测试脚本。在本文档编写时也没有要实现该功能的计划。这部分是因为技术原因，部分是因为 Selenium 的开发者所推荐的自动化测试的最佳实践常常是需要编写一些代码的。Selenium IDE 只是被设计为一个快速的原型工具。Selenium 的开发者推荐选用支持的最好的语言来创建严谨、健壮的测试，不管是使用 Selenium 1 还是 Selenium 2.</p>\n<h3 id=\"Selenium-Grid\"><a href=\"#Selenium-Grid\" class=\"headerlink\" title=\"Selenium-Grid\"></a>Selenium-Grid</h3><p>Selenium-Grid 使得 Selenium RC 解决方案能提升针对大型的测试套件或者哪些需要运行在多环境的测试套件的处理能力。Selenium Grid 能让你并行的运行你的测试，也就是说，不同的测试可以同时跑在不同的远程机器上。这样做有两个有事，首先，如果你有一个大型的测试套件，或者一个跑的很慢的测试套件，你可以使用 Selenium Grid 将你的测试套件划分成几份同时在几个不同的机器上运行，这样能显著的提升它的性能。同时，如果你必须在多环境中运行你的测试套件，你可以获得多个远程机器的支持，它们将同时运行你的测试套件。在每种情况下，Selenium Grid 都能通过并行处理显著地缩短你的测试套件的处理时间。</p>\n<h2 id=\"选择合适你的-Selenium-工具\"><a href=\"#选择合适你的-Selenium-工具\" class=\"headerlink\" title=\"选择合适你的 Selenium 工具\"></a>选择合适你的 Selenium 工具</h2><p>很多人都从 Selenium IDE 开始学习使用，如果你不是特别善于编程或者编写一门脚本语言，你可以通过使用 Selenium IDE 来熟悉 Selenium 命令。使用 IDE，你能在很短的时间内（有时是数秒）创建简单的测试。</p>\n<p>但是我们不推荐你使用 Selenium IDE 来处理所有的测试自动化工作。更高效的做法是，你需要使用它支持的语言创建和运行你的测试，无论是 Selenium 1 还是 Selenium 2。至于选择什么语言则取决于你的喜好。</p>\n<p>在编写本文档时，Selenium 的开发者认为Selenium-WebDriver API 才是 Selenium未来的趋势。但Selenium 1 提供向后兼容。同时，我们也在之前讨论了两者的优势和劣势。</p>\n<p>我们强烈建议那些初次接触 Selenium 的用户通读这这个章节的内容。那些第一次使用 Selenium ，随意创建了一些测试套件的用户，你通常会希望从 Selenium 2 开始，因为这部分是 Selenium 在将来都会持续支持的。</p>\n<h2 id=\"支持的浏览器和平台\"><a href=\"#支持的浏览器和平台\" class=\"headerlink\" title=\"支持的浏览器和平台\"></a>支持的浏览器和平台</h2><p>在 Selenium 2.0 中，支持的浏览器完全取决于你是否使用 Selenium-WebDriver 或 Selenium-RC。</p>\n<h3 id=\"Selenium-WebDriver\"><a href=\"#Selenium-WebDriver\" class=\"headerlink\" title=\"Selenium-WebDriver\"></a>Selenium-WebDriver</h3><p>Selenium-WebDriver 支持如下浏览器，在所有支持这些浏览器的操作系统中能都运行良好。</p>\n<ul>\n<li>Google Chrome 12.0.712.0+</li>\n<li>Internet Explorer 6, 7, 8, 9 - 32 and 64-bit where applicable</li>\n<li>Firefox 3.0, 3.5, 3.6, 4.0, 5.0, 6, 7</li>\n<li>Opera 11.5+</li>\n<li>HtmlUnit 2.9</li>\n<li>Android – 2.3+ for phones and tablets (devices &amp; emulators)</li>\n<li>iOS 3+ for phones (devices &amp; emulators) and 3.2+ for tablets (devices &amp; emulators)</li>\n</ul>\n<p><strong>注意：</strong> </p>\n<p>在写本文档的时候，一款 Android 2.3 的模拟器被报有bug。但是在 tablet 模拟器和真实设备中均工作良好。</p>\n<h3 id=\"Selenium-1-0-and-Selenium-RC\"><a href=\"#Selenium-1-0-and-Selenium-RC\" class=\"headerlink\" title=\"Selenium 1.0 and Selenium-RC\"></a>Selenium 1.0 and Selenium-RC</h3><p>这里是指老的，支持 Selenium 1 的部分。它也适用于 Selenium 2 版本中的 Selenium RC。</p>\n<table border=\"1\"><br>    <tbody><br>    <tr><br>        <td><strong>Browser</strong></td><br>        <td><strong>Selenium IDE</strong></td><br>        <td><strong>Selenium 1 (RC)</strong></td><br>        <td><strong>Operating Systems</strong></td><br>    </tr><br>    <tr><br>        <td>Firefox 3.x</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Firefox 3</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Firefox 2</td><br>        <td>Record and playback tests</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>IE 8</td><br>        <td>Test execution only via Selenium RC<em></td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>IE 7</td><br>        <td>Test execution only via Selenium RC</em></td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>IE 6</td><br>        <td>Test execution only via Selenium RC<em></td><br>        <td>Start browser, run tests</td><br>        <td>Windows</td><br>    </tr><br>    <tr><br>        <td>Safari 4</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Safari 3</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Safari 2</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 10</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 9</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Opera 8</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Google Chrome</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Start browser, run tests</td><br>        <td>Windows, Linux, Mac</td><br>    </tr><br>    <tr><br>        <td>Others</td><br>        <td>Test execution only via Selenium RC</td><br>        <td>Partial support possible*</em></td><br>        <td>As applicable</td><br>    </tr><br>    </tbody><br></table>\n\n<p>* 在 Firefox 上通过 Selenium IDE 开发的测试，可以通过简单的 Selenium RC 命令行在任意支持的浏览器上运行。</p>\n<p>** Selenium RC 服务器能开启任何可运行的测试。但根据浏览器的安全设置，可能会有部分特性不可用。</p>\n<h2 id=\"灵活性和可扩展性\"><a href=\"#灵活性和可扩展性\" class=\"headerlink\" title=\"灵活性和可扩展性\"></a>灵活性和可扩展性</h2><p>你将发现 Selenium 是高度灵活的。你有很多方式为 Selenium 的测试脚本和 Selenium 框架添加功能来定制你的自动化测试。同其他的自动化工具相比，Selenium 可能是最强的。定制相关的内容贯穿整个文档有多处提及。另外，Selenium 是开源的，它的源码可以下载和修改。</p>\n<h2 id=\"本文档包含哪些内容？\"><a href=\"#本文档包含哪些内容？\" class=\"headerlink\" title=\"本文档包含哪些内容？\"></a>本文档包含哪些内容？</h2><p>本文档同时面向于新手和那些希望了解更多的 Selenium 用户。我们向新手介绍 Selenium，我们并不要求你对 Selenium 非常了解，但你至少需要知道一些自动化测试的基本知识。对于那些经验丰富的用户来说，本文档可作为一个使用参考。如果真的非常熟悉，我们建议你浏览一下每个章节和其副标题。我们提供了 Selenium 的架构信息，常见用法的例子和一章关于测试设计的内容。</p>\n<p>剩下的章节将讲述以下内容:</p>\n<h3 id=\"Selenium-IDE-1\"><a href=\"#Selenium-IDE-1\" class=\"headerlink\" title=\"Selenium IDE\"></a>Selenium IDE</h3><p>介绍 Selenium IDE 以及如何使用它创建测试脚本。如果你缺乏编程经验，但仍然希望学习测试自动化，那么从本章开始入手是个不错的主意，并且你将会发现自己能通过 Selenium IDE 创建不少的测试用例。如果你编程经验丰富，但你希望使用 Seleinum IDE 快速创建测试原型的话，这一章对你也很有用。本章还将向你演示如何导出指定语言的测试脚本，以添加更多 Selenium IDE 不能支持的功能。</p>\n<h3 id=\"Selenium-2\"><a href=\"#Selenium-2\" class=\"headerlink\" title=\"Selenium 2\"></a>Selenium 2</h3><p>解释如何通过 Selenium 2 创建自动化测试项目。</p>\n<h3 id=\"Selenium-1\"><a href=\"#Selenium-1\" class=\"headerlink\" title=\"Selenium 1\"></a>Selenium 1</h3><p>解释如何通过 Selenium RC API 开发一个自动化测试项目。我们使用了多种语言来进行代码演示。同时包括了如何安装 Selenium RC 的内容。Seleium RC 支持的各种模式、配置也将会介绍，包括它们的限制和如何进行权衡。我们还提供了架构图来帮助演示这些点。对于 Selenium RC 新手来说，一些常见问题的解决方案也列在其中，例如，操作安全证书， HTTPS 请求，弹出框和打开新窗口。</p>\n<h3 id=\"测试设计\"><a href=\"#测试设计\" class=\"headerlink\" title=\"测试设计\"></a>测试设计</h3><p>这个章节介绍了使用 Selenium WebDriver 和 Selenium RC 的编程技巧。我们还演示了论坛中常被问道的技巧，例如如何设计 setup 和 teardown 方法，如何实施数据驱动测试（每次测试通过数据都有数据发生变化）和其他一些常见的测试自动化任务的编程方法。</p>\n<h3 id=\"Selenium-Grid-1\"><a href=\"#Selenium-Grid-1\" class=\"headerlink\" title=\"Selenium-Grid\"></a>Selenium-Grid</h3><p>这部分内容未完成。</p>\n<h3 id=\"User-extensions\"><a href=\"#User-extensions\" class=\"headerlink\" title=\"User extensions\"></a>User extensions</h3><p>讲述如何修改、扩展和定制 Selenium。</p>"},{"layout":"post","title":"selenium文档:selenium Grid","date":"2013-05-30T11:55:00.000Z","comments":1,"_content":"# Selenium Grid\n\n## 快速上手\n\n如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 [Selenium Wiki](http://code.google.com/p/selenium/wiki/Grid2) 的相关文章。\n\n## 什么是 Selenium-Grid ?\n\nSelenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。\n<!--more-->\n## 何时需要使用\n\n通常，以下两种情况你都会需要使用 Selenium-Grid。\n\n- 在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。\n- 减少测试运行时间。\n\nSelenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。\n\nSelenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。\n\n另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。\n\nSelenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。\n\n## Selenium-Grid 2.0\n\nSelenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。\n\n## Selenium-Grid 1.0\n\n版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 [Selenium-Grid website](http://selenium-grid.seleniumhq.org/)\n\n## Selenium-Grid 的 Hub 和 Nodes 是如何工作的？\n\nGrid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。\n\n中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。 \n\n我们提供了一些[图标](http://selenium-grid.seleniumhq.org/how_it_works.html)来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。\n\n## 下载\n\n下载过程很简单。从 SeleniumHq 站点的[下载页面](http://docs.seleniumhq.org/download/)下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。\n\n将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。\n\n## 启动 Selenium-Grid\n\n由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。\n\n### 启动中心\n\n通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub\n\n我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。\n\n### 启动节点\n\n通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register\n\n该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。\n\n**警告：** 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。\n\n## 配置 Selenium-Grid\n\n### 默认配置\n### JSON 配置文件\n### 通过命令行选项配置\n\n## 中心配置\n\n通过指定 `-role hub` 即以默认设置启动中心：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub\n\n你将看到以下日志输出：\n\n    Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main\n    INFO: Launching a selenium grid server\n    2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT\n    2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}\n    2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444\n\n### 指定端口\n\n中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：\n\n    10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444\n    Exception in thread \"main\" java.net.BindException: Selenium is already running on port 4444. Or some other service is.\n\n如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。`-port` 选项用于修改中心的端口：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441\n\n即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。\n\n你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：\n\n    netstat -a\n    \nUnix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。\n\n## 节点配置\n\n## 时间参数\n\n## 获取命令行帮助\n\nSelenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。\n\nSelenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。\n\n如果你仅传递一个 `-h` 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。\n\n    java -jar selenium-server-standalone-2.21.0.jar -h\n\n上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 `-hub` 或 `-node` 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 `-h` 选项。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node -h\n\n对于这个问题，你还可以给 `-role node` 传递一个垃圾参数：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node xx\n\n你将先看到 “INFO...” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：\n\n    Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main\n    INFO: Launching a selenium grid node\n    org.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n            at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)\n            at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)\n            at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)\n    Error building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n    Usage :\n      -hubConfig:\n            (hub) a JSON file following grid2 format.\n    \n     -nodeTimeout:\n            (node) <XXXX>  the timeout in seconds before the hub\n              automatically ends a test that hasn't had aby activity than XX\n              sec.The browser will be released for another test to use.This\n              typically takes care of the client crashes.\n\n## 常见错误\n\n### Unable to acess the jarfile\n\nUnable to access jarfile selenium-server-standalone-2.21.0.jar\n\n无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。\n\n\n","source":"_posts/2013-05-30-selenium-doc-selenium-grid.markdown","raw":"---\nlayout: post\ntitle: \"selenium文档:selenium Grid\"\ndate: 2013-05-30 19:55\ncomments: true\ncategories: selenium官方文档\ntags: [ selenium ] \n---\n# Selenium Grid\n\n## 快速上手\n\n如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 [Selenium Wiki](http://code.google.com/p/selenium/wiki/Grid2) 的相关文章。\n\n## 什么是 Selenium-Grid ?\n\nSelenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。\n<!--more-->\n## 何时需要使用\n\n通常，以下两种情况你都会需要使用 Selenium-Grid。\n\n- 在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。\n- 减少测试运行时间。\n\nSelenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。\n\nSelenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。\n\n另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。\n\nSelenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。\n\n## Selenium-Grid 2.0\n\nSelenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。\n\n## Selenium-Grid 1.0\n\n版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 [Selenium-Grid website](http://selenium-grid.seleniumhq.org/)\n\n## Selenium-Grid 的 Hub 和 Nodes 是如何工作的？\n\nGrid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。\n\n中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。 \n\n我们提供了一些[图标](http://selenium-grid.seleniumhq.org/how_it_works.html)来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。\n\n## 下载\n\n下载过程很简单。从 SeleniumHq 站点的[下载页面](http://docs.seleniumhq.org/download/)下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。\n\n将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。\n\n## 启动 Selenium-Grid\n\n由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。\n\n### 启动中心\n\n通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub\n\n我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。\n\n### 启动节点\n\n通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register\n\n该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。\n\n**警告：** 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。\n\n## 配置 Selenium-Grid\n\n### 默认配置\n### JSON 配置文件\n### 通过命令行选项配置\n\n## 中心配置\n\n通过指定 `-role hub` 即以默认设置启动中心：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub\n\n你将看到以下日志输出：\n\n    Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main\n    INFO: Launching a selenium grid server\n    2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT\n    2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}\n    2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444\n\n### 指定端口\n\n中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：\n\n    10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444\n    Exception in thread \"main\" java.net.BindException: Selenium is already running on port 4444. Or some other service is.\n\n如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。`-port` 选项用于修改中心的端口：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441\n\n即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。\n\n你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：\n\n    netstat -a\n    \nUnix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。\n\n## 节点配置\n\n## 时间参数\n\n## 获取命令行帮助\n\nSelenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。\n\nSelenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。\n\n如果你仅传递一个 `-h` 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。\n\n    java -jar selenium-server-standalone-2.21.0.jar -h\n\n上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 `-hub` 或 `-node` 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 `-h` 选项。\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node -h\n\n对于这个问题，你还可以给 `-role node` 传递一个垃圾参数：\n\n    java -jar selenium-server-standalone-2.21.0.jar -role node xx\n\n你将先看到 “INFO...” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：\n\n    Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main\n    INFO: Launching a selenium grid node\n    org.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n            at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)\n            at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)\n            at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)\n    Error building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n    Usage :\n      -hubConfig:\n            (hub) a JSON file following grid2 format.\n    \n     -nodeTimeout:\n            (node) <XXXX>  the timeout in seconds before the hub\n              automatically ends a test that hasn't had aby activity than XX\n              sec.The browser will be released for another test to use.This\n              typically takes care of the client crashes.\n\n## 常见错误\n\n### Unable to acess the jarfile\n\nUnable to access jarfile selenium-server-standalone-2.21.0.jar\n\n无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。\n\n\n","slug":"2013-05-30-selenium-doc-selenium-grid","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5t0061v8fyqq294hgh","content":"<h1 id=\"Selenium-Grid\"><a href=\"#Selenium-Grid\" class=\"headerlink\" title=\"Selenium Grid\"></a>Selenium Grid</h1><h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><p>如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 <a href=\"http://code.google.com/p/selenium/wiki/Grid2\" target=\"_blank\" rel=\"external\">Selenium Wiki</a> 的相关文章。</p>\n<h2 id=\"什么是-Selenium-Grid\"><a href=\"#什么是-Selenium-Grid\" class=\"headerlink\" title=\"什么是 Selenium-Grid ?\"></a>什么是 Selenium-Grid ?</h2><p>Selenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。<br><a id=\"more\"></a></p>\n<h2 id=\"何时需要使用\"><a href=\"#何时需要使用\" class=\"headerlink\" title=\"何时需要使用\"></a>何时需要使用</h2><p>通常，以下两种情况你都会需要使用 Selenium-Grid。</p>\n<ul>\n<li>在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。</li>\n<li>减少测试运行时间。</li>\n</ul>\n<p>Selenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。</p>\n<p>Selenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。</p>\n<p>另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。</p>\n<p>Selenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。</p>\n<h2 id=\"Selenium-Grid-2-0\"><a href=\"#Selenium-Grid-2-0\" class=\"headerlink\" title=\"Selenium-Grid 2.0\"></a>Selenium-Grid 2.0</h2><p>Selenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。</p>\n<h2 id=\"Selenium-Grid-1-0\"><a href=\"#Selenium-Grid-1-0\" class=\"headerlink\" title=\"Selenium-Grid 1.0\"></a>Selenium-Grid 1.0</h2><p>版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 <a href=\"http://selenium-grid.seleniumhq.org/\" target=\"_blank\" rel=\"external\">Selenium-Grid website</a></p>\n<h2 id=\"Selenium-Grid-的-Hub-和-Nodes-是如何工作的？\"><a href=\"#Selenium-Grid-的-Hub-和-Nodes-是如何工作的？\" class=\"headerlink\" title=\"Selenium-Grid 的 Hub 和 Nodes 是如何工作的？\"></a>Selenium-Grid 的 Hub 和 Nodes 是如何工作的？</h2><p>Grid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。</p>\n<p>中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。 </p>\n<p>我们提供了一些<a href=\"http://selenium-grid.seleniumhq.org/how_it_works.html\" target=\"_blank\" rel=\"external\">图标</a>来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>下载过程很简单。从 SeleniumHq 站点的<a href=\"http://docs.seleniumhq.org/download/\" target=\"_blank\" rel=\"external\">下载页面</a>下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。</p>\n<p>将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。</p>\n<h2 id=\"启动-Selenium-Grid\"><a href=\"#启动-Selenium-Grid\" class=\"headerlink\" title=\"启动 Selenium-Grid\"></a>启动 Selenium-Grid</h2><p>由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。</p>\n<h3 id=\"启动中心\"><a href=\"#启动中心\" class=\"headerlink\" title=\"启动中心\"></a>启动中心</h3><p>通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub\n</code></pre><p>我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。</p>\n<h3 id=\"启动节点\"><a href=\"#启动节点\" class=\"headerlink\" title=\"启动节点\"></a>启动节点</h3><p>通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register\n</code></pre><p>该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。</p>\n<p><strong>警告：</strong> 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。</p>\n<h2 id=\"配置-Selenium-Grid\"><a href=\"#配置-Selenium-Grid\" class=\"headerlink\" title=\"配置 Selenium-Grid\"></a>配置 Selenium-Grid</h2><h3 id=\"默认配置\"><a href=\"#默认配置\" class=\"headerlink\" title=\"默认配置\"></a>默认配置</h3><h3 id=\"JSON-配置文件\"><a href=\"#JSON-配置文件\" class=\"headerlink\" title=\"JSON 配置文件\"></a>JSON 配置文件</h3><h3 id=\"通过命令行选项配置\"><a href=\"#通过命令行选项配置\" class=\"headerlink\" title=\"通过命令行选项配置\"></a>通过命令行选项配置</h3><h2 id=\"中心配置\"><a href=\"#中心配置\" class=\"headerlink\" title=\"中心配置\"></a>中心配置</h2><p>通过指定 <code>-role hub</code> 即以默认设置启动中心：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub\n</code></pre><p>你将看到以下日志输出：</p>\n<pre><code>Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main\nINFO: Launching a selenium grid server\n2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT\n2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}\n2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444\n</code></pre><h3 id=\"指定端口\"><a href=\"#指定端口\" class=\"headerlink\" title=\"指定端口\"></a>指定端口</h3><p>中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：</p>\n<pre><code>10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444\nException in thread &quot;main&quot; java.net.BindException: Selenium is already running on port 4444. Or some other service is.\n</code></pre><p>如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。<code>-port</code> 选项用于修改中心的端口：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441\n</code></pre><p>即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。</p>\n<p>你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：</p>\n<pre><code>netstat -a\n</code></pre><p>Unix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。</p>\n<h2 id=\"节点配置\"><a href=\"#节点配置\" class=\"headerlink\" title=\"节点配置\"></a>节点配置</h2><h2 id=\"时间参数\"><a href=\"#时间参数\" class=\"headerlink\" title=\"时间参数\"></a>时间参数</h2><h2 id=\"获取命令行帮助\"><a href=\"#获取命令行帮助\" class=\"headerlink\" title=\"获取命令行帮助\"></a>获取命令行帮助</h2><p>Selenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。</p>\n<p>Selenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。</p>\n<p>如果你仅传递一个 <code>-h</code> 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -h\n</code></pre><p>上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 <code>-hub</code> 或 <code>-node</code> 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 <code>-h</code> 选项。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node -h\n</code></pre><p>对于这个问题，你还可以给 <code>-role node</code> 传递一个垃圾参数：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node xx\n</code></pre><p>你将先看到 “INFO…” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：</p>\n<pre><code>Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main\nINFO: Launching a selenium grid node\norg.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n        at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)\n        at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)\n        at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)\nError building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\nUsage :\n  -hubConfig:\n        (hub) a JSON file following grid2 format.\n\n -nodeTimeout:\n        (node) &lt;XXXX&gt;  the timeout in seconds before the hub\n          automatically ends a test that hasn&apos;t had aby activity than XX\n          sec.The browser will be released for another test to use.This\n          typically takes care of the client crashes.\n</code></pre><h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><h3 id=\"Unable-to-acess-the-jarfile\"><a href=\"#Unable-to-acess-the-jarfile\" class=\"headerlink\" title=\"Unable to acess the jarfile\"></a>Unable to acess the jarfile</h3><p>Unable to access jarfile selenium-server-standalone-2.21.0.jar</p>\n<p>无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。</p>\n","excerpt":"<h1 id=\"Selenium-Grid\"><a href=\"#Selenium-Grid\" class=\"headerlink\" title=\"Selenium Grid\"></a>Selenium Grid</h1><h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><p>如果你对 Selenium 自动化测试已经非常熟悉，你仅仅需要一个快速上手来使程序运行起来。本章节的内容能满足不同的技术层次，但是如果你仅仅需要一个可以快速上手的指引，那么就显得有点多。如果是这样，你可以参考 <a href=\"http://code.google.com/p/selenium/wiki/Grid2\">Selenium Wiki</a> 的相关文章。</p>\n<h2 id=\"什么是-Selenium-Grid\"><a href=\"#什么是-Selenium-Grid\" class=\"headerlink\" title=\"什么是 Selenium-Grid ?\"></a>什么是 Selenium-Grid ?</h2><p>Selenium-Grid 允许你在多台机器的多个浏览器上并行的进行测试，也就是说，你可以同时运行多个测试。本质上来说就是，Selenium-Grid 支持分布式的测试执行。它可以让你的测试在一个分布式的执行环境中运行。<br>","more":"</p>\n<h2 id=\"何时需要使用\"><a href=\"#何时需要使用\" class=\"headerlink\" title=\"何时需要使用\"></a>何时需要使用</h2><p>通常，以下两种情况你都会需要使用 Selenium-Grid。</p>\n<ul>\n<li>在多个浏览器中运行测试，在多个版本的浏览器中进行测试，或在不同操作系统的浏览器中进行测试。</li>\n<li>减少测试运行时间。</li>\n</ul>\n<p>Selenium-Grid 通过使用多台机器并行地运行测试来加速测试的执行过程。例如,如果你有一个包含100个测试用例的测试套件,你使用 Selenium-Grid 支持4台不同的机器（虚拟机或实体机均可）来运行那些测试，同仅使用一台机器相比，你的测试所需要的运行时间大致为其 1/4。对于大型的测试套件和那些会进行大量数据校验的需要长时间运行的测试套件来说，这将节约很多时间。有些测试套件可能要运行好几小时。另一个需要缩短套件运行时间的原因是开发者检入（check-in）AUT 代码后，需要缩短测试的运行周期。越来越多的团队使用敏捷开发，相比整夜整夜的等待测试通过，他们希望尽快地看到测试反馈。</p>\n<p>Selenium-Grid 也可以用于支持多执行环境的测试运行，典型的，同时在多个不同的浏览器中运行。例如，Grid 的虚拟机可以安装测试必须的各种浏览器。于是，机器 1 上有 ie8，机器 2 上有 ie9，机器 3 上有最新版的 chrome，而机器 4 上有最新版的 firefox。当测试套件运行时，Selenium-Grid 可以使测试在指定的浏览器中运行，并且接收每个浏览器的运行结果。</p>\n<p>另外，我们可以拥有一个装有多个类型和版本都一样的浏览器 Grid。例如，一个 Grid 拥有 4 台机器，每台机器可以运行 3 个 firefox 12 实例，形成一个 firefox 的服务农场。当测试套件运行时，每个传递给 Selenium-Grid 的测试都被指派给下一个可用的 firefox 实例。通过这种方式，我们可以使得同时有 12 个测试在并行的运行以完成测试，显著地缩短了测试完成需要的时间。</p>\n<p>Selenium-Grid 非常灵活。以上两个例子可以联合起来使用，这样可以就可以使得不同类型和版本的浏览器有多个可运行实例。使用这样的配置，既并行地执行测试，同时又可以测试多个浏览器类型和版本。</p>\n<h2 id=\"Selenium-Grid-2-0\"><a href=\"#Selenium-Grid-2-0\" class=\"headerlink\" title=\"Selenium-Grid 2.0\"></a>Selenium-Grid 2.0</h2><p>Selenium-Grid 2.0 是在编写本文时(5/26/2012)已发布的最新版本。它同版本 1 有很多不同之处。在 2.0 中，Selenium-Grid 和 Selenium-RC 服务端进行了合并。现在，你仅需要下载一个 jar 包就可以获得它们。</p>\n<h2 id=\"Selenium-Grid-1-0\"><a href=\"#Selenium-Grid-1-0\" class=\"headerlink\" title=\"Selenium-Grid 1.0\"></a>Selenium-Grid 1.0</h2><p>版本 1 是 Selenium-Grid 的第一个发布版本。如果你是一个 Selenium-Grid 新手，你应该选择版本 2 。新版本已经在原有基础上进行了更新，页增加了一些新特性，并且支持 Selenium-WebDriver。一些老的系统可能仍然在使用版本 1.关于 Selenium-Grid 版本 1 的信息可以参考 <a href=\"http://selenium-grid.seleniumhq.org/\">Selenium-Grid website</a></p>\n<h2 id=\"Selenium-Grid-的-Hub-和-Nodes-是如何工作的？\"><a href=\"#Selenium-Grid-的-Hub-和-Nodes-是如何工作的？\" class=\"headerlink\" title=\"Selenium-Grid 的 Hub 和 Nodes 是如何工作的？\"></a>Selenium-Grid 的 Hub 和 Nodes 是如何工作的？</h2><p>Grid 由一个中心和一到多个节点组成。两者都是通过 selenium-server.jar 启动。在接下来的章节中，我们列出了一些例子。</p>\n<p>中心接收要执行的测试信息，包括在哪些平台和浏览器执行等。它知道每个注册了的节点的配置。根据测试信息，它会选择符合需求的节点进行测试。一旦选定了一个节点，测试脚本就会初始化 Selenium 命令，并且由重心发送给选定的要运行测试的节点。这个节点会启动浏览器，然后在浏览器中执行这个 AUT 的 Selenium 命令。 </p>\n<p>我们提供了一些<a href=\"http://selenium-grid.seleniumhq.org/how_it_works.html\">图标</a>来演示其原理。第二张图标是用以说明 Selenium-Grid 1 的，版本 2 也适用并且对于我们的描述是一个很好的说明。唯一的区别在于相关术语。使用“Selenium-Grid 节点”替换“Selenium Remote Control”即符合我们对 Selenium-Grid 2 的描述。</p>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>下载过程很简单。从 SeleniumHq 站点的<a href=\"http://docs.seleniumhq.org/download/\">下载页面</a>下载 Selenium-Server jar 包。你需要的链接在“Selenium-Server (以前是 Selenium-RC)”章节中。</p>\n<p>将它存放到任意文件夹中。你需要确保机器上正确的安装了 java。如果 java 没有正常运行，检查你系统的 path 变量是否包含了 java.exe 的路径。</p>\n<h2 id=\"启动-Selenium-Grid\"><a href=\"#启动-Selenium-Grid\" class=\"headerlink\" title=\"启动 Selenium-Grid\"></a>启动 Selenium-Grid</h2><p>由于节点对中心有依赖，所以你通常需要先启动一个中心。这也不是必须的，因为节点可以识别其中心是否已经启动，反之亦然。作为教程，我们建议你先启动中心，否则会显示一些错误信息，你应该不会想在第一次使用 Selenium-Grid 的时候就看到它们。</p>\n<h3 id=\"启动中心\"><a href=\"#启动中心\" class=\"headerlink\" title=\"启动中心\"></a>启动中心</h3><p>通过在命令行执行以下命令，可以启动一个使用默认设置的中心。所有平台可用，包括 Windows Linux, 或 MacOs 。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub\n</code></pre><p>我们将在接下来的章节中解释各个参数。注意，你可能需要修改上述命令中 jar 包的版本号，这取决于你使用的 selenium-server 的版本。</p>\n<h3 id=\"启动节点\"><a href=\"#启动节点\" class=\"headerlink\" title=\"启动节点\"></a>启动节点</h3><p>通过在命令行执行以下命令，可以你懂一个使用默认设置的节点。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node  -hub http://localhost:4444/grid/register\n</code></pre><p>该操作假设中心是使用默认设置启动的。中心用于监听请求使用的默认端口号为 4444，这就是为什么端口 4444 被用于中心 url 中。同时“localhost”假定你的节点和中心运行在同一台机器上。对于新手来说，这是最简单的方式。如果要在两台不同的机器上运行中心和节点，只需要将“localhost”替换成中心所在机器的 hostname 即可。</p>\n<p><strong>警告：</strong> 确保运行中心和节点的机器均已关闭防火墙，否则你将看到一个连接错误。</p>\n<h2 id=\"配置-Selenium-Grid\"><a href=\"#配置-Selenium-Grid\" class=\"headerlink\" title=\"配置 Selenium-Grid\"></a>配置 Selenium-Grid</h2><h3 id=\"默认配置\"><a href=\"#默认配置\" class=\"headerlink\" title=\"默认配置\"></a>默认配置</h3><h3 id=\"JSON-配置文件\"><a href=\"#JSON-配置文件\" class=\"headerlink\" title=\"JSON 配置文件\"></a>JSON 配置文件</h3><h3 id=\"通过命令行选项配置\"><a href=\"#通过命令行选项配置\" class=\"headerlink\" title=\"通过命令行选项配置\"></a>通过命令行选项配置</h3><h2 id=\"中心配置\"><a href=\"#中心配置\" class=\"headerlink\" title=\"中心配置\"></a>中心配置</h2><p>通过指定 <code>-role hub</code> 即以默认设置启动中心：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub\n</code></pre><p>你将看到以下日志输出：</p>\n<pre><code>Jul 19, 2012 10:46:21 AM org.openqa.grid.selenium.GridLauncher main\nINFO: Launching a selenium grid server\n2012-07-19 10:46:25.082:INFO:osjs.Server:jetty-7.x.y-SNAPSHOT\n2012-07-19 10:46:25.151:INFO:osjsh.ContextHandler:started o.s.j.s.ServletContextHandler{/,null}\n2012-07-19 10:46:25.185:INFO:osjs.AbstractConnector:Started SocketConnector@0.0.0.0:4444\n</code></pre><h3 id=\"指定端口\"><a href=\"#指定端口\" class=\"headerlink\" title=\"指定端口\"></a>指定端口</h3><p>中心默认使用的端口是 4444 。这是一个 TCP/IP 端口，被用于监听客户端，即自动化测试脚本到 Selenium-Grid 中心的连接。如果你电脑上的另一个应用已经占用这个接口，或者你已经启动了一个 Selenium-Server，你将看到以下输出：</p>\n<pre><code>10:56:35.490 WARN - Failed to start: SocketListener0@0.0.0.0:4444\nException in thread &quot;main&quot; java.net.BindException: Selenium is already running on port 4444. Or some other service is.\n</code></pre><p>如果看到这个信息，你可以关掉在使用端口 4444 的进程，或者告诉 Selenium-Grid 使用一个别的端口来启动中心。<code>-port</code> 选项用于修改中心的端口：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role hub -port 4441\n</code></pre><p>即使已经有一个中心运行在这台机器上，只要它们不使用同一个端口，就能正常工作。</p>\n<p>你可能想知道哪个进程使用了 4444 端口，这样你就可以让中心使用这个默认端口。使用以下命令可以查看你机器上所有运行程序使用的端口：</p>\n<pre><code>netstat -a\n</code></pre><p>Unix/Linux, MacOs 和 Windows 均支持此命令，只是在 Windows 中 -a 参数为必须的。基本上，你需要显示进程 id 和端口。在 Unix 中，你可以通过管道 “grep” 输出那些你关心的端口相关的条目。</p>\n<h2 id=\"节点配置\"><a href=\"#节点配置\" class=\"headerlink\" title=\"节点配置\"></a>节点配置</h2><h2 id=\"时间参数\"><a href=\"#时间参数\" class=\"headerlink\" title=\"时间参数\"></a>时间参数</h2><h2 id=\"获取命令行帮助\"><a href=\"#获取命令行帮助\" class=\"headerlink\" title=\"获取命令行帮助\"></a>获取命令行帮助</h2><p>Selenium-Server 提供了一个可选项列表，每个选项都有一个简短的描述。目前（2012夏），命令行帮助还有一些奇怪，但是如果你知道如何去找、如何解读信息会对你很有帮助。</p>\n<p>Selenium-Server 提供了两种不同的功能，Selenium-RC server 和 Selenium-Grid。它们是两个不同的团队编写的，所以每个功能的命令行帮助被放置在不同的地方。因此，对于新手来说，在初次使用任意一个功能时，帮助都不是那么显而易见。</p>\n<p>如果你仅传递一个 <code>-h</code> 选项，你将看到 Selenium-RC Server 的可选项而不是 Selenium-Grid 的。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -h\n</code></pre><p>上述代码将显示 Selenium-RC server 选项。如果你想看到 Selenium-Grid 的命令行帮助，你需要先使用 <code>-hub</code> 或 <code>-node</code> 选项告诉 Selenium-Server 你想看的是关于 Selenium-Grid 的，然后再追加 <code>-h</code> 选项。</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node -h\n</code></pre><p>对于这个问题，你还可以给 <code>-role node</code> 传递一个垃圾参数：</p>\n<pre><code>java -jar selenium-server-standalone-2.21.0.jar -role node xx\n</code></pre><p>你将先看到 “INFO…” 和一个 “ERROR”，在其后你将看到 Selenium-Grid 的命令行选项。我们没有列出这个命令的所有输出，因为它实在太长了，这个输出的最初几行看起来如下：</p>\n<pre><code>Jul 19, 2012 10:10:39 AM org.openqa.grid.selenium.GridLauncher main\nINFO: Launching a selenium grid node\norg.openqa.grid.common.exception.GridConfigurationException: You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\n        at org.openqa.grid.common.RegistrationRequest.validate(RegistrationRequest.java:610)\n        at org.openqa.grid.internal.utils.SelfRegisteringRemote.startRemoteServer(SelfRegisteringRemote.java:88)\n        at org.openqa.grid.selenium.GridLauncher.main(GridLauncher.java:72)\nError building the config :You need to specify a hub to register to using -hubHost X -hubPort 5555. The specified config was -hubHost null -hubPort 4444\nUsage :\n  -hubConfig:\n        (hub) a JSON file following grid2 format.\n\n -nodeTimeout:\n        (node) &lt;XXXX&gt;  the timeout in seconds before the hub\n          automatically ends a test that hasn&apos;t had aby activity than XX\n          sec.The browser will be released for another test to use.This\n          typically takes care of the client crashes.\n</code></pre><h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><h3 id=\"Unable-to-acess-the-jarfile\"><a href=\"#Unable-to-acess-the-jarfile\" class=\"headerlink\" title=\"Unable to acess the jarfile\"></a>Unable to acess the jarfile</h3><p>Unable to access jarfile selenium-server-standalone-2.21.0.jar</p>\n<p>无论是启动中心还是节点都有可能产生这个错误。这意味着 java 无法找到 selenium-server jar 包。你需要从 selenium-server-XXXX.jar 文件存放在目录运行命令或者指定 jar 包的完整路径。</p>"},{"layout":"post","title":"selenium文档:selenium RC","date":"2013-05-30T11:55:00.000Z","comments":1,"_content":"# Selenium 1 (Selenium RC)¶\n\n## 介绍\n\n正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。\n\nSelenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。 \n\n## Selenium RC 如何工作\n\n首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。\n\n### RC 组件\n\nSelenium RC 组件是：\n\nSelenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。   \n<!--more-->\n客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。   \n\n以下是一个简单的架构图：\n\n![架构图](http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png)\n\n上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。\n\n### Selenium 服务端\n\nSelenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。\n\nRC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。\n\nServer 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。\n\n### 客户端库\n\n客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。\n\n客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。\n\n因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。\n\n## 安装\n\n用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。\n\n一旦你选定了一种编程语言，你仅需要：\n\n- 安装 Selenium RC 服务端。\n- 使用特定于该语言的客户端驱动创建你的项目\n\n### 安装 Selenium 服务端\n\nSelenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。\n\n### 运行 Selenium 服务\n\n在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：\n\n    java -jar selenium-server-standalone-<version-number>.jar\n    \n\n你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。\n\n要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：\n\n    java -version\n\n如果你得到一个版本号（必须>=1.5），那么你已经成功启动 Selenium RC。\n\n### 使用 Java 客户端驱动\n\n- 从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。\n- 提取 selenium-java-<version-number>.jar\n- 打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)\n- 创建一个 java 项目。\n- 将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。\n- 将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。\n- 从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。\n- 从命令行运行 Selenium 服务。\n- 从 Java IDE 或者命令行中执行你的测试。\n\n关于更多 Java 测试项目的配置细节，可查看本章附件：**在 Eclipse 中配置 Selenium RC** 和 **在 Intellij 中配置 Selenium RC**。\n\n## 将 Selenese 转换成程序\n\n使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。\n\n### 测试脚本范例\n\n让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：\n\n<table>\n    <tbody>\n        <tr>\n            <td>open</td>\n            <td>/</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium rc</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium rc</td>\n            <td>&nbsp;</td>\n        </tr>\n    </tbody>\n</table>\n\n注意: 这个例子仅仅在 Google 搜索页面 http://www.google.com 工作。\n\n## Selenese 作为编程代码\n\n以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。\n\n    /** Add JUnit framework to your classpath if not already there\n     *  for this example to work\n     */\n    package com.example.tests;\n    \n    import com.thoughtworks.selenium.*;\n    import java.util.regex.Pattern;\n    \n    public class NewTest extends SeleneseTestCase {\n        public void setUp() throws Exception {\n            setUp(\"http://www.google.com/\", \"*firefox\");\n        }\n          public void testNew() throws Exception {\n              selenium.open(\"/\");\n              selenium.type(\"q\", \"selenium rc\");\n              selenium.click(\"btnG\");\n              selenium.waitForPageToLoad(\"30000\");\n              assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n        }\n    }\n\n在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。\n\n## 编写你的测试代码\n\n现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：\n\n- 从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。\n- 编写一个 main() 方法来执行创建的代码。\n\n你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。\n\n这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。\n\n### Java\n\n在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。\n\n你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。\n\n    selenium = new DefaultSelenium(\"localhost\", 4444, \"*iehta\", \"http://www.google.com/\");\n\n使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。\n\n    \n    package com.example.tests;\n    // 我们指定了这个文件的包\n    \n    import com.thoughtworks.selenium.*;\n    // 导入驱动。\n    // 你将使用它来初始化浏览器并执行一些任务。\n    \n    import java.util.regex.Pattern;\n    // 加入正则表达式模块，因为有些我们需要使用它进行校验。\n    // 如果你的代码不需要它，完全可以移除掉。 \n    \n    public class NewTest extends SeleneseTestCase {\n    // 创建 Selenium 测试用例\n    \n          public void setUp() throws Exception {\n            setUp(\"http://www.google.com/\", \"*firefox\");\n                 // 初始化并启动浏览器\n          }\n    \n          public void testNew() throws Exception {\n               selenium.open(\"/\");\n               selenium.type(\"q\", \"selenium rc\");\n               selenium.click(\"btnG\");\n               selenium.waitForPageToLoad(\"30000\");\n               assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n               // 以上为真实的测试步骤\n         }\n    }\n\n## 学习使用 API\n\nSelenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。\n\n### 启动浏览器\n\n    setUp(\"http://www.google.com/\", \"*firefox\");\n\n每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。\n\n创建浏览器对象所需要的参数如下：\n\n#### host\n\n指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。\n\n#### port\n\n指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。\n\n#### browser\n\n指定你希望运行测试的浏览器。该参数必选。\n\n#### url\n\nAUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。\n\n注意，有些客户端要求调用 start() 方法来启动浏览器。\n\n### 运行 命令\n\n一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 \"Selenium\"），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：\n\n    selenium.type(“field-id”,”string to type”)\n\n此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。\n\n## 报告结果\n\nSelenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。\n\n### 测试框架报告工具\n\n很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。\n\n我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。\n\n### 测试报告库\n\n同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。\n\n### 最佳实践是？\n\n大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。\n\n### 测试报告范例\n\n为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。\n\n#### Java 中的测试报告\n\n- 如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 [JUnit 报告](http://ant.apache.org/manual/Tasks/junitreport.html) 。\n- 如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 [TestNG 报告](http://testng.org/doc/documentation-main.html#test-results) 。\n- ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 [TestNG](http://reportng.uncommons.org/)\n- 同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：\n\n    ![TestNG-xslt](http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png)\n\n    了解更多 [TestNG-xslt]()\n\n##### 记录 Selenese 命令\n\nLogging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 [Logging Selenium](http://loggingselenium.sourceforge.net/index.html)\n\n## 为你的测试加点料\n\n现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。\n\n当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。\n\n本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。\n\n### 迭代\n\n迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。\n\n使用同之前一样的 [Google 搜索例子](http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example)，让我们来检查搜索结果。这个测试将使用 Selenese：\n\n<table>\n    <tbody>\n        <tr>\n            <td>open</td>\n            <td>/</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium rc</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium rc</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium ide</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium ide</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium grid</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium grid</td>\n            <td>&nbsp;</td>\n        </tr>\n    </tbody>\n</table>\n\n同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。\n\n### In Csharp\n\n    // Collection of String values.\n    String[] arr = {\"ide\", \"rc\", \"grid\"};\n    \n    // Execute loop for each String in array 'arr'.\n    foreach (String s in arr) {\n        sel.open(\"/\");\n        sel.type(\"q\", \"selenium \" +s);\n        sel.click(\"btnG\");\n        sel.waitForPageToLoad(\"30000\");\n        assertTrue(\"Expected text: \" +s+ \" is missing on page.\"\n        , sel.isTextPresent(\"Results * for selenium \" + s));\n    }\n\n### 条件语句\n\n我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：\n\n    // Java\n    selenium.type(\"q\", \"selenium \" +s);\n    \n如果元素“q”不在页面上将会抛出一个异常：\n\n    com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found\n\n这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。\n\n一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：\n\n    // 如果元素可用，则则行类型判定操作\n    if(selenium.isElementPresent(\"q\")) {\n        selenium.type(\"q\", \"Selenium rc\");\n    } else {\n        System.out.printf(\"Element: \" +q+ \" is not available on page.\")\n    }\n\n这样做的好处是，即使页面上没有这个元素测试也能够继续执行。\n\n### 在你的测试中执行 JavaScript\n\n在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。\n\n考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。\n\n\n    // Java\n    public static String[] getAllCheckboxIds () {\n         String script = \"var inputId  = new Array();\";// Create array in java script.\n                script += \"var cnt = 0;\"; // Counter for check box ids.\n                script += \"var inputFields  = new Array();\"; // Create array in java script.\n                script += \"inputFields = window.document.getElementsByTagName('input');\"; // Collect input elements.\n                script += \"for(var i=0; i<inputFields.length; i++) {\"; // Loop through the collected elements.\n                script += \"if(inputFields[i].id !=null \" +\n                          \"&& inputFields[i].id !='undefined' \" +\n                          \"&& inputFields[i].getAttribute('type') == 'checkbox') {\"; // If input field is of type check box and input id is not null.\n                script += \"inputId[cnt]=inputFields[i].id ;\" + // Save check box id to inputId array.\n                          \"cnt++;\" + // increment the counter.\n                          \"}\" + // end of if.\n                          \"}\"; // end of for.\n                script += \"inputId.toString();\" ;// Convert array in to string.\n         String[] checkboxIds = selenium.getEval(script).split(\",\"); // Split the string.\n         return checkboxIds;\n     }\n \n如果要计算页面中的图片数，你可以：\n\n    // Java\n    selenium.getEval(\"window.document.images.length;\");\n    \n记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。\n\n## 服务端选项\n\n当服务启动时，可以使用命令行配置项来改变其默认行为。\n\n回想一下，我们是这样启动服务的：\n\n    $ java -jar selenium-server-standalone-<version-number>.jar\n    \n你可以使用 -h 来查看所有的配置项：\n\n    $ java -jar selenium-server-standalone-<version-number>.jar -h\n    \n你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。\n\n### 代理配置\n\n如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。\n\n    $ java -jar selenium-server-standalone-<version-number>.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password\n\n### 多窗口模式\n\n如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。\n\n![multi-window](http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png)\n\n有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。\n\n![multi-window2](http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png)\n\n对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：\n\n    -multiwindow\n    \n在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：\n\n    -singlewindow\n\n### 指定 Firefox 配置\n\nFirefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。\n\n首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：\n\n    firefox.exe -profilemanager\n\n    firefox.exe -P\n\n使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。\n\n    -firefoxProfileTemplate \"path to the profile\"\n\n**警告**\n\n确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。\n\n更多请参考 [Mozilla’s Knowledge Base](http://support.mozilla.com/zh-CN/kb/Managing+profiles)\n\n### 通过 -htmlSuite 配置项在服务端直接运行 Selenese\n\n通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：\n\n    java -jar selenium-server-standalone-<version-number>.jar -htmlSuite \"*firefox\"\n    \"http://www.google.com\" \"c:\\absolute\\path\\to\\my\\HTMLSuite.html\"\n    \"c:\\absolute\\path\\to\\my\\results.html\"\n    \n这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。\n\n**注意**\n\n在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。\n\n这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。\n\n### Selenium 服务日志\n\n#### 服务端日志\n\n当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。\n\n    java -jar selenium-server-standalone-<version-number>.jar -log selenium.log\n\n这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：\n\n    20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -\n    Browser 465828/:top frame1 posted START NEW\n\n该信息格式为：\n\n    TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE\n\n#### 浏览器端日志\n\n在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。\n\n    java -jar selenium-server-standalone-<version-number>.jar -browserSideLog\n    \n为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。\n\n### 指定特定浏览器路径\n\n你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：\n\n    *custom <path to browser>\n\n## Selenium RC 架构\n\n**注意**\n\n该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。\n\n为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 [同源策略](http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy)。\n\n### 同源策略\n\nSelenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。\n\n为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。\n\n之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。\n\n**注意**\n\n你可以在维基百科上找到更多关于 [同源策略](http://en.wikipedia.org/wiki/Same_origin_policy) 和 [XSS](http://en.wikipedia.org/wiki/Cross-site_scripting) 的内容\n\n### 代理注入\n\nSelenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。\n\n1. 代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。\n2. 浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：\n\n![proxy](http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png)\n\n当测试开始时，将发生以下事情：\n\n1. 客户端驱动将和 Selenium RC 服务端建立一个连接。\n2. Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。\n3. 客户端驱动向服务端传递一个 Selenese 命令。\n4. 服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。\n5. Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。\n6. 浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）\n7. Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）\n8. 浏览器接收到这个页面并且渲染到相应的帧或者窗口。\n\n### 高特权浏览器（Heightened Privileges Browsers）\n\n这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。\n\n结构图如下：\n\n![Heightened Privileges Browsers](http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png)\n\n此时，将发生以下事情：\n\n1. 客户端驱动和 Selenium RC 服务端建立一个连接。\n2. Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。\n3. Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。\n4. Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。\n5. 浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。\n\n## 处理 HTTPS 和安全警告弹出框\n\n当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。\n\n为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。\n\n当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。\n\n在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 *firefox 和 *iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 *chrome 和 *iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。\n\n在版本1中，推荐运行 *firefox 和 *iexplore 运行模式。然而，我们还提供 *iexploreproxy 和 *firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。\n\n在 Selenium RC 的早期版本中，*chrome 或 *iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。\n\n### 关于安全证书\n\n通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。\n\n为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。\n\n另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。\n\n## 更多浏览器支持和相关配置\n\nSelenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”*custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 *firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。\n\n    cmd=getNewBrowserSession&1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe&2=http://www.google.com\n\n### 使用不同的浏览器配置来运行测试\n\n通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。\n\n例如，你使用如下自定义配置启动 Firefox：\n\n    cmd=getNewBrowserSession&1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe&2=http://www.google.com\n    \n注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。\n\n注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。\n\n## 常见问题\n\n**译者注：**这部分内容不翻译了，请参考原英文文档。\n\n- Unable to Connect to Server\n- Unable to Load the Browser\n- Selenium Cannot Find the AUT\n- Firefox Refused Shutdown While Preparing a Profile\n- Versioning Problems\n- Error message: “(Unsupported major.minor version 49.0)” while starting server\n- 404 error when running the getNewBrowserSession command\n- Permission Denied Error\n- Handling Browser Popup Windows\n- On Linux, why isn’t my Firefox browser session closing?\n- Firefox *chrome doesn’t work with custom profile\n- Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?\n- Problems With Verify Commands\n- Safari and MultiWindow Mode\n- Firefox on Linux\n- IE and Style Attributes\n- Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser\n- Where can I Ask Questions that Aren’t Answered Here?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2013-05-30-selenium-doc-selenium-rc.markdown","raw":"---\nlayout: post\ntitle: \"selenium文档:selenium RC\"\ndate: 2013-05-30 19:55\ncomments: true\ncategories: selenium官方文档\ntags: [ selenium ]\n---\n# Selenium 1 (Selenium RC)¶\n\n## 介绍\n\n正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。\n\nSelenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。 \n\n## Selenium RC 如何工作\n\n首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。\n\n### RC 组件\n\nSelenium RC 组件是：\n\nSelenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。   \n<!--more-->\n客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。   \n\n以下是一个简单的架构图：\n\n![架构图](http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png)\n\n上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。\n\n### Selenium 服务端\n\nSelenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。\n\nRC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。\n\nServer 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。\n\n### 客户端库\n\n客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。\n\n客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。\n\n因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。\n\n## 安装\n\n用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。\n\n一旦你选定了一种编程语言，你仅需要：\n\n- 安装 Selenium RC 服务端。\n- 使用特定于该语言的客户端驱动创建你的项目\n\n### 安装 Selenium 服务端\n\nSelenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。\n\n### 运行 Selenium 服务\n\n在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：\n\n    java -jar selenium-server-standalone-<version-number>.jar\n    \n\n你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。\n\n要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：\n\n    java -version\n\n如果你得到一个版本号（必须>=1.5），那么你已经成功启动 Selenium RC。\n\n### 使用 Java 客户端驱动\n\n- 从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。\n- 提取 selenium-java-<version-number>.jar\n- 打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)\n- 创建一个 java 项目。\n- 将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。\n- 将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。\n- 从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。\n- 从命令行运行 Selenium 服务。\n- 从 Java IDE 或者命令行中执行你的测试。\n\n关于更多 Java 测试项目的配置细节，可查看本章附件：**在 Eclipse 中配置 Selenium RC** 和 **在 Intellij 中配置 Selenium RC**。\n\n## 将 Selenese 转换成程序\n\n使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。\n\n### 测试脚本范例\n\n让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：\n\n<table>\n    <tbody>\n        <tr>\n            <td>open</td>\n            <td>/</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium rc</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium rc</td>\n            <td>&nbsp;</td>\n        </tr>\n    </tbody>\n</table>\n\n注意: 这个例子仅仅在 Google 搜索页面 http://www.google.com 工作。\n\n## Selenese 作为编程代码\n\n以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。\n\n    /** Add JUnit framework to your classpath if not already there\n     *  for this example to work\n     */\n    package com.example.tests;\n    \n    import com.thoughtworks.selenium.*;\n    import java.util.regex.Pattern;\n    \n    public class NewTest extends SeleneseTestCase {\n        public void setUp() throws Exception {\n            setUp(\"http://www.google.com/\", \"*firefox\");\n        }\n          public void testNew() throws Exception {\n              selenium.open(\"/\");\n              selenium.type(\"q\", \"selenium rc\");\n              selenium.click(\"btnG\");\n              selenium.waitForPageToLoad(\"30000\");\n              assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n        }\n    }\n\n在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。\n\n## 编写你的测试代码\n\n现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：\n\n- 从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。\n- 编写一个 main() 方法来执行创建的代码。\n\n你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。\n\n这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。\n\n### Java\n\n在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。\n\n你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。\n\n    selenium = new DefaultSelenium(\"localhost\", 4444, \"*iehta\", \"http://www.google.com/\");\n\n使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。\n\n    \n    package com.example.tests;\n    // 我们指定了这个文件的包\n    \n    import com.thoughtworks.selenium.*;\n    // 导入驱动。\n    // 你将使用它来初始化浏览器并执行一些任务。\n    \n    import java.util.regex.Pattern;\n    // 加入正则表达式模块，因为有些我们需要使用它进行校验。\n    // 如果你的代码不需要它，完全可以移除掉。 \n    \n    public class NewTest extends SeleneseTestCase {\n    // 创建 Selenium 测试用例\n    \n          public void setUp() throws Exception {\n            setUp(\"http://www.google.com/\", \"*firefox\");\n                 // 初始化并启动浏览器\n          }\n    \n          public void testNew() throws Exception {\n               selenium.open(\"/\");\n               selenium.type(\"q\", \"selenium rc\");\n               selenium.click(\"btnG\");\n               selenium.waitForPageToLoad(\"30000\");\n               assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n               // 以上为真实的测试步骤\n         }\n    }\n\n## 学习使用 API\n\nSelenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。\n\n### 启动浏览器\n\n    setUp(\"http://www.google.com/\", \"*firefox\");\n\n每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。\n\n创建浏览器对象所需要的参数如下：\n\n#### host\n\n指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。\n\n#### port\n\n指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。\n\n#### browser\n\n指定你希望运行测试的浏览器。该参数必选。\n\n#### url\n\nAUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。\n\n注意，有些客户端要求调用 start() 方法来启动浏览器。\n\n### 运行 命令\n\n一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 \"Selenium\"），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：\n\n    selenium.type(“field-id”,”string to type”)\n\n此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。\n\n## 报告结果\n\nSelenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。\n\n### 测试框架报告工具\n\n很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。\n\n我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。\n\n### 测试报告库\n\n同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。\n\n### 最佳实践是？\n\n大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。\n\n### 测试报告范例\n\n为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。\n\n#### Java 中的测试报告\n\n- 如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 [JUnit 报告](http://ant.apache.org/manual/Tasks/junitreport.html) 。\n- 如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 [TestNG 报告](http://testng.org/doc/documentation-main.html#test-results) 。\n- ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 [TestNG](http://reportng.uncommons.org/)\n- 同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：\n\n    ![TestNG-xslt](http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png)\n\n    了解更多 [TestNG-xslt]()\n\n##### 记录 Selenese 命令\n\nLogging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 [Logging Selenium](http://loggingselenium.sourceforge.net/index.html)\n\n## 为你的测试加点料\n\n现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。\n\n当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。\n\n本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。\n\n### 迭代\n\n迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。\n\n使用同之前一样的 [Google 搜索例子](http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example)，让我们来检查搜索结果。这个测试将使用 Selenese：\n\n<table>\n    <tbody>\n        <tr>\n            <td>open</td>\n            <td>/</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium rc</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium rc</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium ide</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium ide</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>type</td>\n            <td>q</td>\n            <td>selenium grid</td>\n        </tr>\n        <tr>\n            <td>clickAndWait</td>\n            <td>btnG</td>\n            <td>&nbsp;</td>\n        </tr>\n        <tr>\n            <td>assertTextPresent</td>\n            <td>Results * for selenium grid</td>\n            <td>&nbsp;</td>\n        </tr>\n    </tbody>\n</table>\n\n同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。\n\n### In Csharp\n\n    // Collection of String values.\n    String[] arr = {\"ide\", \"rc\", \"grid\"};\n    \n    // Execute loop for each String in array 'arr'.\n    foreach (String s in arr) {\n        sel.open(\"/\");\n        sel.type(\"q\", \"selenium \" +s);\n        sel.click(\"btnG\");\n        sel.waitForPageToLoad(\"30000\");\n        assertTrue(\"Expected text: \" +s+ \" is missing on page.\"\n        , sel.isTextPresent(\"Results * for selenium \" + s));\n    }\n\n### 条件语句\n\n我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：\n\n    // Java\n    selenium.type(\"q\", \"selenium \" +s);\n    \n如果元素“q”不在页面上将会抛出一个异常：\n\n    com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found\n\n这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。\n\n一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：\n\n    // 如果元素可用，则则行类型判定操作\n    if(selenium.isElementPresent(\"q\")) {\n        selenium.type(\"q\", \"Selenium rc\");\n    } else {\n        System.out.printf(\"Element: \" +q+ \" is not available on page.\")\n    }\n\n这样做的好处是，即使页面上没有这个元素测试也能够继续执行。\n\n### 在你的测试中执行 JavaScript\n\n在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。\n\n考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。\n\n\n    // Java\n    public static String[] getAllCheckboxIds () {\n         String script = \"var inputId  = new Array();\";// Create array in java script.\n                script += \"var cnt = 0;\"; // Counter for check box ids.\n                script += \"var inputFields  = new Array();\"; // Create array in java script.\n                script += \"inputFields = window.document.getElementsByTagName('input');\"; // Collect input elements.\n                script += \"for(var i=0; i<inputFields.length; i++) {\"; // Loop through the collected elements.\n                script += \"if(inputFields[i].id !=null \" +\n                          \"&& inputFields[i].id !='undefined' \" +\n                          \"&& inputFields[i].getAttribute('type') == 'checkbox') {\"; // If input field is of type check box and input id is not null.\n                script += \"inputId[cnt]=inputFields[i].id ;\" + // Save check box id to inputId array.\n                          \"cnt++;\" + // increment the counter.\n                          \"}\" + // end of if.\n                          \"}\"; // end of for.\n                script += \"inputId.toString();\" ;// Convert array in to string.\n         String[] checkboxIds = selenium.getEval(script).split(\",\"); // Split the string.\n         return checkboxIds;\n     }\n \n如果要计算页面中的图片数，你可以：\n\n    // Java\n    selenium.getEval(\"window.document.images.length;\");\n    \n记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。\n\n## 服务端选项\n\n当服务启动时，可以使用命令行配置项来改变其默认行为。\n\n回想一下，我们是这样启动服务的：\n\n    $ java -jar selenium-server-standalone-<version-number>.jar\n    \n你可以使用 -h 来查看所有的配置项：\n\n    $ java -jar selenium-server-standalone-<version-number>.jar -h\n    \n你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。\n\n### 代理配置\n\n如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。\n\n    $ java -jar selenium-server-standalone-<version-number>.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password\n\n### 多窗口模式\n\n如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。\n\n![multi-window](http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png)\n\n有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。\n\n![multi-window2](http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png)\n\n对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：\n\n    -multiwindow\n    \n在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：\n\n    -singlewindow\n\n### 指定 Firefox 配置\n\nFirefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。\n\n首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：\n\n    firefox.exe -profilemanager\n\n    firefox.exe -P\n\n使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。\n\n    -firefoxProfileTemplate \"path to the profile\"\n\n**警告**\n\n确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。\n\n更多请参考 [Mozilla’s Knowledge Base](http://support.mozilla.com/zh-CN/kb/Managing+profiles)\n\n### 通过 -htmlSuite 配置项在服务端直接运行 Selenese\n\n通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：\n\n    java -jar selenium-server-standalone-<version-number>.jar -htmlSuite \"*firefox\"\n    \"http://www.google.com\" \"c:\\absolute\\path\\to\\my\\HTMLSuite.html\"\n    \"c:\\absolute\\path\\to\\my\\results.html\"\n    \n这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。\n\n**注意**\n\n在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。\n\n这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。\n\n### Selenium 服务日志\n\n#### 服务端日志\n\n当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。\n\n    java -jar selenium-server-standalone-<version-number>.jar -log selenium.log\n\n这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：\n\n    20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -\n    Browser 465828/:top frame1 posted START NEW\n\n该信息格式为：\n\n    TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE\n\n#### 浏览器端日志\n\n在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。\n\n    java -jar selenium-server-standalone-<version-number>.jar -browserSideLog\n    \n为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。\n\n### 指定特定浏览器路径\n\n你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：\n\n    *custom <path to browser>\n\n## Selenium RC 架构\n\n**注意**\n\n该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。\n\n为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 [同源策略](http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy)。\n\n### 同源策略\n\nSelenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。\n\n为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。\n\n之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。\n\n**注意**\n\n你可以在维基百科上找到更多关于 [同源策略](http://en.wikipedia.org/wiki/Same_origin_policy) 和 [XSS](http://en.wikipedia.org/wiki/Cross-site_scripting) 的内容\n\n### 代理注入\n\nSelenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。\n\n1. 代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。\n2. 浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：\n\n![proxy](http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png)\n\n当测试开始时，将发生以下事情：\n\n1. 客户端驱动将和 Selenium RC 服务端建立一个连接。\n2. Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。\n3. 客户端驱动向服务端传递一个 Selenese 命令。\n4. 服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。\n5. Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。\n6. 浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）\n7. Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）\n8. 浏览器接收到这个页面并且渲染到相应的帧或者窗口。\n\n### 高特权浏览器（Heightened Privileges Browsers）\n\n这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。\n\n结构图如下：\n\n![Heightened Privileges Browsers](http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png)\n\n此时，将发生以下事情：\n\n1. 客户端驱动和 Selenium RC 服务端建立一个连接。\n2. Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。\n3. Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。\n4. Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。\n5. 浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。\n\n## 处理 HTTPS 和安全警告弹出框\n\n当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。\n\n为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。\n\n当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。\n\n在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 *firefox 和 *iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 *chrome 和 *iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。\n\n在版本1中，推荐运行 *firefox 和 *iexplore 运行模式。然而，我们还提供 *iexploreproxy 和 *firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。\n\n在 Selenium RC 的早期版本中，*chrome 或 *iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。\n\n### 关于安全证书\n\n通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。\n\n为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。\n\n另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。\n\n## 更多浏览器支持和相关配置\n\nSelenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”*custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 *firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。\n\n    cmd=getNewBrowserSession&1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe&2=http://www.google.com\n\n### 使用不同的浏览器配置来运行测试\n\n通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。\n\n例如，你使用如下自定义配置启动 Firefox：\n\n    cmd=getNewBrowserSession&1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe&2=http://www.google.com\n    \n注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。\n\n注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。\n\n## 常见问题\n\n**译者注：**这部分内容不翻译了，请参考原英文文档。\n\n- Unable to Connect to Server\n- Unable to Load the Browser\n- Selenium Cannot Find the AUT\n- Firefox Refused Shutdown While Preparing a Profile\n- Versioning Problems\n- Error message: “(Unsupported major.minor version 49.0)” while starting server\n- 404 error when running the getNewBrowserSession command\n- Permission Denied Error\n- Handling Browser Popup Windows\n- On Linux, why isn’t my Firefox browser session closing?\n- Firefox *chrome doesn’t work with custom profile\n- Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?\n- Problems With Verify Commands\n- Safari and MultiWindow Mode\n- Firefox on Linux\n- IE and Style Attributes\n- Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser\n- Where can I Ask Questions that Aren’t Answered Here?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2013-05-30-selenium-doc-selenium-rc","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5v0065v8fy21pri61n","content":"<h1 id=\"Selenium-1-Selenium-RC-¶\"><a href=\"#Selenium-1-Selenium-RC-¶\" class=\"headerlink\" title=\"Selenium 1 (Selenium RC)¶\"></a>Selenium 1 (Selenium RC)¶</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。</p>\n<p>Selenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。 </p>\n<h2 id=\"Selenium-RC-如何工作\"><a href=\"#Selenium-RC-如何工作\" class=\"headerlink\" title=\"Selenium RC 如何工作\"></a>Selenium RC 如何工作</h2><p>首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。</p>\n<h3 id=\"RC-组件\"><a href=\"#RC-组件\" class=\"headerlink\" title=\"RC 组件\"></a>RC 组件</h3><p>Selenium RC 组件是：</p>\n<p>Selenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。<br><a id=\"more\"></a><br>客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。   </p>\n<p>以下是一个简单的架构图：</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png\" alt=\"架构图\"></p>\n<p>上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。</p>\n<h3 id=\"Selenium-服务端\"><a href=\"#Selenium-服务端\" class=\"headerlink\" title=\"Selenium 服务端\"></a>Selenium 服务端</h3><p>Selenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。</p>\n<p>RC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。</p>\n<p>Server 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。</p>\n<h3 id=\"客户端库\"><a href=\"#客户端库\" class=\"headerlink\" title=\"客户端库\"></a>客户端库</h3><p>客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。</p>\n<p>客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。</p>\n<p>因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。</p>\n<p>一旦你选定了一种编程语言，你仅需要：</p>\n<ul>\n<li>安装 Selenium RC 服务端。</li>\n<li>使用特定于该语言的客户端驱动创建你的项目</li>\n</ul>\n<h3 id=\"安装-Selenium-服务端\"><a href=\"#安装-Selenium-服务端\" class=\"headerlink\" title=\"安装 Selenium 服务端\"></a>安装 Selenium 服务端</h3><p>Selenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。</version-number></p>\n<h3 id=\"运行-Selenium-服务\"><a href=\"#运行-Selenium-服务\" class=\"headerlink\" title=\"运行 Selenium 服务\"></a>运行 Selenium 服务</h3><p>在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar\n</code></pre><p>你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。</p>\n<p>要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：</p>\n<pre><code>java -version\n</code></pre><p>如果你得到一个版本号（必须&gt;=1.5），那么你已经成功启动 Selenium RC。</p>\n<h3 id=\"使用-Java-客户端驱动\"><a href=\"#使用-Java-客户端驱动\" class=\"headerlink\" title=\"使用 Java 客户端驱动\"></a>使用 Java 客户端驱动</h3><ul>\n<li>从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。</li>\n<li>提取 selenium-java-<version-number>.jar</version-number></li>\n<li>打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)</li>\n<li>创建一个 java 项目。</li>\n<li>将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。</version-number></li>\n<li>将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。</version-number></li>\n<li>从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。</li>\n<li>从命令行运行 Selenium 服务。</li>\n<li>从 Java IDE 或者命令行中执行你的测试。</li>\n</ul>\n<p>关于更多 Java 测试项目的配置细节，可查看本章附件：<strong>在 Eclipse 中配置 Selenium RC</strong> 和 <strong>在 Intellij 中配置 Selenium RC</strong>。</p>\n<h2 id=\"将-Selenese-转换成程序\"><a href=\"#将-Selenese-转换成程序\" class=\"headerlink\" title=\"将 Selenese 转换成程序\"></a>将 Selenese 转换成程序</h2><p>使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。</p>\n<h3 id=\"测试脚本范例\"><a href=\"#测试脚本范例\" class=\"headerlink\" title=\"测试脚本范例\"></a>测试脚本范例</h3><p>让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：</p>\n<table><br>    <tbody><br>        <tr><br>            <td>open</td><br>            <td>/</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium rc</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results * for selenium rc</td><br>            <td>&nbsp;</td><br>        </tr><br>    </tbody><br></table>\n\n<p>注意: 这个例子仅仅在 Google 搜索页面 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"external\">http://www.google.com</a> 工作。</p>\n<h2 id=\"Selenese-作为编程代码\"><a href=\"#Selenese-作为编程代码\" class=\"headerlink\" title=\"Selenese 作为编程代码\"></a>Selenese 作为编程代码</h2><p>以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。</p>\n<pre><code>/** Add JUnit framework to your classpath if not already there\n *  for this example to work\n */\npackage com.example.tests;\n\nimport com.thoughtworks.selenium.*;\nimport java.util.regex.Pattern;\n\npublic class NewTest extends SeleneseTestCase {\n    public void setUp() throws Exception {\n        setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n    }\n      public void testNew() throws Exception {\n          selenium.open(&quot;/&quot;);\n          selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n          selenium.click(&quot;btnG&quot;);\n          selenium.waitForPageToLoad(&quot;30000&quot;);\n          assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n    }\n}\n</code></pre><p>在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。</p>\n<h2 id=\"编写你的测试代码\"><a href=\"#编写你的测试代码\" class=\"headerlink\" title=\"编写你的测试代码\"></a>编写你的测试代码</h2><p>现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：</p>\n<ul>\n<li>从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。</li>\n<li>编写一个 main() 方法来执行创建的代码。</li>\n</ul>\n<p>你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。</p>\n<p>这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。</p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p>在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。</p>\n<p>你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。</p>\n<pre><code>selenium = new DefaultSelenium(&quot;localhost&quot;, 4444, &quot;*iehta&quot;, &quot;http://www.google.com/&quot;);\n</code></pre><p>使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。</p>\n<pre><code>package com.example.tests;\n// 我们指定了这个文件的包\n\nimport com.thoughtworks.selenium.*;\n// 导入驱动。\n// 你将使用它来初始化浏览器并执行一些任务。\n\nimport java.util.regex.Pattern;\n// 加入正则表达式模块，因为有些我们需要使用它进行校验。\n// 如果你的代码不需要它，完全可以移除掉。 \n\npublic class NewTest extends SeleneseTestCase {\n// 创建 Selenium 测试用例\n\n      public void setUp() throws Exception {\n        setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n             // 初始化并启动浏览器\n      }\n\n      public void testNew() throws Exception {\n           selenium.open(&quot;/&quot;);\n           selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n           selenium.click(&quot;btnG&quot;);\n           selenium.waitForPageToLoad(&quot;30000&quot;);\n           assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n           // 以上为真实的测试步骤\n     }\n}\n</code></pre><h2 id=\"学习使用-API\"><a href=\"#学习使用-API\" class=\"headerlink\" title=\"学习使用 API\"></a>学习使用 API</h2><p>Selenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。</p>\n<h3 id=\"启动浏览器\"><a href=\"#启动浏览器\" class=\"headerlink\" title=\"启动浏览器\"></a>启动浏览器</h3><pre><code>setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n</code></pre><p>每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。</p>\n<p>创建浏览器对象所需要的参数如下：</p>\n<h4 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h4><p>指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。</p>\n<h4 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h4><p>指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。</p>\n<h4 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h4><p>指定你希望运行测试的浏览器。该参数必选。</p>\n<h4 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h4><p>AUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。</p>\n<p>注意，有些客户端要求调用 start() 方法来启动浏览器。</p>\n<h3 id=\"运行-命令\"><a href=\"#运行-命令\" class=\"headerlink\" title=\"运行 命令\"></a>运行 命令</h3><p>一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 “Selenium”），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：</p>\n<pre><code>selenium.type(“field-id”,”string to type”)\n</code></pre><p>此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。</p>\n<h2 id=\"报告结果\"><a href=\"#报告结果\" class=\"headerlink\" title=\"报告结果\"></a>报告结果</h2><p>Selenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。</p>\n<h3 id=\"测试框架报告工具\"><a href=\"#测试框架报告工具\" class=\"headerlink\" title=\"测试框架报告工具\"></a>测试框架报告工具</h3><p>很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。</p>\n<p>我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。</p>\n<h3 id=\"测试报告库\"><a href=\"#测试报告库\" class=\"headerlink\" title=\"测试报告库\"></a>测试报告库</h3><p>同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。</p>\n<h3 id=\"最佳实践是？\"><a href=\"#最佳实践是？\" class=\"headerlink\" title=\"最佳实践是？\"></a>最佳实践是？</h3><p>大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。</p>\n<h3 id=\"测试报告范例\"><a href=\"#测试报告范例\" class=\"headerlink\" title=\"测试报告范例\"></a>测试报告范例</h3><p>为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。</p>\n<h4 id=\"Java-中的测试报告\"><a href=\"#Java-中的测试报告\" class=\"headerlink\" title=\"Java 中的测试报告\"></a>Java 中的测试报告</h4><ul>\n<li>如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 <a href=\"http://ant.apache.org/manual/Tasks/junitreport.html\" target=\"_blank\" rel=\"external\">JUnit 报告</a> 。</li>\n<li>如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 <a href=\"http://testng.org/doc/documentation-main.html#test-results\" target=\"_blank\" rel=\"external\">TestNG 报告</a> 。</li>\n<li>ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 <a href=\"http://reportng.uncommons.org/\" target=\"_blank\" rel=\"external\">TestNG</a></li>\n<li><p>同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：</p>\n<p>  <img src=\"http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png\" alt=\"TestNG-xslt\"></p>\n<p>  了解更多 <a href=\"\">TestNG-xslt</a></p>\n</li>\n</ul>\n<h5 id=\"记录-Selenese-命令\"><a href=\"#记录-Selenese-命令\" class=\"headerlink\" title=\"记录 Selenese 命令\"></a>记录 Selenese 命令</h5><p>Logging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 <a href=\"http://loggingselenium.sourceforge.net/index.html\" target=\"_blank\" rel=\"external\">Logging Selenium</a></p>\n<h2 id=\"为你的测试加点料\"><a href=\"#为你的测试加点料\" class=\"headerlink\" title=\"为你的测试加点料\"></a>为你的测试加点料</h2><p>现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。</p>\n<p>当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。</p>\n<p>本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。</p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。</p>\n<p>使用同之前一样的 <a href=\"http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example\" target=\"_blank\" rel=\"external\">Google 搜索例子</a>，让我们来检查搜索结果。这个测试将使用 Selenese：</p>\n<table><br>    <tbody><br>        <tr><br>            <td>open</td><br>            <td>/</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium rc</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results <em> for selenium rc</em></td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium ide</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results  for selenium ide</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium grid</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results * for selenium grid</td><br>            <td>&nbsp;</td><br>        </tr><br>    </tbody><br></table>\n\n<p>同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。</p>\n<h3 id=\"In-Csharp\"><a href=\"#In-Csharp\" class=\"headerlink\" title=\"In Csharp\"></a>In Csharp</h3><pre><code>// Collection of String values.\nString[] arr = {&quot;ide&quot;, &quot;rc&quot;, &quot;grid&quot;};\n\n// Execute loop for each String in array &apos;arr&apos;.\nforeach (String s in arr) {\n    sel.open(&quot;/&quot;);\n    sel.type(&quot;q&quot;, &quot;selenium &quot; +s);\n    sel.click(&quot;btnG&quot;);\n    sel.waitForPageToLoad(&quot;30000&quot;);\n    assertTrue(&quot;Expected text: &quot; +s+ &quot; is missing on page.&quot;\n    , sel.isTextPresent(&quot;Results * for selenium &quot; + s));\n}\n</code></pre><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：</p>\n<pre><code>// Java\nselenium.type(&quot;q&quot;, &quot;selenium &quot; +s);\n</code></pre><p>如果元素“q”不在页面上将会抛出一个异常：</p>\n<pre><code>com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found\n</code></pre><p>这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。</p>\n<p>一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：</p>\n<pre><code>// 如果元素可用，则则行类型判定操作\nif(selenium.isElementPresent(&quot;q&quot;)) {\n    selenium.type(&quot;q&quot;, &quot;Selenium rc&quot;);\n} else {\n    System.out.printf(&quot;Element: &quot; +q+ &quot; is not available on page.&quot;)\n}\n</code></pre><p>这样做的好处是，即使页面上没有这个元素测试也能够继续执行。</p>\n<h3 id=\"在你的测试中执行-JavaScript\"><a href=\"#在你的测试中执行-JavaScript\" class=\"headerlink\" title=\"在你的测试中执行 JavaScript\"></a>在你的测试中执行 JavaScript</h3><p>在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。</p>\n<p>考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。</p>\n<pre><code>// Java\npublic static String[] getAllCheckboxIds () {\n     String script = &quot;var inputId  = new Array();&quot;;// Create array in java script.\n            script += &quot;var cnt = 0;&quot;; // Counter for check box ids.\n            script += &quot;var inputFields  = new Array();&quot;; // Create array in java script.\n            script += &quot;inputFields = window.document.getElementsByTagName(&apos;input&apos;);&quot;; // Collect input elements.\n            script += &quot;for(var i=0; i&lt;inputFields.length; i++) {&quot;; // Loop through the collected elements.\n            script += &quot;if(inputFields[i].id !=null &quot; +\n                      &quot;&amp;&amp; inputFields[i].id !=&apos;undefined&apos; &quot; +\n                      &quot;&amp;&amp; inputFields[i].getAttribute(&apos;type&apos;) == &apos;checkbox&apos;) {&quot;; // If input field is of type check box and input id is not null.\n            script += &quot;inputId[cnt]=inputFields[i].id ;&quot; + // Save check box id to inputId array.\n                      &quot;cnt++;&quot; + // increment the counter.\n                      &quot;}&quot; + // end of if.\n                      &quot;}&quot;; // end of for.\n            script += &quot;inputId.toString();&quot; ;// Convert array in to string.\n     String[] checkboxIds = selenium.getEval(script).split(&quot;,&quot;); // Split the string.\n     return checkboxIds;\n }\n</code></pre><p>如果要计算页面中的图片数，你可以：</p>\n<pre><code>// Java\nselenium.getEval(&quot;window.document.images.length;&quot;);\n</code></pre><p>记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。</p>\n<h2 id=\"服务端选项\"><a href=\"#服务端选项\" class=\"headerlink\" title=\"服务端选项\"></a>服务端选项</h2><p>当服务启动时，可以使用命令行配置项来改变其默认行为。</p>\n<p>回想一下，我们是这样启动服务的：</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar\n</code></pre><p>你可以使用 -h 来查看所有的配置项：</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -h\n</code></pre><p>你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。</p>\n<h3 id=\"代理配置\"><a href=\"#代理配置\" class=\"headerlink\" title=\"代理配置\"></a>代理配置</h3><p>如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password\n</code></pre><h3 id=\"多窗口模式\"><a href=\"#多窗口模式\" class=\"headerlink\" title=\"多窗口模式\"></a>多窗口模式</h3><p>如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png\" alt=\"multi-window\"></p>\n<p>有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png\" alt=\"multi-window2\"></p>\n<p>对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：</p>\n<pre><code>-multiwindow\n</code></pre><p>在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：</p>\n<pre><code>-singlewindow\n</code></pre><h3 id=\"指定-Firefox-配置\"><a href=\"#指定-Firefox-配置\" class=\"headerlink\" title=\"指定 Firefox 配置\"></a>指定 Firefox 配置</h3><p>Firefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。</p>\n<p>首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：</p>\n<pre><code>firefox.exe -profilemanager\n\nfirefox.exe -P\n</code></pre><p>使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。</p>\n<pre><code>-firefoxProfileTemplate &quot;path to the profile&quot;\n</code></pre><p><strong>警告</strong></p>\n<p>确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。</p>\n<p>更多请参考 <a href=\"http://support.mozilla.com/zh-CN/kb/Managing+profiles\" target=\"_blank\" rel=\"external\">Mozilla’s Knowledge Base</a></p>\n<h3 id=\"通过-htmlSuite-配置项在服务端直接运行-Selenese\"><a href=\"#通过-htmlSuite-配置项在服务端直接运行-Selenese\" class=\"headerlink\" title=\"通过 -htmlSuite 配置项在服务端直接运行 Selenese\"></a>通过 -htmlSuite 配置项在服务端直接运行 Selenese</h3><p>通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -htmlSuite &quot;*firefox&quot;\n&quot;http://www.google.com&quot; &quot;c:\\absolute\\path\\to\\my\\HTMLSuite.html&quot;\n&quot;c:\\absolute\\path\\to\\my\\results.html&quot;\n</code></pre><p>这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。</p>\n<p><strong>注意</strong></p>\n<p>在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。</p>\n<p>这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。</p>\n<h3 id=\"Selenium-服务日志\"><a href=\"#Selenium-服务日志\" class=\"headerlink\" title=\"Selenium 服务日志\"></a>Selenium 服务日志</h3><h4 id=\"服务端日志\"><a href=\"#服务端日志\" class=\"headerlink\" title=\"服务端日志\"></a>服务端日志</h4><p>当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -log selenium.log\n</code></pre><p>这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：</p>\n<pre><code>20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -\nBrowser 465828/:top frame1 posted START NEW\n</code></pre><p>该信息格式为：</p>\n<pre><code>TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE\n</code></pre><h4 id=\"浏览器端日志\"><a href=\"#浏览器端日志\" class=\"headerlink\" title=\"浏览器端日志\"></a>浏览器端日志</h4><p>在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -browserSideLog\n</code></pre><p>为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。</p>\n<h3 id=\"指定特定浏览器路径\"><a href=\"#指定特定浏览器路径\" class=\"headerlink\" title=\"指定特定浏览器路径\"></a>指定特定浏览器路径</h3><p>你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：</p>\n<pre><code>*custom &lt;path to browser&gt;\n</code></pre><h2 id=\"Selenium-RC-架构\"><a href=\"#Selenium-RC-架构\" class=\"headerlink\" title=\"Selenium RC 架构\"></a>Selenium RC 架构</h2><p><strong>注意</strong></p>\n<p>该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。</p>\n<p>为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 <a href=\"http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy\" target=\"_blank\" rel=\"external\">同源策略</a>。</p>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>Selenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。</p>\n<p>为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。</p>\n<p>之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。</p>\n<p><strong>注意</strong></p>\n<p>你可以在维基百科上找到更多关于 <a href=\"http://en.wikipedia.org/wiki/Same_origin_policy\" target=\"_blank\" rel=\"external\">同源策略</a> 和 <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"external\">XSS</a> 的内容</p>\n<h3 id=\"代理注入\"><a href=\"#代理注入\" class=\"headerlink\" title=\"代理注入\"></a>代理注入</h3><p>Selenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。</p>\n<ol>\n<li>代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。</li>\n<li>浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：</li>\n</ol>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png\" alt=\"proxy\"></p>\n<p>当测试开始时，将发生以下事情：</p>\n<ol>\n<li>客户端驱动将和 Selenium RC 服务端建立一个连接。</li>\n<li>Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。</li>\n<li>客户端驱动向服务端传递一个 Selenese 命令。</li>\n<li>服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。</li>\n<li>Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。</li>\n<li>浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）</li>\n<li>Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）</li>\n<li>浏览器接收到这个页面并且渲染到相应的帧或者窗口。</li>\n</ol>\n<h3 id=\"高特权浏览器（Heightened-Privileges-Browsers）\"><a href=\"#高特权浏览器（Heightened-Privileges-Browsers）\" class=\"headerlink\" title=\"高特权浏览器（Heightened Privileges Browsers）\"></a>高特权浏览器（Heightened Privileges Browsers）</h3><p>这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。</p>\n<p>结构图如下：</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png\" alt=\"Heightened Privileges Browsers\"></p>\n<p>此时，将发生以下事情：</p>\n<ol>\n<li>客户端驱动和 Selenium RC 服务端建立一个连接。</li>\n<li>Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。</li>\n<li>Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。</li>\n<li>Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。</li>\n<li>浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。</li>\n</ol>\n<h2 id=\"处理-HTTPS-和安全警告弹出框\"><a href=\"#处理-HTTPS-和安全警告弹出框\" class=\"headerlink\" title=\"处理 HTTPS 和安全警告弹出框\"></a>处理 HTTPS 和安全警告弹出框</h2><p>当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。</p>\n<p>为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。</p>\n<p>当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。</p>\n<p>在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 <em>firefox 和 </em>iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 <em>chrome 和 </em>iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。</p>\n<p>在版本1中，推荐运行 <em>firefox 和 </em>iexplore 运行模式。然而，我们还提供 <em>iexploreproxy 和 </em>firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。</p>\n<p>在 Selenium RC 的早期版本中，<em>chrome 或 </em>iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。</p>\n<h3 id=\"关于安全证书\"><a href=\"#关于安全证书\" class=\"headerlink\" title=\"关于安全证书\"></a>关于安全证书</h3><p>通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。</p>\n<p>为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。</p>\n<p>另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。</p>\n<h2 id=\"更多浏览器支持和相关配置\"><a href=\"#更多浏览器支持和相关配置\" class=\"headerlink\" title=\"更多浏览器支持和相关配置\"></a>更多浏览器支持和相关配置</h2><p>Selenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”<em>custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 </em>firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。</p>\n<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe&amp;2=http://www.google.com\n</code></pre><h3 id=\"使用不同的浏览器配置来运行测试\"><a href=\"#使用不同的浏览器配置来运行测试\" class=\"headerlink\" title=\"使用不同的浏览器配置来运行测试\"></a>使用不同的浏览器配置来运行测试</h3><p>通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。</p>\n<p>例如，你使用如下自定义配置启动 Firefox：</p>\n<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe&amp;2=http://www.google.com\n</code></pre><p>注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。</p>\n<p>注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p><strong>译者注：</strong>这部分内容不翻译了，请参考原英文文档。</p>\n<ul>\n<li>Unable to Connect to Server</li>\n<li>Unable to Load the Browser</li>\n<li>Selenium Cannot Find the AUT</li>\n<li>Firefox Refused Shutdown While Preparing a Profile</li>\n<li>Versioning Problems</li>\n<li>Error message: “(Unsupported major.minor version 49.0)” while starting server</li>\n<li>404 error when running the getNewBrowserSession command</li>\n<li>Permission Denied Error</li>\n<li>Handling Browser Popup Windows</li>\n<li>On Linux, why isn’t my Firefox browser session closing?</li>\n<li>Firefox *chrome doesn’t work with custom profile</li>\n<li>Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?</li>\n<li>Problems With Verify Commands</li>\n<li>Safari and MultiWindow Mode</li>\n<li>Firefox on Linux</li>\n<li>IE and Style Attributes</li>\n<li>Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser</li>\n<li>Where can I Ask Questions that Aren’t Answered Here?</li>\n</ul>\n","excerpt":"<h1 id=\"Selenium-1-Selenium-RC-¶\"><a href=\"#Selenium-1-Selenium-RC-¶\" class=\"headerlink\" title=\"Selenium 1 (Selenium RC)¶\"></a>Selenium 1 (Selenium RC)¶</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>正如你在 Selenium 项目简史里读到的，Selenium RC 在很长一段时间内都是 Selenium 的主要项目，直到 WebDriver/Selenium 合并而产生了最新和最强大的 Selenium 2。</p>\n<p>Selenium 仍然被活跃的支持（大部分是维护工作），并且提供了一些 Selenium 2 短期不会支持的特性，包括支持多语言 (Java, Javascript, Ruby, PHP, Python, Perl 和 C#) 和支持几乎所有的浏览器。 </p>\n<h2 id=\"Selenium-RC-如何工作\"><a href=\"#Selenium-RC-如何工作\" class=\"headerlink\" title=\"Selenium RC 如何工作\"></a>Selenium RC 如何工作</h2><p>首先，我们将讲述 Selenium RC 的组件如何操作，以及在测试脚本运行时各自扮演的角色。</p>\n<h3 id=\"RC-组件\"><a href=\"#RC-组件\" class=\"headerlink\" title=\"RC 组件\"></a>RC 组件</h3><p>Selenium RC 组件是：</p>\n<p>Selenium Server 能启动和杀死浏览器进程，解析并运行由测试程序传递过来的 Selenese 命令，并且可以是一个 HTTP 代理，拦截和验证浏览器和 AUT(测试中的应用)之间的 HTTP 通信。<br>","more":"<br>客户端库提供了各种编程语言和 Selenium RC Server 之间的接口。   </p>\n<p>以下是一个简单的架构图：</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img01_Architecture_Diagram_Simple.png\" alt=\"架构图\"></p>\n<p>上图演示了客户端和服务端进行通信以传递要执行的 Selenium 命令。然后服务端使用 Selenium-Core JavaScript 命令将 Selenium 命令传递给浏览器。浏览器则使用其内置的 JavaScript 解析器来执行 Selenium 命令。这样运行 Seleniun 动作或者验证你指定的测试脚本。</p>\n<h3 id=\"Selenium-服务端\"><a href=\"#Selenium-服务端\" class=\"headerlink\" title=\"Selenium 服务端\"></a>Selenium 服务端</h3><p>Selenium 服务端从你的测试程序接收 Selenium 命令，解析它们，并且反馈给你程序的测试执行结果。</p>\n<p>RC 服务端绑定了 Selenium Core 并且自动将其注入浏览器。这在你的测试程序打开浏览器时发生（使用客户端库的方法）。Selenium-Core 是一个 JavaScript 程序，实际上是一些利用浏览器的内置 JavaScript 解析器解析和实行 Selenese 命令 的 JavaScript 函数。</p>\n<p>Server 使用简单的 HTTP GET/POST 请求来接收你的测试程序中的 Selenese 命令。这意味这你可以使用任何可以发送 HTTP 请求的编程语言来实现 Selenium 测试在浏览器中的自动运行。</p>\n<h3 id=\"客户端库\"><a href=\"#客户端库\" class=\"headerlink\" title=\"客户端库\"></a>客户端库</h3><p>客户端库提供了能让你从自定义的程序中运行 Selenium 命令的编程支持。每种支持的语言都有一个不同的客户端库。Selenium 客户端库提供了一组接口，例如一些从你的程序中运行 Selenium 命令的方法。通过实现这些接口，我们就能得到一个支持所有 Selenese 命令的编程方法。</p>\n<p>客户端库将 Selenese 命令传递给 Selenium 服务端来处理一个特定的动作或者执行 AUT 的测试。客户端库同时接收所传递命令的执行结果，并将其返回给你的程序。你的程序可以接收这个结果并且将其存储到一个变量中，然后报告其运行结果是成功还是失败，或者当其发生错误是进行适当的处理。</p>\n<p>因此要创建一个测试程序，你仅仅需要使用客户端库的 API 来编写一个可以运行 Selenium 命令的程序。或者，如果你已经有了使用 Selenium-IDE 创建的 Selenium 测试脚本，你可以使用它来生成 Selenium RC 代码。Selenium-IDE 可以将 Selenium 命令转换（使用导出菜单）成客户端 API 的方法调用。查看 Selenium-IDE 章节中关于从 Selenium-IDE 中导出 RC 代码的细节。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>用安装这个词不是很恰当。Selenium 在你选择的编程语言中有一组组件可用。你可以从下载页面下载它们。</p>\n<p>一旦你选定了一种编程语言，你仅需要：</p>\n<ul>\n<li>安装 Selenium RC 服务端。</li>\n<li>使用特定于该语言的客户端驱动创建你的项目</li>\n</ul>\n<h3 id=\"安装-Selenium-服务端\"><a href=\"#安装-Selenium-服务端\" class=\"headerlink\" title=\"安装 Selenium 服务端\"></a>安装 Selenium 服务端</h3><p>Selenium RC 服务端是一个简单的 jar 包 (selenium-server-standalone-<version-number>.jar)，它不需要安装。只需要下载这个zip文件，并提取服务所需的目录即可。</p>\n<h3 id=\"运行-Selenium-服务\"><a href=\"#运行-Selenium-服务\" class=\"headerlink\" title=\"运行 Selenium 服务\"></a>运行 Selenium 服务</h3><p>在开始任何测试之前，你必须先启动服务。进到 Selenium RC 服务端所在的目录，并在命令行中运行以下命令：</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar\n</code></pre><p>你也可以简单的创建一个包含上述命令的批处理或shell文件（Windows 中扩展名为 .bat，Linux 中扩展名为 .sh）。然后在你的桌面上创建一个该可执行文件的快捷方式，通过双击图标来启动服务。</p>\n<p>要成功启动服务必须确保 Java 已安装，并且设置了正确的 PATH 环境变量。你可以通过下面的命令检查你的 Java 是否安装正确：</p>\n<pre><code>java -version\n</code></pre><p>如果你得到一个版本号（必须&gt;=1.5），那么你已经成功启动 Selenium RC。</p>\n<h3 id=\"使用-Java-客户端驱动\"><a href=\"#使用-Java-客户端驱动\" class=\"headerlink\" title=\"使用 Java 客户端驱动\"></a>使用 Java 客户端驱动</h3><ul>\n<li>从 SeleniumHQ 下载页面下载 Selenium java 客户端驱动 zip 包。</li>\n<li>提取 selenium-java-<version-number>.jar</li>\n<li>打开你喜欢的 Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.)</li>\n<li>创建一个 java 项目。</li>\n<li>将 selenium-java-<version-number>.jar 文件作为引用添加到你的项目中。</li>\n<li>将 selenium-java-<version-number>.jar 文件添加到你项目的 classpath 中。</li>\n<li>从 Selenium-IDE 到处一个 Java 文件，并放入你的项目，或者使用 Selenium 的 Java 客户端 API 编写一个 Selenium 测试文件。这些 API 将在本章的后面部分进行讲解。你可以使用 JUnit，或者 TestNg 来运行你的测试，或者你可以简单的写一个 main() 方法。这些概念也将在本文后面进行说明。</li>\n<li>从命令行运行 Selenium 服务。</li>\n<li>从 Java IDE 或者命令行中执行你的测试。</li>\n</ul>\n<p>关于更多 Java 测试项目的配置细节，可查看本章附件：<strong>在 Eclipse 中配置 Selenium RC</strong> 和 <strong>在 Intellij 中配置 Selenium RC</strong>。</p>\n<h2 id=\"将-Selenese-转换成程序\"><a href=\"#将-Selenese-转换成程序\" class=\"headerlink\" title=\"将 Selenese 转换成程序\"></a>将 Selenese 转换成程序</h2><p>使用 Selenium RC 的主要任务就是将你的 Selenese 转换成一个编程语言。在本小结中，我们提供几种不同的语言演示。</p>\n<h3 id=\"测试脚本范例\"><a href=\"#测试脚本范例\" class=\"headerlink\" title=\"测试脚本范例\"></a>测试脚本范例</h3><p>让我们从一个 Selenese 测试脚本的例子开始. 假定我们使用 Selenium-IDE 记录了如下测试：</p>\n<table><br>    <tbody><br>        <tr><br>            <td>open</td><br>            <td>/</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium rc</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results * for selenium rc</td><br>            <td>&nbsp;</td><br>        </tr><br>    </tbody><br></table>\n\n<p>注意: 这个例子仅仅在 Google 搜索页面 <a href=\"http://www.google.com\">http://www.google.com</a> 工作。</p>\n<h2 id=\"Selenese-作为编程代码\"><a href=\"#Selenese-作为编程代码\" class=\"headerlink\" title=\"Selenese 作为编程代码\"></a>Selenese 作为编程代码</h2><p>以下为使用支持的多种编程序言从 Selenium-IDE 中导出的测试脚本。如果你有一些面向对象编程的基础知识，你就可以通过阅读以下代码理解 Selenium 如何运行 Selenese 命令。</p>\n<pre><code>/** Add JUnit framework to your classpath if not already there\n *  for this example to work\n */\npackage com.example.tests;\n\nimport com.thoughtworks.selenium.*;\nimport java.util.regex.Pattern;\n\npublic class NewTest extends SeleneseTestCase {\n    public void setUp() throws Exception {\n        setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n    }\n      public void testNew() throws Exception {\n          selenium.open(&quot;/&quot;);\n          selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n          selenium.click(&quot;btnG&quot;);\n          selenium.waitForPageToLoad(&quot;30000&quot;);\n          assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n    }\n}\n</code></pre><p>在接下来的章节中，我们将介绍如何通过生成的代码创建你的测试程序。</p>\n<h2 id=\"编写你的测试代码\"><a href=\"#编写你的测试代码\" class=\"headerlink\" title=\"编写你的测试代码\"></a>编写你的测试代码</h2><p>现在我们将为每种支持的语言演示如何通过上述例子编写你自己的测试代码。我们主要需要做2件事情：</p>\n<ul>\n<li>从 Selenium-IDE 导出指定语言的脚本，有选择性的修改它。</li>\n<li>编写一个 main() 方法来执行创建的代码。</li>\n</ul>\n<p>你可以选择平台支持的任意测试引擎，如 Java 的 JUnit 或 TestNG。</p>\n<p>这里我们将演示指定语言的例子。每种语言的 API 都有所不同，所以我们将单独解释每一个。</p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p>在 Java 中，大家通常选择 JUnit 或 TestNG 作为测试引擎。一些像 Eclipse 这样的 IDE 能通过插件直接支持它们，使得事情更简单。JUnit 和 TestNG 教学不在本文档的范围内，但是你可以通过网络找到相关资料。如果你是一个 Java 程序员，你可能已经有使用这些框架的经验了。</p>\n<p>你可能希望为 “NewTest” 测试类重命名。同时，你可能也需要修改以下语句中的浏览器打开参数。</p>\n<pre><code>selenium = new DefaultSelenium(&quot;localhost&quot;, 4444, &quot;*iehta&quot;, &quot;http://www.google.com/&quot;);\n</code></pre><p>使用 Selenium-IDE 创建的代码看起来大致如下。为了使代码更清晰易读，我们手工加入了注释。</p>\n<pre><code>package com.example.tests;\n// 我们指定了这个文件的包\n\nimport com.thoughtworks.selenium.*;\n// 导入驱动。\n// 你将使用它来初始化浏览器并执行一些任务。\n\nimport java.util.regex.Pattern;\n// 加入正则表达式模块，因为有些我们需要使用它进行校验。\n// 如果你的代码不需要它，完全可以移除掉。 \n\npublic class NewTest extends SeleneseTestCase {\n// 创建 Selenium 测试用例\n\n      public void setUp() throws Exception {\n        setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n             // 初始化并启动浏览器\n      }\n\n      public void testNew() throws Exception {\n           selenium.open(&quot;/&quot;);\n           selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n           selenium.click(&quot;btnG&quot;);\n           selenium.waitForPageToLoad(&quot;30000&quot;);\n           assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n           // 以上为真实的测试步骤\n     }\n}\n</code></pre><h2 id=\"学习使用-API\"><a href=\"#学习使用-API\" class=\"headerlink\" title=\"学习使用 API\"></a>学习使用 API</h2><p>Selenium RC API 使用以下约定：假设你了解 Selenese，并且大部分接口是自解释的。在此，我们仅解释最具争议或者看起来不那么直接明了的部分。</p>\n<h3 id=\"启动浏览器\"><a href=\"#启动浏览器\" class=\"headerlink\" title=\"启动浏览器\"></a>启动浏览器</h3><pre><code>setUp(&quot;http://www.google.com/&quot;, &quot;*firefox&quot;);\n</code></pre><p>每个例子都打开了一个浏览器，并且将浏览器作为一个浏览器对象返回，赋值给一个变量。这个变量将用于调用浏览器方法。这些方法可以执行 Selenium 命令，例如打开、键入或者校验。</p>\n<p>创建浏览器对象所需要的参数如下：</p>\n<h4 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h4><p>指定服务所在的机器的 IP 地址。通常它和运行客户端的机器是同一台。所以在这个例子中我们传入 localhost。在某些客户端中，这是一个可选参数。</p>\n<h4 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h4><p>指定服务监听的客户端用于创建连接的 TCP/IP socket。这在某些客户端中也是可选的。</p>\n<h4 id=\"browser\"><a href=\"#browser\" class=\"headerlink\" title=\"browser\"></a>browser</h4><p>指定你希望运行测试的浏览器。该参数必选。</p>\n<h4 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h4><p>AUT 的基准 url。在所有的客户端中必选，并且是启动浏览器代理的 AUT 通讯的必须信息。</p>\n<p>注意，有些客户端要求调用 start() 方法来启动浏览器。</p>\n<h3 id=\"运行-命令\"><a href=\"#运行-命令\" class=\"headerlink\" title=\"运行 命令\"></a>运行 命令</h3><p>一旦你初始化了一个浏览器并且将其赋值给一个变量（通常命名为 “Selenium”），你可以使用这个变量调用各种方法来运行 Selenese 命令。例如，调用 selenium 对象的键入方法：</p>\n<pre><code>selenium.type(“field-id”,”string to type”)\n</code></pre><p>此时浏览器将真正执行指定的操作，在这个方法调用时指定了定位符和要键入的字符串，本质上就像是一个用户在浏览器中输入了这些内容。</p>\n<h2 id=\"报告结果\"><a href=\"#报告结果\" class=\"headerlink\" title=\"报告结果\"></a>报告结果</h2><p>Selenium RC 没有内置的结果报告机制。而是让你根据所选语言的特性创建符合你需求的自定义报告。这非常棒！但是你是不是希望这些事情都已经就绪，而你可以快速使用它们？其实市面上不难找到符合你需求的库或框架，这比编写你自己的测试报告代码快多了。</p>\n<h3 id=\"测试框架报告工具\"><a href=\"#测试框架报告工具\" class=\"headerlink\" title=\"测试框架报告工具\"></a>测试框架报告工具</h3><p>很多语言都有对应的测试框架。它们除了提供灵活的测试引擎执行你的测试之外，通常还包括结果报告的库。例如，Java有两个常用的测试框架，JUnit 和 TestNG. .NET 也有适合它的, NUnit。</p>\n<p>我们不会教你如何使用这些框架，那超出了本指南的范围。但我们将简单介绍一下这些框架中你可以使用的跟 Selenium 相关的特性。有很多关于学习这些测试框架的书，互联网上页有丰富的资料。</p>\n<h3 id=\"测试报告库\"><a href=\"#测试报告库\" class=\"headerlink\" title=\"测试报告库\"></a>测试报告库</h3><p>同样可以利用的是使用你所选语言编写的专门用于报告测试结果的三方库。它们通常支持多种格式，如 HTML 或 PDF。</p>\n<h3 id=\"最佳实践是？\"><a href=\"#最佳实践是？\" class=\"headerlink\" title=\"最佳实践是？\"></a>最佳实践是？</h3><p>大多数新接触测试框架的人将会从框架内置的报告功能开始。他们会检查任何可用库，这可比你自己开发的开销要小。当你开始使用 Selenium，毫无疑问你将开始在报告处理中使用你自己的 “print 语句”。这将可能导致你在使用一个库或框架的同时，逐渐开发开发你自己的报告功能。无论如何，在最初短暂的学习曲线之后，你将自然而然的开发出最适合你的报告功能。</p>\n<h3 id=\"测试报告范例\"><a href=\"#测试报告范例\" class=\"headerlink\" title=\"测试报告范例\"></a>测试报告范例</h3><p>为了进行演示，我们将直接使用 Selenium 支持的语言的特定工具。以下列出的是最常用的，而且也是最为推荐的。</p>\n<h4 id=\"Java-中的测试报告\"><a href=\"#Java-中的测试报告\" class=\"headerlink\" title=\"Java 中的测试报告\"></a>Java 中的测试报告</h4><ul>\n<li>如果 Selenium 测试用例是使用 JUnit 开发的，那么 JUnit 报告就能用于创建测试报告。了解更多 <a href=\"http://ant.apache.org/manual/Tasks/junitreport.html\">JUnit 报告</a> 。</li>\n<li>如果 Selenium 测试用例是使用 TestNG 开发的，那也不需要依赖外部任务来创建测试报告。TestNG 框架创建包含测试详情列表的 HTML 报告。了解更多 <a href=\"http://testng.org/doc/documentation-main.html#test-results\">TestNG 报告</a> 。</li>\n<li>ReportNG 是一个用于TestNG 框架的 HTML 报告插件。它的初衷是用于取代默认的 HTML 报告。ReportNG 提供了简单、彩色的测试结果显示。了解更多 <a href=\"http://reportng.uncommons.org/\">TestNG</a></li>\n<li><p>同时，TestNG-xslt 是一个很好的摘要报告工具。TestNG-xslt 报告看起来如下图：</p>\n<p>  <img src=\"http://seleniumhq.org/docs/_images/chapt5_TestNGxsltReport.png\" alt=\"TestNG-xslt\"></p>\n<p>  了解更多 <a href=\"\">TestNG-xslt</a></p>\n</li>\n</ul>\n<h5 id=\"记录-Selenese-命令\"><a href=\"#记录-Selenese-命令\" class=\"headerlink\" title=\"记录 Selenese 命令\"></a>记录 Selenese 命令</h5><p>Logging Selenium 可以用于为你的测试创建一个含有所有 Selenium 命令及其运行结果（成功或失败）的报告。为了获得这项功能，使用 Logging Selenium 扩展你的 Java 客户端。了解更多 <a href=\"http://loggingselenium.sourceforge.net/index.html\">Logging Selenium</a></p>\n<h2 id=\"为你的测试加点料\"><a href=\"#为你的测试加点料\" class=\"headerlink\" title=\"为你的测试加点料\"></a>为你的测试加点料</h2><p>现在我们将获得所有使用 Selenium 的理由，它能为你的测试添加逻辑。就像任何程序一样。程序流通过条件语句和迭代控制。另外，你能使用 IO 来报告处理信息。在这一小结中，我们将演示一些可联合 Selenium 使用的编程语言构建例子，用以解决常见的测试问题。</p>\n<p>当你将页面元素是否存在的简单测试转换成涉及多个网页和数据的动态功能时，你将发现你需要编程逻辑来校验期待的结果。一般的， Selenium-IDE 不支持迭代和标准的条件语句。你可以通过将 javascript 嵌入 Selenese 参数来实现条件控制和迭代，并且大部分的条件都比真正的编程语言要简单。此外，你可能需要使用异常处理来进行错误回复。基于这些原因，我们编写了这一小结内容来演示普通编程技巧的使用，以使你在自动化测试中获得更大的校验能力。</p>\n<p>本小结例子使用 C# 和 Java 编写而成，它们非常简单，也很容易转换成其他语言。如果你有一些面向对象编程的基础知识，你将很容易掌握这个章节。</p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>迭代是测试中最常用的功能了。例如你可能希望执行一个查询多次。或者你需要处理那些从数据库中返回的结果集以校验你的测试结果。</p>\n<p>使用同之前一样的 <a href=\"http://seleniumhq.org/docs/05_selenium_rc.jsp#google-search-example\">Google 搜索例子</a>，让我们来检查搜索结果。这个测试将使用 Selenese：</p>\n<table><br>    <tbody><br>        <tr><br>            <td>open</td><br>            <td>/</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium rc</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results <em> for selenium rc</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium ide</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results </em> for selenium ide</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>type</td><br>            <td>q</td><br>            <td>selenium grid</td><br>        </tr><br>        <tr><br>            <td>clickAndWait</td><br>            <td>btnG</td><br>            <td>&nbsp;</td><br>        </tr><br>        <tr><br>            <td>assertTextPresent</td><br>            <td>Results * for selenium grid</td><br>            <td>&nbsp;</td><br>        </tr><br>    </tbody><br></table>\n\n<p>同样的代码重复跑了3次。将同样的代码拷贝多次运行可不是一个好的编程实践，因为维护的时候成本会很高。使用编程语言，我们可以通过迭代这一更灵活更易于维护的方式来处理搜索结果。</p>\n<h3 id=\"In-Csharp\"><a href=\"#In-Csharp\" class=\"headerlink\" title=\"In Csharp\"></a>In Csharp</h3><pre><code>// Collection of String values.\nString[] arr = {&quot;ide&quot;, &quot;rc&quot;, &quot;grid&quot;};\n\n// Execute loop for each String in array &apos;arr&apos;.\nforeach (String s in arr) {\n    sel.open(&quot;/&quot;);\n    sel.type(&quot;q&quot;, &quot;selenium &quot; +s);\n    sel.click(&quot;btnG&quot;);\n    sel.waitForPageToLoad(&quot;30000&quot;);\n    assertTrue(&quot;Expected text: &quot; +s+ &quot; is missing on page.&quot;\n    , sel.isTextPresent(&quot;Results * for selenium &quot; + s));\n}\n</code></pre><h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>我们使用一个例子来演示条件语句的使用。让运行 Selenium 测试时，如果一个原本应该存在的元素没有出现在页面上时，将会触发一个普通的错误。例如，我们运行如下 代码：</p>\n<pre><code>// Java\nselenium.type(&quot;q&quot;, &quot;selenium &quot; +s);\n</code></pre><p>如果元素“q”不在页面上将会抛出一个异常：</p>\n<pre><code>com.thoughtworks.selenium.SeleniumException: ERROR: Element q not found\n</code></pre><p>这个异常将会终止你的测试。对于某些测试来说这正是你想要的。但是更多的时候，你并不希望这样，因为还有很多后续的测试要执行。</p>\n<p>一个更好的解决办法是我们首先判定元素是否存在，然后再进行相应的处理。我们来看看 Java 的写法：</p>\n<pre><code>// 如果元素可用，则则行类型判定操作\nif(selenium.isElementPresent(&quot;q&quot;)) {\n    selenium.type(&quot;q&quot;, &quot;Selenium rc&quot;);\n} else {\n    System.out.printf(&quot;Element: &quot; +q+ &quot; is not available on page.&quot;)\n}\n</code></pre><p>这样做的好处是，即使页面上没有这个元素测试也能够继续执行。</p>\n<h3 id=\"在你的测试中执行-JavaScript\"><a href=\"#在你的测试中执行-JavaScript\" class=\"headerlink\" title=\"在你的测试中执行 JavaScript\"></a>在你的测试中执行 JavaScript</h3><p>在一个应用程序中使用 JavaScript 是非常方便的，但是 Selenium 不直接支持它。你可以在 Selenium RC 中使用 getEval 接口的方法来执行它。</p>\n<p>考虑一个应用中的没有静态 id 的多选框。在这种情况下，你可以通过使用 Selenium RC 对 JavaScript 语句进行求值（evaluate）来找到所有的多选框并处理它们。</p>\n<pre><code>// Java\npublic static String[] getAllCheckboxIds () {\n     String script = &quot;var inputId  = new Array();&quot;;// Create array in java script.\n            script += &quot;var cnt = 0;&quot;; // Counter for check box ids.\n            script += &quot;var inputFields  = new Array();&quot;; // Create array in java script.\n            script += &quot;inputFields = window.document.getElementsByTagName(&apos;input&apos;);&quot;; // Collect input elements.\n            script += &quot;for(var i=0; i&lt;inputFields.length; i++) {&quot;; // Loop through the collected elements.\n            script += &quot;if(inputFields[i].id !=null &quot; +\n                      &quot;&amp;&amp; inputFields[i].id !=&apos;undefined&apos; &quot; +\n                      &quot;&amp;&amp; inputFields[i].getAttribute(&apos;type&apos;) == &apos;checkbox&apos;) {&quot;; // If input field is of type check box and input id is not null.\n            script += &quot;inputId[cnt]=inputFields[i].id ;&quot; + // Save check box id to inputId array.\n                      &quot;cnt++;&quot; + // increment the counter.\n                      &quot;}&quot; + // end of if.\n                      &quot;}&quot;; // end of for.\n            script += &quot;inputId.toString();&quot; ;// Convert array in to string.\n     String[] checkboxIds = selenium.getEval(script).split(&quot;,&quot;); // Split the string.\n     return checkboxIds;\n }\n</code></pre><p>如果要计算页面中的图片数，你可以：</p>\n<pre><code>// Java\nselenium.getEval(&quot;window.document.images.length;&quot;);\n</code></pre><p>记住要调用 window 对象，以防在 DOM 表达式中其默认指向 Selenium 窗口而不是测试窗口。</p>\n<h2 id=\"服务端选项\"><a href=\"#服务端选项\" class=\"headerlink\" title=\"服务端选项\"></a>服务端选项</h2><p>当服务启动时，可以使用命令行配置项来改变其默认行为。</p>\n<p>回想一下，我们是这样启动服务的：</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar\n</code></pre><p>你可以使用 -h 来查看所有的配置项：</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -h\n</code></pre><p>你将看到所有配置项列表，每个配置项附带间断描述。这里提供的描述并不总是足够禽畜，所以接下来我们将对一些重要的配置项进行补充描述。</p>\n<h3 id=\"代理配置\"><a href=\"#代理配置\" class=\"headerlink\" title=\"代理配置\"></a>代理配置</h3><p>如果你的 AUAT 使用了一个需要授权的 HTTP 代理，你需要使用以下命令来配置 http.proxyHost, http.proxyPort, http.proxyUser 和 http.proxyPassword。</p>\n<pre><code>$ java -jar selenium-server-standalone-&lt;version-number&gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password\n</code></pre><h3 id=\"多窗口模式\"><a href=\"#多窗口模式\" class=\"headerlink\" title=\"多窗口模式\"></a>多窗口模式</h3><p>如果你正在使用 Selenium 1，你可以跳过这部分内容，因为多窗口模式已经是默认配置。但是在更早的版本中，AUT 默认是在子帧(sub frame)中运行的。</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img26_single_window_mode.png\" alt=\"multi-window\"></p>\n<p>有些应用在子帧中不能正常运行，必须要加载到顶级帧中运行。多窗口模式允许 AUT 在两个独立的窗口中运行，而不是在默认的帧中运行，这样它就能在顶级帧中运行了。</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img27_multi_window_mode.png\" alt=\"multi-window2\"></p>\n<p>对于老版本的 Selenium 来说，你必须通过下面的配置项明确指定多窗口模式：</p>\n<pre><code>-multiwindow\n</code></pre><p>在 Selenium 1 以及更新的版本中，如果你希望在单窗口中运行你的测试，你可以使用以下配置项：</p>\n<pre><code>-singlewindow\n</code></pre><h3 id=\"指定-Firefox-配置\"><a href=\"#指定-Firefox-配置\" class=\"headerlink\" title=\"指定 Firefox 配置\"></a>指定 Firefox 配置</h3><p>Firefox 不会同时运行两个实例，除非你为每一个指定单独的配置。Selenium RC 1 及其后续版本会自动运行两个单独的配置，所以如果你正在使用 Selenium 1，你可以跳过这个章节。如果你在使用更老的版本而你有需要指定单独的配置，你需要明确的指定它。</p>\n<p>首先，穿加你一个单独的 Firefox 配置，根据以下步骤。打开 Windows 的开始菜单，选择 “run”，然后键入以下内容：</p>\n<pre><code>firefox.exe -profilemanager\n\nfirefox.exe -P\n</code></pre><p>使用对话框来创建新配置。当你运行 Selenium 服务时，你需要使用命令行选项 -firefoxProfileTemplate 告诉它使用新的 Firefox 配置，并且指定要使用的配置的路径。</p>\n<pre><code>-firefoxProfileTemplate &quot;path to the profile&quot;\n</code></pre><p><strong>警告</strong></p>\n<p>确保你的配置文件被存放在一个不同于默认路径的文件夹中！！！Firefox 配置管理会在你删除一个配置的时候删除该配置所在文件夹的所有内容，而不管它是不是配置文件。</p>\n<p>更多请参考 <a href=\"http://support.mozilla.com/zh-CN/kb/Managing+profiles\">Mozilla’s Knowledge Base</a></p>\n<h3 id=\"通过-htmlSuite-配置项在服务端直接运行-Selenese\"><a href=\"#通过-htmlSuite-配置项在服务端直接运行-Selenese\" class=\"headerlink\" title=\"通过 -htmlSuite 配置项在服务端直接运行 Selenese\"></a>通过 -htmlSuite 配置项在服务端直接运行 Selenese</h3><p>通过将 html 文件传递给服务端的命令行，你可以直接在 Selenium 服务端运行 Selenese html 文件。例如：</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -htmlSuite &quot;*firefox&quot;\n&quot;http://www.google.com&quot; &quot;c:\\absolute\\path\\to\\my\\HTMLSuite.html&quot;\n&quot;c:\\absolute\\path\\to\\my\\results.html&quot;\n</code></pre><p>这个例子将自动加载你的 html 测试套件，运行所有的测试并生成一份 html 格式的测试报告。</p>\n<p><strong>注意</strong></p>\n<p>在使用这个配置项时，服务端将开始运行测试，并为测试结束等待指定的秒数，如果测试没有在指定时间内结束，命令行将以一个非0的退出码退出，并且没有报告文件生成。</p>\n<p>这个命令行非常长，所以键入它的时候需要非常小心。注意这要求你传入一个 html 测试套件，而非单个的测试。并且配置项和 -interactive 不兼容，你不能同时使用他们。</p>\n<h3 id=\"Selenium-服务日志\"><a href=\"#Selenium-服务日志\" class=\"headerlink\" title=\"Selenium 服务日志\"></a>Selenium 服务日志</h3><h4 id=\"服务端日志\"><a href=\"#服务端日志\" class=\"headerlink\" title=\"服务端日志\"></a>服务端日志</h4><p>当启动 Selenium 服务，可以使用 -log 配置项来将 Selenium 服务报告的有价值的 debug 信息记录到一个文本文件。</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -log selenium.log\n</code></pre><p>这个日志文件相比标准的 console 日志而言要冗余的多（它包括了 debug 级别的日志信息）。它页包含了 logger name，打印日志信息的线程 id。例如：</p>\n<pre><code>20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler -\nBrowser 465828/:top frame1 posted START NEW\n</code></pre><p>该信息格式为：</p>\n<pre><code>TIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE\n</code></pre><h4 id=\"浏览器端日志\"><a href=\"#浏览器端日志\" class=\"headerlink\" title=\"浏览器端日志\"></a>浏览器端日志</h4><p>在浏览器端的 javascript （Selenium Core）也将记录重要的日志信息。在很多时候，对最终用户而言，这比常规的 Selenium 服务端日志有用的多。为了访问浏览器端日志，将 -browserSideLog 参数传递给 Selenium 服务。</p>\n<pre><code>java -jar selenium-server-standalone-&lt;version-number&gt;.jar -browserSideLog\n</code></pre><p>为了将所有浏览器端的日志保存到一个文件中，-browserSideLog 必须和 -log 配置项联合使用。</p>\n<h3 id=\"指定特定浏览器路径\"><a href=\"#指定特定浏览器路径\" class=\"headerlink\" title=\"指定特定浏览器路径\"></a>指定特定浏览器路径</h3><p>你可以为 Selenium RC 指定一个特定浏览器的路径。如果你需要测试同一个浏览器的不同版本时，这一功能将非常有效。同时这也允许你在一个 Selenium RC 不直接支持的浏览器中运行你的测试。当指定这个运行模式，使用 *cunstom 来指定可执行的浏览器的全路径：</p>\n<pre><code>*custom &lt;path to browser&gt;\n</code></pre><h2 id=\"Selenium-RC-架构\"><a href=\"#Selenium-RC-架构\" class=\"headerlink\" title=\"Selenium RC 架构\"></a>Selenium RC 架构</h2><p><strong>注意</strong></p>\n<p>该主题尝试解释 Selenium RC 背后的运行原理。这并不是 Selnium 用户需要了解的基础知识，但是你会发现它对于了解一些问题非常有用。</p>\n<p>为了理解 Selenium RC 服务端工作的细节，以及为什么它使用代理注入和高特权模式你必须先了解 <a href=\"http://seleniumhq.org/docs/05_selenium_rc.jsp#the-same-origin-policy\">同源策略</a>。</p>\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>Selenium 面临的主要约束即同源策略。市面上所有的浏览器都有这个安全约束，它的目的是确保一个网站的内容永远不会被另外一个站点的脚本访问到。同源策略规定浏览器加载的任何脚本仅能操作引入它的页面所在的域的内容。它也不能执行另一个网站中的方法。例如，如果浏览器在载入 www.mysite.com 时加载了一个脚本，这脚本就不能操作 www.mysite2.com 的内容，即使那是另一个你自己的网站。如果这被允许，脚本将可以操作你打开的任何网站的内容，于是当你在 tab 页中打开一个银行站点时它就能读取你的银行账号信息。。我们把这叫 XSS(Cross-site Scripting) 攻击。</p>\n<p>为了在这个约束下工作，Selenium Core（包括它的 javascript 脚本）必须和 AUT 放置在同一个域下。</p>\n<p>之前，因为 Selenium core 使用 JavaScript 实现的，所以一直被这个问题困扰。但现在，这个问题已经得到解决。它使用 Selenium 服务端作为一个代理来避免这个问题。本质上来讲，Selenium RC 告诉浏览器它是运行在服务端提供的一个“被欺骗的”站点上。</p>\n<p><strong>注意</strong></p>\n<p>你可以在维基百科上找到更多关于 <a href=\"http://en.wikipedia.org/wiki/Same_origin_policy\">同源策略</a> 和 <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">XSS</a> 的内容</p>\n<h3 id=\"代理注入\"><a href=\"#代理注入\" class=\"headerlink\" title=\"代理注入\"></a>代理注入</h3><p>Selenium 避免同源策略约束的首选方法是代理注入。在代理注入模式，Seleniium 服务端扮演一个客户端配置[1] 的 HTTP 代理[2] 的角色，它位于浏览器和 AUT 之间。它为 AUT 伪装了一个虚假的 url（将Selenium Core 和测试注入到 AUT，就好像他们来自同一个域）。</p>\n<ol>\n<li>代理扮演一个第三方角色，在双方传递内容的过程中。它好像一个 web 服务器将 AUT 传送给浏览器。作为一个代理，使得 Selenium 服务端有能力伪装 AUT 的真实 url。</li>\n<li>浏览器加载的时候，配置文件将指定 localhost:4444 作为 http 代理，这就是为什么浏览器发起一个 http 请求将通过 Selenium 服务端并且响应页将通过它而不是来自真实的服务器。以下是结构图：</li>\n</ol>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_1.png\" alt=\"proxy\"></p>\n<p>当测试开始时，将发生以下事情：</p>\n<ol>\n<li>客户端驱动将和 Selenium RC 服务端建立一个连接。</li>\n<li>Selenium RC 服务端启动一个打开指定 url 的浏览器（或复用一个已打开的），将 Selenium Core 的 JavaScript 代码注入的这个页面中。</li>\n<li>客户端驱动向服务端传递一个 Selenese 命令。</li>\n<li>服务端解析这个命令，然后触发 JavaScript 脚本执行浏览器中相应的命令。</li>\n<li>Selenium Core 指示浏览器在第一个指令后开始执行，典型的是打开一个 AUT 页面。</li>\n<li>浏览器收到打开页面的请求，并且从 Selenium RC 服务端询问获取页面内容（作为浏览器的 http 代理）</li>\n<li>Selenium RC 服务端和网站服务器通讯，一旦获取到页面，它就对页面的源进行伪装然后发送到浏览器，使这个页面看起来像是和 Selenium Core 来自于同一个源（这使得我们可以绕开同源策略的限制）</li>\n<li>浏览器接收到这个页面并且渲染到相应的帧或者窗口。</li>\n</ol>\n<h3 id=\"高特权浏览器（Heightened-Privileges-Browsers）\"><a href=\"#高特权浏览器（Heightened-Privileges-Browsers）\" class=\"headerlink\" title=\"高特权浏览器（Heightened Privileges Browsers）\"></a>高特权浏览器（Heightened Privileges Browsers）</h3><p>这种方法的工作流程和代理注入非常像，主要的区别是浏览器在一个叫高特权的模式下启动，这将允许网站做一些平时不被允许做的事情（例如 XSS，或者填充文件上传输入框，或者其他一些对 Selenium 非常有用的操作）。使用这种浏览器模式， Selenium Core 就可以直接打开 AUT 并且读取或操作其内容，而不需要将整个 AUT 通过 Selenium RC 服务端中转。</p>\n<p>结构图如下：</p>\n<p><img src=\"http://seleniumhq.org/docs/_images/chapt5_img02_Architecture_Diagram_2.png\" alt=\"Heightened Privileges Browsers\"></p>\n<p>此时，将发生以下事情：</p>\n<ol>\n<li>客户端驱动和 Selenium RC 服务端建立一个连接。</li>\n<li>Selenium RC 服务端启动一个开打指定 url 的浏览器，并且将 Selenium Core 加载到整个页面中。</li>\n<li>Selenium Core 从客户端驱动获得第一个指令（通过向 Selenium RC 服务端发起的另一个 http 请求）。</li>\n<li>Selenium Core 执行第一个指令，典型的是打开一个 AUT 页面。</li>\n<li>浏览器收到这个请求并且向站点服务器请求页面。一旦浏览器接收到页面内容，就会渲染到相应的帧或窗口。</li>\n</ol>\n<h2 id=\"处理-HTTPS-和安全警告弹出框\"><a href=\"#处理-HTTPS-和安全警告弹出框\" class=\"headerlink\" title=\"处理 HTTPS 和安全警告弹出框\"></a>处理 HTTPS 和安全警告弹出框</h2><p>当需要发送诸如密码或信用卡等加密信息时，我们往往会从 http 转为 https。这在今天的应用中非常常见。Selenium RC 也支持。</p>\n<p>为了确保这个 https 站点的真实性，浏览器需要一个安全整数。否则，当浏览器使用 https 访问 AUT 时，这个应用经常被认为是不受信任的。当遇到这种情况时，浏览器会显示安全警告弹出框，而 Selenium RC 无法关闭这个弹出框。</p>\n<p>当在 Selenium RC 测试中使用 https 时，你必须使用一个支持的运行模式，并且能为你处理安全证书。你可以在测试项目初始化 Selenium 时指定这个运行模式。</p>\n<p>在 Selenium RC 1.0 beta 2 和其后续版本中，可以使用 <em>firefox 和 </em>iexplore 运行模式。在更早期的版本中，包括 Selenium RC 1.0 beta 1 使用 <em>chrome 和 </em>iehta 运行模式。通过使用这些运行模式，你不需要安装任何特殊的安全证书，Selenium RC 将帮你处理它。</p>\n<p>在版本1中，推荐运行 <em>firefox 和 </em>iexplore 运行模式。然而，我们还提供 <em>iexploreproxy 和 </em>firefoxproxy 运行模式。它们只是用于提供向后兼容，除非遗留的测试项目，否则我们不应该使用它们。在你需要处理安全证书和运行多窗口时，它们的处理将存在局限性。</p>\n<p>在 Selenium RC 的早期版本中，<em>chrome 或 </em>iehta 是支持 https 和能处理安全警告弹出窗的运行模式。它们被认为是实验性的模式，虽然现在它们已经很稳定并且有大量用户。如果你在使用 Selenium 1，你不应该使用那些老的运行模式。</p>\n<h3 id=\"关于安全证书\"><a href=\"#关于安全证书\" class=\"headerlink\" title=\"关于安全证书\"></a>关于安全证书</h3><p>通常来来说，安装了安全证书后，浏览器将信任你测试的应用。你可以在浏览器的选项或者 Internet 属性中检查它（如果你不知道你的 AUT 的安全证书，询问你的系统管理员）。当 Selenium 启动了浏览器，它注入代码以解析浏览器和服务器之间的通讯。这时，浏览器认为这个引用是不被信任的了，并且会弹出一个安全警告。</p>\n<p>为了绕过这个问题，Selenium RC，（又需要使用支持的运行模式）将安装它自己的证书。将临时装在你的客户机上，能被浏览器访问到的地方。这将欺骗浏览器认为它在访问一个和你的 AUT 完全不同的重难点，就能成功的组织弹出框。</p>\n<p>另一个在早期的版本中解决此问题的方法是安装一个随 Selenium 安装提供的 Cybervillians 安全证书。大部分用户不需要做这件事情，但是当你在代理注入的模式下运行 Selenium RC 时，你就需要安装它了。</p>\n<h2 id=\"更多浏览器支持和相关配置\"><a href=\"#更多浏览器支持和相关配置\" class=\"headerlink\" title=\"更多浏览器支持和相关配置\"></a>更多浏览器支持和相关配置</h2><p>Selenium API 支持在多个浏览器中运行，包括 ie 和 Firefox。请从 SeleniumHQ.org 查看支持的浏览器。另外，当一个浏览器不直接被支持时，启动浏览器时，你可以使用 ”<em>custom“ 来指定一个浏览器运行你的 Selenium 测试（例如：替换 </em>firefox 或 *iexplore）。这样，你可以将这个 API 调用可执行的路径传递给浏览器。这个操作也可以在服务端的交互模式下完成。</p>\n<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe&amp;2=http://www.google.com\n</code></pre><h3 id=\"使用不同的浏览器配置来运行测试\"><a href=\"#使用不同的浏览器配置来运行测试\" class=\"headerlink\" title=\"使用不同的浏览器配置来运行测试\"></a>使用不同的浏览器配置来运行测试</h3><p>通常 Selenium RC 会自动配置浏览器, 但是如果你使用 “*custom” 运行模式启动浏览器，你必须强制 Selenium RC 启动浏览器，就像自动配置不存在一样。</p>\n<p>例如，你使用如下自定义配置启动 Firefox：</p>\n<pre><code>cmd=getNewBrowserSession&amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe&amp;2=http://www.google.com\n</code></pre><p>注意，当使用这种方法启动浏览器时，我们必须手工配置浏览器使用 Selenium 服务端作为代理。通常这意味这你需要打开你的浏览器选项，指定 “localhost:4444” 作为 http 代理，但是每种浏览器的设置方式可能不太一样。</p>\n<p>注意 Mozilla 浏览器的启动和停止不太一样。你需要设置 MOZ_NO_REMOTE 环境变量确保它表现如预期。Unix 用户应该避免使用 shell 脚本来启动它，直接使用一个二进制可执行文（如：firefox-bin）会更好。</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p><strong>译者注：</strong>这部分内容不翻译了，请参考原英文文档。</p>\n<ul>\n<li>Unable to Connect to Server</li>\n<li>Unable to Load the Browser</li>\n<li>Selenium Cannot Find the AUT</li>\n<li>Firefox Refused Shutdown While Preparing a Profile</li>\n<li>Versioning Problems</li>\n<li>Error message: “(Unsupported major.minor version 49.0)” while starting server</li>\n<li>404 error when running the getNewBrowserSession command</li>\n<li>Permission Denied Error</li>\n<li>Handling Browser Popup Windows</li>\n<li>On Linux, why isn’t my Firefox browser session closing?</li>\n<li>Firefox *chrome doesn’t work with custom profile</li>\n<li>Is it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page’s javascript window.onload() function runs)?</li>\n<li>Problems With Verify Commands</li>\n<li>Safari and MultiWindow Mode</li>\n<li>Firefox on Linux</li>\n<li>IE and Style Attributes</li>\n<li>Error encountered - “Cannot convert object to primitive value” with shut down of *googlechrome browser</li>\n<li>Where can I Ask Questions that Aren’t Answered Here?</li>\n</ul>"},{"layout":"post","title":"selenium文档:selenium WebDriver","date":"2013-05-30T11:55:00.000Z","comments":1,"_content":"# Selenium WebDriver\n\n注意：本章内容官方团队正在完善中。\n\n## 介绍 WebDriver\n\nSelenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。\n\n## 同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？\n\nSelenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。\n\n相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。\n<!--more-->\n## WebDriver 和 Selenium-Server\n\n你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。\n\n在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：\n\n- 你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。\n- 你希望连接一台远程的机器来测试一个特定的浏览器。\n- 你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。\n\n## 设置一个 Selenium-WebDriver 项目\n\n安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。\n\n### Java\n\n创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。\n\n首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>MySel20Proj</groupId>\n        <artifactId>MySel20Proj</artifactId>\n        <version>1.0</version>\n        <dependencies>\n            <dependency>\n                <groupId>org.seleniumhq.selenium</groupId>\n                <artifactId>selenium-java</artifactId>\n                <version>2.28.0</version>\n            </dependency>\n            <dependency>\n                <groupId>com.opera</groupId>\n                <artifactId>operadriver</artifactId>\n            </dependency>\n        </dependencies>\n        <dependencyManagement>\n            <dependencies>\n                <dependency>\n                    <groupId>com.opera</groupId>\n                    <artifactId>operadriver</artifactId>\n                    <version>1.1</version>\n                    <exclusions>\n                        <exclusion>\n                            <groupId>org.seleniumhq.selenium</groupId>\n                            <artifactId>selenium-remote-driver</artifactId>\n                        </exclusion>\n                    </exclusions>\n                </dependency>\n            </dependencies>\n        </dependencyManagement>\n    </project>\n    \n确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 [Maven 下载页面](http://seleniumhq.org/download/maven.html) 中的最新版本，并修改上述文件中依赖的版本。\n\n命令行进入本目录，运行如下命令：\n\n    mvn clean install\n\n该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。\n\n最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。\n\n[Importing a maven project into IntelliJ IDEA](http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference)\n\n[Importing a maven project into Eclipse](http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference)\n\n## 从 Selenium 1.0 迁移\n\n对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。\n\n[Migrating From Selenium RC to Selenium WebDriver](http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference)\n\n## 实例介绍 Selenium-WebDriver API\n\nWebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。  \n\n建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。\n\n**注意：** 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。\n\n我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。\n\n    package org.openqa.selenium.example;\n\n    import org.openqa.selenium.By;\n    import org.openqa.selenium.WebDriver;\n    import org.openqa.selenium.WebElement;\n    import org.openqa.selenium.firefox.FirefoxDriver;\n    import org.openqa.selenium.support.ui.ExpectedCondition;\n    import org.openqa.selenium.support.ui.WebDriverWait;\n    \n    public class Selenium2Example  {\n        public static void main(String[] args) {\n            // 创建了一个 Firefox driver 的实例\n            // 注意，其余的代码依赖于接口而非实例\n            WebDriver driver = new FirefoxDriver();\n    \n            // 使用它访问 Google\n            driver.get(\"http://www.google.com\");\n            // 同样的事情也可以通过以下代码完成\n            // driver.navigate().to(\"http://www.google.com\");\n    \n            // 找到搜索输入框\n            WebElement element = driver.findElement(By.name(\"q\"));\n    \n            // 输入要查找的词\n            element.sendKeys(\"Cheese!\");\n    \n            // 提交表单\n            element.submit();\n    \n            // 检查页面标题\n            System.out.println(\"Page title is: \" + driver.getTitle());\n            \n            // Google 搜索结果由 JavaScript 动态渲染\n            // 等待页面加载完毕，超时时间设为10秒\n            (new WebDriverWait(driver, 10)).until(new ExpectedCondition<Boolean>() {\n                public Boolean apply(WebDriver d) {\n                    return d.getTitle().toLowerCase().startsWith(\"cheese!\");\n                }\n            });\n    \n            //应该能看到: \"cheese! - Google Search\"\n            System.out.println(\"Page title is: \" + driver.getTitle());\n            \n            //关闭浏览器\n            driver.quit();\n        }\n    }\n\n在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。\n\n## Selenium-WebDriver API 和操作\n\n### 获取一个页面\n\n访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：\n\n    driver.get(\"http://www.google.com\");\n\n包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 [Explicit and Implicit Waits](http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference) 等到页面元素可用。\n\n### 查找 UI 元素（web 元素）\n\nWebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。\n\n“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：\n\n#### By id\n\n这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。\n\nHTML:\n\n    <div id=\"coolestWidgetEvah\">...</div>\n\nJava：\n\n    WebElement element = driver.findElement(By.id(\"coolestWidgetEvah\"));\n\n#### By Class Name\n\n\"class\" 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。\n\nHTML:\n\n    <div class=\"cheese\"><span>Cheddar</span></div><div class=\"cheese\"><span>Gouda</span></div>\n\nJava：\n\n    List<WebElement> cheeses = driver.findElements(By.className(\"cheese\"));\n\n#### By Tag Name\n\n根据元素标签名查找。\n\nHTML:\n\n    <iframe src=\"...\"></iframe>\n\nJava：\n\n    WebElement frame = driver.findElement(By.tagName(\"iframe\"));\n\n#### By Name\n\n查找 name 属性匹配的表单元素。\n\nHTML:\n\n    <input name=\"cheese\" type=\"text\"/>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.name(\"cheese\"));\n\n#### By Link Text\n\n查找链接文字匹配的链接元素。\n\nHTML：\n\n    <a href=\"http://www.google.com/search?q=cheese\">cheese</a>>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.linkText(\"cheese\"));\n\n#### By Partial Link Text\n\n查找链接文字部分匹配的链接元素。\n\nHTML:\n\n    <a href=\"http://www.google.com/search?q=cheese\">search for cheese</a>>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.partialLinkText(\"cheese\"));\n\n#### By CSS\n\n正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 [css 选择器](http://www.w3.org/TR/CSS/#selectors)。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。\n\n注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。\n\nHTML:\n\n    <div id=\"food\"><span class=\"dairy\">milk</span><span class=\"dairy aged\">cheese</span></div>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.cssSelector(\"#food span.dairy.aged\"));\n\n#### By XPATH\n\n此处略过不译\n\n### 用户输入 - 填充表单\n\n我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：\n\n    WebElement select = driver.findElement(By.tagName(\"select\"));\n    List<WebElement> allOptions = select.findElements(By.tagName(\"option\"));\n    for (WebElement option : allOptions) {\n        System.out.println(String.format(\"Value is: %s\", option.getAttribute(\"value\")));\n        option.click();\n    }\n\n上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver\n有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。\n\n    Select select = new Select(driver.findElement(By.tagName(\"select\")));\n    select.deselectAll();\n    select.selectByVisibleText(\"Edam\");\n\n上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。\n\n如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。\n\n    driver.findElement(By.id(\"submit\")).click();\n\n或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。\n\n    element.submit();\n    \n### 在窗口和帧(frames)之间切换\n\n有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。\n\n    driver.switchTo().window(\"windowName\");\n\n所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：\n\n    <a href=\"somewhere.html\" target=\"windowName\">Click here to open a new window</a>\n\n你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：\n\n   for (String handle : driver.getWindowHandles()) {\n        driver.switchTo().window(handle);\n    }\n\n你也可以切换到指定帧：\n\n    driver.switchTo().frame(\"frameName\");\n\n你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：\n\n    driver.switchTo().frame(\"frameName.0.child\");\n\n该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 **top** 开始。\n\n### 弹出框\n\n由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：\n\n    Alert alert = driver.switchTo().alert();\n\n该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。\n\n### 导航：历史记录和位置\n\n更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(\"http://www.example.com\"))。正如你所见，WebDriver 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：\n\n    driver.navigate().to(\"http://www.example.com\");\n\n重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。\n\n“navigate” 接口暴露了访问浏览器历史记录的接口：\n\n    driver.navigate().forward();\n    driver.navigate().back();\n\n需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。\n\n### Cookies\n\n在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (http://example.com/some404page)。\n\n    // 进到正确的域\n    driver.get(\"http://www.example.com\");\n    \n    // 设置 cookie，这个cookie 对整个域都有效\n    Cookie cookie = new Cookie(\"key\", \"value\");\n    driver.manage().addCookie(cookie);\n    \n    // 输出当前 url 所有可用的 cookie\n    Set<Cookie> allCookies = driver.manage().getCookies();\n    for (Cookie loadedCookie : allCookies) {\n        System.out.println(String.format(\"%s -> %s\", loadedCookie.getName(), loadedCookie.getValue()));\n    }\n    \n    // 你可以通过3中方式删除 cookie\n    // By name\n    driver.manage().deleteCookieNamed(\"CookieName\");\n    // By Cookie\n    driver.manage().deleteCookie(loadedCookie);\n    // Or all of them\n    driver.manage().deleteAllCookies();\n\n### 改变 UA\n\n当使用 Firefox Driver 的时候这很容易：\n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.addAdditionalPreference(\"general.useragent.override\", \"some UA string\");\n    WebDriver driver = new FirefoxDriver(profile);\n\n### 拖拽\n\n以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：\n\n    WebElement element = driver.findElement(By.name(\"source\"));\n    WebElement target = driver.findElement(By.name(\"target\"));\n    \n    (new Actions(driver)).dragAndDrop(element, target).perform();\n\n## Driver 特性和权衡\n\n## Selenium-WebDriver’s Drivers\n\nWebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：\n\n### HtmlUnit Driver\n\n这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。\n\n#### 使用\n\n    WebDriver driver = new HtmlUnitDriver();\n\n#### 优势\n\n- WebDriver 最快速的实现\n- 纯 Java 实现，跨平台\n- 支持 JavaScript\n\n#### 劣势\n\n- 需要模拟浏览器中 JavaScript 的行为（如下）。\n\n#### JavaScript in the HtmlUnit Driver\n\n没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。\n\n当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。\n\n使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。\n\n##### 启用 JavaScript\n\n启用 JavaScript 也非常简单：\n\n    HtmlUnitDriver driver = new HtmlUnitDriver(true);\n\n上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。\n\n### Firefox Driver\n\n我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（[see the source to see which ones](http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55)）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。\n\n#### 使用\n\n    WebDriver driver = new FirefoxDriver();\n\n#### 优势\n\n- 在真实的浏览器里运行，且支持 JavaScript\n- 比 IE Driver 快\n\n#### 劣势\n\n- 比 HtmlUnit Driver 慢\n- 需要修改 Firefox 配置\n\n例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：\n\n    ProfilesIni allProfiles = new ProfilesIni();\n    FirefoxProfile profile = allProfiles.getProfile(\"WebDriver\");\n    profile.setPreferences(\"foo.bar\", 23);\n    WebDriver driver = new FirefoxDriver(profile);\n\n如果配置文件没有注册至 Firefox：\n\n    File profileDir = new File(\"path/to/top/level/of/profile\");\n    FirefoxProfile profile = new FirefoxProfile(profileDir);\n    profile.addAdditionalPreferences(extraPrefs);\n    WebDriver driver = new FirefoxDriver(profile);\n\n当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：\n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.setEnableNativeEvents(true);\n    WebDriver driver = new FirefoxDriver(profile);\n\n#### 信息\n\n查看 [Firefox section in the wiki page](http://code.google.com/p/selenium/wiki/FirefoxDriver) 以获得更多新鲜信息。\n\n### Internet Explorer Driver\n\n这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。\n\n#### 使用\n\n    WebDriver driver = new InternetExplorerDriver();\n\n#### 优势\n\n- 运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。\n\n#### 劣势\n\n- 显然它只在 Windows 系统上有效。\n- 相对较慢。\n- Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。\n- IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。\n- IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.\n\n#### 信息\n\n访问 [Internet Explorer section of the wiki page](http://code.google.com/p/selenium/wiki/InternetExplorerDriver) 以获得更多新鲜信息。特别注意配置部分的内容。\n\n### Chrome Driver\n\nChrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 以获得更多信息。\n\n#### 使用\n\n    WebDriver driver = new ChromeDriver();\n\n#### 优势\n\n- 运行在真实的浏览器中，并且支持 JavaScript。\n- 由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。\n\n#### 劣势\n\n- 比 HtmlUnit 慢\n\n#### 信息\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 以获得更多最新信息。更多信息可以在 [下载页面](http://seleniumhq.org/download/) 找到。\n\n#### 运行 Chrome Driver\n\n下载 [Chrome Driver](http://code.google.com/p/chromium/downloads/list) 并参考 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 上的其他建议。\n\n### Opera Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/OperaDriver)\n\n### iPhone Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/IPhoneDriver)\n\n### Android Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/AndroidDriver)\n\n## 可选择的后端：混合 WebDriver 和 RC 技术\n\n### WebDriver-Backed Selenium-RC\n\nJava 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。\n\nSelenium-WebDriver 的用法如下：\n\n    // 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。\n    WebDriver driver = new FirefoxDriver();\n    \n    // 基准 url，selenium 用于解析相对路径。\n     String baseUrl = \"http://www.google.com\";\n    \n    // 创建一个 Selenium 实现。\n    Selenium selenium = new WebDriverBackedSelenium(driver, baseUrl);\n    \n    // 使用 selenium 进行一些操作。\n    selenium.open(\"http://www.google.com\");\n    selenium.type(\"name=q\", \"cheese\");\n    selenium.click(\"name=btnG\");\n    \n    // Get the underlying WebDriver implementation back. This will refer to the\n    // same WebDriver instance as the \"driver\" variable above.\n    WebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();\n    \n    // 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。\n    // 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。\n    selenium.stop();\n\n#### 优势\n\n- 允许 WebDriver 和 Selenium API 并存。\n- 提供了简单的机制从 Selenium RC API 迁移至 WebDriver。\n- 不需要运行 Selenium RC server。\n\n#### 劣势\n\n- 没有实现所有的方法。\n- 一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。\n- 由于底层的实现，有些方法会比较慢。\n\n### Backing WebDriver with Selenium\n\nWebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。\n\n通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：\n\n    DesiredCapabilities capabilities = new DesiredCapabilities();\n    capabilities.setBrowserName(\"safari\");\n    CommandExecutor executor = new SeleneseCommandExecutor(new URL(\"http://localhost:4444/\"), new URL(\"http://www.google.com/\"), capabilities);\n    WebDriver driver = new RemoteWebDriver(executor, capabilities);\n\n这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。\n\n## 运行 Selenium Server 以使用 RemoteDrivers¶\n\n从 [Selenium 下载页面](https://code.google.com/p/selenium/downloads/list) 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 [google code](http://chromedriver.googlecode.com/) 下载它。\n\n把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。\n\n从命令行启动服务：\n\n    java -jar <path_to>/selenium-server-standalone-<version>.jar\n\n如果你希望使用本地事件功能，在命令行添加以下参数：\n\n    -Dwebdriver.enable.native.events=1\n    \n查看帮助：\n\n    java -jar <path_to>/selenium-server-standalone-<version>.jar -help\n\n为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。\n\n## 更多资源\n\n你可以在 [WebDriver wiki](http://code.google.com/p/selenium/wiki/FurtherResources) 找到更多有用的资源。\n\n当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：http://groups.google.com/group/selenium-users。\n\n## 接下来\n\n本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2013-05-30-selenium-doc-selenium-web-driver.markdown","raw":"---\nlayout: post\ntitle: \"selenium文档:selenium WebDriver\"\ndate: 2013-05-30 19:55\ncomments: true\ncategories: selenium官方文档\ntags: [ selenium ]\n---\n# Selenium WebDriver\n\n注意：本章内容官方团队正在完善中。\n\n## 介绍 WebDriver\n\nSelenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。\n\n## 同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？\n\nSelenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。\n\n相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。\n<!--more-->\n## WebDriver 和 Selenium-Server\n\n你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。\n\n在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：\n\n- 你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。\n- 你希望连接一台远程的机器来测试一个特定的浏览器。\n- 你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。\n\n## 设置一个 Selenium-WebDriver 项目\n\n安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。\n\n### Java\n\n创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。\n\n首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n                 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                 xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>MySel20Proj</groupId>\n        <artifactId>MySel20Proj</artifactId>\n        <version>1.0</version>\n        <dependencies>\n            <dependency>\n                <groupId>org.seleniumhq.selenium</groupId>\n                <artifactId>selenium-java</artifactId>\n                <version>2.28.0</version>\n            </dependency>\n            <dependency>\n                <groupId>com.opera</groupId>\n                <artifactId>operadriver</artifactId>\n            </dependency>\n        </dependencies>\n        <dependencyManagement>\n            <dependencies>\n                <dependency>\n                    <groupId>com.opera</groupId>\n                    <artifactId>operadriver</artifactId>\n                    <version>1.1</version>\n                    <exclusions>\n                        <exclusion>\n                            <groupId>org.seleniumhq.selenium</groupId>\n                            <artifactId>selenium-remote-driver</artifactId>\n                        </exclusion>\n                    </exclusions>\n                </dependency>\n            </dependencies>\n        </dependencyManagement>\n    </project>\n    \n确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 [Maven 下载页面](http://seleniumhq.org/download/maven.html) 中的最新版本，并修改上述文件中依赖的版本。\n\n命令行进入本目录，运行如下命令：\n\n    mvn clean install\n\n该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。\n\n最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。\n\n[Importing a maven project into IntelliJ IDEA](http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference)\n\n[Importing a maven project into Eclipse](http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference)\n\n## 从 Selenium 1.0 迁移\n\n对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。\n\n[Migrating From Selenium RC to Selenium WebDriver](http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference)\n\n## 实例介绍 Selenium-WebDriver API\n\nWebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。  \n\n建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。\n\n**注意：** 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。\n\n我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。\n\n    package org.openqa.selenium.example;\n\n    import org.openqa.selenium.By;\n    import org.openqa.selenium.WebDriver;\n    import org.openqa.selenium.WebElement;\n    import org.openqa.selenium.firefox.FirefoxDriver;\n    import org.openqa.selenium.support.ui.ExpectedCondition;\n    import org.openqa.selenium.support.ui.WebDriverWait;\n    \n    public class Selenium2Example  {\n        public static void main(String[] args) {\n            // 创建了一个 Firefox driver 的实例\n            // 注意，其余的代码依赖于接口而非实例\n            WebDriver driver = new FirefoxDriver();\n    \n            // 使用它访问 Google\n            driver.get(\"http://www.google.com\");\n            // 同样的事情也可以通过以下代码完成\n            // driver.navigate().to(\"http://www.google.com\");\n    \n            // 找到搜索输入框\n            WebElement element = driver.findElement(By.name(\"q\"));\n    \n            // 输入要查找的词\n            element.sendKeys(\"Cheese!\");\n    \n            // 提交表单\n            element.submit();\n    \n            // 检查页面标题\n            System.out.println(\"Page title is: \" + driver.getTitle());\n            \n            // Google 搜索结果由 JavaScript 动态渲染\n            // 等待页面加载完毕，超时时间设为10秒\n            (new WebDriverWait(driver, 10)).until(new ExpectedCondition<Boolean>() {\n                public Boolean apply(WebDriver d) {\n                    return d.getTitle().toLowerCase().startsWith(\"cheese!\");\n                }\n            });\n    \n            //应该能看到: \"cheese! - Google Search\"\n            System.out.println(\"Page title is: \" + driver.getTitle());\n            \n            //关闭浏览器\n            driver.quit();\n        }\n    }\n\n在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。\n\n## Selenium-WebDriver API 和操作\n\n### 获取一个页面\n\n访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：\n\n    driver.get(\"http://www.google.com\");\n\n包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 [Explicit and Implicit Waits](http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference) 等到页面元素可用。\n\n### 查找 UI 元素（web 元素）\n\nWebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。\n\n“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：\n\n#### By id\n\n这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。\n\nHTML:\n\n    <div id=\"coolestWidgetEvah\">...</div>\n\nJava：\n\n    WebElement element = driver.findElement(By.id(\"coolestWidgetEvah\"));\n\n#### By Class Name\n\n\"class\" 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。\n\nHTML:\n\n    <div class=\"cheese\"><span>Cheddar</span></div><div class=\"cheese\"><span>Gouda</span></div>\n\nJava：\n\n    List<WebElement> cheeses = driver.findElements(By.className(\"cheese\"));\n\n#### By Tag Name\n\n根据元素标签名查找。\n\nHTML:\n\n    <iframe src=\"...\"></iframe>\n\nJava：\n\n    WebElement frame = driver.findElement(By.tagName(\"iframe\"));\n\n#### By Name\n\n查找 name 属性匹配的表单元素。\n\nHTML:\n\n    <input name=\"cheese\" type=\"text\"/>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.name(\"cheese\"));\n\n#### By Link Text\n\n查找链接文字匹配的链接元素。\n\nHTML：\n\n    <a href=\"http://www.google.com/search?q=cheese\">cheese</a>>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.linkText(\"cheese\"));\n\n#### By Partial Link Text\n\n查找链接文字部分匹配的链接元素。\n\nHTML:\n\n    <a href=\"http://www.google.com/search?q=cheese\">search for cheese</a>>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.partialLinkText(\"cheese\"));\n\n#### By CSS\n\n正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 [css 选择器](http://www.w3.org/TR/CSS/#selectors)。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。\n\n注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。\n\nHTML:\n\n    <div id=\"food\"><span class=\"dairy\">milk</span><span class=\"dairy aged\">cheese</span></div>\n\nJava：\n\n    WebElement cheese = driver.findElement(By.cssSelector(\"#food span.dairy.aged\"));\n\n#### By XPATH\n\n此处略过不译\n\n### 用户输入 - 填充表单\n\n我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：\n\n    WebElement select = driver.findElement(By.tagName(\"select\"));\n    List<WebElement> allOptions = select.findElements(By.tagName(\"option\"));\n    for (WebElement option : allOptions) {\n        System.out.println(String.format(\"Value is: %s\", option.getAttribute(\"value\")));\n        option.click();\n    }\n\n上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver\n有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。\n\n    Select select = new Select(driver.findElement(By.tagName(\"select\")));\n    select.deselectAll();\n    select.selectByVisibleText(\"Edam\");\n\n上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。\n\n如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。\n\n    driver.findElement(By.id(\"submit\")).click();\n\n或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。\n\n    element.submit();\n    \n### 在窗口和帧(frames)之间切换\n\n有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。\n\n    driver.switchTo().window(\"windowName\");\n\n所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：\n\n    <a href=\"somewhere.html\" target=\"windowName\">Click here to open a new window</a>\n\n你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：\n\n   for (String handle : driver.getWindowHandles()) {\n        driver.switchTo().window(handle);\n    }\n\n你也可以切换到指定帧：\n\n    driver.switchTo().frame(\"frameName\");\n\n你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：\n\n    driver.switchTo().frame(\"frameName.0.child\");\n\n该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 **top** 开始。\n\n### 弹出框\n\n由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：\n\n    Alert alert = driver.switchTo().alert();\n\n该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。\n\n### 导航：历史记录和位置\n\n更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(\"http://www.example.com\"))。正如你所见，WebDriver 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：\n\n    driver.navigate().to(\"http://www.example.com\");\n\n重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。\n\n“navigate” 接口暴露了访问浏览器历史记录的接口：\n\n    driver.navigate().forward();\n    driver.navigate().back();\n\n需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。\n\n### Cookies\n\n在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (http://example.com/some404page)。\n\n    // 进到正确的域\n    driver.get(\"http://www.example.com\");\n    \n    // 设置 cookie，这个cookie 对整个域都有效\n    Cookie cookie = new Cookie(\"key\", \"value\");\n    driver.manage().addCookie(cookie);\n    \n    // 输出当前 url 所有可用的 cookie\n    Set<Cookie> allCookies = driver.manage().getCookies();\n    for (Cookie loadedCookie : allCookies) {\n        System.out.println(String.format(\"%s -> %s\", loadedCookie.getName(), loadedCookie.getValue()));\n    }\n    \n    // 你可以通过3中方式删除 cookie\n    // By name\n    driver.manage().deleteCookieNamed(\"CookieName\");\n    // By Cookie\n    driver.manage().deleteCookie(loadedCookie);\n    // Or all of them\n    driver.manage().deleteAllCookies();\n\n### 改变 UA\n\n当使用 Firefox Driver 的时候这很容易：\n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.addAdditionalPreference(\"general.useragent.override\", \"some UA string\");\n    WebDriver driver = new FirefoxDriver(profile);\n\n### 拖拽\n\n以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：\n\n    WebElement element = driver.findElement(By.name(\"source\"));\n    WebElement target = driver.findElement(By.name(\"target\"));\n    \n    (new Actions(driver)).dragAndDrop(element, target).perform();\n\n## Driver 特性和权衡\n\n## Selenium-WebDriver’s Drivers\n\nWebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：\n\n### HtmlUnit Driver\n\n这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。\n\n#### 使用\n\n    WebDriver driver = new HtmlUnitDriver();\n\n#### 优势\n\n- WebDriver 最快速的实现\n- 纯 Java 实现，跨平台\n- 支持 JavaScript\n\n#### 劣势\n\n- 需要模拟浏览器中 JavaScript 的行为（如下）。\n\n#### JavaScript in the HtmlUnit Driver\n\n没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。\n\n当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。\n\n使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。\n\n##### 启用 JavaScript\n\n启用 JavaScript 也非常简单：\n\n    HtmlUnitDriver driver = new HtmlUnitDriver(true);\n\n上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。\n\n### Firefox Driver\n\n我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（[see the source to see which ones](http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55)）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。\n\n#### 使用\n\n    WebDriver driver = new FirefoxDriver();\n\n#### 优势\n\n- 在真实的浏览器里运行，且支持 JavaScript\n- 比 IE Driver 快\n\n#### 劣势\n\n- 比 HtmlUnit Driver 慢\n- 需要修改 Firefox 配置\n\n例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：\n\n    ProfilesIni allProfiles = new ProfilesIni();\n    FirefoxProfile profile = allProfiles.getProfile(\"WebDriver\");\n    profile.setPreferences(\"foo.bar\", 23);\n    WebDriver driver = new FirefoxDriver(profile);\n\n如果配置文件没有注册至 Firefox：\n\n    File profileDir = new File(\"path/to/top/level/of/profile\");\n    FirefoxProfile profile = new FirefoxProfile(profileDir);\n    profile.addAdditionalPreferences(extraPrefs);\n    WebDriver driver = new FirefoxDriver(profile);\n\n当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：\n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.setEnableNativeEvents(true);\n    WebDriver driver = new FirefoxDriver(profile);\n\n#### 信息\n\n查看 [Firefox section in the wiki page](http://code.google.com/p/selenium/wiki/FirefoxDriver) 以获得更多新鲜信息。\n\n### Internet Explorer Driver\n\n这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。\n\n#### 使用\n\n    WebDriver driver = new InternetExplorerDriver();\n\n#### 优势\n\n- 运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。\n\n#### 劣势\n\n- 显然它只在 Windows 系统上有效。\n- 相对较慢。\n- Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。\n- IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。\n- IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.\n\n#### 信息\n\n访问 [Internet Explorer section of the wiki page](http://code.google.com/p/selenium/wiki/InternetExplorerDriver) 以获得更多新鲜信息。特别注意配置部分的内容。\n\n### Chrome Driver\n\nChrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 以获得更多信息。\n\n#### 使用\n\n    WebDriver driver = new ChromeDriver();\n\n#### 优势\n\n- 运行在真实的浏览器中，并且支持 JavaScript。\n- 由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。\n\n#### 劣势\n\n- 比 HtmlUnit 慢\n\n#### 信息\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 以获得更多最新信息。更多信息可以在 [下载页面](http://seleniumhq.org/download/) 找到。\n\n#### 运行 Chrome Driver\n\n下载 [Chrome Driver](http://code.google.com/p/chromium/downloads/list) 并参考 [wiki](http://code.google.com/p/selenium/wiki/ChromeDriver) 上的其他建议。\n\n### Opera Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/OperaDriver)\n\n### iPhone Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/IPhoneDriver)\n\n### Android Driver\n\n查看 [wiki](http://code.google.com/p/selenium/wiki/AndroidDriver)\n\n## 可选择的后端：混合 WebDriver 和 RC 技术\n\n### WebDriver-Backed Selenium-RC\n\nJava 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。\n\nSelenium-WebDriver 的用法如下：\n\n    // 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。\n    WebDriver driver = new FirefoxDriver();\n    \n    // 基准 url，selenium 用于解析相对路径。\n     String baseUrl = \"http://www.google.com\";\n    \n    // 创建一个 Selenium 实现。\n    Selenium selenium = new WebDriverBackedSelenium(driver, baseUrl);\n    \n    // 使用 selenium 进行一些操作。\n    selenium.open(\"http://www.google.com\");\n    selenium.type(\"name=q\", \"cheese\");\n    selenium.click(\"name=btnG\");\n    \n    // Get the underlying WebDriver implementation back. This will refer to the\n    // same WebDriver instance as the \"driver\" variable above.\n    WebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();\n    \n    // 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。\n    // 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。\n    selenium.stop();\n\n#### 优势\n\n- 允许 WebDriver 和 Selenium API 并存。\n- 提供了简单的机制从 Selenium RC API 迁移至 WebDriver。\n- 不需要运行 Selenium RC server。\n\n#### 劣势\n\n- 没有实现所有的方法。\n- 一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。\n- 由于底层的实现，有些方法会比较慢。\n\n### Backing WebDriver with Selenium\n\nWebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。\n\n通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：\n\n    DesiredCapabilities capabilities = new DesiredCapabilities();\n    capabilities.setBrowserName(\"safari\");\n    CommandExecutor executor = new SeleneseCommandExecutor(new URL(\"http://localhost:4444/\"), new URL(\"http://www.google.com/\"), capabilities);\n    WebDriver driver = new RemoteWebDriver(executor, capabilities);\n\n这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。\n\n## 运行 Selenium Server 以使用 RemoteDrivers¶\n\n从 [Selenium 下载页面](https://code.google.com/p/selenium/downloads/list) 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 [google code](http://chromedriver.googlecode.com/) 下载它。\n\n把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。\n\n从命令行启动服务：\n\n    java -jar <path_to>/selenium-server-standalone-<version>.jar\n\n如果你希望使用本地事件功能，在命令行添加以下参数：\n\n    -Dwebdriver.enable.native.events=1\n    \n查看帮助：\n\n    java -jar <path_to>/selenium-server-standalone-<version>.jar -help\n\n为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。\n\n## 更多资源\n\n你可以在 [WebDriver wiki](http://code.google.com/p/selenium/wiki/FurtherResources) 找到更多有用的资源。\n\n当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：http://groups.google.com/group/selenium-users。\n\n## 接下来\n\n本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2013-05-30-selenium-doc-selenium-web-driver","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5x0069v8fyse368f4w","content":"<h1 id=\"Selenium-WebDriver\"><a href=\"#Selenium-WebDriver\" class=\"headerlink\" title=\"Selenium WebDriver\"></a>Selenium WebDriver</h1><p>注意：本章内容官方团队正在完善中。</p>\n<h2 id=\"介绍-WebDriver\"><a href=\"#介绍-WebDriver\" class=\"headerlink\" title=\"介绍 WebDriver\"></a>介绍 WebDriver</h2><p>Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。</p>\n<h2 id=\"同-Selenium-RC-相比，WebDriver-如何驱动浏览器的？\"><a href=\"#同-Selenium-RC-相比，WebDriver-如何驱动浏览器的？\" class=\"headerlink\" title=\"同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？\"></a>同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？</h2><p>Selenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。</p>\n<p>相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。<br><a id=\"more\"></a></p>\n<h2 id=\"WebDriver-和-Selenium-Server\"><a href=\"#WebDriver-和-Selenium-Server\" class=\"headerlink\" title=\"WebDriver 和 Selenium-Server\"></a>WebDriver 和 Selenium-Server</h2><p>你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。</p>\n<p>在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：</p>\n<ul>\n<li>你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。</li>\n<li>你希望连接一台远程的机器来测试一个特定的浏览器。</li>\n<li>你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。</li>\n</ul>\n<h2 id=\"设置一个-Selenium-WebDriver-项目\"><a href=\"#设置一个-Selenium-WebDriver-项目\" class=\"headerlink\" title=\"设置一个 Selenium-WebDriver 项目\"></a>设置一个 Selenium-WebDriver 项目</h2><p>安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。</p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p>创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。</p>\n<p>首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n             xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;MySel20Proj&lt;/groupId&gt;\n    &lt;artifactId&gt;MySel20Proj&lt;/artifactId&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;\n            &lt;version&gt;2.28.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.opera&lt;/groupId&gt;\n            &lt;artifactId&gt;operadriver&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.opera&lt;/groupId&gt;\n                &lt;artifactId&gt;operadriver&lt;/artifactId&gt;\n                &lt;version&gt;1.1&lt;/version&gt;\n                &lt;exclusions&gt;\n                    &lt;exclusion&gt;\n                        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n                        &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n                    &lt;/exclusion&gt;\n                &lt;/exclusions&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n&lt;/project&gt;\n</code></pre><p>确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 <a href=\"http://seleniumhq.org/download/maven.html\" target=\"_blank\" rel=\"external\">Maven 下载页面</a> 中的最新版本，并修改上述文件中依赖的版本。</p>\n<p>命令行进入本目录，运行如下命令：</p>\n<pre><code>mvn clean install\n</code></pre><p>该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。</p>\n<p>最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。</p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference\" target=\"_blank\" rel=\"external\">Importing a maven project into IntelliJ IDEA</a></p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference\" target=\"_blank\" rel=\"external\">Importing a maven project into Eclipse</a></p>\n<h2 id=\"从-Selenium-1-0-迁移\"><a href=\"#从-Selenium-1-0-迁移\" class=\"headerlink\" title=\"从 Selenium 1.0 迁移\"></a>从 Selenium 1.0 迁移</h2><p>对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。</p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference\" target=\"_blank\" rel=\"external\">Migrating From Selenium RC to Selenium WebDriver</a></p>\n<h2 id=\"实例介绍-Selenium-WebDriver-API\"><a href=\"#实例介绍-Selenium-WebDriver-API\" class=\"headerlink\" title=\"实例介绍 Selenium-WebDriver API\"></a>实例介绍 Selenium-WebDriver API</h2><p>WebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。  </p>\n<p>建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。</p>\n<p><strong>注意：</strong> 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。</p>\n<p>我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。</p>\n<pre><code>package org.openqa.selenium.example;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\npublic class Selenium2Example  {\n    public static void main(String[] args) {\n        // 创建了一个 Firefox driver 的实例\n        // 注意，其余的代码依赖于接口而非实例\n        WebDriver driver = new FirefoxDriver();\n\n        // 使用它访问 Google\n        driver.get(&quot;http://www.google.com&quot;);\n        // 同样的事情也可以通过以下代码完成\n        // driver.navigate().to(&quot;http://www.google.com&quot;);\n\n        // 找到搜索输入框\n        WebElement element = driver.findElement(By.name(&quot;q&quot;));\n\n        // 输入要查找的词\n        element.sendKeys(&quot;Cheese!&quot;);\n\n        // 提交表单\n        element.submit();\n\n        // 检查页面标题\n        System.out.println(&quot;Page title is: &quot; + driver.getTitle());\n\n        // Google 搜索结果由 JavaScript 动态渲染\n        // 等待页面加载完毕，超时时间设为10秒\n        (new WebDriverWait(driver, 10)).until(new ExpectedCondition&lt;Boolean&gt;() {\n            public Boolean apply(WebDriver d) {\n                return d.getTitle().toLowerCase().startsWith(&quot;cheese!&quot;);\n            }\n        });\n\n        //应该能看到: &quot;cheese! - Google Search&quot;\n        System.out.println(&quot;Page title is: &quot; + driver.getTitle());\n\n        //关闭浏览器\n        driver.quit();\n    }\n}\n</code></pre><p>在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。</p>\n<h2 id=\"Selenium-WebDriver-API-和操作\"><a href=\"#Selenium-WebDriver-API-和操作\" class=\"headerlink\" title=\"Selenium-WebDriver API 和操作\"></a>Selenium-WebDriver API 和操作</h2><h3 id=\"获取一个页面\"><a href=\"#获取一个页面\" class=\"headerlink\" title=\"获取一个页面\"></a>获取一个页面</h3><p>访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：</p>\n<pre><code>driver.get(&quot;http://www.google.com&quot;);\n</code></pre><p>包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 <a href=\"http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference\" target=\"_blank\" rel=\"external\">Explicit and Implicit Waits</a> 等到页面元素可用。</p>\n<h3 id=\"查找-UI-元素（web-元素）\"><a href=\"#查找-UI-元素（web-元素）\" class=\"headerlink\" title=\"查找 UI 元素（web 元素）\"></a>查找 UI 元素（web 元素）</h3><p>WebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。</p>\n<p>“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：</p>\n<h4 id=\"By-id\"><a href=\"#By-id\" class=\"headerlink\" title=\"By id\"></a>By id</h4><p>这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。</p>\n<p>HTML:</p>\n<pre><code>&lt;div id=&quot;coolestWidgetEvah&quot;&gt;...&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement element = driver.findElement(By.id(&quot;coolestWidgetEvah&quot;));\n</code></pre><h4 id=\"By-Class-Name\"><a href=\"#By-Class-Name\" class=\"headerlink\" title=\"By Class Name\"></a>By Class Name</h4><p>“class” 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>List&lt;WebElement&gt; cheeses = driver.findElements(By.className(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Tag-Name\"><a href=\"#By-Tag-Name\" class=\"headerlink\" title=\"By Tag Name\"></a>By Tag Name</h4><p>根据元素标签名查找。</p>\n<p>HTML:</p>\n<pre><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement frame = driver.findElement(By.tagName(&quot;iframe&quot;));\n</code></pre><h4 id=\"By-Name\"><a href=\"#By-Name\" class=\"headerlink\" title=\"By Name\"></a>By Name</h4><p>查找 name 属性匹配的表单元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;input name=&quot;cheese&quot; type=&quot;text&quot;/&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.name(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Link-Text\"><a href=\"#By-Link-Text\" class=\"headerlink\" title=\"By Link Text\"></a>By Link Text</h4><p>查找链接文字匹配的链接元素。</p>\n<p>HTML：</p>\n<pre><code>&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;cheese&lt;/a&gt;&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.linkText(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Partial-Link-Text\"><a href=\"#By-Partial-Link-Text\" class=\"headerlink\" title=\"By Partial Link Text\"></a>By Partial Link Text</h4><p>查找链接文字部分匹配的链接元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;search for cheese&lt;/a&gt;&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.partialLinkText(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-CSS\"><a href=\"#By-CSS\" class=\"headerlink\" title=\"By CSS\"></a>By CSS</h4><p>正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 <a href=\"http://www.w3.org/TR/CSS/#selectors\" target=\"_blank\" rel=\"external\">css 选择器</a>。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。</p>\n<p>注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。</p>\n<p>HTML:</p>\n<pre><code>&lt;div id=&quot;food&quot;&gt;&lt;span class=&quot;dairy&quot;&gt;milk&lt;/span&gt;&lt;span class=&quot;dairy aged&quot;&gt;cheese&lt;/span&gt;&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.cssSelector(&quot;#food span.dairy.aged&quot;));\n</code></pre><h4 id=\"By-XPATH\"><a href=\"#By-XPATH\" class=\"headerlink\" title=\"By XPATH\"></a>By XPATH</h4><p>此处略过不译</p>\n<h3 id=\"用户输入-填充表单\"><a href=\"#用户输入-填充表单\" class=\"headerlink\" title=\"用户输入 - 填充表单\"></a>用户输入 - 填充表单</h3><p>我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：</p>\n<pre><code>WebElement select = driver.findElement(By.tagName(&quot;select&quot;));\nList&lt;WebElement&gt; allOptions = select.findElements(By.tagName(&quot;option&quot;));\nfor (WebElement option : allOptions) {\n    System.out.println(String.format(&quot;Value is: %s&quot;, option.getAttribute(&quot;value&quot;)));\n    option.click();\n}\n</code></pre><p>上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver<br>有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。</p>\n<pre><code>Select select = new Select(driver.findElement(By.tagName(&quot;select&quot;)));\nselect.deselectAll();\nselect.selectByVisibleText(&quot;Edam&quot;);\n</code></pre><p>上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。</p>\n<p>如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。</p>\n<pre><code>driver.findElement(By.id(&quot;submit&quot;)).click();\n</code></pre><p>或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。</p>\n<pre><code>element.submit();\n</code></pre><h3 id=\"在窗口和帧-frames-之间切换\"><a href=\"#在窗口和帧-frames-之间切换\" class=\"headerlink\" title=\"在窗口和帧(frames)之间切换\"></a>在窗口和帧(frames)之间切换</h3><p>有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。</p>\n<pre><code>driver.switchTo().window(&quot;windowName&quot;);\n</code></pre><p>所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：</p>\n<pre><code>&lt;a href=&quot;somewhere.html&quot; target=&quot;windowName&quot;&gt;Click here to open a new window&lt;/a&gt;\n</code></pre><p>你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：</p>\n<p>   for (String handle : driver.getWindowHandles()) {<br>        driver.switchTo().window(handle);<br>    }</p>\n<p>你也可以切换到指定帧：</p>\n<pre><code>driver.switchTo().frame(&quot;frameName&quot;);\n</code></pre><p>你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：</p>\n<pre><code>driver.switchTo().frame(&quot;frameName.0.child&quot;);\n</code></pre><p>该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 <strong>top</strong> 开始。</p>\n<h3 id=\"弹出框\"><a href=\"#弹出框\" class=\"headerlink\" title=\"弹出框\"></a>弹出框</h3><p>由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：</p>\n<pre><code>Alert alert = driver.switchTo().alert();\n</code></pre><p>该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。</p>\n<h3 id=\"导航：历史记录和位置\"><a href=\"#导航：历史记录和位置\" class=\"headerlink\" title=\"导航：历史记录和位置\"></a>导航：历史记录和位置</h3><p>更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(“<a href=\"http://www.example.com&quot;))。正如你所见，WebDriver\" target=\"_blank\" rel=\"external\">http://www.example.com&quot;))。正如你所见，WebDriver</a> 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：</p>\n<pre><code>driver.navigate().to(&quot;http://www.example.com&quot;);\n</code></pre><p>重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。</p>\n<p>“navigate” 接口暴露了访问浏览器历史记录的接口：</p>\n<pre><code>driver.navigate().forward();\ndriver.navigate().back();\n</code></pre><p>需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。</p>\n<h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (<a href=\"http://example.com/some404page)。\" target=\"_blank\" rel=\"external\">http://example.com/some404page)。</a></p>\n<pre><code>// 进到正确的域\ndriver.get(&quot;http://www.example.com&quot;);\n\n// 设置 cookie，这个cookie 对整个域都有效\nCookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);\ndriver.manage().addCookie(cookie);\n\n// 输出当前 url 所有可用的 cookie\nSet&lt;Cookie&gt; allCookies = driver.manage().getCookies();\nfor (Cookie loadedCookie : allCookies) {\n    System.out.println(String.format(&quot;%s -&gt; %s&quot;, loadedCookie.getName(), loadedCookie.getValue()));\n}\n\n// 你可以通过3中方式删除 cookie\n// By name\ndriver.manage().deleteCookieNamed(&quot;CookieName&quot;);\n// By Cookie\ndriver.manage().deleteCookie(loadedCookie);\n// Or all of them\ndriver.manage().deleteAllCookies();\n</code></pre><h3 id=\"改变-UA\"><a href=\"#改变-UA\" class=\"headerlink\" title=\"改变 UA\"></a>改变 UA</h3><p>当使用 Firefox Driver 的时候这很容易：</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.addAdditionalPreference(&quot;general.useragent.override&quot;, &quot;some UA string&quot;);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><h3 id=\"拖拽\"><a href=\"#拖拽\" class=\"headerlink\" title=\"拖拽\"></a>拖拽</h3><p>以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：</p>\n<pre><code>WebElement element = driver.findElement(By.name(&quot;source&quot;));\nWebElement target = driver.findElement(By.name(&quot;target&quot;));\n\n(new Actions(driver)).dragAndDrop(element, target).perform();\n</code></pre><h2 id=\"Driver-特性和权衡\"><a href=\"#Driver-特性和权衡\" class=\"headerlink\" title=\"Driver 特性和权衡\"></a>Driver 特性和权衡</h2><h2 id=\"Selenium-WebDriver’s-Drivers\"><a href=\"#Selenium-WebDriver’s-Drivers\" class=\"headerlink\" title=\"Selenium-WebDriver’s Drivers\"></a>Selenium-WebDriver’s Drivers</h2><p>WebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：</p>\n<h3 id=\"HtmlUnit-Driver\"><a href=\"#HtmlUnit-Driver\" class=\"headerlink\" title=\"HtmlUnit Driver\"></a>HtmlUnit Driver</h3><p>这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new HtmlUnitDriver();\n</code></pre><h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>WebDriver 最快速的实现</li>\n<li>纯 Java 实现，跨平台</li>\n<li>支持 JavaScript</li>\n</ul>\n<h4 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>需要模拟浏览器中 JavaScript 的行为（如下）。</li>\n</ul>\n<h4 id=\"JavaScript-in-the-HtmlUnit-Driver\"><a href=\"#JavaScript-in-the-HtmlUnit-Driver\" class=\"headerlink\" title=\"JavaScript in the HtmlUnit Driver\"></a>JavaScript in the HtmlUnit Driver</h4><p>没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。</p>\n<p>当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。</p>\n<p>使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。</p>\n<h5 id=\"启用-JavaScript\"><a href=\"#启用-JavaScript\" class=\"headerlink\" title=\"启用 JavaScript\"></a>启用 JavaScript</h5><p>启用 JavaScript 也非常简单：</p>\n<pre><code>HtmlUnitDriver driver = new HtmlUnitDriver(true);\n</code></pre><p>上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。</p>\n<h3 id=\"Firefox-Driver\"><a href=\"#Firefox-Driver\" class=\"headerlink\" title=\"Firefox Driver\"></a>Firefox Driver</h3><p>我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（<a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55\" target=\"_blank\" rel=\"external\">see the source to see which ones</a>）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。</p>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new FirefoxDriver();\n</code></pre><h4 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>在真实的浏览器里运行，且支持 JavaScript</li>\n<li>比 IE Driver 快</li>\n</ul>\n<h4 id=\"劣势-1\"><a href=\"#劣势-1\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>比 HtmlUnit Driver 慢</li>\n<li>需要修改 Firefox 配置</li>\n</ul>\n<p>例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：</p>\n<pre><code>ProfilesIni allProfiles = new ProfilesIni();\nFirefoxProfile profile = allProfiles.getProfile(&quot;WebDriver&quot;);\nprofile.setPreferences(&quot;foo.bar&quot;, 23);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>如果配置文件没有注册至 Firefox：</p>\n<pre><code>File profileDir = new File(&quot;path/to/top/level/of/profile&quot;);\nFirefoxProfile profile = new FirefoxProfile(profileDir);\nprofile.addAdditionalPreferences(extraPrefs);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.setEnableNativeEvents(true);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><h4 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/FirefoxDriver\" target=\"_blank\" rel=\"external\">Firefox section in the wiki page</a> 以获得更多新鲜信息。</p>\n<h3 id=\"Internet-Explorer-Driver\"><a href=\"#Internet-Explorer-Driver\" class=\"headerlink\" title=\"Internet Explorer Driver\"></a>Internet Explorer Driver</h3><p>这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。</p>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new InternetExplorerDriver();\n</code></pre><h4 id=\"优势-2\"><a href=\"#优势-2\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。</li>\n</ul>\n<h4 id=\"劣势-2\"><a href=\"#劣势-2\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>显然它只在 Windows 系统上有效。</li>\n<li>相对较慢。</li>\n<li>Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。</li>\n<li>IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。</li>\n<li>IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.</li>\n</ul>\n<h4 id=\"信息-1\"><a href=\"#信息-1\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>访问 <a href=\"http://code.google.com/p/selenium/wiki/InternetExplorerDriver\" target=\"_blank\" rel=\"external\">Internet Explorer section of the wiki page</a> 以获得更多新鲜信息。特别注意配置部分的内容。</p>\n<h3 id=\"Chrome-Driver\"><a href=\"#Chrome-Driver\" class=\"headerlink\" title=\"Chrome Driver\"></a>Chrome Driver</h3><p>Chrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\" target=\"_blank\" rel=\"external\">wiki</a> 以获得更多信息。</p>\n<h4 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new ChromeDriver();\n</code></pre><h4 id=\"优势-3\"><a href=\"#优势-3\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>运行在真实的浏览器中，并且支持 JavaScript。</li>\n<li>由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。</li>\n</ul>\n<h4 id=\"劣势-3\"><a href=\"#劣势-3\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>比 HtmlUnit 慢</li>\n</ul>\n<h4 id=\"信息-2\"><a href=\"#信息-2\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\" target=\"_blank\" rel=\"external\">wiki</a> 以获得更多最新信息。更多信息可以在 <a href=\"http://seleniumhq.org/download/\" target=\"_blank\" rel=\"external\">下载页面</a> 找到。</p>\n<h4 id=\"运行-Chrome-Driver\"><a href=\"#运行-Chrome-Driver\" class=\"headerlink\" title=\"运行 Chrome Driver\"></a>运行 Chrome Driver</h4><p>下载 <a href=\"http://code.google.com/p/chromium/downloads/list\" target=\"_blank\" rel=\"external\">Chrome Driver</a> 并参考 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\" target=\"_blank\" rel=\"external\">wiki</a> 上的其他建议。</p>\n<h3 id=\"Opera-Driver\"><a href=\"#Opera-Driver\" class=\"headerlink\" title=\"Opera Driver\"></a>Opera Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/OperaDriver\" target=\"_blank\" rel=\"external\">wiki</a></p>\n<h3 id=\"iPhone-Driver\"><a href=\"#iPhone-Driver\" class=\"headerlink\" title=\"iPhone Driver\"></a>iPhone Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/IPhoneDriver\" target=\"_blank\" rel=\"external\">wiki</a></p>\n<h3 id=\"Android-Driver\"><a href=\"#Android-Driver\" class=\"headerlink\" title=\"Android Driver\"></a>Android Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/AndroidDriver\" target=\"_blank\" rel=\"external\">wiki</a></p>\n<h2 id=\"可选择的后端：混合-WebDriver-和-RC-技术\"><a href=\"#可选择的后端：混合-WebDriver-和-RC-技术\" class=\"headerlink\" title=\"可选择的后端：混合 WebDriver 和 RC 技术\"></a>可选择的后端：混合 WebDriver 和 RC 技术</h2><h3 id=\"WebDriver-Backed-Selenium-RC\"><a href=\"#WebDriver-Backed-Selenium-RC\" class=\"headerlink\" title=\"WebDriver-Backed Selenium-RC\"></a>WebDriver-Backed Selenium-RC</h3><p>Java 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。</p>\n<p>Selenium-WebDriver 的用法如下：</p>\n<pre><code>// 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。\nWebDriver driver = new FirefoxDriver();\n\n// 基准 url，selenium 用于解析相对路径。\n String baseUrl = &quot;http://www.google.com&quot;;\n\n// 创建一个 Selenium 实现。\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl);\n\n// 使用 selenium 进行一些操作。\nselenium.open(&quot;http://www.google.com&quot;);\nselenium.type(&quot;name=q&quot;, &quot;cheese&quot;);\nselenium.click(&quot;name=btnG&quot;);\n\n// Get the underlying WebDriver implementation back. This will refer to the\n// same WebDriver instance as the &quot;driver&quot; variable above.\nWebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();\n\n// 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。\n// 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。\nselenium.stop();\n</code></pre><h4 id=\"优势-4\"><a href=\"#优势-4\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>允许 WebDriver 和 Selenium API 并存。</li>\n<li>提供了简单的机制从 Selenium RC API 迁移至 WebDriver。</li>\n<li>不需要运行 Selenium RC server。</li>\n</ul>\n<h4 id=\"劣势-4\"><a href=\"#劣势-4\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>没有实现所有的方法。</li>\n<li>一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。</li>\n<li>由于底层的实现，有些方法会比较慢。</li>\n</ul>\n<h3 id=\"Backing-WebDriver-with-Selenium\"><a href=\"#Backing-WebDriver-with-Selenium\" class=\"headerlink\" title=\"Backing WebDriver with Selenium\"></a>Backing WebDriver with Selenium</h3><p>WebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。</p>\n<p>通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：</p>\n<pre><code>DesiredCapabilities capabilities = new DesiredCapabilities();\ncapabilities.setBrowserName(&quot;safari&quot;);\nCommandExecutor executor = new SeleneseCommandExecutor(new URL(&quot;http://localhost:4444/&quot;), new URL(&quot;http://www.google.com/&quot;), capabilities);\nWebDriver driver = new RemoteWebDriver(executor, capabilities);\n</code></pre><p>这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。</p>\n<h2 id=\"运行-Selenium-Server-以使用-RemoteDrivers¶\"><a href=\"#运行-Selenium-Server-以使用-RemoteDrivers¶\" class=\"headerlink\" title=\"运行 Selenium Server 以使用 RemoteDrivers¶\"></a>运行 Selenium Server 以使用 RemoteDrivers¶</h2><p>从 <a href=\"https://code.google.com/p/selenium/downloads/list\" target=\"_blank\" rel=\"external\">Selenium 下载页面</a> 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 <a href=\"http://chromedriver.googlecode.com/\" target=\"_blank\" rel=\"external\">google code</a> 下载它。</version></p>\n<p>把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。</p>\n<p>从命令行启动服务：</p>\n<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar\n</code></pre><p>如果你希望使用本地事件功能，在命令行添加以下参数：</p>\n<pre><code>-Dwebdriver.enable.native.events=1\n</code></pre><p>查看帮助：</p>\n<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar -help\n</code></pre><p>为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。</p>\n<h2 id=\"更多资源\"><a href=\"#更多资源\" class=\"headerlink\" title=\"更多资源\"></a>更多资源</h2><p>你可以在 <a href=\"http://code.google.com/p/selenium/wiki/FurtherResources\" target=\"_blank\" rel=\"external\">WebDriver wiki</a> 找到更多有用的资源。</p>\n<p>当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：<a href=\"http://groups.google.com/group/selenium-users。\" target=\"_blank\" rel=\"external\">http://groups.google.com/group/selenium-users。</a></p>\n<h2 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a>接下来</h2><p>本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。</p>\n","excerpt":"<h1 id=\"Selenium-WebDriver\"><a href=\"#Selenium-WebDriver\" class=\"headerlink\" title=\"Selenium WebDriver\"></a>Selenium WebDriver</h1><p>注意：本章内容官方团队正在完善中。</p>\n<h2 id=\"介绍-WebDriver\"><a href=\"#介绍-WebDriver\" class=\"headerlink\" title=\"介绍 WebDriver\"></a>介绍 WebDriver</h2><p>Selenium 2.0 最主要的一个新特性就是集成了 WebDriver API。WebDriver 提供更精简的编程几口，以解决 Selenium-RC API 中的一些限制。WebDriver 为那些页面元素可以不通过页面重新加载来更新的动态网页提供了更好的支持。WebDriver 的目标是提供一套精心设计的面向对象的 API 来更好的支持现代高级 web 应用的测试工作。</p>\n<h2 id=\"同-Selenium-RC-相比，WebDriver-如何驱动浏览器的？\"><a href=\"#同-Selenium-RC-相比，WebDriver-如何驱动浏览器的？\" class=\"headerlink\" title=\"同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？\"></a>同 Selenium-RC 相比，WebDriver 如何驱动浏览器的？</h2><p>Selenium-WebDriver 直接通过浏览器自动化的本地接口来调用浏览器。如何直接调用，和调用的细节取决于你使用什么浏览器。本章后续的内容介绍了每个 “browser driver” 的详细信息。</p>\n<p>相比 Selenium-RC ，WebDriver 确实非常不一样。Selenium-RC 在所有支持的浏览器中工作原理是一样的。它将 JavaScript 在浏览器加载的时候注入浏览器，然后使用这些 JavaScript 驱动 AUT 运行 WebDriver 使用的是不同的技术，再一次强调，它是直接调用浏览器自动化的本地接口。<br>","more":"</p>\n<h2 id=\"WebDriver-和-Selenium-Server\"><a href=\"#WebDriver-和-Selenium-Server\" class=\"headerlink\" title=\"WebDriver 和 Selenium-Server\"></a>WebDriver 和 Selenium-Server</h2><p>你可能需要，也可能不需要 Selenium Server，取决于你打算如何使用 Selenium-WebDriver。如果你仅仅需要使用 WebDriver API，那就不需要 Selenium-Server。如果你所有的测试和浏览器都在一台机器上，那么你仅需要 WebDriver API。WebDriver 将直接操作浏览器。</p>\n<p>在有些情况下，你需要使用 Selenium-Server 来配合 Selenium-WebDriver 工作，例如：</p>\n<ul>\n<li>你使用 Selenium-Grid 来分发你的测试给多个机器或者虚拟机。</li>\n<li>你希望连接一台远程的机器来测试一个特定的浏览器。</li>\n<li>你没有使用 Java 绑定（例如 Python, C#, 或 Ruby），并且可能希望使用 HtmlUnit Driver。</li>\n</ul>\n<h2 id=\"设置一个-Selenium-WebDriver-项目\"><a href=\"#设置一个-Selenium-WebDriver-项目\" class=\"headerlink\" title=\"设置一个 Selenium-WebDriver 项目\"></a>设置一个 Selenium-WebDriver 项目</h2><p>安装 Selenium 意味着当你创建一个项目，你可以在项目中使用 Selenium 开发。具体怎么做取决于你的项目语言和开发环境。</p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><p>创建一个 Selenium 2.0 Java 项目最简单的方式是使用 maven。Maven 将下载 Java 绑定（Selenium 2.0 的 Java 客户端）和其所有依赖，并且通过 pom.xml（mvn项目配置）为你创建项目。当你完成这些操作的时候，你可以将 maven 项目导入到你偏好的 IDE 中，例如 IntelliJ IDEA 或 Eclipse。</p>\n<p>首先，创建一个用于放置项目的文件夹。然后，在这个文件夹中创建 pom.xml 文件，内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n             xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;MySel20Proj&lt;/groupId&gt;\n    &lt;artifactId&gt;MySel20Proj&lt;/artifactId&gt;\n    &lt;version&gt;1.0&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;\n            &lt;version&gt;2.28.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.opera&lt;/groupId&gt;\n            &lt;artifactId&gt;operadriver&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.opera&lt;/groupId&gt;\n                &lt;artifactId&gt;operadriver&lt;/artifactId&gt;\n                &lt;version&gt;1.1&lt;/version&gt;\n                &lt;exclusions&gt;\n                    &lt;exclusion&gt;\n                        &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n                        &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n                    &lt;/exclusion&gt;\n                &lt;/exclusions&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n&lt;/project&gt;\n</code></pre><p>确保你指定了最新版本。在编写本文档时，范例代码中的即为最新版本。但是，稍后 Selenium 2.0 还会不断有新发布。检查 <a href=\"http://seleniumhq.org/download/maven.html\">Maven 下载页面</a> 中的最新版本，并修改上述文件中依赖的版本。</p>\n<p>命令行进入本目录，运行如下命令：</p>\n<pre><code>mvn clean install\n</code></pre><p>该命令会下载 Selenium 和其所有依赖，并添加到这个项目中。</p>\n<p>最后，将项目导入到你的 IDE。对于不太熟悉 IDE 的用户，我们提供了附件来说明相关内容。</p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-intellij-reference\">Importing a maven project into IntelliJ IDEA</a></p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_installing_java_driver_Sel20_via_maven.jsp#importing-maven-into-eclipse-reference\">Importing a maven project into Eclipse</a></p>\n<h2 id=\"从-Selenium-1-0-迁移\"><a href=\"#从-Selenium-1-0-迁移\" class=\"headerlink\" title=\"从 Selenium 1.0 迁移\"></a>从 Selenium 1.0 迁移</h2><p>对于那些已经使用 Selenium 1.0 编写测试套件的用户，我们提供了一些迁移的建议。Selenium 2.0 的核心工程师 Simon Stewart 写了一篇关于从 Selenium 1.0 迁移的文章，包含在本文的附件中。</p>\n<p><a href=\"http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.jsp#migrating-to-webdriver-reference\">Migrating From Selenium RC to Selenium WebDriver</a></p>\n<h2 id=\"实例介绍-Selenium-WebDriver-API\"><a href=\"#实例介绍-Selenium-WebDriver-API\" class=\"headerlink\" title=\"实例介绍 Selenium-WebDriver API\"></a>实例介绍 Selenium-WebDriver API</h2><p>WebDriver 是一个进行 web 应用测试自动化的工具，主要用于验证它们的行为是否符合期望。WebDriver 的目标是提供一套易于掌握的 API，且比 Selenium-RC (1.0) 更易于使用，页能是你的测试更具可读性和维护性。它没有同任何特定的测试框架进行绑定，所以可以在单元测试或者是 main 方法中工作良好。本小节介绍  WebDriver API，并且帮助你熟悉它。如果你还没有任何 WebDriver 项目，请按照上一小节的介绍新建一个。  </p>\n<p>建好项目后，你可以发现 WebDriver 和任何普通的库一样：它是自包含的，通常不需要进行任何额外的处理或者运行安装。这一点和 Selenium-RC 的代理服务器是不一样的。</p>\n<p><strong>注意：</strong> 使用 Chrome Driver、 Opera Driver、Android Driver 和 iPhone Driver 是需要一些额外操作的。</p>\n<p>我们准备了一个简单的例子：在 Google 上搜索 “Cheese”，然偶输出搜索结果页的页面标题到 console。</p>\n<pre><code>package org.openqa.selenium.example;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\npublic class Selenium2Example  {\n    public static void main(String[] args) {\n        // 创建了一个 Firefox driver 的实例\n        // 注意，其余的代码依赖于接口而非实例\n        WebDriver driver = new FirefoxDriver();\n\n        // 使用它访问 Google\n        driver.get(&quot;http://www.google.com&quot;);\n        // 同样的事情也可以通过以下代码完成\n        // driver.navigate().to(&quot;http://www.google.com&quot;);\n\n        // 找到搜索输入框\n        WebElement element = driver.findElement(By.name(&quot;q&quot;));\n\n        // 输入要查找的词\n        element.sendKeys(&quot;Cheese!&quot;);\n\n        // 提交表单\n        element.submit();\n\n        // 检查页面标题\n        System.out.println(&quot;Page title is: &quot; + driver.getTitle());\n\n        // Google 搜索结果由 JavaScript 动态渲染\n        // 等待页面加载完毕，超时时间设为10秒\n        (new WebDriverWait(driver, 10)).until(new ExpectedCondition&lt;Boolean&gt;() {\n            public Boolean apply(WebDriver d) {\n                return d.getTitle().toLowerCase().startsWith(&quot;cheese!&quot;);\n            }\n        });\n\n        //应该能看到: &quot;cheese! - Google Search&quot;\n        System.out.println(&quot;Page title is: &quot; + driver.getTitle());\n\n        //关闭浏览器\n        driver.quit();\n    }\n}\n</code></pre><p>在接下来的章节中，你将学习到更多使用 WebDriver 的知识，例如根据浏览器历史记录前进和后退，如何测试 frames 和 windows。针对这些点我们提供了全面的讨论和范例。</p>\n<h2 id=\"Selenium-WebDriver-API-和操作\"><a href=\"#Selenium-WebDriver-API-和操作\" class=\"headerlink\" title=\"Selenium-WebDriver API 和操作\"></a>Selenium-WebDriver API 和操作</h2><h3 id=\"获取一个页面\"><a href=\"#获取一个页面\" class=\"headerlink\" title=\"获取一个页面\"></a>获取一个页面</h3><p>访问一个页面或许是使用 WebDriver 时你第一件想要做的事情。最常见的是调用 “get” 方法：</p>\n<pre><code>driver.get(&quot;http://www.google.com&quot;);\n</code></pre><p>包括操作系统和浏览器在内的多种因素影响，WebDriver 可能会也可能不会等待页面加载。在某些情况下，WebDriver可能在页面加载完毕前就返回控制了，甚至是开始加载之前。为了确保健壮性，你需要使用 <a href=\"http://seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits-reference\">Explicit and Implicit Waits</a> 等到页面元素可用。</p>\n<h3 id=\"查找-UI-元素（web-元素）\"><a href=\"#查找-UI-元素（web-元素）\" class=\"headerlink\" title=\"查找 UI 元素（web 元素）\"></a>查找 UI 元素（web 元素）</h3><p>WebDriver 实例可以查找 UI 元素。每种语言实现都暴露了 “查找单个元素” 和 “查找所有元素” 的方法。第一个方法如果找到则返回该元素，如果没找到则抛出异常。第二种如果找到则返回一个包含所有元素的列表，如果没找到则返回一个空数组。</p>\n<p>“查找” 方法使用了一个定位器或者一个叫 “By” 的查询对象。“By” 支持的元素查找策略如下：</p>\n<h4 id=\"By-id\"><a href=\"#By-id\" class=\"headerlink\" title=\"By id\"></a>By id</h4><p>这是最高效也是首选的方法用于查找一个元素。UI 开发人员常犯的错误是，要么没有指定 id，要么自动生成随机 id，这两种情况都应避免。及时是使用 class 也比使用自动生成随机 id 要好的多。</p>\n<p>HTML:</p>\n<pre><code>&lt;div id=&quot;coolestWidgetEvah&quot;&gt;...&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement element = driver.findElement(By.id(&quot;coolestWidgetEvah&quot;));\n</code></pre><h4 id=\"By-Class-Name\"><a href=\"#By-Class-Name\" class=\"headerlink\" title=\"By Class Name\"></a>By Class Name</h4><p>“class” 是 DOM 元素上的一个属性。在实践中，通常是多个 DOM 元素有同样的 class 名，所以通常用它来查找多个元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>List&lt;WebElement&gt; cheeses = driver.findElements(By.className(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Tag-Name\"><a href=\"#By-Tag-Name\" class=\"headerlink\" title=\"By Tag Name\"></a>By Tag Name</h4><p>根据元素标签名查找。</p>\n<p>HTML:</p>\n<pre><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement frame = driver.findElement(By.tagName(&quot;iframe&quot;));\n</code></pre><h4 id=\"By-Name\"><a href=\"#By-Name\" class=\"headerlink\" title=\"By Name\"></a>By Name</h4><p>查找 name 属性匹配的表单元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;input name=&quot;cheese&quot; type=&quot;text&quot;/&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.name(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Link-Text\"><a href=\"#By-Link-Text\" class=\"headerlink\" title=\"By Link Text\"></a>By Link Text</h4><p>查找链接文字匹配的链接元素。</p>\n<p>HTML：</p>\n<pre><code>&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;cheese&lt;/a&gt;&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.linkText(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-Partial-Link-Text\"><a href=\"#By-Partial-Link-Text\" class=\"headerlink\" title=\"By Partial Link Text\"></a>By Partial Link Text</h4><p>查找链接文字部分匹配的链接元素。</p>\n<p>HTML:</p>\n<pre><code>&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;search for cheese&lt;/a&gt;&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.partialLinkText(&quot;cheese&quot;));\n</code></pre><h4 id=\"By-CSS\"><a href=\"#By-CSS\" class=\"headerlink\" title=\"By CSS\"></a>By CSS</h4><p>正如名字所表明的，它通过 css 来定位元素。默认使用浏览器本地支持的选择器，可参考 w3c 的 <a href=\"http://www.w3.org/TR/CSS/#selectors\">css 选择器</a>。如果浏览器默认不支持 css 查询，则使用 Sizzle。ie6、7 和 ff3.0 都使用了 Sizzle。</p>\n<p>注意使用 css 选择器不能保证在所有浏览器里都表现一样，有些在某些浏览器里工作良好，在另一些浏览器里可能无法工作。</p>\n<p>HTML:</p>\n<pre><code>&lt;div id=&quot;food&quot;&gt;&lt;span class=&quot;dairy&quot;&gt;milk&lt;/span&gt;&lt;span class=&quot;dairy aged&quot;&gt;cheese&lt;/span&gt;&lt;/div&gt;\n</code></pre><p>Java：</p>\n<pre><code>WebElement cheese = driver.findElement(By.cssSelector(&quot;#food span.dairy.aged&quot;));\n</code></pre><h4 id=\"By-XPATH\"><a href=\"#By-XPATH\" class=\"headerlink\" title=\"By XPATH\"></a>By XPATH</h4><p>此处略过不译</p>\n<h3 id=\"用户输入-填充表单\"><a href=\"#用户输入-填充表单\" class=\"headerlink\" title=\"用户输入 - 填充表单\"></a>用户输入 - 填充表单</h3><p>我们已经了解了怎么在输入框或者文本框中输入文字，但是如何操作其他的表单元素呢？你可以切换多选框的选中状态，你可以通过“点击”以选中一个 select 的选项。操作 select 元素不是一件很难的事情：</p>\n<pre><code>WebElement select = driver.findElement(By.tagName(&quot;select&quot;));\nList&lt;WebElement&gt; allOptions = select.findElements(By.tagName(&quot;option&quot;));\nfor (WebElement option : allOptions) {\n    System.out.println(String.format(&quot;Value is: %s&quot;, option.getAttribute(&quot;value&quot;)));\n    option.click();\n}\n</code></pre><p>上述代码将找到页面中第一个 select 元素，然后遍历其中的每个 option，打印其值，再依次进行点击操作以选中这个 option。这并不是处理 select 元素最高效的方式。WebDriver<br>有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。</p>\n<pre><code>Select select = new Select(driver.findElement(By.tagName(&quot;select&quot;)));\nselect.deselectAll();\nselect.selectByVisibleText(&quot;Edam&quot;);\n</code></pre><p>上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。</p>\n<p>如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。</p>\n<pre><code>driver.findElement(By.id(&quot;submit&quot;)).click();\n</code></pre><p>或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。</p>\n<pre><code>element.submit();\n</code></pre><h3 id=\"在窗口和帧-frames-之间切换\"><a href=\"#在窗口和帧-frames-之间切换\" class=\"headerlink\" title=\"在窗口和帧(frames)之间切换\"></a>在窗口和帧(frames)之间切换</h3><p>有些 web 应用含有多个帧或者窗口。WebDriver 支持通过使用 “switchTo” 方法在多个帧或者窗口之间切换。</p>\n<pre><code>driver.switchTo().window(&quot;windowName&quot;);\n</code></pre><p>所有 dirver 上的方法调用均被解析为指向这个特定的窗口。但是我们如何知道这个窗口的名字？来看一个打开窗口的链接：</p>\n<pre><code>&lt;a href=&quot;somewhere.html&quot; target=&quot;windowName&quot;&gt;Click here to open a new window&lt;/a&gt;\n</code></pre><p>你可以将 “window handle” 传递给 “switchTo().window()” 方法。因此，你可以通过如下方法遍历所有打开的窗口：</p>\n<p>   for (String handle : driver.getWindowHandles()) {<br>        driver.switchTo().window(handle);<br>    }</p>\n<p>你也可以切换到指定帧：</p>\n<pre><code>driver.switchTo().frame(&quot;frameName&quot;);\n</code></pre><p>你可以通过点分隔符来访问子帧，也可以通过索引号指定它，例如：</p>\n<pre><code>driver.switchTo().frame(&quot;frameName.0.child&quot;);\n</code></pre><p>该方法将查找到名为 “frameName” 的帧的第一个子帧的名为 “child” 的子帧。所有帧的计算都会从 <strong>top</strong> 开始。</p>\n<h3 id=\"弹出框\"><a href=\"#弹出框\" class=\"headerlink\" title=\"弹出框\"></a>弹出框</h3><p>由 Selenium 2.0 beta 1 开始，就内置了对弹出框的处理。如果你触发了一个弹出框，你可以通过如下方访问到它：</p>\n<pre><code>Alert alert = driver.switchTo().alert();\n</code></pre><p>该方法将返回目前被打开的弹出框。通过这个返回对象，你可以访问、关闭、读取它的内容甚至在 prompt 中输入一些内容。这个接口可以胜任 alerts,comfirms 和 prompts 的处理。</p>\n<h3 id=\"导航：历史记录和位置\"><a href=\"#导航：历史记录和位置\" class=\"headerlink\" title=\"导航：历史记录和位置\"></a>导航：历史记录和位置</h3><p>更早的时候，我们通过 “get” 方法来访问一个页面 (driver.get(“<a href=\"http://www.example.com&quot;))。正如你所见，WebDriver\">http://www.example.com&quot;))。正如你所见，WebDriver</a> 有一些更小巧的、聚焦任务的接口，而 navigation 就是其中一个非常有用的任务。因为加载页面是一个非常基本的需求，实现该功能的方法取决于 WebDriver 暴露的接口。它等同于如下代码：</p>\n<pre><code>driver.navigate().to(&quot;http://www.example.com&quot;);\n</code></pre><p>重申一下: “navigate().to()” 和 “get()” 做的事情是完全一样的。只是前者更易用。</p>\n<p>“navigate” 接口暴露了访问浏览器历史记录的接口：</p>\n<pre><code>driver.navigate().forward();\ndriver.navigate().back();\n</code></pre><p>需要注意的是，该功能的表现完全依赖于你所使用的浏览器。如果你习惯了一种浏览器，那么在另一种浏览器中使用它时，完全可能发生一些意外的事情。</p>\n<h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>在我们继续介绍更多内容之前，还有必要介绍一下如何操作 cookie。首先，你必须在 cookie 所在的域。如果你希望在加载一个大页面之前重设 cookie，你可以先访问站点中一个较小的页面，典型的是 404 页面 (<a href=\"http://example.com/some404page)。\">http://example.com/some404page)。</a></p>\n<pre><code>// 进到正确的域\ndriver.get(&quot;http://www.example.com&quot;);\n\n// 设置 cookie，这个cookie 对整个域都有效\nCookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);\ndriver.manage().addCookie(cookie);\n\n// 输出当前 url 所有可用的 cookie\nSet&lt;Cookie&gt; allCookies = driver.manage().getCookies();\nfor (Cookie loadedCookie : allCookies) {\n    System.out.println(String.format(&quot;%s -&gt; %s&quot;, loadedCookie.getName(), loadedCookie.getValue()));\n}\n\n// 你可以通过3中方式删除 cookie\n// By name\ndriver.manage().deleteCookieNamed(&quot;CookieName&quot;);\n// By Cookie\ndriver.manage().deleteCookie(loadedCookie);\n// Or all of them\ndriver.manage().deleteAllCookies();\n</code></pre><h3 id=\"改变-UA\"><a href=\"#改变-UA\" class=\"headerlink\" title=\"改变 UA\"></a>改变 UA</h3><p>当使用 Firefox Driver 的时候这很容易：</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.addAdditionalPreference(&quot;general.useragent.override&quot;, &quot;some UA string&quot;);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><h3 id=\"拖拽\"><a href=\"#拖拽\" class=\"headerlink\" title=\"拖拽\"></a>拖拽</h3><p>以下代码演示了如何使用 “Actions” 类来实现拖拽。浏览器本地方法必须要启用：</p>\n<pre><code>WebElement element = driver.findElement(By.name(&quot;source&quot;));\nWebElement target = driver.findElement(By.name(&quot;target&quot;));\n\n(new Actions(driver)).dragAndDrop(element, target).perform();\n</code></pre><h2 id=\"Driver-特性和权衡\"><a href=\"#Driver-特性和权衡\" class=\"headerlink\" title=\"Driver 特性和权衡\"></a>Driver 特性和权衡</h2><h2 id=\"Selenium-WebDriver’s-Drivers\"><a href=\"#Selenium-WebDriver’s-Drivers\" class=\"headerlink\" title=\"Selenium-WebDriver’s Drivers\"></a>Selenium-WebDriver’s Drivers</h2><p>WebDriver 是编写测试时需要用到的方法的主要接口，这套接口有几套实现。包括：</p>\n<h3 id=\"HtmlUnit-Driver\"><a href=\"#HtmlUnit-Driver\" class=\"headerlink\" title=\"HtmlUnit Driver\"></a>HtmlUnit Driver</h3><p>这是目前 WebDriver 最快速最轻量的实现。顾名思义，它是基于 HtmlUnit 的。HtmlUnit 是一个由 Java 实现的没有 GUI 的浏览器。任何非 Java 的语言绑定， Selenium Server 都需要使用这个 driver。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new HtmlUnitDriver();\n</code></pre><h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>WebDriver 最快速的实现</li>\n<li>纯 Java 实现，跨平台</li>\n<li>支持 JavaScript</li>\n</ul>\n<h4 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>需要模拟浏览器中 JavaScript 的行为（如下）。</li>\n</ul>\n<h4 id=\"JavaScript-in-the-HtmlUnit-Driver\"><a href=\"#JavaScript-in-the-HtmlUnit-Driver\" class=\"headerlink\" title=\"JavaScript in the HtmlUnit Driver\"></a>JavaScript in the HtmlUnit Driver</h4><p>没有任何一个主流浏览器支持 HtmlUnit 使用的 JavaScript 引擎（Rhino）。如果你使用 HtmlUnit，测试结果可能和真实在浏览器中跑的很不一样。</p>\n<p>当我们说到 “JavaScript” 时通常是指 “JavaScript 和 DOM”。虽然 DOM 由 W3C 组织定义，但是每个浏览器在 DOM 和 JavaScript 的交互的实现方面都有一些怪异和不同的地方。HtmlUnit 完全实现了 DOM 规范，并且对 JavaScript 提供了良好的支持，但它的实现和真实的浏览器都不一样：虽然它模拟了浏览器中的实现，但既不同于 W3C 指定的标准，也不同于其他主流浏览器的实现。</p>\n<p>使用 WebDriver，我们需要做出选择：如果我们启用 HtmlUnit 的 JavaScript 支持，团队可能会遇到只有在这中情况下才会遇到的问题；如果我们禁用 JavaScript，但实际上越来越多的网站都依赖于 JavaScript。我们使用了最保守的方式，默认禁用 JavaScript 支持。对于 WebDriver 和 HtmlUnit 的每个发布版本，我们都会再次评估：这个版本是否可以默认开启 JavaScript 支持。</p>\n<h5 id=\"启用-JavaScript\"><a href=\"#启用-JavaScript\" class=\"headerlink\" title=\"启用 JavaScript\"></a>启用 JavaScript</h5><p>启用 JavaScript 也非常简单：</p>\n<pre><code>HtmlUnitDriver driver = new HtmlUnitDriver(true);\n</code></pre><p>上述代码会使得 HtmlUnit Driver 模拟 Firefox3.6 对 JavaScript 的处理。</p>\n<h3 id=\"Firefox-Driver\"><a href=\"#Firefox-Driver\" class=\"headerlink\" title=\"Firefox Driver\"></a>Firefox Driver</h3><p>我们通过一个 Firefox 的插件来控制 Firefox 浏览器。使用的配置文件是从默认安装的版本精简成只包含 Selenium WebDriver.xpi (插件) 的版本。我们还修改了一些默认配置（<a href=\"http://code.google.com/p/selenium/source/browse/trunk/java/client/src/org/openqa/selenium/firefox/FirefoxProfile.java#55\">see the source to see which ones</a>）,使得 Firefox Driver 可以运行和测试在 Windows、Mac、Linux 上。</p>\n<h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new FirefoxDriver();\n</code></pre><h4 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>在真实的浏览器里运行，且支持 JavaScript</li>\n<li>比 IE Driver 快</li>\n</ul>\n<h4 id=\"劣势-1\"><a href=\"#劣势-1\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>比 HtmlUnit Driver 慢</li>\n<li>需要修改 Firefox 配置</li>\n</ul>\n<p>例如你想修改 UA，但是你得到的是一个假的包含很多扩展的配置文件。这里有两种方式可以拿到真是的配置，假定配置文件是由 Firefox 配置管理器生成的：</p>\n<pre><code>ProfilesIni allProfiles = new ProfilesIni();\nFirefoxProfile profile = allProfiles.getProfile(&quot;WebDriver&quot;);\nprofile.setPreferences(&quot;foo.bar&quot;, 23);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>如果配置文件没有注册至 Firefox：</p>\n<pre><code>File profileDir = new File(&quot;path/to/top/level/of/profile&quot;);\nFirefoxProfile profile = new FirefoxProfile(profileDir);\nprofile.addAdditionalPreferences(extraPrefs);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>当我们开发 Firefox Driver 的特性时，需要评估它们是否可用。例如，直到我们认为本地方法在 Linux 的 Firefox 上是稳定的了，否则我们会默认禁用它。如需开启：</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.setEnableNativeEvents(true);\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><h4 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/FirefoxDriver\">Firefox section in the wiki page</a> 以获得更多新鲜信息。</p>\n<h3 id=\"Internet-Explorer-Driver\"><a href=\"#Internet-Explorer-Driver\" class=\"headerlink\" title=\"Internet Explorer Driver\"></a>Internet Explorer Driver</h3><p>这个 driver 由一个 .dll 文件控制，并且只在 windows 系统中可用。每个 Selenium 的发布版本都包含可用于测试的核心功能，兼容 XP 上的 ie6、7、8 和 Windows7 上的 ie9。</p>\n<h4 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new InternetExplorerDriver();\n</code></pre><h4 id=\"优势-2\"><a href=\"#优势-2\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>运行在真实的浏览器中，并且支持 JavaScript，包括最终用户会碰到的一些怪异的问题。</li>\n</ul>\n<h4 id=\"劣势-2\"><a href=\"#劣势-2\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>显然它只在 Windows 系统上有效。</li>\n<li>相对较慢。</li>\n<li>Xpath 在很多版本中都是非原生支持。Sizzle 会注入到浏览器，这使得它比其他浏览器要慢很多，也比在相同的浏览器中使用 CSS 选择器要慢。</li>\n<li>IE 6、7 不支持 CSS 选择器，由 Sizzle 注入替代。</li>\n<li>IE 8、9 虽然原生支持 CSS 选择器，但它们不完全支持 CSS3.</li>\n</ul>\n<h4 id=\"信息-1\"><a href=\"#信息-1\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>访问 <a href=\"http://code.google.com/p/selenium/wiki/InternetExplorerDriver\">Internet Explorer section of the wiki page</a> 以获得更多新鲜信息。特别注意配置部分的内容。</p>\n<h3 id=\"Chrome-Driver\"><a href=\"#Chrome-Driver\" class=\"headerlink\" title=\"Chrome Driver\"></a>Chrome Driver</h3><p>Chrome Driver 由 Chromium 项目团队自己维护和支持。WebDriver 通过 chromedriver 二进制包（可以在 chromiun 的下载页面找到）来工作。你需要确保同时安装了某版本的 chrome 浏览器和 chromedriver。chromedriver 需要存放在某个指定的路径下使得 WebDriver 可以自动发现它。chromedriver 可以发现安装在默认路径下的 chrome 浏览器。这些都可以被环境变量覆盖。请查看 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\">wiki</a> 以获得更多信息。</p>\n<h4 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>WebDriver driver = new ChromeDriver();\n</code></pre><h4 id=\"优势-3\"><a href=\"#优势-3\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>运行在真实的浏览器中，并且支持 JavaScript。</li>\n<li>由于 chorme 是一个 webkit 内核的浏览器，Chrome Driver 能让你的站点在 Safari 中运行。注意自从 Chrome 使用了自己的 Javascript 引擎 V8 以后（之前是 Safari 的 Nitro 引擎），Javascript 的执行可能会一点不一样。</li>\n</ul>\n<h4 id=\"劣势-3\"><a href=\"#劣势-3\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>比 HtmlUnit 慢</li>\n</ul>\n<h4 id=\"信息-2\"><a href=\"#信息-2\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\">wiki</a> 以获得更多最新信息。更多信息可以在 <a href=\"http://seleniumhq.org/download/\">下载页面</a> 找到。</p>\n<h4 id=\"运行-Chrome-Driver\"><a href=\"#运行-Chrome-Driver\" class=\"headerlink\" title=\"运行 Chrome Driver\"></a>运行 Chrome Driver</h4><p>下载 <a href=\"http://code.google.com/p/chromium/downloads/list\">Chrome Driver</a> 并参考 <a href=\"http://code.google.com/p/selenium/wiki/ChromeDriver\">wiki</a> 上的其他建议。</p>\n<h3 id=\"Opera-Driver\"><a href=\"#Opera-Driver\" class=\"headerlink\" title=\"Opera Driver\"></a>Opera Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/OperaDriver\">wiki</a></p>\n<h3 id=\"iPhone-Driver\"><a href=\"#iPhone-Driver\" class=\"headerlink\" title=\"iPhone Driver\"></a>iPhone Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/IPhoneDriver\">wiki</a></p>\n<h3 id=\"Android-Driver\"><a href=\"#Android-Driver\" class=\"headerlink\" title=\"Android Driver\"></a>Android Driver</h3><p>查看 <a href=\"http://code.google.com/p/selenium/wiki/AndroidDriver\">wiki</a></p>\n<h2 id=\"可选择的后端：混合-WebDriver-和-RC-技术\"><a href=\"#可选择的后端：混合-WebDriver-和-RC-技术\" class=\"headerlink\" title=\"可选择的后端：混合 WebDriver 和 RC 技术\"></a>可选择的后端：混合 WebDriver 和 RC 技术</h2><h3 id=\"WebDriver-Backed-Selenium-RC\"><a href=\"#WebDriver-Backed-Selenium-RC\" class=\"headerlink\" title=\"WebDriver-Backed Selenium-RC\"></a>WebDriver-Backed Selenium-RC</h3><p>Java 版本的 WebDriver 提供了一套 Selenium-RC API 的实现。这意味着你可以使用 WebDriver 技术底层的 Selenium-RC API。这从根本上提供了向后兼容。这使得那些使用了 Selenium-RC API 的测试套件可以使用 WebDriver。这缓和了到 WebDriver 的迁移成本。同时，也允许你在同一个测试中使用两者的 API。</p>\n<p>Selenium-WebDriver 的用法如下：</p>\n<pre><code>// 你可以使用任何 WebDriver 的实现，这里以 Firefox 的为例。\nWebDriver driver = new FirefoxDriver();\n\n// 基准 url，selenium 用于解析相对路径。\n String baseUrl = &quot;http://www.google.com&quot;;\n\n// 创建一个 Selenium 实现。\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl);\n\n// 使用 selenium 进行一些操作。\nselenium.open(&quot;http://www.google.com&quot;);\nselenium.type(&quot;name=q&quot;, &quot;cheese&quot;);\nselenium.click(&quot;name=btnG&quot;);\n\n// Get the underlying WebDriver implementation back. This will refer to the\n// same WebDriver instance as the &quot;driver&quot; variable above.\nWebDriver driverInstance = ((WebDriverBackedSelenium) selenium).getWrappedDriver();\n\n// 最后，通过调用 WebDriverBackedSelenium 实例的 stop 方法关闭浏览器。\n// 应该避免使用 quit 方法，因为这样，在浏览器关闭后 jvm 还会继续运行。\nselenium.stop();\n</code></pre><h4 id=\"优势-4\"><a href=\"#优势-4\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>允许 WebDriver 和 Selenium API 并存。</li>\n<li>提供了简单的机制从 Selenium RC API 迁移至 WebDriver。</li>\n<li>不需要运行 Selenium RC server。</li>\n</ul>\n<h4 id=\"劣势-4\"><a href=\"#劣势-4\" class=\"headerlink\" title=\"劣势\"></a>劣势</h4><ul>\n<li>没有实现所有的方法。</li>\n<li>一些高级用法可能无效（例如 Selenium Core 中的 “browserbot” 或其他内置的 js 方法）。</li>\n<li>由于底层的实现，有些方法会比较慢。</li>\n</ul>\n<h3 id=\"Backing-WebDriver-with-Selenium\"><a href=\"#Backing-WebDriver-with-Selenium\" class=\"headerlink\" title=\"Backing WebDriver with Selenium\"></a>Backing WebDriver with Selenium</h3><p>WebDriver 支持的浏览器数量没有 Selenium RC 多，所以如果希望使用 WebDriver 时获得更多的浏览器支持，你可以使用 SeleneseCommandExecutor。</p>\n<p>通过下面的代码，WebDriver 可以支持 safari（确保禁用弹出层）：</p>\n<pre><code>DesiredCapabilities capabilities = new DesiredCapabilities();\ncapabilities.setBrowserName(&quot;safari&quot;);\nCommandExecutor executor = new SeleneseCommandExecutor(new URL(&quot;http://localhost:4444/&quot;), new URL(&quot;http://www.google.com/&quot;), capabilities);\nWebDriver driver = new RemoteWebDriver(executor, capabilities);\n</code></pre><p>这种方案有一些明显的限制，特别是 findElements 不会如预期工作。同时，我们使用了 Selenium Core 来驱动浏览器，所以你也会受到 JavaScript 的沙箱限制。</p>\n<h2 id=\"运行-Selenium-Server-以使用-RemoteDrivers¶\"><a href=\"#运行-Selenium-Server-以使用-RemoteDrivers¶\" class=\"headerlink\" title=\"运行 Selenium Server 以使用 RemoteDrivers¶\"></a>运行 Selenium Server 以使用 RemoteDrivers¶</h2><p>从 <a href=\"https://code.google.com/p/selenium/downloads/list\">Selenium 下载页面</a> 下载 selenium-server-standalone-<version>.jar，你也可以选择下载 IEDriverServer。如果你需要测试 chrome，则从 <a href=\"http://chromedriver.googlecode.com/\">google code</a> 下载它。</p>\n<p>把 IEDriverServer 和 chromedriver 解压到某个路径，并确保这个路径在 $PATH / %PATH% 中，这样 Selenium Server 就可以不需要任何设置就能操作 IE 和 chrome。</p>\n<p>从命令行启动服务：</p>\n<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar\n</code></pre><p>如果你希望使用本地事件功能，在命令行添加以下参数：</p>\n<pre><code>-Dwebdriver.enable.native.events=1\n</code></pre><p>查看帮助：</p>\n<pre><code>java -jar &lt;path_to&gt;/selenium-server-standalone-&lt;version&gt;.jar -help\n</code></pre><p>为了运转正常，以下端口应该允许 TCP 请求链接：4444， 7054-5（或两倍于你计划并发运行的实例数量）。在 Windows 中，你可能需要 unblock 这个应用。</p>\n<h2 id=\"更多资源\"><a href=\"#更多资源\" class=\"headerlink\" title=\"更多资源\"></a>更多资源</h2><p>你可以在 <a href=\"http://code.google.com/p/selenium/wiki/FurtherResources\">WebDriver wiki</a> 找到更多有用的资源。</p>\n<p>当然，你可以在互联网上搜索到更多 Selenium 的话题，包括 Selenium-WebDriver’s drivers。有不少博客和众多论坛的帖子谈及到 Selenium。另外，Selenium 用户群组也是很重要的资源：<a href=\"http://groups.google.com/group/selenium-users。\">http://groups.google.com/group/selenium-users。</a></p>\n<h2 id=\"接下来\"><a href=\"#接下来\" class=\"headerlink\" title=\"接下来\"></a>接下来</h2><p>本章节简要地从较高的层面介绍了 WebDriver 和其可信功能。一旦你熟悉了 Selenium WebDriver API 你可能会想要学习如何创建一个易于维护、可扩展的测试套件，并且提高哪些特性频繁修改的 AUT 的健壮性。大多数 Selenium 专家推荐的一种方式是：使用页面对象设计模式（可能是一个页面工厂）来设计你的测试代码。 Selenium WebDriver 在 Java 和 C sharp 中通过一个 PageFactory 类提供了这项支持。它同其他高级话题一样，将在下一章节讨论。同时，对于此项技术的较高层次的描述，你可以希望查看“测试设计考虑”章节。这两个章节都描述了如何通过模块化的思想使你的测试代码更易于维护。</p>"},{"layout":"post","title":"selenium wiki:高级用户交互","date":"2013-05-30T11:56:00.000Z","comments":1,"_content":"###AdvancedUserInteractions(高级用户交互)\n###入门\n高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。    \n####开始（short how to）\n为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：   \n\n    Actions builder = new Actions(driver);\n    \n    builder.keyDown(Keys.CONTROL)\n    .click(someElement)\n    .click(someOtherElement)\n    .keyUp(Keys.CONTROL);\n然后，获得操作（Action）:    \n\n    Action selectMultiple = builder.build();\n最后，执行这个动作：   \n\n    selectMultiple.perform();   \n这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。   \n<!--more-->     \n####键盘交互（Keyboard interactions）\n键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。   \n既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（`Keys.TAB`）键。  \nThe new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.     \n####鼠标交互（Mouse interactions）\n鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。   \n###支持情况\n这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。    \n###大纲\n####单个动作\n所有的动作都实现了`Action`接口，这个接口只有一个方法：`perform（）`。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。   \n下面是一些动作：   \n\n- ButtonReleaseAction - 释放鼠标左键\n- ClickAction - 相当于 WebElement.click()\n- ClickAndHoldAction - 按下鼠标左键并保持\n- ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。\n- DoubleClickAction - 双击某个元素\n- KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）\n- KeyUpAction - 释放修饰键\n- MoveMouseAction - 移动鼠标从当前位置到另外的元素.\n- MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。\n- SendKeysAction - 相当于 WebElement.sendKey(...)\n\n`CompositeAction`包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用`ActionChainsGenerator`。   \n####生成动作链\n`Actions`链生成器实现了创建者模式来新建一个包含一组动作的`CompositeAction`。使用Actions生成器可以很容易的生成动作并调用`build（）`方法来获得复杂的操作。    \n\n    Actions builder = new Actions(driver);\n    \n    Action dragAndDrop = builder.clickAndHold(someElement)\n       .moveToElement(otherElement)\n       .release(otherElement)\n       .build();\n    \n    dragAndDrop.perform();\n有一个对`Actions`进行扩展的计划，给`Actions`类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展`Actions`,请往下看。    \n####扩展Action接口的指导\nAction接口只有一个方法-`perform()`。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。   \n###实现细节\n为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：`Mouse`和`Keyboard`。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。   \n####一字警告\n`Keyboard`和`Mouse`接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。    \n####Keyboard接口\nKeyboard接口包含3个方法：    \n\n- void sendKeys(CharSequence... keysToSend) - 与 sendKeys(...)相似.\n- void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).\n- void releaseKey(Keys keyToRelease) - 释放修饰键.\n\n至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。   \n####Mouse接口\n`Mouse`接口包含以下方法（有可能不久之后会有变化）：\n\n- void click(WebElement onElement) - 同click()方法一样.\n- void doubleClick(WebElement onElement) - 双击一个元素.\n- void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持\nAction selectMultiple = builder.build();\n- void mouseUp(WebElement onElement) - 在一个元素上释放左键.\n- void mouseMove(WebElement toElement) - 从当前位置移动到一个元素\n- void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标\n- void contextClick(WebElement onElement) - 在一个元素上做一个右键操作\n\n####Native events（原生事件） VS synthetic events（合成事件）\nWebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加[native events on Linux](https://code.google.com/p/selenium/wiki/NativeEventsOnLinux)。原生事件无论什么时候总是应该尽可能的使用。   \n\n下面的表格展示了浏览器对事件的支持情况。   \n<table border=\"1px\">\n<tr>\n<td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td>\n</tr>\n<tr>\n<td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td>\n</tr>\n<tr>\n<td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td>\n</tr>\n<tr>\n<td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n<tr>\n<td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td>\n</tr>\n<tr>\n<td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n<tr>\n<td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n</table>\n\\*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。     \n\nFirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。    \n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.setEnableNativeEvents(true);\n    FirefoxDriver driver = new FirefoxDriver(profile);\n#####例子\n以下是原生事件与合成事件表现不同的一些例子：   \n\n- 使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。   \n- 当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。   \n\n---\n原文：<https://code.google.com/p/selenium/wiki/AdvancedUserInteractions>","source":"_posts/2013-05-30-selenium-wiki-advanced-user-interactions.markdown","raw":"---\nlayout: post\ntitle: \"selenium wiki:高级用户交互\"\ndate: 2013-05-30 19:56\ncomments: true\ncategories: selenium-wiki\ntags: [ selenium ]\n---\n###AdvancedUserInteractions(高级用户交互)\n###入门\n高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。    \n####开始（short how to）\n为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：   \n\n    Actions builder = new Actions(driver);\n    \n    builder.keyDown(Keys.CONTROL)\n    .click(someElement)\n    .click(someOtherElement)\n    .keyUp(Keys.CONTROL);\n然后，获得操作（Action）:    \n\n    Action selectMultiple = builder.build();\n最后，执行这个动作：   \n\n    selectMultiple.perform();   \n这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。   \n<!--more-->     \n####键盘交互（Keyboard interactions）\n键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。   \n既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（`Keys.TAB`）键。  \nThe new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.     \n####鼠标交互（Mouse interactions）\n鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。   \n###支持情况\n这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。    \n###大纲\n####单个动作\n所有的动作都实现了`Action`接口，这个接口只有一个方法：`perform（）`。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。   \n下面是一些动作：   \n\n- ButtonReleaseAction - 释放鼠标左键\n- ClickAction - 相当于 WebElement.click()\n- ClickAndHoldAction - 按下鼠标左键并保持\n- ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。\n- DoubleClickAction - 双击某个元素\n- KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）\n- KeyUpAction - 释放修饰键\n- MoveMouseAction - 移动鼠标从当前位置到另外的元素.\n- MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。\n- SendKeysAction - 相当于 WebElement.sendKey(...)\n\n`CompositeAction`包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用`ActionChainsGenerator`。   \n####生成动作链\n`Actions`链生成器实现了创建者模式来新建一个包含一组动作的`CompositeAction`。使用Actions生成器可以很容易的生成动作并调用`build（）`方法来获得复杂的操作。    \n\n    Actions builder = new Actions(driver);\n    \n    Action dragAndDrop = builder.clickAndHold(someElement)\n       .moveToElement(otherElement)\n       .release(otherElement)\n       .build();\n    \n    dragAndDrop.perform();\n有一个对`Actions`进行扩展的计划，给`Actions`类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展`Actions`,请往下看。    \n####扩展Action接口的指导\nAction接口只有一个方法-`perform()`。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。   \n###实现细节\n为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：`Mouse`和`Keyboard`。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。   \n####一字警告\n`Keyboard`和`Mouse`接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。    \n####Keyboard接口\nKeyboard接口包含3个方法：    \n\n- void sendKeys(CharSequence... keysToSend) - 与 sendKeys(...)相似.\n- void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).\n- void releaseKey(Keys keyToRelease) - 释放修饰键.\n\n至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。   \n####Mouse接口\n`Mouse`接口包含以下方法（有可能不久之后会有变化）：\n\n- void click(WebElement onElement) - 同click()方法一样.\n- void doubleClick(WebElement onElement) - 双击一个元素.\n- void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持\nAction selectMultiple = builder.build();\n- void mouseUp(WebElement onElement) - 在一个元素上释放左键.\n- void mouseMove(WebElement toElement) - 从当前位置移动到一个元素\n- void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标\n- void contextClick(WebElement onElement) - 在一个元素上做一个右键操作\n\n####Native events（原生事件） VS synthetic events（合成事件）\nWebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加[native events on Linux](https://code.google.com/p/selenium/wiki/NativeEventsOnLinux)。原生事件无论什么时候总是应该尽可能的使用。   \n\n下面的表格展示了浏览器对事件的支持情况。   \n<table border=\"1px\">\n<tr>\n<td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td>\n</tr>\n<tr>\n<td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td>\n</tr>\n<tr>\n<td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td>\n</tr>\n<tr>\n<td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n<tr>\n<td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td>\n</tr>\n<tr>\n<td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n<tr>\n<td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>\n</tr>\n</table>\n\\*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。     \n\nFirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。    \n\n    FirefoxProfile profile = new FirefoxProfile();\n    profile.setEnableNativeEvents(true);\n    FirefoxDriver driver = new FirefoxDriver(profile);\n#####例子\n以下是原生事件与合成事件表现不同的一些例子：   \n\n- 使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。   \n- 当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。   \n\n---\n原文：<https://code.google.com/p/selenium/wiki/AdvancedUserInteractions>","slug":"2013-05-30-selenium-wiki-advanced-user-interactions","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop5z006cv8fywvgf5w4z","content":"<p>###AdvancedUserInteractions(高级用户交互)</p>\n<p>###入门<br>高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。    </p>\n<p>####开始（short how to）<br>为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：   </p>\n<pre><code>Actions builder = new Actions(driver);\n\nbuilder.keyDown(Keys.CONTROL)\n.click(someElement)\n.click(someOtherElement)\n.keyUp(Keys.CONTROL);\n</code></pre><p>然后，获得操作（Action）:    </p>\n<pre><code>Action selectMultiple = builder.build();\n</code></pre><p>最后，执行这个动作：   </p>\n<pre><code>selectMultiple.perform();   \n</code></pre><p>这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。<br><a id=\"more\"></a>     </p>\n<p>####键盘交互（Keyboard interactions）<br>键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。<br>既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（<code>Keys.TAB</code>）键。<br>The new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.     </p>\n<p>####鼠标交互（Mouse interactions）<br>鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。   </p>\n<p>###支持情况<br>这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。    </p>\n<p>###大纲</p>\n<p>####单个动作<br>所有的动作都实现了<code>Action</code>接口，这个接口只有一个方法：<code>perform（）</code>。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。<br>下面是一些动作：   </p>\n<ul>\n<li>ButtonReleaseAction - 释放鼠标左键</li>\n<li>ClickAction - 相当于 WebElement.click()</li>\n<li>ClickAndHoldAction - 按下鼠标左键并保持</li>\n<li>ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。</li>\n<li>DoubleClickAction - 双击某个元素</li>\n<li>KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）</li>\n<li>KeyUpAction - 释放修饰键</li>\n<li>MoveMouseAction - 移动鼠标从当前位置到另外的元素.</li>\n<li>MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。</li>\n<li>SendKeysAction - 相当于 WebElement.sendKey(…)</li>\n</ul>\n<p><code>CompositeAction</code>包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用<code>ActionChainsGenerator</code>。   </p>\n<p>####生成动作链<br><code>Actions</code>链生成器实现了创建者模式来新建一个包含一组动作的<code>CompositeAction</code>。使用Actions生成器可以很容易的生成动作并调用<code>build（）</code>方法来获得复杂的操作。    </p>\n<pre><code>Actions builder = new Actions(driver);\n\nAction dragAndDrop = builder.clickAndHold(someElement)\n   .moveToElement(otherElement)\n   .release(otherElement)\n   .build();\n\ndragAndDrop.perform();\n</code></pre><p>有一个对<code>Actions</code>进行扩展的计划，给<code>Actions</code>类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展<code>Actions</code>,请往下看。    </p>\n<p>####扩展Action接口的指导<br>Action接口只有一个方法-<code>perform()</code>。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。   </p>\n<p>###实现细节<br>为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：<code>Mouse</code>和<code>Keyboard</code>。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。   </p>\n<p>####一字警告<br><code>Keyboard</code>和<code>Mouse</code>接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。    </p>\n<p>####Keyboard接口<br>Keyboard接口包含3个方法：    </p>\n<ul>\n<li>void sendKeys(CharSequence… keysToSend) - 与 sendKeys(…)相似.</li>\n<li>void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).</li>\n<li>void releaseKey(Keys keyToRelease) - 释放修饰键.</li>\n</ul>\n<p>至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。   </p>\n<p>####Mouse接口<br><code>Mouse</code>接口包含以下方法（有可能不久之后会有变化）：</p>\n<ul>\n<li>void click(WebElement onElement) - 同click()方法一样.</li>\n<li>void doubleClick(WebElement onElement) - 双击一个元素.</li>\n<li>void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持<br>Action selectMultiple = builder.build();</li>\n<li>void mouseUp(WebElement onElement) - 在一个元素上释放左键.</li>\n<li>void mouseMove(WebElement toElement) - 从当前位置移动到一个元素</li>\n<li>void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标</li>\n<li>void contextClick(WebElement onElement) - 在一个元素上做一个右键操作</li>\n</ul>\n<p>####Native events（原生事件） VS synthetic events（合成事件）<br>WebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加<a href=\"https://code.google.com/p/selenium/wiki/NativeEventsOnLinux\" target=\"_blank\" rel=\"external\">native events on Linux</a>。原生事件无论什么时候总是应该尽可能的使用。   </p>\n<p>下面的表格展示了浏览器对事件的支持情况。   </p>\n<p><table border=\"1px\"></table></p>\n<p><tr></tr></p>\n<p><td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td><br></p>\n<p><tr></tr></p>\n<p><td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td><br></p>\n<p><tr></tr></p>\n<p><td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td><br></p>\n<p><tr></tr></p>\n<p><td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td><br></p>\n<p><tr></tr></p>\n<p><td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td><br></p>\n<p><tr></tr></p>\n<p><td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td><br></p>\n<p><tr></tr></p>\n<p><td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td><br><br><br>*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。     </p>\n<p>FirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。    </p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.setEnableNativeEvents(true);\nFirefoxDriver driver = new FirefoxDriver(profile);\n</code></pre><p>#####例子<br>以下是原生事件与合成事件表现不同的一些例子：   </p>\n<ul>\n<li>使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。   </li>\n<li>当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。   </li>\n</ul>\n<hr>\n<p>原文：<a href=\"https://code.google.com/p/selenium/wiki/AdvancedUserInteractions\" target=\"_blank\" rel=\"external\">https://code.google.com/p/selenium/wiki/AdvancedUserInteractions</a></p>\n","excerpt":"<p>###AdvancedUserInteractions(高级用户交互)</p>\n<p>###入门<br>高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。    </p>\n<p>####开始（short how to）<br>为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：   </p>\n<pre><code>Actions builder = new Actions(driver);\n\nbuilder.keyDown(Keys.CONTROL)\n.click(someElement)\n.click(someOtherElement)\n.keyUp(Keys.CONTROL);\n</code></pre><p>然后，获得操作（Action）:    </p>\n<pre><code>Action selectMultiple = builder.build();\n</code></pre><p>最后，执行这个动作：   </p>\n<pre><code>selectMultiple.perform();   \n</code></pre><p>这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。<br>","more":"</p>\n<p>####键盘交互（Keyboard interactions）<br>键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。<br>既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（<code>Keys.TAB</code>）键。<br>The new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.     </p>\n<p>####鼠标交互（Mouse interactions）<br>鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。   </p>\n<p>###支持情况<br>这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。    </p>\n<p>###大纲</p>\n<p>####单个动作<br>所有的动作都实现了<code>Action</code>接口，这个接口只有一个方法：<code>perform（）</code>。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。<br>下面是一些动作：   </p>\n<ul>\n<li>ButtonReleaseAction - 释放鼠标左键</li>\n<li>ClickAction - 相当于 WebElement.click()</li>\n<li>ClickAndHoldAction - 按下鼠标左键并保持</li>\n<li>ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。</li>\n<li>DoubleClickAction - 双击某个元素</li>\n<li>KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）</li>\n<li>KeyUpAction - 释放修饰键</li>\n<li>MoveMouseAction - 移动鼠标从当前位置到另外的元素.</li>\n<li>MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。</li>\n<li>SendKeysAction - 相当于 WebElement.sendKey(…)</li>\n</ul>\n<p><code>CompositeAction</code>包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用<code>ActionChainsGenerator</code>。   </p>\n<p>####生成动作链<br><code>Actions</code>链生成器实现了创建者模式来新建一个包含一组动作的<code>CompositeAction</code>。使用Actions生成器可以很容易的生成动作并调用<code>build（）</code>方法来获得复杂的操作。    </p>\n<pre><code>Actions builder = new Actions(driver);\n\nAction dragAndDrop = builder.clickAndHold(someElement)\n   .moveToElement(otherElement)\n   .release(otherElement)\n   .build();\n\ndragAndDrop.perform();\n</code></pre><p>有一个对<code>Actions</code>进行扩展的计划，给<code>Actions</code>类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展<code>Actions</code>,请往下看。    </p>\n<p>####扩展Action接口的指导<br>Action接口只有一个方法-<code>perform()</code>。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。   </p>\n<p>###实现细节<br>为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：<code>Mouse</code>和<code>Keyboard</code>。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。   </p>\n<p>####一字警告<br><code>Keyboard</code>和<code>Mouse</code>接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。    </p>\n<p>####Keyboard接口<br>Keyboard接口包含3个方法：    </p>\n<ul>\n<li>void sendKeys(CharSequence… keysToSend) - 与 sendKeys(…)相似.</li>\n<li>void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).</li>\n<li>void releaseKey(Keys keyToRelease) - 释放修饰键.</li>\n</ul>\n<p>至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。   </p>\n<p>####Mouse接口<br><code>Mouse</code>接口包含以下方法（有可能不久之后会有变化）：</p>\n<ul>\n<li>void click(WebElement onElement) - 同click()方法一样.</li>\n<li>void doubleClick(WebElement onElement) - 双击一个元素.</li>\n<li>void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持<br>Action selectMultiple = builder.build();</li>\n<li>void mouseUp(WebElement onElement) - 在一个元素上释放左键.</li>\n<li>void mouseMove(WebElement toElement) - 从当前位置移动到一个元素</li>\n<li>void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标</li>\n<li>void contextClick(WebElement onElement) - 在一个元素上做一个右键操作</li>\n</ul>\n<p>####Native events（原生事件） VS synthetic events（合成事件）<br>WebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加<a href=\"https://code.google.com/p/selenium/wiki/NativeEventsOnLinux\">native events on Linux</a>。原生事件无论什么时候总是应该尽可能的使用。   </p>\n<p>下面的表格展示了浏览器对事件的支持情况。   </p>\n<p><table border=\"1px\"></p>\n<p><tr></p>\n<p><td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td><br></tr></p>\n<p><tr></p>\n<p><td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td><br></tr></p>\n<p><tr></p>\n<p><td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td><br></tr></p>\n<p><tr></p>\n<p><td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td><br></tr></p>\n<p><tr></p>\n<p><td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td><br></tr></p>\n<p><tr></p>\n<p><td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td><br></tr></p>\n<p><tr></p>\n<p><td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td><br></tr><br></table><br>*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。     </p>\n<p>FirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。    </p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile();\nprofile.setEnableNativeEvents(true);\nFirefoxDriver driver = new FirefoxDriver(profile);\n</code></pre><p>#####例子<br>以下是原生事件与合成事件表现不同的一些例子：   </p>\n<ul>\n<li>使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。   </li>\n<li>当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。   </li>\n</ul>\n<hr>\n<p>原文：<a href=\"https://code.google.com/p/selenium/wiki/AdvancedUserInteractions\">https://code.google.com/p/selenium/wiki/AdvancedUserInteractions</a></p>"},{"layout":"post","title":"selenium wiki:selenium常见问题","date":"2013-05-30T11:57:00.000Z","comments":1,"_content":"###selenium常见问题\n---\n原文：<https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions>     \n####Q:什么是WebDriver?\nA:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。  \n####Q:Selenium与[Sahi](http://sahi.co.in/)有什么异同？\nA:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。\n####Q：什么是Selenium 2.0?\nA:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。\n<!--more-->\n####Q：如何从原来的selenium api迁移到新的webdriver api?\nA:参见<http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html>\n####Q:WebDriver支持哪些浏览器？\nA:目前支持[ChromeDriver](https://code.google.com/p/selenium/wiki/ChromeDriver),[InternetExplorerDriver](https://code.google.com/p/selenium/wiki/InternetExplorerDriver),[FirefoxDriver](https://code.google.com/p/selenium/wiki/FirefoxDriver),[OperaDriver](https://code.google.com/p/selenium/wiki/OperaDriver),[HtmlUnitDriver](https://code.google.com/p/selenium/wiki/HtmlUnitDriver)。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括[AndroidDriver](https://code.google.com/p/selenium/wiki/AndroidDriver),OperaMobileDriver,IPhoneDriver。\n####Q：“developer focused”是什么意思？\nA:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。\n####Q:如何直接执行Javascript?\nA:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。    \n我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。\n    \n    WebDriver driver; // Assigned elsewhere\n    JavascriptExecutor js =     (JavascriptExecutor) driver;\n    js.executeScript(\"return document.title\");\n至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。\n####Q：为什么我执行Javascript,总是返回NULL？\nA:你需要让你的JS脚本有返回值。所以`js.executeScript(\"document.title\");`会返回null;而`js.executeScript(\"return document.title\");`则会返回页面的title。\n####Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？\nA:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见[XpathInWebDriver](https://code.google.com/p/selenium/wiki/XpathInWebDriver)章节。\n####Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？\nA:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：  \n\n    DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();\n    capabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);\n    WebDriver driver = new InternetExplorerDriver(capabilities);    \n正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。   \n####Q：除了Java，还支持哪些语言？\nA:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。\n####Q：如何处理新弹出的浏览器窗口？\nA:WebDriver提供了处理多浏览器窗口的能力。通过使用`WebDriver.switchTo().window()`可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用`\"WebDriver.getWindowHandles()`获取窗口的名字列表。然后就可以使用`switchTo().window()`来转向了。\n####Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？\nA: 使用[Alert API](http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html)可以搞定:\n\n    // Get a handle to the open alert, prompt or confirmation\n    Alert alert = driver.switchTo().alert();\n    // Get the text of the alert or prompt\n    alert.getText();  \n    // And acknowledge the alert (equivalent to clicking \"OK\")\n    alert.accept();\n####Q：WebDriver支持文件上传？\nA:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用`WebElement#sendKeys(\"/path/to/file\")` 就可以正确上传。同时你要保证不要在文件上传元素上进行`WebElement#click()`操作，否则可能导致浏览器挂起。   \n小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。    \n\n    ((JavascriptExecutor)driver).executeScript(\"arguments[0].style.visibility = 'visible';      arguments[0].style.height = '1px'; arguments[0].style.width = '1px'; arguments[0].style.opacity = 1\", fileUploadElement); \n    \n####Q：为什么在执行`sendKeys`后，没有触发onchange事件？\nA:WebDriver是将焦点一直放在调用`sendKeys`的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的`click`下其他元素即可。   \n####Q：能同时运行多个WebDriver的实例？\nA:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。   \n####Q：我需要使用代理。我该如何配置呢？\nA：代理配置是通过`org.openqa.selenium.Proxy`类来实现的，类似下面代码所示：   \n\n    Proxy proxy = new Proxy();\n    proxy.setProxyAutoconfigUrl(\"http://youdomain/config\");\n    \n    // We use firefox as an example here.\n    DesiredCapabilities capabilities = DesiredCapabilities.firefox();\n    capabilities.setCapability(CapabilityType.PROXY, proxy);\n    \n    // You could use any webdriver implementation here\n    WebDriver driver = new FirefoxDriver(capabilities);\n####Q：使用HtmlUnitDriver该如何实现权限验证？\nA:当创建HtmlUnitDriver时，重写`modifyWebClient`方法即可。例如：    \n\n    WebDriver driver = new HtmlUnitDriver() {\n      protected WebClient modifyWebClient(WebClient client) {\n        // This class ships with HtmlUnit itself\n        DefaultCredentialsProvider creds = new DefaultCredentialsProvider();\n    \n        // Set some example credentials\n        creds.addCredentials(\"username\", \"password\");\n    \n        // And now add the provider to the webClient instance\n        client.setCredentialsProvider(creds);\n    \n        return client;\n      }\n    };\n####Q：WebDriver是线程安全的吗？\nA:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。    \n####Q：如何向一个可编辑的iframe里输入？\nA:假设那个iframe的name是“foo”:   \n\n    driver.switchTo().frame(\"foo\");\n    WebElement editable = driver.switchTo().activeElement();\n    editable.sendKeys(\"Your text here\");\n有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在`sendKeys`之前做以下的操作：    \n\n    ((JavascriptExecutor) driver).executeScript(\"document.body.innerHTML = '<br>'\");\n因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。   \n记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。    \n\n    driver.switchTo().defaultContent();\n####Q：在Linux系统上WebDriver无法启动Firefox，并抛出`java.net.SocketException`。\nA:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：   \n\n    Caused by: java.net.SocketException: Invalid argument\n            at java.net.PlainSocketImpl.socketBind(Native Method)\n            at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)\n            at java.net.Socket.bind(Socket.java:571)\n            at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)\n            at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)\n这可能是因为机器上的IPv6设置导致的。执行下面的脚本：  \n\n    sudo sysctl net.ipv6.bindv6only=0\n为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑`/etc/sysctl.d/bindv6only.conf`禁用这个行为。   \n####Q:WebDriver找不到元素/页面没有完全加载就返回了。\nA:这个问题可以从各种方式显现出来：  \n\n- 使用WebDriver.findElement(...)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。\n- 调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。\n- click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？\n- 我怎么才能知道一个页面是否已经完全加载了？   \n\n**解析**：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。    \n**解决方案**：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用[WebDriver.manage().timeouts()](http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html)来实现.    \n####Q:如何能触发页面上的任意事件？\nA:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。   \n触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。     \n####Q:为什么不能与隐藏的元素进行交互？\nA:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。\n然而，执行JavaScript来直接调用隐藏元素的getText是允许的。\n\n    WebElement element = ...;\n    ((JavascriptExecutor) driver).executeScript(\"return arguments[0].getText();\", element);\n####Q:如何启动一个带插件的Firefox？\nA:\n\n    FirefoxProfile profile = new FirefoxProfile()\n    profile.addExtension(....);\n    \n    WebDriver driver = new FirefoxDriver(profile);\n####Q: 要是WebDriver有...功能，我会更喜欢它。\nA: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。    \n####Q: 有时Selenium server启动一个新session的时候要花费很长的时间？\nA:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。  \n在Windows(XP)系统上，你可以看下<http://bugs.sun.com/view_bug.do?bug_id=6705872>,这通常需要从你的临时文件夹清理大量的数据文件。\n####Q: 在Selenium WebDriver的API中哪个与TextPresent对等?\nA:    \n\n    driver.findElement(By.tagName(\"body\")).getText()\n    \n会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。\n\n####Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。\nA:守护Firefox启动的socket lock在设计时，有以下的限制：   \n\n- socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。\n- 启动firefox的某些关键部分必须在机器上独占锁定。\n- socket lock本身不是瓶颈。启动firefox才是。\n\n`SocketLock`是`Lock`接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。\n\n####Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？\nA: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=\"en_US.UTF-8\"就可以了.","source":"_posts/2013-05-30-selenium-wiki-frequently-asked-questions.markdown","raw":"---\nlayout: post\ntitle: \"selenium wiki:selenium常见问题\"\ndate: 2013-05-30 19:57\ncomments: true\ncategories: selenium-wiki\ntags: [ selenium ]\n---\n###selenium常见问题\n---\n原文：<https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions>     \n####Q:什么是WebDriver?\nA:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。  \n####Q:Selenium与[Sahi](http://sahi.co.in/)有什么异同？\nA:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。\n####Q：什么是Selenium 2.0?\nA:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。\n<!--more-->\n####Q：如何从原来的selenium api迁移到新的webdriver api?\nA:参见<http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html>\n####Q:WebDriver支持哪些浏览器？\nA:目前支持[ChromeDriver](https://code.google.com/p/selenium/wiki/ChromeDriver),[InternetExplorerDriver](https://code.google.com/p/selenium/wiki/InternetExplorerDriver),[FirefoxDriver](https://code.google.com/p/selenium/wiki/FirefoxDriver),[OperaDriver](https://code.google.com/p/selenium/wiki/OperaDriver),[HtmlUnitDriver](https://code.google.com/p/selenium/wiki/HtmlUnitDriver)。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括[AndroidDriver](https://code.google.com/p/selenium/wiki/AndroidDriver),OperaMobileDriver,IPhoneDriver。\n####Q：“developer focused”是什么意思？\nA:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。\n####Q:如何直接执行Javascript?\nA:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。    \n我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。\n    \n    WebDriver driver; // Assigned elsewhere\n    JavascriptExecutor js =     (JavascriptExecutor) driver;\n    js.executeScript(\"return document.title\");\n至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。\n####Q：为什么我执行Javascript,总是返回NULL？\nA:你需要让你的JS脚本有返回值。所以`js.executeScript(\"document.title\");`会返回null;而`js.executeScript(\"return document.title\");`则会返回页面的title。\n####Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？\nA:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见[XpathInWebDriver](https://code.google.com/p/selenium/wiki/XpathInWebDriver)章节。\n####Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？\nA:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：  \n\n    DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();\n    capabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);\n    WebDriver driver = new InternetExplorerDriver(capabilities);    \n正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。   \n####Q：除了Java，还支持哪些语言？\nA:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。\n####Q：如何处理新弹出的浏览器窗口？\nA:WebDriver提供了处理多浏览器窗口的能力。通过使用`WebDriver.switchTo().window()`可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用`\"WebDriver.getWindowHandles()`获取窗口的名字列表。然后就可以使用`switchTo().window()`来转向了。\n####Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？\nA: 使用[Alert API](http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html)可以搞定:\n\n    // Get a handle to the open alert, prompt or confirmation\n    Alert alert = driver.switchTo().alert();\n    // Get the text of the alert or prompt\n    alert.getText();  \n    // And acknowledge the alert (equivalent to clicking \"OK\")\n    alert.accept();\n####Q：WebDriver支持文件上传？\nA:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用`WebElement#sendKeys(\"/path/to/file\")` 就可以正确上传。同时你要保证不要在文件上传元素上进行`WebElement#click()`操作，否则可能导致浏览器挂起。   \n小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。    \n\n    ((JavascriptExecutor)driver).executeScript(\"arguments[0].style.visibility = 'visible';      arguments[0].style.height = '1px'; arguments[0].style.width = '1px'; arguments[0].style.opacity = 1\", fileUploadElement); \n    \n####Q：为什么在执行`sendKeys`后，没有触发onchange事件？\nA:WebDriver是将焦点一直放在调用`sendKeys`的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的`click`下其他元素即可。   \n####Q：能同时运行多个WebDriver的实例？\nA:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。   \n####Q：我需要使用代理。我该如何配置呢？\nA：代理配置是通过`org.openqa.selenium.Proxy`类来实现的，类似下面代码所示：   \n\n    Proxy proxy = new Proxy();\n    proxy.setProxyAutoconfigUrl(\"http://youdomain/config\");\n    \n    // We use firefox as an example here.\n    DesiredCapabilities capabilities = DesiredCapabilities.firefox();\n    capabilities.setCapability(CapabilityType.PROXY, proxy);\n    \n    // You could use any webdriver implementation here\n    WebDriver driver = new FirefoxDriver(capabilities);\n####Q：使用HtmlUnitDriver该如何实现权限验证？\nA:当创建HtmlUnitDriver时，重写`modifyWebClient`方法即可。例如：    \n\n    WebDriver driver = new HtmlUnitDriver() {\n      protected WebClient modifyWebClient(WebClient client) {\n        // This class ships with HtmlUnit itself\n        DefaultCredentialsProvider creds = new DefaultCredentialsProvider();\n    \n        // Set some example credentials\n        creds.addCredentials(\"username\", \"password\");\n    \n        // And now add the provider to the webClient instance\n        client.setCredentialsProvider(creds);\n    \n        return client;\n      }\n    };\n####Q：WebDriver是线程安全的吗？\nA:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。    \n####Q：如何向一个可编辑的iframe里输入？\nA:假设那个iframe的name是“foo”:   \n\n    driver.switchTo().frame(\"foo\");\n    WebElement editable = driver.switchTo().activeElement();\n    editable.sendKeys(\"Your text here\");\n有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在`sendKeys`之前做以下的操作：    \n\n    ((JavascriptExecutor) driver).executeScript(\"document.body.innerHTML = '<br>'\");\n因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。   \n记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。    \n\n    driver.switchTo().defaultContent();\n####Q：在Linux系统上WebDriver无法启动Firefox，并抛出`java.net.SocketException`。\nA:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：   \n\n    Caused by: java.net.SocketException: Invalid argument\n            at java.net.PlainSocketImpl.socketBind(Native Method)\n            at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)\n            at java.net.Socket.bind(Socket.java:571)\n            at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)\n            at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)\n这可能是因为机器上的IPv6设置导致的。执行下面的脚本：  \n\n    sudo sysctl net.ipv6.bindv6only=0\n为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑`/etc/sysctl.d/bindv6only.conf`禁用这个行为。   \n####Q:WebDriver找不到元素/页面没有完全加载就返回了。\nA:这个问题可以从各种方式显现出来：  \n\n- 使用WebDriver.findElement(...)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。\n- 调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。\n- click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？\n- 我怎么才能知道一个页面是否已经完全加载了？   \n\n**解析**：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。    \n**解决方案**：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用[WebDriver.manage().timeouts()](http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html)来实现.    \n####Q:如何能触发页面上的任意事件？\nA:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。   \n触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。     \n####Q:为什么不能与隐藏的元素进行交互？\nA:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。\n然而，执行JavaScript来直接调用隐藏元素的getText是允许的。\n\n    WebElement element = ...;\n    ((JavascriptExecutor) driver).executeScript(\"return arguments[0].getText();\", element);\n####Q:如何启动一个带插件的Firefox？\nA:\n\n    FirefoxProfile profile = new FirefoxProfile()\n    profile.addExtension(....);\n    \n    WebDriver driver = new FirefoxDriver(profile);\n####Q: 要是WebDriver有...功能，我会更喜欢它。\nA: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。    \n####Q: 有时Selenium server启动一个新session的时候要花费很长的时间？\nA:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。  \n在Windows(XP)系统上，你可以看下<http://bugs.sun.com/view_bug.do?bug_id=6705872>,这通常需要从你的临时文件夹清理大量的数据文件。\n####Q: 在Selenium WebDriver的API中哪个与TextPresent对等?\nA:    \n\n    driver.findElement(By.tagName(\"body\")).getText()\n    \n会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。\n\n####Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。\nA:守护Firefox启动的socket lock在设计时，有以下的限制：   \n\n- socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。\n- 启动firefox的某些关键部分必须在机器上独占锁定。\n- socket lock本身不是瓶颈。启动firefox才是。\n\n`SocketLock`是`Lock`接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。\n\n####Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？\nA: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=\"en_US.UTF-8\"就可以了.","slug":"2013-05-30-selenium-wiki-frequently-asked-questions","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop61006hv8fykw0v6hrx","content":"<h2 id=\"selenium常见问题\"><a href=\"#selenium常见问题\" class=\"headerlink\" title=\"###selenium常见问题\"></a>###selenium常见问题</h2><p>原文：<a href=\"https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions\" target=\"_blank\" rel=\"external\">https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions</a>     </p>\n<p>####Q:什么是WebDriver?<br>A:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。  </p>\n<p>####Q:Selenium与<a href=\"http://sahi.co.in/\" target=\"_blank\" rel=\"external\">Sahi</a>有什么异同？<br>A:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。</p>\n<p>####Q：什么是Selenium 2.0?<br>A:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。<br><a id=\"more\"></a></p>\n<p>####Q：如何从原来的selenium api迁移到新的webdriver api?<br>A:参见<a href=\"http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html\" target=\"_blank\" rel=\"external\">http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html</a></p>\n<p>####Q:WebDriver支持哪些浏览器？<br>A:目前支持<a href=\"https://code.google.com/p/selenium/wiki/ChromeDriver\" target=\"_blank\" rel=\"external\">ChromeDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/InternetExplorerDriver\" target=\"_blank\" rel=\"external\">InternetExplorerDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/FirefoxDriver\" target=\"_blank\" rel=\"external\">FirefoxDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/OperaDriver\" target=\"_blank\" rel=\"external\">OperaDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/HtmlUnitDriver\" target=\"_blank\" rel=\"external\">HtmlUnitDriver</a>。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括<a href=\"https://code.google.com/p/selenium/wiki/AndroidDriver\" target=\"_blank\" rel=\"external\">AndroidDriver</a>,OperaMobileDriver,IPhoneDriver。</p>\n<p>####Q：“developer focused”是什么意思？<br>A:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。</p>\n<p>####Q:如何直接执行Javascript?<br>A:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。<br>我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。</p>\n<pre><code>WebDriver driver; // Assigned elsewhere\nJavascriptExecutor js =     (JavascriptExecutor) driver;\njs.executeScript(&quot;return document.title&quot;);\n</code></pre><p>至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。</p>\n<p>####Q：为什么我执行Javascript,总是返回NULL？<br>A:你需要让你的JS脚本有返回值。所以<code>js.executeScript(&quot;document.title&quot;);</code>会返回null;而<code>js.executeScript(&quot;return document.title&quot;);</code>则会返回页面的title。</p>\n<p>####Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？<br>A:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见<a href=\"https://code.google.com/p/selenium/wiki/XpathInWebDriver\" target=\"_blank\" rel=\"external\">XpathInWebDriver</a>章节。</p>\n<p>####Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？<br>A:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：  </p>\n<pre><code>DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();\ncapabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);\nWebDriver driver = new InternetExplorerDriver(capabilities);    \n</code></pre><p>正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。   </p>\n<p>####Q：除了Java，还支持哪些语言？<br>A:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。</p>\n<p>####Q：如何处理新弹出的浏览器窗口？<br>A:WebDriver提供了处理多浏览器窗口的能力。通过使用<code>WebDriver.switchTo().window()</code>可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用<code>&quot;WebDriver.getWindowHandles()</code>获取窗口的名字列表。然后就可以使用<code>switchTo().window()</code>来转向了。</p>\n<p>####Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？<br>A: 使用<a href=\"http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html\" target=\"_blank\" rel=\"external\">Alert API</a>可以搞定:</p>\n<pre><code>// Get a handle to the open alert, prompt or confirmation\nAlert alert = driver.switchTo().alert();\n// Get the text of the alert or prompt\nalert.getText();  \n// And acknowledge the alert (equivalent to clicking &quot;OK&quot;)\nalert.accept();\n</code></pre><p>####Q：WebDriver支持文件上传？<br>A:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用<code>WebElement#sendKeys(&quot;/path/to/file&quot;)</code> 就可以正确上传。同时你要保证不要在文件上传元素上进行<code>WebElement#click()</code>操作，否则可能导致浏览器挂起。<br>小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。    </p>\n<pre><code>((JavascriptExecutor)driver).executeScript(&quot;arguments[0].style.visibility = &apos;visible&apos;;      arguments[0].style.height = &apos;1px&apos;; arguments[0].style.width = &apos;1px&apos;; arguments[0].style.opacity = 1&quot;, fileUploadElement); \n</code></pre><p>####Q：为什么在执行<code>sendKeys</code>后，没有触发onchange事件？<br>A:WebDriver是将焦点一直放在调用<code>sendKeys</code>的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的<code>click</code>下其他元素即可。   </p>\n<p>####Q：能同时运行多个WebDriver的实例？<br>A:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。   </p>\n<p>####Q：我需要使用代理。我该如何配置呢？<br>A：代理配置是通过<code>org.openqa.selenium.Proxy</code>类来实现的，类似下面代码所示：   </p>\n<pre><code>Proxy proxy = new Proxy();\nproxy.setProxyAutoconfigUrl(&quot;http://youdomain/config&quot;);\n\n// We use firefox as an example here.\nDesiredCapabilities capabilities = DesiredCapabilities.firefox();\ncapabilities.setCapability(CapabilityType.PROXY, proxy);\n\n// You could use any webdriver implementation here\nWebDriver driver = new FirefoxDriver(capabilities);\n</code></pre><p>####Q：使用HtmlUnitDriver该如何实现权限验证？<br>A:当创建HtmlUnitDriver时，重写<code>modifyWebClient</code>方法即可。例如：    </p>\n<pre><code>WebDriver driver = new HtmlUnitDriver() {\n  protected WebClient modifyWebClient(WebClient client) {\n    // This class ships with HtmlUnit itself\n    DefaultCredentialsProvider creds = new DefaultCredentialsProvider();\n\n    // Set some example credentials\n    creds.addCredentials(&quot;username&quot;, &quot;password&quot;);\n\n    // And now add the provider to the webClient instance\n    client.setCredentialsProvider(creds);\n\n    return client;\n  }\n};\n</code></pre><p>####Q：WebDriver是线程安全的吗？<br>A:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。    </p>\n<p>####Q：如何向一个可编辑的iframe里输入？<br>A:假设那个iframe的name是“foo”:   </p>\n<pre><code>driver.switchTo().frame(&quot;foo&quot;);\nWebElement editable = driver.switchTo().activeElement();\neditable.sendKeys(&quot;Your text here&quot;);\n</code></pre><p>有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在<code>sendKeys</code>之前做以下的操作：    </p>\n<pre><code>((JavascriptExecutor) driver).executeScript(&quot;document.body.innerHTML = &apos;&lt;br&gt;&apos;&quot;);\n</code></pre><p>因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。<br>记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。    </p>\n<pre><code>driver.switchTo().defaultContent();\n</code></pre><p>####Q：在Linux系统上WebDriver无法启动Firefox，并抛出<code>java.net.SocketException</code>。<br>A:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：   </p>\n<pre><code>Caused by: java.net.SocketException: Invalid argument\n        at java.net.PlainSocketImpl.socketBind(Native Method)\n        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)\n        at java.net.Socket.bind(Socket.java:571)\n        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)\n        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)\n</code></pre><p>这可能是因为机器上的IPv6设置导致的。执行下面的脚本：  </p>\n<pre><code>sudo sysctl net.ipv6.bindv6only=0\n</code></pre><p>为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑<code>/etc/sysctl.d/bindv6only.conf</code>禁用这个行为。   </p>\n<p>####Q:WebDriver找不到元素/页面没有完全加载就返回了。<br>A:这个问题可以从各种方式显现出来：  </p>\n<ul>\n<li>使用WebDriver.findElement(…)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。</li>\n<li>调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。</li>\n<li>click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？</li>\n<li>我怎么才能知道一个页面是否已经完全加载了？   </li>\n</ul>\n<p><strong>解析</strong>：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。<br><strong>解决方案</strong>：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用<a href=\"http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html\" target=\"_blank\" rel=\"external\">WebDriver.manage().timeouts()</a>来实现.    </p>\n<p>####Q:如何能触发页面上的任意事件？<br>A:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。<br>触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。     </p>\n<p>####Q:为什么不能与隐藏的元素进行交互？<br>A:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。<br>然而，执行JavaScript来直接调用隐藏元素的getText是允许的。</p>\n<pre><code>WebElement element = ...;\n((JavascriptExecutor) driver).executeScript(&quot;return arguments[0].getText();&quot;, element);\n</code></pre><p>####Q:如何启动一个带插件的Firefox？<br>A:</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile()\nprofile.addExtension(....);\n\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>####Q: 要是WebDriver有…功能，我会更喜欢它。<br>A: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。    </p>\n<p>####Q: 有时Selenium server启动一个新session的时候要花费很长的时间？<br>A:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。<br>在Windows(XP)系统上，你可以看下<a href=\"http://bugs.sun.com/view_bug.do?bug_id=6705872\" target=\"_blank\" rel=\"external\">http://bugs.sun.com/view_bug.do?bug_id=6705872</a>,这通常需要从你的临时文件夹清理大量的数据文件。</p>\n<p>####Q: 在Selenium WebDriver的API中哪个与TextPresent对等?<br>A:    </p>\n<pre><code>driver.findElement(By.tagName(&quot;body&quot;)).getText()\n</code></pre><p>会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。</p>\n<p>####Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。<br>A:守护Firefox启动的socket lock在设计时，有以下的限制：   </p>\n<ul>\n<li>socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。</li>\n<li>启动firefox的某些关键部分必须在机器上独占锁定。</li>\n<li>socket lock本身不是瓶颈。启动firefox才是。</li>\n</ul>\n<p><code>SocketLock</code>是<code>Lock</code>接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。</p>\n<p>####Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？<br>A: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=”en_US.UTF-8”就可以了.</p>\n","excerpt":"<h2 id=\"selenium常见问题\"><a href=\"#selenium常见问题\" class=\"headerlink\" title=\"###selenium常见问题\"></a>###selenium常见问题</h2><p>原文：<a href=\"https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions\">https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions</a>     </p>\n<p>####Q:什么是WebDriver?<br>A:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。  </p>\n<p>####Q:Selenium与<a href=\"http://sahi.co.in/\">Sahi</a>有什么异同？<br>A:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。</p>\n<p>####Q：什么是Selenium 2.0?<br>A:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。<br>","more":"</p>\n<p>####Q：如何从原来的selenium api迁移到新的webdriver api?<br>A:参见<a href=\"http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html\">http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html</a></p>\n<p>####Q:WebDriver支持哪些浏览器？<br>A:目前支持<a href=\"https://code.google.com/p/selenium/wiki/ChromeDriver\">ChromeDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/InternetExplorerDriver\">InternetExplorerDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/FirefoxDriver\">FirefoxDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/OperaDriver\">OperaDriver</a>,<a href=\"https://code.google.com/p/selenium/wiki/HtmlUnitDriver\">HtmlUnitDriver</a>。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括<a href=\"https://code.google.com/p/selenium/wiki/AndroidDriver\">AndroidDriver</a>,OperaMobileDriver,IPhoneDriver。</p>\n<p>####Q：“developer focused”是什么意思？<br>A:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。</p>\n<p>####Q:如何直接执行Javascript?<br>A:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。<br>我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。</p>\n<pre><code>WebDriver driver; // Assigned elsewhere\nJavascriptExecutor js =     (JavascriptExecutor) driver;\njs.executeScript(&quot;return document.title&quot;);\n</code></pre><p>至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。</p>\n<p>####Q：为什么我执行Javascript,总是返回NULL？<br>A:你需要让你的JS脚本有返回值。所以<code>js.executeScript(&quot;document.title&quot;);</code>会返回null;而<code>js.executeScript(&quot;return document.title&quot;);</code>则会返回页面的title。</p>\n<p>####Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？<br>A:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见<a href=\"https://code.google.com/p/selenium/wiki/XpathInWebDriver\">XpathInWebDriver</a>章节。</p>\n<p>####Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？<br>A:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：  </p>\n<pre><code>DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();\ncapabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);\nWebDriver driver = new InternetExplorerDriver(capabilities);    \n</code></pre><p>正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。   </p>\n<p>####Q：除了Java，还支持哪些语言？<br>A:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。</p>\n<p>####Q：如何处理新弹出的浏览器窗口？<br>A:WebDriver提供了处理多浏览器窗口的能力。通过使用<code>WebDriver.switchTo().window()</code>可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用<code>&quot;WebDriver.getWindowHandles()</code>获取窗口的名字列表。然后就可以使用<code>switchTo().window()</code>来转向了。</p>\n<p>####Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？<br>A: 使用<a href=\"http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html\">Alert API</a>可以搞定:</p>\n<pre><code>// Get a handle to the open alert, prompt or confirmation\nAlert alert = driver.switchTo().alert();\n// Get the text of the alert or prompt\nalert.getText();  \n// And acknowledge the alert (equivalent to clicking &quot;OK&quot;)\nalert.accept();\n</code></pre><p>####Q：WebDriver支持文件上传？<br>A:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用<code>WebElement#sendKeys(&quot;/path/to/file&quot;)</code> 就可以正确上传。同时你要保证不要在文件上传元素上进行<code>WebElement#click()</code>操作，否则可能导致浏览器挂起。<br>小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。    </p>\n<pre><code>((JavascriptExecutor)driver).executeScript(&quot;arguments[0].style.visibility = &apos;visible&apos;;      arguments[0].style.height = &apos;1px&apos;; arguments[0].style.width = &apos;1px&apos;; arguments[0].style.opacity = 1&quot;, fileUploadElement); \n</code></pre><p>####Q：为什么在执行<code>sendKeys</code>后，没有触发onchange事件？<br>A:WebDriver是将焦点一直放在调用<code>sendKeys</code>的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的<code>click</code>下其他元素即可。   </p>\n<p>####Q：能同时运行多个WebDriver的实例？<br>A:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。   </p>\n<p>####Q：我需要使用代理。我该如何配置呢？<br>A：代理配置是通过<code>org.openqa.selenium.Proxy</code>类来实现的，类似下面代码所示：   </p>\n<pre><code>Proxy proxy = new Proxy();\nproxy.setProxyAutoconfigUrl(&quot;http://youdomain/config&quot;);\n\n// We use firefox as an example here.\nDesiredCapabilities capabilities = DesiredCapabilities.firefox();\ncapabilities.setCapability(CapabilityType.PROXY, proxy);\n\n// You could use any webdriver implementation here\nWebDriver driver = new FirefoxDriver(capabilities);\n</code></pre><p>####Q：使用HtmlUnitDriver该如何实现权限验证？<br>A:当创建HtmlUnitDriver时，重写<code>modifyWebClient</code>方法即可。例如：    </p>\n<pre><code>WebDriver driver = new HtmlUnitDriver() {\n  protected WebClient modifyWebClient(WebClient client) {\n    // This class ships with HtmlUnit itself\n    DefaultCredentialsProvider creds = new DefaultCredentialsProvider();\n\n    // Set some example credentials\n    creds.addCredentials(&quot;username&quot;, &quot;password&quot;);\n\n    // And now add the provider to the webClient instance\n    client.setCredentialsProvider(creds);\n\n    return client;\n  }\n};\n</code></pre><p>####Q：WebDriver是线程安全的吗？<br>A:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。    </p>\n<p>####Q：如何向一个可编辑的iframe里输入？<br>A:假设那个iframe的name是“foo”:   </p>\n<pre><code>driver.switchTo().frame(&quot;foo&quot;);\nWebElement editable = driver.switchTo().activeElement();\neditable.sendKeys(&quot;Your text here&quot;);\n</code></pre><p>有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在<code>sendKeys</code>之前做以下的操作：    </p>\n<pre><code>((JavascriptExecutor) driver).executeScript(&quot;document.body.innerHTML = &apos;&lt;br&gt;&apos;&quot;);\n</code></pre><p>因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。<br>记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。    </p>\n<pre><code>driver.switchTo().defaultContent();\n</code></pre><p>####Q：在Linux系统上WebDriver无法启动Firefox，并抛出<code>java.net.SocketException</code>。<br>A:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：   </p>\n<pre><code>Caused by: java.net.SocketException: Invalid argument\n        at java.net.PlainSocketImpl.socketBind(Native Method)\n        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)\n        at java.net.Socket.bind(Socket.java:571)\n        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)\n        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)\n</code></pre><p>这可能是因为机器上的IPv6设置导致的。执行下面的脚本：  </p>\n<pre><code>sudo sysctl net.ipv6.bindv6only=0\n</code></pre><p>为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑<code>/etc/sysctl.d/bindv6only.conf</code>禁用这个行为。   </p>\n<p>####Q:WebDriver找不到元素/页面没有完全加载就返回了。<br>A:这个问题可以从各种方式显现出来：  </p>\n<ul>\n<li>使用WebDriver.findElement(…)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。</li>\n<li>调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。</li>\n<li>click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？</li>\n<li>我怎么才能知道一个页面是否已经完全加载了？   </li>\n</ul>\n<p><strong>解析</strong>：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。<br><strong>解决方案</strong>：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用<a href=\"http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html\">WebDriver.manage().timeouts()</a>来实现.    </p>\n<p>####Q:如何能触发页面上的任意事件？<br>A:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。<br>触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。     </p>\n<p>####Q:为什么不能与隐藏的元素进行交互？<br>A:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。<br>然而，执行JavaScript来直接调用隐藏元素的getText是允许的。</p>\n<pre><code>WebElement element = ...;\n((JavascriptExecutor) driver).executeScript(&quot;return arguments[0].getText();&quot;, element);\n</code></pre><p>####Q:如何启动一个带插件的Firefox？<br>A:</p>\n<pre><code>FirefoxProfile profile = new FirefoxProfile()\nprofile.addExtension(....);\n\nWebDriver driver = new FirefoxDriver(profile);\n</code></pre><p>####Q: 要是WebDriver有…功能，我会更喜欢它。<br>A: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。    </p>\n<p>####Q: 有时Selenium server启动一个新session的时候要花费很长的时间？<br>A:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。<br>在Windows(XP)系统上，你可以看下<a href=\"http://bugs.sun.com/view_bug.do?bug_id=6705872\">http://bugs.sun.com/view_bug.do?bug_id=6705872</a>,这通常需要从你的临时文件夹清理大量的数据文件。</p>\n<p>####Q: 在Selenium WebDriver的API中哪个与TextPresent对等?<br>A:    </p>\n<pre><code>driver.findElement(By.tagName(&quot;body&quot;)).getText()\n</code></pre><p>会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。</p>\n<p>####Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。<br>A:守护Firefox启动的socket lock在设计时，有以下的限制：   </p>\n<ul>\n<li>socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。</li>\n<li>启动firefox的某些关键部分必须在机器上独占锁定。</li>\n<li>socket lock本身不是瓶颈。启动firefox才是。</li>\n</ul>\n<p><code>SocketLock</code>是<code>Lock</code>接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。</p>\n<p>####Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？<br>A: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE=”en_US.UTF-8”就可以了.</p>"},{"layout":"post","title":"使用Eclipse AST来解析Java","date":"2013-06-19T06:46:00.000Z","comments":1,"_content":"Eclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。\n另外，Eclipse有一个[AST View](http://www.eclipse.org/jdt/ui/astview/)插件，使用这个能更加的清楚的看到解析后的效果。   \n\n![Eclipse AST View](/images/blog/eclipse-ast-view.png)    \n\n<!--more-->\n####依赖的jar包\n\n- org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar\n- org.eclipse.core.jobs_3.5.101.v20120113-1953.jar\n- org.eclipse.core.resources_3.7.101.v20120125-1505.jar\n- org.eclipse.core.runtime_3.7.0.v20110110.jar\n- org.eclipse.equinox.common_3.6.0.v20110523.jar\n- org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar\n- org.eclipse.jdt.core_3.7.3.v20120119-1537.jar\n- org.eclipse.osgi_3.7.2.v20120110-1415.jar\n\n这些包都可以在eclipse的plugin目录找到。可能版本有所区别。   \n如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。   \n\n              <dependency>\n                    <groupId>org.eclipse.tycho</groupId>\n                    <artifactId>org.eclipse.jdt.core</artifactId>\n                    <version>3.8.0.v_C03</version>\n                </dependency>\n                 <dependency>\n                     <groupId>org.eclipse.core</groupId>\n                     <artifactId>org.eclipse.core.runtime</artifactId>\n                     <version>3.6.0.v20100505</version>\n                 </dependency>\n                <dependency>\n                    <groupId>org.eclipse.core</groupId>\n                    <artifactId>org.eclipse.core.resources</artifactId>\n                    <version>3.6.0.v20100526-0737</version>\n                </dependency>\n\n####如何解析Java\n\n    package cn.shenyanchao.ast;\n    \n    import org.apache.commons.io.FileUtils;\n    import org.eclipse.jdt.core.dom.*;\n    \n    import java.io.File;\n    import java.io.IOException;\n    import java.util.List;\n    \n    /**\n     * Created with IntelliJ IDEA.\n     *\n     * @author shenyanchao\n     *         Date:  6/13/13\n     *         Time:  11:52 AM\n     */\n    public class AstAnalyzer {\n        public static void main(String[] args) throws IOException {\n    \n            String javaSource = FileUtils.readFileToString(new File(\"/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java\"));\n    \n            ASTParser parser = ASTParser.newParser(AST.JLS3);\n            parser.setSource(javaSource.toCharArray());\n    \n            // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)\n            CompilationUnit result = (CompilationUnit) parser.createAST(null);\n    \n            result.imports();\n            result.getPackage();\n            result.getCommentList();\n            System.out.println(result.getCommentList().toString());\n    \n            TypeDeclaration type = (TypeDeclaration) result.types().get(0);\n            System.out.println(\"---------Type---------\");\n            System.out.println(type.toString());\n    \n            MethodDeclaration method = type.getMethods()[0];\n            method.parameters();\n            method.isConstructor();\n    \n            System.out.println(\"---------Method---------\");\n            System.out.println(method.toString());\n            method.getName();\n            method.getModifiers();\n            Type returnType = method.getReturnType2();\n            System.out.println(\"returnType = \" + returnType.toString());\n    \n    \n            Block methodBody = method.getBody();\n            List<Statement> statementList = methodBody.statements();\n    \n            System.out.println(statementList.toString());\n    \n            statementList.get(0);\n    \n            ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);\n            Assignment expression = (Assignment) ifs.getExpression();\n            Expression exp = expression.getRightHandSide();\n    \n            System.out.println(result.toString());\n        }\n    }\n\n####如何创建Java\n\n    package cn.shenyanchao.ast;\n    \n    import org.eclipse.jdt.core.dom.*;\n    \n    /**\n     * Created with IntelliJ IDEA.\n     *\n     * @author shenyanchao\n     *         Date:  6/13/13\n     *         Time:  11:27 AM\n     */\n    public class AstHelloWorld {\n    \n    \n        public static void main(String[] args) {\n            AST ast = AST.newAST(AST.JLS3);\n            CompilationUnit compilationUnit = ast.newCompilationUnit();\n    \n            // 创建类\n            TypeDeclaration programClass = ast.newTypeDeclaration();\n            programClass.setName(ast.newSimpleName(\"HelloWorld\"));\n            programClass.modifiers().add(\n                    ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n            compilationUnit.types().add(programClass);\n    \n            // 创建包\n            PackageDeclaration packageDeclaration = ast.newPackageDeclaration();\n            packageDeclaration.setName(ast.newName(\"cn.shenyanchao.hello\"));\n            compilationUnit.setPackage(packageDeclaration);\n    \n            MethodDeclaration main = ast.newMethodDeclaration();\n            main.setName(ast.newSimpleName(\"main\"));\n            main.modifiers().add(\n                    ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n            main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n            main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n            programClass.bodyDeclarations().add(main);\n            Block mainBlock = ast.newBlock();\n            main.setBody(mainBlock);\n    \n            // 给main方法定义String[]参数\n            SingleVariableDeclaration mainParameter = ast\n                    .newSingleVariableDeclaration();\n            mainParameter.setName(ast.newSimpleName(\"arg\"));\n            mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast\n                    .newName(\"String\"))));\n            main.parameters().add(mainParameter);\n    \n            MethodInvocation println = ast.newMethodInvocation();\n            println.setName(ast.newSimpleName(\"println\"));\n    \n            //生成String类型的常量\n            StringLiteral s = ast.newStringLiteral();\n            s.setLiteralValue(\"Hello World\");\n            println.arguments().add(s);\n    \n            println.setExpression(ast.newName(\"System.out\"));\n    \n            mainBlock.statements().add(ast.newExpressionStatement(println));\n    \n            System.out.println(compilationUnit.toString());\n        }\n    }\n\n具体的使用手册，参见<http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/>\n\n","source":"_posts/2013-06-19-use-eclipse-ast-to-parser-java.markdown","raw":"---\nlayout: post\ntitle: \"使用Eclipse AST来解析Java\"\ndate: 2013-06-19 14:46\ncomments: true\ncategories: java\ntags: [ eclipse, ast ]\n---\nEclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。\n另外，Eclipse有一个[AST View](http://www.eclipse.org/jdt/ui/astview/)插件，使用这个能更加的清楚的看到解析后的效果。   \n\n![Eclipse AST View](/images/blog/eclipse-ast-view.png)    \n\n<!--more-->\n####依赖的jar包\n\n- org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar\n- org.eclipse.core.jobs_3.5.101.v20120113-1953.jar\n- org.eclipse.core.resources_3.7.101.v20120125-1505.jar\n- org.eclipse.core.runtime_3.7.0.v20110110.jar\n- org.eclipse.equinox.common_3.6.0.v20110523.jar\n- org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar\n- org.eclipse.jdt.core_3.7.3.v20120119-1537.jar\n- org.eclipse.osgi_3.7.2.v20120110-1415.jar\n\n这些包都可以在eclipse的plugin目录找到。可能版本有所区别。   \n如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。   \n\n              <dependency>\n                    <groupId>org.eclipse.tycho</groupId>\n                    <artifactId>org.eclipse.jdt.core</artifactId>\n                    <version>3.8.0.v_C03</version>\n                </dependency>\n                 <dependency>\n                     <groupId>org.eclipse.core</groupId>\n                     <artifactId>org.eclipse.core.runtime</artifactId>\n                     <version>3.6.0.v20100505</version>\n                 </dependency>\n                <dependency>\n                    <groupId>org.eclipse.core</groupId>\n                    <artifactId>org.eclipse.core.resources</artifactId>\n                    <version>3.6.0.v20100526-0737</version>\n                </dependency>\n\n####如何解析Java\n\n    package cn.shenyanchao.ast;\n    \n    import org.apache.commons.io.FileUtils;\n    import org.eclipse.jdt.core.dom.*;\n    \n    import java.io.File;\n    import java.io.IOException;\n    import java.util.List;\n    \n    /**\n     * Created with IntelliJ IDEA.\n     *\n     * @author shenyanchao\n     *         Date:  6/13/13\n     *         Time:  11:52 AM\n     */\n    public class AstAnalyzer {\n        public static void main(String[] args) throws IOException {\n    \n            String javaSource = FileUtils.readFileToString(new File(\"/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java\"));\n    \n            ASTParser parser = ASTParser.newParser(AST.JLS3);\n            parser.setSource(javaSource.toCharArray());\n    \n            // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)\n            CompilationUnit result = (CompilationUnit) parser.createAST(null);\n    \n            result.imports();\n            result.getPackage();\n            result.getCommentList();\n            System.out.println(result.getCommentList().toString());\n    \n            TypeDeclaration type = (TypeDeclaration) result.types().get(0);\n            System.out.println(\"---------Type---------\");\n            System.out.println(type.toString());\n    \n            MethodDeclaration method = type.getMethods()[0];\n            method.parameters();\n            method.isConstructor();\n    \n            System.out.println(\"---------Method---------\");\n            System.out.println(method.toString());\n            method.getName();\n            method.getModifiers();\n            Type returnType = method.getReturnType2();\n            System.out.println(\"returnType = \" + returnType.toString());\n    \n    \n            Block methodBody = method.getBody();\n            List<Statement> statementList = methodBody.statements();\n    \n            System.out.println(statementList.toString());\n    \n            statementList.get(0);\n    \n            ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);\n            Assignment expression = (Assignment) ifs.getExpression();\n            Expression exp = expression.getRightHandSide();\n    \n            System.out.println(result.toString());\n        }\n    }\n\n####如何创建Java\n\n    package cn.shenyanchao.ast;\n    \n    import org.eclipse.jdt.core.dom.*;\n    \n    /**\n     * Created with IntelliJ IDEA.\n     *\n     * @author shenyanchao\n     *         Date:  6/13/13\n     *         Time:  11:27 AM\n     */\n    public class AstHelloWorld {\n    \n    \n        public static void main(String[] args) {\n            AST ast = AST.newAST(AST.JLS3);\n            CompilationUnit compilationUnit = ast.newCompilationUnit();\n    \n            // 创建类\n            TypeDeclaration programClass = ast.newTypeDeclaration();\n            programClass.setName(ast.newSimpleName(\"HelloWorld\"));\n            programClass.modifiers().add(\n                    ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n            compilationUnit.types().add(programClass);\n    \n            // 创建包\n            PackageDeclaration packageDeclaration = ast.newPackageDeclaration();\n            packageDeclaration.setName(ast.newName(\"cn.shenyanchao.hello\"));\n            compilationUnit.setPackage(packageDeclaration);\n    \n            MethodDeclaration main = ast.newMethodDeclaration();\n            main.setName(ast.newSimpleName(\"main\"));\n            main.modifiers().add(\n                    ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n            main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n            main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n            programClass.bodyDeclarations().add(main);\n            Block mainBlock = ast.newBlock();\n            main.setBody(mainBlock);\n    \n            // 给main方法定义String[]参数\n            SingleVariableDeclaration mainParameter = ast\n                    .newSingleVariableDeclaration();\n            mainParameter.setName(ast.newSimpleName(\"arg\"));\n            mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast\n                    .newName(\"String\"))));\n            main.parameters().add(mainParameter);\n    \n            MethodInvocation println = ast.newMethodInvocation();\n            println.setName(ast.newSimpleName(\"println\"));\n    \n            //生成String类型的常量\n            StringLiteral s = ast.newStringLiteral();\n            s.setLiteralValue(\"Hello World\");\n            println.arguments().add(s);\n    \n            println.setExpression(ast.newName(\"System.out\"));\n    \n            mainBlock.statements().add(ast.newExpressionStatement(println));\n    \n            System.out.println(compilationUnit.toString());\n        }\n    }\n\n具体的使用手册，参见<http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/>\n\n","slug":"2013-06-19-use-eclipse-ast-to-parser-java","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop62006kv8fyyfnsd87t","content":"<p>Eclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。<br>另外，Eclipse有一个<a href=\"http://www.eclipse.org/jdt/ui/astview/\" target=\"_blank\" rel=\"external\">AST View</a>插件，使用这个能更加的清楚的看到解析后的效果。   </p>\n<p><img src=\"/images/blog/eclipse-ast-view.png\" alt=\"Eclipse AST View\">    </p>\n<a id=\"more\"></a>\n<p>####依赖的jar包</p>\n<ul>\n<li>org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar</li>\n<li>org.eclipse.core.jobs_3.5.101.v20120113-1953.jar</li>\n<li>org.eclipse.core.resources_3.7.101.v20120125-1505.jar</li>\n<li>org.eclipse.core.runtime_3.7.0.v20110110.jar</li>\n<li>org.eclipse.equinox.common_3.6.0.v20110523.jar</li>\n<li>org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar</li>\n<li>org.eclipse.jdt.core_3.7.3.v20120119-1537.jar</li>\n<li>org.eclipse.osgi_3.7.2.v20120110-1415.jar</li>\n</ul>\n<p>这些包都可以在eclipse的plugin目录找到。可能版本有所区别。<br>如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。   </p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;\n      &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;\n      &lt;version&gt;3.8.0.v_C03&lt;/version&gt;\n  &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;\n       &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;\n       &lt;version&gt;3.6.0.v20100505&lt;/version&gt;\n   &lt;/dependency&gt;\n  &lt;dependency&gt;\n      &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;\n      &lt;artifactId&gt;org.eclipse.core.resources&lt;/artifactId&gt;\n      &lt;version&gt;3.6.0.v20100526-0737&lt;/version&gt;\n  &lt;/dependency&gt;\n</code></pre><p>####如何解析Java</p>\n<pre><code>package cn.shenyanchao.ast;\n\nimport org.apache.commons.io.FileUtils;\nimport org.eclipse.jdt.core.dom.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author shenyanchao\n *         Date:  6/13/13\n *         Time:  11:52 AM\n */\npublic class AstAnalyzer {\n    public static void main(String[] args) throws IOException {\n\n        String javaSource = FileUtils.readFileToString(new File(&quot;/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java&quot;));\n\n        ASTParser parser = ASTParser.newParser(AST.JLS3);\n        parser.setSource(javaSource.toCharArray());\n\n        // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)\n        CompilationUnit result = (CompilationUnit) parser.createAST(null);\n\n        result.imports();\n        result.getPackage();\n        result.getCommentList();\n        System.out.println(result.getCommentList().toString());\n\n        TypeDeclaration type = (TypeDeclaration) result.types().get(0);\n        System.out.println(&quot;---------Type---------&quot;);\n        System.out.println(type.toString());\n\n        MethodDeclaration method = type.getMethods()[0];\n        method.parameters();\n        method.isConstructor();\n\n        System.out.println(&quot;---------Method---------&quot;);\n        System.out.println(method.toString());\n        method.getName();\n        method.getModifiers();\n        Type returnType = method.getReturnType2();\n        System.out.println(&quot;returnType = &quot; + returnType.toString());\n\n\n        Block methodBody = method.getBody();\n        List&lt;Statement&gt; statementList = methodBody.statements();\n\n        System.out.println(statementList.toString());\n\n        statementList.get(0);\n\n        ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);\n        Assignment expression = (Assignment) ifs.getExpression();\n        Expression exp = expression.getRightHandSide();\n\n        System.out.println(result.toString());\n    }\n}\n</code></pre><p>####如何创建Java</p>\n<pre><code>package cn.shenyanchao.ast;\n\nimport org.eclipse.jdt.core.dom.*;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author shenyanchao\n *         Date:  6/13/13\n *         Time:  11:27 AM\n */\npublic class AstHelloWorld {\n\n\n    public static void main(String[] args) {\n        AST ast = AST.newAST(AST.JLS3);\n        CompilationUnit compilationUnit = ast.newCompilationUnit();\n\n        // 创建类\n        TypeDeclaration programClass = ast.newTypeDeclaration();\n        programClass.setName(ast.newSimpleName(&quot;HelloWorld&quot;));\n        programClass.modifiers().add(\n                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n        compilationUnit.types().add(programClass);\n\n        // 创建包\n        PackageDeclaration packageDeclaration = ast.newPackageDeclaration();\n        packageDeclaration.setName(ast.newName(&quot;cn.shenyanchao.hello&quot;));\n        compilationUnit.setPackage(packageDeclaration);\n\n        MethodDeclaration main = ast.newMethodDeclaration();\n        main.setName(ast.newSimpleName(&quot;main&quot;));\n        main.modifiers().add(\n                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n        main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n        main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n        programClass.bodyDeclarations().add(main);\n        Block mainBlock = ast.newBlock();\n        main.setBody(mainBlock);\n\n        // 给main方法定义String[]参数\n        SingleVariableDeclaration mainParameter = ast\n                .newSingleVariableDeclaration();\n        mainParameter.setName(ast.newSimpleName(&quot;arg&quot;));\n        mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast\n                .newName(&quot;String&quot;))));\n        main.parameters().add(mainParameter);\n\n        MethodInvocation println = ast.newMethodInvocation();\n        println.setName(ast.newSimpleName(&quot;println&quot;));\n\n        //生成String类型的常量\n        StringLiteral s = ast.newStringLiteral();\n        s.setLiteralValue(&quot;Hello World&quot;);\n        println.arguments().add(s);\n\n        println.setExpression(ast.newName(&quot;System.out&quot;));\n\n        mainBlock.statements().add(ast.newExpressionStatement(println));\n\n        System.out.println(compilationUnit.toString());\n    }\n}\n</code></pre><p>具体的使用手册，参见<a href=\"http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/\">http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/</a></p>\n","excerpt":"<p>Eclipse中有个Outline视图，这个视图内可以显示类的各种信息，包括属性、方法等。同时在这个视图内点击哪里，就能定位的类什么地方。这是个神奇的东西，那么它是如何实现的呢？其实就是AST（Abstract Syntax Tree），抽象语法树了。利用这个来对Java源码进行解析。<br>另外，Eclipse有一个<a href=\"http://www.eclipse.org/jdt/ui/astview/\">AST View</a>插件，使用这个能更加的清楚的看到解析后的效果。   </p>\n<p><img src=\"/images/blog/eclipse-ast-view.png\" alt=\"Eclipse AST View\">    </p>","more":"<p>####依赖的jar包</p>\n<ul>\n<li>org.eclipse.core.contenttype_3.4.100.v20110423-0524.jar</li>\n<li>org.eclipse.core.jobs_3.5.101.v20120113-1953.jar</li>\n<li>org.eclipse.core.resources_3.7.101.v20120125-1505.jar</li>\n<li>org.eclipse.core.runtime_3.7.0.v20110110.jar</li>\n<li>org.eclipse.equinox.common_3.6.0.v20110523.jar</li>\n<li>org.eclipse.equinox.preferences_3.4.2.v20120111-2020.jar</li>\n<li>org.eclipse.jdt.core_3.7.3.v20120119-1537.jar</li>\n<li>org.eclipse.osgi_3.7.2.v20120110-1415.jar</li>\n</ul>\n<p>这些包都可以在eclipse的plugin目录找到。可能版本有所区别。<br>如果使用maven管理，经个人试验，直接使用以下dependency也是可以的。   </p>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;\n      &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;\n      &lt;version&gt;3.8.0.v_C03&lt;/version&gt;\n  &lt;/dependency&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;\n       &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;\n       &lt;version&gt;3.6.0.v20100505&lt;/version&gt;\n   &lt;/dependency&gt;\n  &lt;dependency&gt;\n      &lt;groupId&gt;org.eclipse.core&lt;/groupId&gt;\n      &lt;artifactId&gt;org.eclipse.core.resources&lt;/artifactId&gt;\n      &lt;version&gt;3.6.0.v20100526-0737&lt;/version&gt;\n  &lt;/dependency&gt;\n</code></pre><p>####如何解析Java</p>\n<pre><code>package cn.shenyanchao.ast;\n\nimport org.apache.commons.io.FileUtils;\nimport org.eclipse.jdt.core.dom.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author shenyanchao\n *         Date:  6/13/13\n *         Time:  11:52 AM\n */\npublic class AstAnalyzer {\n    public static void main(String[] args) throws IOException {\n\n        String javaSource = FileUtils.readFileToString(new File(&quot;/home/shenyanchao/IdeaProjects/ast/src/main/java/cn/shenyanchao/from/ShenYanChaoAST.java&quot;));\n\n        ASTParser parser = ASTParser.newParser(AST.JLS3);\n        parser.setSource(javaSource.toCharArray());\n\n        // 使用解析器进行解析并返回AST上下文结果(CompilationUnit为根节点)\n        CompilationUnit result = (CompilationUnit) parser.createAST(null);\n\n        result.imports();\n        result.getPackage();\n        result.getCommentList();\n        System.out.println(result.getCommentList().toString());\n\n        TypeDeclaration type = (TypeDeclaration) result.types().get(0);\n        System.out.println(&quot;---------Type---------&quot;);\n        System.out.println(type.toString());\n\n        MethodDeclaration method = type.getMethods()[0];\n        method.parameters();\n        method.isConstructor();\n\n        System.out.println(&quot;---------Method---------&quot;);\n        System.out.println(method.toString());\n        method.getName();\n        method.getModifiers();\n        Type returnType = method.getReturnType2();\n        System.out.println(&quot;returnType = &quot; + returnType.toString());\n\n\n        Block methodBody = method.getBody();\n        List&lt;Statement&gt; statementList = methodBody.statements();\n\n        System.out.println(statementList.toString());\n\n        statementList.get(0);\n\n        ExpressionStatement ifs = (ExpressionStatement) method.getBody().statements().get(1);\n        Assignment expression = (Assignment) ifs.getExpression();\n        Expression exp = expression.getRightHandSide();\n\n        System.out.println(result.toString());\n    }\n}\n</code></pre><p>####如何创建Java</p>\n<pre><code>package cn.shenyanchao.ast;\n\nimport org.eclipse.jdt.core.dom.*;\n\n/**\n * Created with IntelliJ IDEA.\n *\n * @author shenyanchao\n *         Date:  6/13/13\n *         Time:  11:27 AM\n */\npublic class AstHelloWorld {\n\n\n    public static void main(String[] args) {\n        AST ast = AST.newAST(AST.JLS3);\n        CompilationUnit compilationUnit = ast.newCompilationUnit();\n\n        // 创建类\n        TypeDeclaration programClass = ast.newTypeDeclaration();\n        programClass.setName(ast.newSimpleName(&quot;HelloWorld&quot;));\n        programClass.modifiers().add(\n                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n        compilationUnit.types().add(programClass);\n\n        // 创建包\n        PackageDeclaration packageDeclaration = ast.newPackageDeclaration();\n        packageDeclaration.setName(ast.newName(&quot;cn.shenyanchao.hello&quot;));\n        compilationUnit.setPackage(packageDeclaration);\n\n        MethodDeclaration main = ast.newMethodDeclaration();\n        main.setName(ast.newSimpleName(&quot;main&quot;));\n        main.modifiers().add(\n                ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));\n        main.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n        main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n        programClass.bodyDeclarations().add(main);\n        Block mainBlock = ast.newBlock();\n        main.setBody(mainBlock);\n\n        // 给main方法定义String[]参数\n        SingleVariableDeclaration mainParameter = ast\n                .newSingleVariableDeclaration();\n        mainParameter.setName(ast.newSimpleName(&quot;arg&quot;));\n        mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast\n                .newName(&quot;String&quot;))));\n        main.parameters().add(mainParameter);\n\n        MethodInvocation println = ast.newMethodInvocation();\n        println.setName(ast.newSimpleName(&quot;println&quot;));\n\n        //生成String类型的常量\n        StringLiteral s = ast.newStringLiteral();\n        s.setLiteralValue(&quot;Hello World&quot;);\n        println.arguments().add(s);\n\n        println.setExpression(ast.newName(&quot;System.out&quot;));\n\n        mainBlock.statements().add(ast.newExpressionStatement(println));\n\n        System.out.println(compilationUnit.toString());\n    }\n}\n</code></pre><p>具体的使用手册，参见<a href=\"http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/\">http://www.shenyanchao.cn/blog/2013/06/07/eclipse-ast/</a></p>"},{"layout":"post","title":"selenium wiki:webdriverJs","date":"2013-05-30T11:56:00.000Z","comments":1,"_content":"# WebDriverJS\n\nWebDriver 的 JavaScript 语言绑定。本文包含以下内容：\n\n- 介绍\n- 快速上手\n    - 在 Node 中运行\n    - 在浏览器中运行\n- 设计细节\n    - 管理异步 API\n    - 同服务端通讯\n    - /xdrpc\n- 未来计划\n\n## 介绍\n\nWebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。\n\n**警告：** WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。\n<!--more-->\n## 快速上手\n\n### 在 Node 中运行\n\n虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：\n\n    $ ./go selenium-server-standalone //javascript/node:webdriver\n    \n当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：\n\n    $ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &\n    $ node\n    \n    var webdriver = require('./build/javascript/node/webdriver');\n    \n    var driver = new webdriver.Builder().\n        usingServer('http://localhost:4444/wd/hub').\n        withCapabilities({\n          'browserName': 'chrome',\n          'version': '',\n          'platform': 'ANY',\n          'javascriptEnabled': true\n        }).\n        build();\n    \n    driver.get('http://www.google.com');\n    driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n    driver.findElement(webdriver.By.name('btnG')).click();\n    driver.getTitle().then(function(title) {\n      require('assert').equal('webdriver - Google Search', title);\n    \n    });\n    \n    driver.quit();\n\n### 在浏览器中运行\n\n除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：\n\n    $ ./go //javascript/webdriver:webdriver\n\n为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 [JsonWireProtocol](https://code.google.com/p/selenium/wiki/JsonWireProtocol) 和 [cross-origin resource sharing](https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing)：\n\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <script>\n      var client = new webdriver.http.CorsClient('http://localhost:4444/wd/hub');\n      var executor = new webdriver.http.Executor(client);\n    \n      // 启动一个新浏览器，这个浏览器可以被这段脚本控制\n      var driver = webdriver.WebDriver.createSession(executor, {\n        'browserName': 'chrome',\n        'version': '',\n        'platform': 'ANY',\n        'javascriptEnabled': true\n      });\n    \n      driver.get('http://www.google.com');\n      driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n      driver.findElement(webdriver.By.name('btnG')).click();\n      driver.getTitle().then(function(title) {\n        if (title !== 'webdriver - Google Search') {\n          throw new Error(\n              'Expected \"webdriver - Google Search\", but was \"' + title + '\"');\n        }\n      });\n    \n      driver.quit();\n    </script>\n\n#### 控制宿主浏览器\n\n启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。\n\n    <!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&wdsid=foo1234 -->\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <input id=\"input\" type=\"text\"/>\n    <script>\n      // Attaches to the server and session controlling this browser.\n      var driver = new webdriver.Builder().build();\n    \n      var input = driver.findElement(webdriver.By.tagName('input'));\n      input.sendKeys('foo bar baz').then(function() {\n        assertEquals('foo bar baz',\n            document.getElementById('input').value);\n      });\n    </script>\n\n##### 警告\n\n在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。\n\n- webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。\n- webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):\n\n\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <script>\n      var testWindow = window.open('', 'slave');\n    \n      var driver = new webdriver.Builder().build();\n      driver.switchTo().window('slave');\n      driver.get('http://www.google.com');\n      driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n      driver.findElement(webdriver.By.name('btnG')).click(); \n    </script>\n\n#### 调试 Tests\n\n你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。\n\n    $ ./go selenium-server-standalone\n    $ java -jar \\\n        -Dwebdriver.server.session.timeout=0 \\\n        build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &\n\n启动服务后，访问 WebDriver 的控制面板： http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除 sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。\n\n##### 支持的浏览器\n\n- IE 8+\n- Firefox 4+\n- Chrome 12+\n- Opera 12.0a+\n- Android 4.0+\n\n## 设计细节\n\n### 管理异步 API\n\n不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 [Promise/A](http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&sa=D&sntz=1&usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw) 提议，它定义了 promise 是任意对象上的 then 函数属性。 \n\n    /**\n     * Registers listeners for when this instance is resolved.\n     *\n     * @param {?function(*)} callback The function to call if this promise is\n     *     successfully resolved. The function should expect a single argument: the\n     *     promise's resolved value.\n     * @param {?function(*)=} opt_errback The function to call if this promise is\n     *     rejected. The function should expect a single argument: the failure\n     *     reason. While this argument is typically an {@code Error}, any type is\n     *     permissible.\n     * @return {!Promise} A new promise which will be resolved\n     *     with the result of the invoked callback.\n     */\n    Promise.prototype.then = function(callback, opt_errback) {\n    };\n\n通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：\n\n    var driver = new webdriver.Builder().build();\n    driver.get('http://www.google.com').then(function() {\n      return driver.findElement(webdriver.By.name('q')).then(function(searchBox){\n        return searchBox.sendKeys('webdriver').then(function() {\n          return driver.findElement(webdriver.By.name('btnG')).then(function(submitButton) {\n            return submitButton.click().then(function() {\n              return driver.getTitle().then(function(title) {\n                assertEquals('webdriver - Google Search', title);\n              });\n            });\n          });\n        });\n      });\n    });\n\n不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。\n\n简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：\n\n    var driver = new webdriver.Builder().build();\n    driver.get('http://www.google.com');\n    \n    var searchBox = driver.findElement(webdriver.By.name('q'));\n    searchBox.sendKeys('webdriver');\n    \n    var submitButton = driver.findElement(webdriver.By.name('btnG'));\n    submitButton.click();\n    \n    driver.getTitle().then(function(title) {\n      assertEquals('webdriver - Google Search', title);\n    });\n\n#### On Frames and Callbacks\n\n就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：\n\n    driver.get(MY_APP_URL);\n    driver.getTitle().then(function(title) {\n      if (title === 'Login page') {\n        driver.findElement(webdriver.By.id('user')).sendKeys('bugs');\n        driver.findElement(webdriver.By.id('pw')).sendKeys('bunny');\n        driver.findElement(webdriver.By.id('login')).click();\n      }\n    });\n    driver.findElement(webdriver.By.id('userPreferences')).click();\n\n这个测试用例可以使用 WebDriver 的 Java API 重写如下：\n\n    driver.get(MY_APP_URL);\n    if (\"Login Page\".equals(driver.getTitle())) {\n      driver.findElement(By.id(\"user\")).sendKeys(\"bugs\");\n      driver.findElement(By.id(\"pw\")).sendKeys(\"bunny\");\n      driver.findElement(By.id(\"login\")).click();\n    }\n    driver.findElement(By.id(\"userPreferences\")).click();\n\n#### 错误处理\n\n既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。\n\n如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。\n\n    // 注册一个事件监听未处理的错误\n    webdriver.promise.Application.\n        getInstance().\n        on('uncaughtException', function(e) {\n          console.error('There was an uncaught exception: ' + e.message);\n        });\n    \n    driver.switchTo().window('foo').then(null, function(e) {\n      // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡\n      if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {\n        throw e;\n      }\n    });\n    // 如果上面的错误不被抑制的话，这句将永远不会执行\n    driver.getTitle();\n\n### 同服务端通讯\n\n当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。\n\n#### Cross-Origin Resource Sharing\n\n如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。\n\n    Access-Control-Origin: *\n    Access-Control-Allow-Methods: DELETE,GET,HEAD,POST\n    Access-Control-Allow-Headers: Accept,Content-Type\n\n在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。\n\n- IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。\n- WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。\n- 如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。\n\n为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。\n\n#### /xdrpc\n\n**POST /xdrpc**\n\n作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。\n\n**参数：**\n\n- method - {string} http 方法\n- path - {string} 命令路径\n- data - {Object} JSON 格式的命令参数\n\n**返回：**\n\n{*} 命令执行的结果。\n\n举个例子，考虑以下 /xdrpc 命令：\n\n    POST /xdrpc HTTP/1.1\n    Accept: application/json\n    Content-Type: application/json\n    Content-Length: 94\n    \n    {\"method\":\"POST\",\"path\":\"/session/123/element/0a/element\",\"data\":{\"using\":\"id\",\"value\":\"foo\"}}\n    \n服务端将编码这个命令并重新分发：\n\n    POST /session/123/element/0a/element HTTP/1.1\n    Accept: application/json\n    Content-Type: application/json\n    Content-Length: 28\n    \n    {\"using\":\"id\",\"value\":\"foo\"}\n    \n不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：\n\n    HTTP/1.1 200 OK\n    Content-Type: application/json\n    Content-Length: 60\n    \n    {\"status\":7,\"value\":{\"message\":\"Unable to locate element.\"}}\n\n## 未来计划\n\n以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）\n\n- 使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。\n- 基于扩展实现一个 SafariDriver。\n- 为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2013-05-30-selenium-wiki-web-driver-js.markdown","raw":"---\nlayout: post\ntitle: \"selenium wiki:webdriverJs\"\ndate: 2013-05-30 19:56\ncomments: true\ncategories: selenium-wiki\ntags: [ selenium ]\n---\n# WebDriverJS\n\nWebDriver 的 JavaScript 语言绑定。本文包含以下内容：\n\n- 介绍\n- 快速上手\n    - 在 Node 中运行\n    - 在浏览器中运行\n- 设计细节\n    - 管理异步 API\n    - 同服务端通讯\n    - /xdrpc\n- 未来计划\n\n## 介绍\n\nWebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。\n\n**警告：** WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。\n<!--more-->\n## 快速上手\n\n### 在 Node 中运行\n\n虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：\n\n    $ ./go selenium-server-standalone //javascript/node:webdriver\n    \n当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：\n\n    $ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &\n    $ node\n    \n    var webdriver = require('./build/javascript/node/webdriver');\n    \n    var driver = new webdriver.Builder().\n        usingServer('http://localhost:4444/wd/hub').\n        withCapabilities({\n          'browserName': 'chrome',\n          'version': '',\n          'platform': 'ANY',\n          'javascriptEnabled': true\n        }).\n        build();\n    \n    driver.get('http://www.google.com');\n    driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n    driver.findElement(webdriver.By.name('btnG')).click();\n    driver.getTitle().then(function(title) {\n      require('assert').equal('webdriver - Google Search', title);\n    \n    });\n    \n    driver.quit();\n\n### 在浏览器中运行\n\n除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：\n\n    $ ./go //javascript/webdriver:webdriver\n\n为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 [JsonWireProtocol](https://code.google.com/p/selenium/wiki/JsonWireProtocol) 和 [cross-origin resource sharing](https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing)：\n\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <script>\n      var client = new webdriver.http.CorsClient('http://localhost:4444/wd/hub');\n      var executor = new webdriver.http.Executor(client);\n    \n      // 启动一个新浏览器，这个浏览器可以被这段脚本控制\n      var driver = webdriver.WebDriver.createSession(executor, {\n        'browserName': 'chrome',\n        'version': '',\n        'platform': 'ANY',\n        'javascriptEnabled': true\n      });\n    \n      driver.get('http://www.google.com');\n      driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n      driver.findElement(webdriver.By.name('btnG')).click();\n      driver.getTitle().then(function(title) {\n        if (title !== 'webdriver - Google Search') {\n          throw new Error(\n              'Expected \"webdriver - Google Search\", but was \"' + title + '\"');\n        }\n      });\n    \n      driver.quit();\n    </script>\n\n#### 控制宿主浏览器\n\n启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。\n\n    <!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&wdsid=foo1234 -->\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <input id=\"input\" type=\"text\"/>\n    <script>\n      // Attaches to the server and session controlling this browser.\n      var driver = new webdriver.Builder().build();\n    \n      var input = driver.findElement(webdriver.By.tagName('input'));\n      input.sendKeys('foo bar baz').then(function() {\n        assertEquals('foo bar baz',\n            document.getElementById('input').value);\n      });\n    </script>\n\n##### 警告\n\n在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。\n\n- webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。\n- webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):\n\n\n    <!DOCTYPE html>\n    <script src=\"webdriver.js\"></script>\n    <script>\n      var testWindow = window.open('', 'slave');\n    \n      var driver = new webdriver.Builder().build();\n      driver.switchTo().window('slave');\n      driver.get('http://www.google.com');\n      driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');\n      driver.findElement(webdriver.By.name('btnG')).click(); \n    </script>\n\n#### 调试 Tests\n\n你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。\n\n    $ ./go selenium-server-standalone\n    $ java -jar \\\n        -Dwebdriver.server.session.timeout=0 \\\n        build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &\n\n启动服务后，访问 WebDriver 的控制面板： http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除 sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。\n\n##### 支持的浏览器\n\n- IE 8+\n- Firefox 4+\n- Chrome 12+\n- Opera 12.0a+\n- Android 4.0+\n\n## 设计细节\n\n### 管理异步 API\n\n不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 [Promise/A](http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&sa=D&sntz=1&usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw) 提议，它定义了 promise 是任意对象上的 then 函数属性。 \n\n    /**\n     * Registers listeners for when this instance is resolved.\n     *\n     * @param {?function(*)} callback The function to call if this promise is\n     *     successfully resolved. The function should expect a single argument: the\n     *     promise's resolved value.\n     * @param {?function(*)=} opt_errback The function to call if this promise is\n     *     rejected. The function should expect a single argument: the failure\n     *     reason. While this argument is typically an {@code Error}, any type is\n     *     permissible.\n     * @return {!Promise} A new promise which will be resolved\n     *     with the result of the invoked callback.\n     */\n    Promise.prototype.then = function(callback, opt_errback) {\n    };\n\n通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：\n\n    var driver = new webdriver.Builder().build();\n    driver.get('http://www.google.com').then(function() {\n      return driver.findElement(webdriver.By.name('q')).then(function(searchBox){\n        return searchBox.sendKeys('webdriver').then(function() {\n          return driver.findElement(webdriver.By.name('btnG')).then(function(submitButton) {\n            return submitButton.click().then(function() {\n              return driver.getTitle().then(function(title) {\n                assertEquals('webdriver - Google Search', title);\n              });\n            });\n          });\n        });\n      });\n    });\n\n不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。\n\n简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：\n\n    var driver = new webdriver.Builder().build();\n    driver.get('http://www.google.com');\n    \n    var searchBox = driver.findElement(webdriver.By.name('q'));\n    searchBox.sendKeys('webdriver');\n    \n    var submitButton = driver.findElement(webdriver.By.name('btnG'));\n    submitButton.click();\n    \n    driver.getTitle().then(function(title) {\n      assertEquals('webdriver - Google Search', title);\n    });\n\n#### On Frames and Callbacks\n\n就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：\n\n    driver.get(MY_APP_URL);\n    driver.getTitle().then(function(title) {\n      if (title === 'Login page') {\n        driver.findElement(webdriver.By.id('user')).sendKeys('bugs');\n        driver.findElement(webdriver.By.id('pw')).sendKeys('bunny');\n        driver.findElement(webdriver.By.id('login')).click();\n      }\n    });\n    driver.findElement(webdriver.By.id('userPreferences')).click();\n\n这个测试用例可以使用 WebDriver 的 Java API 重写如下：\n\n    driver.get(MY_APP_URL);\n    if (\"Login Page\".equals(driver.getTitle())) {\n      driver.findElement(By.id(\"user\")).sendKeys(\"bugs\");\n      driver.findElement(By.id(\"pw\")).sendKeys(\"bunny\");\n      driver.findElement(By.id(\"login\")).click();\n    }\n    driver.findElement(By.id(\"userPreferences\")).click();\n\n#### 错误处理\n\n既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。\n\n如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。\n\n    // 注册一个事件监听未处理的错误\n    webdriver.promise.Application.\n        getInstance().\n        on('uncaughtException', function(e) {\n          console.error('There was an uncaught exception: ' + e.message);\n        });\n    \n    driver.switchTo().window('foo').then(null, function(e) {\n      // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡\n      if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {\n        throw e;\n      }\n    });\n    // 如果上面的错误不被抑制的话，这句将永远不会执行\n    driver.getTitle();\n\n### 同服务端通讯\n\n当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。\n\n#### Cross-Origin Resource Sharing\n\n如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。\n\n    Access-Control-Origin: *\n    Access-Control-Allow-Methods: DELETE,GET,HEAD,POST\n    Access-Control-Allow-Headers: Accept,Content-Type\n\n在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。\n\n- IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。\n- WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。\n- 如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。\n\n为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。\n\n#### /xdrpc\n\n**POST /xdrpc**\n\n作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。\n\n**参数：**\n\n- method - {string} http 方法\n- path - {string} 命令路径\n- data - {Object} JSON 格式的命令参数\n\n**返回：**\n\n{*} 命令执行的结果。\n\n举个例子，考虑以下 /xdrpc 命令：\n\n    POST /xdrpc HTTP/1.1\n    Accept: application/json\n    Content-Type: application/json\n    Content-Length: 94\n    \n    {\"method\":\"POST\",\"path\":\"/session/123/element/0a/element\",\"data\":{\"using\":\"id\",\"value\":\"foo\"}}\n    \n服务端将编码这个命令并重新分发：\n\n    POST /session/123/element/0a/element HTTP/1.1\n    Accept: application/json\n    Content-Type: application/json\n    Content-Length: 28\n    \n    {\"using\":\"id\",\"value\":\"foo\"}\n    \n不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：\n\n    HTTP/1.1 200 OK\n    Content-Type: application/json\n    Content-Length: 60\n    \n    {\"status\":7,\"value\":{\"message\":\"Unable to locate element.\"}}\n\n## 未来计划\n\n以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）\n\n- 使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。\n- 基于扩展实现一个 SafariDriver。\n- 为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2013-05-30-selenium-wiki-web-driver-js","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop65006pv8fy45jh7jjp","content":"<h1 id=\"WebDriverJS\"><a href=\"#WebDriverJS\" class=\"headerlink\" title=\"WebDriverJS\"></a>WebDriverJS</h1><p>WebDriver 的 JavaScript 语言绑定。本文包含以下内容：</p>\n<ul>\n<li>介绍</li>\n<li>快速上手<ul>\n<li>在 Node 中运行</li>\n<li>在浏览器中运行</li>\n</ul>\n</li>\n<li>设计细节<ul>\n<li>管理异步 API</li>\n<li>同服务端通讯</li>\n<li>/xdrpc</li>\n</ul>\n</li>\n<li>未来计划</li>\n</ul>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>WebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。</p>\n<p><strong>警告：</strong> WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。<br><a id=\"more\"></a></p>\n<h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><h3 id=\"在-Node-中运行\"><a href=\"#在-Node-中运行\" class=\"headerlink\" title=\"在 Node 中运行\"></a>在 Node 中运行</h3><p>虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：</p>\n<pre><code>$ ./go selenium-server-standalone //javascript/node:webdriver\n</code></pre><p>当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：</p>\n<pre><code>$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;\n$ node\n\nvar webdriver = require(&apos;./build/javascript/node/webdriver&apos;);\n\nvar driver = new webdriver.Builder().\n    usingServer(&apos;http://localhost:4444/wd/hub&apos;).\n    withCapabilities({\n      &apos;browserName&apos;: &apos;chrome&apos;,\n      &apos;version&apos;: &apos;&apos;,\n      &apos;platform&apos;: &apos;ANY&apos;,\n      &apos;javascriptEnabled&apos;: true\n    }).\n    build();\n\ndriver.get(&apos;http://www.google.com&apos;);\ndriver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\ndriver.findElement(webdriver.By.name(&apos;btnG&apos;)).click();\ndriver.getTitle().then(function(title) {\n  require(&apos;assert&apos;).equal(&apos;webdriver - Google Search&apos;, title);\n\n});\n\ndriver.quit();\n</code></pre><h3 id=\"在浏览器中运行\"><a href=\"#在浏览器中运行\" class=\"headerlink\" title=\"在浏览器中运行\"></a>在浏览器中运行</h3><p>除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：</p>\n<pre><code>$ ./go //javascript/webdriver:webdriver\n</code></pre><p>为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 <a href=\"https://code.google.com/p/selenium/wiki/JsonWireProtocol\" target=\"_blank\" rel=\"external\">JsonWireProtocol</a> 和 <a href=\"https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing\" target=\"_blank\" rel=\"external\">cross-origin resource sharing</a>：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  var client = new webdriver.http.CorsClient(&apos;http://localhost:4444/wd/hub&apos;);\n  var executor = new webdriver.http.Executor(client);\n\n  // 启动一个新浏览器，这个浏览器可以被这段脚本控制\n  var driver = webdriver.WebDriver.createSession(executor, {\n    &apos;browserName&apos;: &apos;chrome&apos;,\n    &apos;version&apos;: &apos;&apos;,\n    &apos;platform&apos;: &apos;ANY&apos;,\n    &apos;javascriptEnabled&apos;: true\n  });\n\n  driver.get(&apos;http://www.google.com&apos;);\n  driver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\n  driver.findElement(webdriver.By.name(&apos;btnG&apos;)).click();\n  driver.getTitle().then(function(title) {\n    if (title !== &apos;webdriver - Google Search&apos;) {\n      throw new Error(\n          &apos;Expected &quot;webdriver - Google Search&quot;, but was &quot;&apos; + title + &apos;&quot;&apos;);\n    }\n  });\n\n  driver.quit();\n&lt;/script&gt;\n</code></pre><h4 id=\"控制宿主浏览器\"><a href=\"#控制宿主浏览器\" class=\"headerlink\" title=\"控制宿主浏览器\"></a>控制宿主浏览器</h4><p>启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。</p>\n<pre><code>&lt;!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&amp;wdsid=foo1234 --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;input id=&quot;input&quot; type=&quot;text&quot;/&gt;\n&lt;script&gt;\n  // Attaches to the server and session controlling this browser.\n  var driver = new webdriver.Builder().build();\n\n  var input = driver.findElement(webdriver.By.tagName(&apos;input&apos;));\n  input.sendKeys(&apos;foo bar baz&apos;).then(function() {\n    assertEquals(&apos;foo bar baz&apos;,\n        document.getElementById(&apos;input&apos;).value);\n  });\n&lt;/script&gt;\n</code></pre><h5 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h5><p>在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。</p>\n<ul>\n<li>webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。</li>\n<li>webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  var testWindow = window.open(&apos;&apos;, &apos;slave&apos;);\n\n  var driver = new webdriver.Builder().build();\n  driver.switchTo().window(&apos;slave&apos;);\n  driver.get(&apos;http://www.google.com&apos;);\n  driver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\n  driver.findElement(webdriver.By.name(&apos;btnG&apos;)).click(); \n&lt;/script&gt;\n</code></pre><h4 id=\"调试-Tests\"><a href=\"#调试-Tests\" class=\"headerlink\" title=\"调试 Tests\"></a>调试 Tests</h4><p>你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。</p>\n<pre><code>$ ./go selenium-server-standalone\n$ java -jar \\\n    -Dwebdriver.server.session.timeout=0 \\\n    build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;\n</code></pre><p>启动服务后，访问 WebDriver 的控制面板： <a href=\"http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除\" target=\"_blank\" rel=\"external\">http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除</a> sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。</p>\n<h5 id=\"支持的浏览器\"><a href=\"#支持的浏览器\" class=\"headerlink\" title=\"支持的浏览器\"></a>支持的浏览器</h5><ul>\n<li>IE 8+</li>\n<li>Firefox 4+</li>\n<li>Chrome 12+</li>\n<li>Opera 12.0a+</li>\n<li>Android 4.0+</li>\n</ul>\n<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><h3 id=\"管理异步-API\"><a href=\"#管理异步-API\" class=\"headerlink\" title=\"管理异步 API\"></a>管理异步 API</h3><p>不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 <a href=\"http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw\" target=\"_blank\" rel=\"external\">Promise/A</a> 提议，它定义了 promise 是任意对象上的 then 函数属性。 </p>\n<pre><code>/**\n * Registers listeners for when this instance is resolved.\n *\n * @param {?function(*)} callback The function to call if this promise is\n *     successfully resolved. The function should expect a single argument: the\n *     promise&apos;s resolved value.\n * @param {?function(*)=} opt_errback The function to call if this promise is\n *     rejected. The function should expect a single argument: the failure\n *     reason. While this argument is typically an {@code Error}, any type is\n *     permissible.\n * @return {!Promise} A new promise which will be resolved\n *     with the result of the invoked callback.\n */\nPromise.prototype.then = function(callback, opt_errback) {\n};\n</code></pre><p>通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：</p>\n<pre><code>var driver = new webdriver.Builder().build();\ndriver.get(&apos;http://www.google.com&apos;).then(function() {\n  return driver.findElement(webdriver.By.name(&apos;q&apos;)).then(function(searchBox){\n    return searchBox.sendKeys(&apos;webdriver&apos;).then(function() {\n      return driver.findElement(webdriver.By.name(&apos;btnG&apos;)).then(function(submitButton) {\n        return submitButton.click().then(function() {\n          return driver.getTitle().then(function(title) {\n            assertEquals(&apos;webdriver - Google Search&apos;, title);\n          });\n        });\n      });\n    });\n  });\n});\n</code></pre><p>不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。</p>\n<p>简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：</p>\n<pre><code>var driver = new webdriver.Builder().build();\ndriver.get(&apos;http://www.google.com&apos;);\n\nvar searchBox = driver.findElement(webdriver.By.name(&apos;q&apos;));\nsearchBox.sendKeys(&apos;webdriver&apos;);\n\nvar submitButton = driver.findElement(webdriver.By.name(&apos;btnG&apos;));\nsubmitButton.click();\n\ndriver.getTitle().then(function(title) {\n  assertEquals(&apos;webdriver - Google Search&apos;, title);\n});\n</code></pre><h4 id=\"On-Frames-and-Callbacks\"><a href=\"#On-Frames-and-Callbacks\" class=\"headerlink\" title=\"On Frames and Callbacks\"></a>On Frames and Callbacks</h4><p>就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：</p>\n<pre><code>driver.get(MY_APP_URL);\ndriver.getTitle().then(function(title) {\n  if (title === &apos;Login page&apos;) {\n    driver.findElement(webdriver.By.id(&apos;user&apos;)).sendKeys(&apos;bugs&apos;);\n    driver.findElement(webdriver.By.id(&apos;pw&apos;)).sendKeys(&apos;bunny&apos;);\n    driver.findElement(webdriver.By.id(&apos;login&apos;)).click();\n  }\n});\ndriver.findElement(webdriver.By.id(&apos;userPreferences&apos;)).click();\n</code></pre><p>这个测试用例可以使用 WebDriver 的 Java API 重写如下：</p>\n<pre><code>driver.get(MY_APP_URL);\nif (&quot;Login Page&quot;.equals(driver.getTitle())) {\n  driver.findElement(By.id(&quot;user&quot;)).sendKeys(&quot;bugs&quot;);\n  driver.findElement(By.id(&quot;pw&quot;)).sendKeys(&quot;bunny&quot;);\n  driver.findElement(By.id(&quot;login&quot;)).click();\n}\ndriver.findElement(By.id(&quot;userPreferences&quot;)).click();\n</code></pre><h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。</p>\n<p>如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。</p>\n<pre><code>// 注册一个事件监听未处理的错误\nwebdriver.promise.Application.\n    getInstance().\n    on(&apos;uncaughtException&apos;, function(e) {\n      console.error(&apos;There was an uncaught exception: &apos; + e.message);\n    });\n\ndriver.switchTo().window(&apos;foo&apos;).then(null, function(e) {\n  // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡\n  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {\n    throw e;\n  }\n});\n// 如果上面的错误不被抑制的话，这句将永远不会执行\ndriver.getTitle();\n</code></pre><h3 id=\"同服务端通讯\"><a href=\"#同服务端通讯\" class=\"headerlink\" title=\"同服务端通讯\"></a>同服务端通讯</h3><p>当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。</p>\n<h4 id=\"Cross-Origin-Resource-Sharing\"><a href=\"#Cross-Origin-Resource-Sharing\" class=\"headerlink\" title=\"Cross-Origin Resource Sharing\"></a>Cross-Origin Resource Sharing</h4><p>如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。</p>\n<pre><code>Access-Control-Origin: *\nAccess-Control-Allow-Methods: DELETE,GET,HEAD,POST\nAccess-Control-Allow-Headers: Accept,Content-Type\n</code></pre><p>在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。</p>\n<ul>\n<li>IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。</li>\n<li>WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。</li>\n<li>如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。</li>\n</ul>\n<p>为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。</p>\n<h4 id=\"xdrpc\"><a href=\"#xdrpc\" class=\"headerlink\" title=\"/xdrpc\"></a>/xdrpc</h4><p><strong>POST /xdrpc</strong></p>\n<p>作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。</p>\n<p><strong>参数：</strong></p>\n<ul>\n<li>method - {string} http 方法</li>\n<li>path - {string} 命令路径</li>\n<li>data - {Object} JSON 格式的命令参数</li>\n</ul>\n<p><strong>返回：</strong></p>\n<p>{*} 命令执行的结果。</p>\n<p>举个例子，考虑以下 /xdrpc 命令：</p>\n<pre><code>POST /xdrpc HTTP/1.1\nAccept: application/json\nContent-Type: application/json\nContent-Length: 94\n\n{&quot;method&quot;:&quot;POST&quot;,&quot;path&quot;:&quot;/session/123/element/0a/element&quot;,&quot;data&quot;:{&quot;using&quot;:&quot;id&quot;,&quot;value&quot;:&quot;foo&quot;}}\n</code></pre><p>服务端将编码这个命令并重新分发：</p>\n<pre><code>POST /session/123/element/0a/element HTTP/1.1\nAccept: application/json\nContent-Type: application/json\nContent-Length: 28\n\n{&quot;using&quot;:&quot;id&quot;,&quot;value&quot;:&quot;foo&quot;}\n</code></pre><p>不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：</p>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 60\n\n{&quot;status&quot;:7,&quot;value&quot;:{&quot;message&quot;:&quot;Unable to locate element.&quot;}}\n</code></pre><h2 id=\"未来计划\"><a href=\"#未来计划\" class=\"headerlink\" title=\"未来计划\"></a>未来计划</h2><p>以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）</p>\n<ul>\n<li>使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。</li>\n<li>基于扩展实现一个 SafariDriver。</li>\n<li>为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。</li>\n</ul>\n","excerpt":"<h1 id=\"WebDriverJS\"><a href=\"#WebDriverJS\" class=\"headerlink\" title=\"WebDriverJS\"></a>WebDriverJS</h1><p>WebDriver 的 JavaScript 语言绑定。本文包含以下内容：</p>\n<ul>\n<li>介绍</li>\n<li>快速上手<ul>\n<li>在 Node 中运行</li>\n<li>在浏览器中运行</li>\n</ul>\n</li>\n<li>设计细节<ul>\n<li>管理异步 API</li>\n<li>同服务端通讯</li>\n<li>/xdrpc</li>\n</ul>\n</li>\n<li>未来计划</li>\n</ul>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>WebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。</p>\n<p><strong>警告：</strong> WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。<br>","more":"</p>\n<h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><h3 id=\"在-Node-中运行\"><a href=\"#在-Node-中运行\" class=\"headerlink\" title=\"在 Node 中运行\"></a>在 Node 中运行</h3><p>虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：</p>\n<pre><code>$ ./go selenium-server-standalone //javascript/node:webdriver\n</code></pre><p>当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：</p>\n<pre><code>$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;\n$ node\n\nvar webdriver = require(&apos;./build/javascript/node/webdriver&apos;);\n\nvar driver = new webdriver.Builder().\n    usingServer(&apos;http://localhost:4444/wd/hub&apos;).\n    withCapabilities({\n      &apos;browserName&apos;: &apos;chrome&apos;,\n      &apos;version&apos;: &apos;&apos;,\n      &apos;platform&apos;: &apos;ANY&apos;,\n      &apos;javascriptEnabled&apos;: true\n    }).\n    build();\n\ndriver.get(&apos;http://www.google.com&apos;);\ndriver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\ndriver.findElement(webdriver.By.name(&apos;btnG&apos;)).click();\ndriver.getTitle().then(function(title) {\n  require(&apos;assert&apos;).equal(&apos;webdriver - Google Search&apos;, title);\n\n});\n\ndriver.quit();\n</code></pre><h3 id=\"在浏览器中运行\"><a href=\"#在浏览器中运行\" class=\"headerlink\" title=\"在浏览器中运行\"></a>在浏览器中运行</h3><p>除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：</p>\n<pre><code>$ ./go //javascript/webdriver:webdriver\n</code></pre><p>为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 <a href=\"https://code.google.com/p/selenium/wiki/JsonWireProtocol\">JsonWireProtocol</a> 和 <a href=\"https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing\">cross-origin resource sharing</a>：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  var client = new webdriver.http.CorsClient(&apos;http://localhost:4444/wd/hub&apos;);\n  var executor = new webdriver.http.Executor(client);\n\n  // 启动一个新浏览器，这个浏览器可以被这段脚本控制\n  var driver = webdriver.WebDriver.createSession(executor, {\n    &apos;browserName&apos;: &apos;chrome&apos;,\n    &apos;version&apos;: &apos;&apos;,\n    &apos;platform&apos;: &apos;ANY&apos;,\n    &apos;javascriptEnabled&apos;: true\n  });\n\n  driver.get(&apos;http://www.google.com&apos;);\n  driver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\n  driver.findElement(webdriver.By.name(&apos;btnG&apos;)).click();\n  driver.getTitle().then(function(title) {\n    if (title !== &apos;webdriver - Google Search&apos;) {\n      throw new Error(\n          &apos;Expected &quot;webdriver - Google Search&quot;, but was &quot;&apos; + title + &apos;&quot;&apos;);\n    }\n  });\n\n  driver.quit();\n&lt;/script&gt;\n</code></pre><h4 id=\"控制宿主浏览器\"><a href=\"#控制宿主浏览器\" class=\"headerlink\" title=\"控制宿主浏览器\"></a>控制宿主浏览器</h4><p>启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。</p>\n<pre><code>&lt;!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&amp;wdsid=foo1234 --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;input id=&quot;input&quot; type=&quot;text&quot;/&gt;\n&lt;script&gt;\n  // Attaches to the server and session controlling this browser.\n  var driver = new webdriver.Builder().build();\n\n  var input = driver.findElement(webdriver.By.tagName(&apos;input&apos;));\n  input.sendKeys(&apos;foo bar baz&apos;).then(function() {\n    assertEquals(&apos;foo bar baz&apos;,\n        document.getElementById(&apos;input&apos;).value);\n  });\n&lt;/script&gt;\n</code></pre><h5 id=\"警告\"><a href=\"#警告\" class=\"headerlink\" title=\"警告\"></a>警告</h5><p>在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。</p>\n<ul>\n<li>webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。</li>\n<li>webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;script src=&quot;webdriver.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  var testWindow = window.open(&apos;&apos;, &apos;slave&apos;);\n\n  var driver = new webdriver.Builder().build();\n  driver.switchTo().window(&apos;slave&apos;);\n  driver.get(&apos;http://www.google.com&apos;);\n  driver.findElement(webdriver.By.name(&apos;q&apos;)).sendKeys(&apos;webdriver&apos;);\n  driver.findElement(webdriver.By.name(&apos;btnG&apos;)).click(); \n&lt;/script&gt;\n</code></pre><h4 id=\"调试-Tests\"><a href=\"#调试-Tests\" class=\"headerlink\" title=\"调试 Tests\"></a>调试 Tests</h4><p>你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。</p>\n<pre><code>$ ./go selenium-server-standalone\n$ java -jar \\\n    -Dwebdriver.server.session.timeout=0 \\\n    build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;\n</code></pre><p>启动服务后，访问 WebDriver 的控制面板： <a href=\"http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除\">http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除</a> sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。</p>\n<h5 id=\"支持的浏览器\"><a href=\"#支持的浏览器\" class=\"headerlink\" title=\"支持的浏览器\"></a>支持的浏览器</h5><ul>\n<li>IE 8+</li>\n<li>Firefox 4+</li>\n<li>Chrome 12+</li>\n<li>Opera 12.0a+</li>\n<li>Android 4.0+</li>\n</ul>\n<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><h3 id=\"管理异步-API\"><a href=\"#管理异步-API\" class=\"headerlink\" title=\"管理异步 API\"></a>管理异步 API</h3><p>不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 <a href=\"http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw\">Promise/A</a> 提议，它定义了 promise 是任意对象上的 then 函数属性。 </p>\n<pre><code>/**\n * Registers listeners for when this instance is resolved.\n *\n * @param {?function(*)} callback The function to call if this promise is\n *     successfully resolved. The function should expect a single argument: the\n *     promise&apos;s resolved value.\n * @param {?function(*)=} opt_errback The function to call if this promise is\n *     rejected. The function should expect a single argument: the failure\n *     reason. While this argument is typically an {@code Error}, any type is\n *     permissible.\n * @return {!Promise} A new promise which will be resolved\n *     with the result of the invoked callback.\n */\nPromise.prototype.then = function(callback, opt_errback) {\n};\n</code></pre><p>通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：</p>\n<pre><code>var driver = new webdriver.Builder().build();\ndriver.get(&apos;http://www.google.com&apos;).then(function() {\n  return driver.findElement(webdriver.By.name(&apos;q&apos;)).then(function(searchBox){\n    return searchBox.sendKeys(&apos;webdriver&apos;).then(function() {\n      return driver.findElement(webdriver.By.name(&apos;btnG&apos;)).then(function(submitButton) {\n        return submitButton.click().then(function() {\n          return driver.getTitle().then(function(title) {\n            assertEquals(&apos;webdriver - Google Search&apos;, title);\n          });\n        });\n      });\n    });\n  });\n});\n</code></pre><p>不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。</p>\n<p>简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：</p>\n<pre><code>var driver = new webdriver.Builder().build();\ndriver.get(&apos;http://www.google.com&apos;);\n\nvar searchBox = driver.findElement(webdriver.By.name(&apos;q&apos;));\nsearchBox.sendKeys(&apos;webdriver&apos;);\n\nvar submitButton = driver.findElement(webdriver.By.name(&apos;btnG&apos;));\nsubmitButton.click();\n\ndriver.getTitle().then(function(title) {\n  assertEquals(&apos;webdriver - Google Search&apos;, title);\n});\n</code></pre><h4 id=\"On-Frames-and-Callbacks\"><a href=\"#On-Frames-and-Callbacks\" class=\"headerlink\" title=\"On Frames and Callbacks\"></a>On Frames and Callbacks</h4><p>就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：</p>\n<pre><code>driver.get(MY_APP_URL);\ndriver.getTitle().then(function(title) {\n  if (title === &apos;Login page&apos;) {\n    driver.findElement(webdriver.By.id(&apos;user&apos;)).sendKeys(&apos;bugs&apos;);\n    driver.findElement(webdriver.By.id(&apos;pw&apos;)).sendKeys(&apos;bunny&apos;);\n    driver.findElement(webdriver.By.id(&apos;login&apos;)).click();\n  }\n});\ndriver.findElement(webdriver.By.id(&apos;userPreferences&apos;)).click();\n</code></pre><p>这个测试用例可以使用 WebDriver 的 Java API 重写如下：</p>\n<pre><code>driver.get(MY_APP_URL);\nif (&quot;Login Page&quot;.equals(driver.getTitle())) {\n  driver.findElement(By.id(&quot;user&quot;)).sendKeys(&quot;bugs&quot;);\n  driver.findElement(By.id(&quot;pw&quot;)).sendKeys(&quot;bunny&quot;);\n  driver.findElement(By.id(&quot;login&quot;)).click();\n}\ndriver.findElement(By.id(&quot;userPreferences&quot;)).click();\n</code></pre><h4 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h4><p>既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。</p>\n<p>如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。</p>\n<pre><code>// 注册一个事件监听未处理的错误\nwebdriver.promise.Application.\n    getInstance().\n    on(&apos;uncaughtException&apos;, function(e) {\n      console.error(&apos;There was an uncaught exception: &apos; + e.message);\n    });\n\ndriver.switchTo().window(&apos;foo&apos;).then(null, function(e) {\n  // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡\n  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {\n    throw e;\n  }\n});\n// 如果上面的错误不被抑制的话，这句将永远不会执行\ndriver.getTitle();\n</code></pre><h3 id=\"同服务端通讯\"><a href=\"#同服务端通讯\" class=\"headerlink\" title=\"同服务端通讯\"></a>同服务端通讯</h3><p>当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。</p>\n<h4 id=\"Cross-Origin-Resource-Sharing\"><a href=\"#Cross-Origin-Resource-Sharing\" class=\"headerlink\" title=\"Cross-Origin Resource Sharing\"></a>Cross-Origin Resource Sharing</h4><p>如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。</p>\n<pre><code>Access-Control-Origin: *\nAccess-Control-Allow-Methods: DELETE,GET,HEAD,POST\nAccess-Control-Allow-Headers: Accept,Content-Type\n</code></pre><p>在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。</p>\n<ul>\n<li>IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。</li>\n<li>WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。</li>\n<li>如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。</li>\n</ul>\n<p>为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。</p>\n<h4 id=\"xdrpc\"><a href=\"#xdrpc\" class=\"headerlink\" title=\"/xdrpc\"></a>/xdrpc</h4><p><strong>POST /xdrpc</strong></p>\n<p>作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。</p>\n<p><strong>参数：</strong></p>\n<ul>\n<li>method - {string} http 方法</li>\n<li>path - {string} 命令路径</li>\n<li>data - {Object} JSON 格式的命令参数</li>\n</ul>\n<p><strong>返回：</strong></p>\n<p>{*} 命令执行的结果。</p>\n<p>举个例子，考虑以下 /xdrpc 命令：</p>\n<pre><code>POST /xdrpc HTTP/1.1\nAccept: application/json\nContent-Type: application/json\nContent-Length: 94\n\n{&quot;method&quot;:&quot;POST&quot;,&quot;path&quot;:&quot;/session/123/element/0a/element&quot;,&quot;data&quot;:{&quot;using&quot;:&quot;id&quot;,&quot;value&quot;:&quot;foo&quot;}}\n</code></pre><p>服务端将编码这个命令并重新分发：</p>\n<pre><code>POST /session/123/element/0a/element HTTP/1.1\nAccept: application/json\nContent-Type: application/json\nContent-Length: 28\n\n{&quot;using&quot;:&quot;id&quot;,&quot;value&quot;:&quot;foo&quot;}\n</code></pre><p>不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：</p>\n<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 60\n\n{&quot;status&quot;:7,&quot;value&quot;:{&quot;message&quot;:&quot;Unable to locate element.&quot;}}\n</code></pre><h2 id=\"未来计划\"><a href=\"#未来计划\" class=\"headerlink\" title=\"未来计划\"></a>未来计划</h2><p>以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）</p>\n<ul>\n<li>使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。</li>\n<li>基于扩展实现一个 SafariDriver。</li>\n<li>为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。</li>\n</ul>"},{"layout":"post","title":"write my maven plugin","date":"2013-06-13T12:35:00.000Z","comments":1,"_content":"\nmvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin\n\n\n\n\n\n\n<http://maven.apache.org/guides/plugin/guide-java-plugin-development.html>","source":"_posts/2013-06-13-write-my-maven-plugin.markdown","raw":"---\nlayout: post\ntitle: \"write my maven plugin\"\ndate: 2013-06-13 20:35\ncomments: true\ncategories: maven\ntags: [ maven, plugin, archetype ]\n---\n\nmvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin\n\n\n\n\n\n\n<http://maven.apache.org/guides/plugin/guide-java-plugin-development.html>","slug":"2013-06-13-write-my-maven-plugin","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop67006qv8fynd80xv1y","content":"<p>mvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin</p>\n<p><a href=\"http://maven.apache.org/guides/plugin/guide-java-plugin-development.html\" target=\"_blank\" rel=\"external\">http://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a></p>\n","excerpt":"","more":"<p>mvn archetype:generate -DgroupId=cn.shenyanchao.ut -DartifactId=ut-maven-plugin -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-plugin</p>\n<p><a href=\"http://maven.apache.org/guides/plugin/guide-java-plugin-development.html\">http://maven.apache.org/guides/plugin/guide-java-plugin-development.html</a></p>\n"},{"layout":"post","title":"Eclipse AST抽象语法树API","date":"2013-06-07T12:29:00.000Z","comments":1,"_content":"###Eclipse AST\nEclipse AST 是 Eclipse JDT 的一个重要组成部分,定义在包 org.eclipse.jdt.core.dom 中,用来表示 Java 语言中的所有语法结构。   \nEclipse AST 采用工厂方法模式和访问者模式   (见 2.7节)来设计和实现,这样可以减轻用户深入了解其内部结构的压力,并且方便用户利用它们构建并处理 AST。你可以打开 Eclipse 帮助页面,通过鼠标依次点击窗口左边的目录“JDT Plug-in Developer Guide”Æ“Reference”Æ“API Reference” Æ“org.eclipse.jdt.core.dom”,即可打开这个包的详细说明。本节将对这个包中重要的类作简要说明,为简便起见,这里省去这些类的包名,即org.eclipse.jdt.core.dom。    \n在 Eclipse AST 中,与本书的课程设计相关的类主要有以下三部分:    \n\n- ASTNode 类及其派生类:用于描述各种 AST 节点的类,每个 AST 节点表示一个Java 源程序中的一个语法结构,例如,一个名字、类型、表达式、语句或声明等。\n- AST 类:创建 AST 节点的工厂类,类中包含许多创建各类 AST 节点的工厂方法,用户可以利用这些方法来构建 AST。\n- ASTVisitor 类:\nAST 的访问者抽象类,类中声明了一组访问各类 AST 节点的 visit( )方法、endVisit( )方法和 preVisit( )方法。   \n\n<!--more-->\n####AST 节点类\n在 Eclipse AST 中,Java 源程序中的每个语法结构对应为一个 AST 节点,所有的 AST节点按其在语法上的关系连接形成一棵 AST 树。类 ASTNode 是 AST 树中各类节点的抽象基类,其余的 AST 节点类都由它派生。在 ASTNode 类中声明有各个具体的 AST 节点类所对应的类型标识,如 ASTNode.COMPILATION_UNIT 代表 Compilation_Unit 节点类,这类节点用来表示一个 Java 源程序文件。    \n为便于自顶向下(从父节点到子节点)或者自底向上(从子节点到父节点)访问 AST树,AST 节点含有指向其父节点的 parent 域以及若干关联的子节点域。在 AST 节点类中,以属性(property)来统一处理子节点以及用户自定义的节点属性,属性的访问方法有:   \n\n    void setProperty(String propertyName, Object data) // 设置指定属性的值\n    Object getProperty(String propertyName) // 取得指定属性的值\n    Map properties( )// 返回节点的所有属性表,这个表是不可修改的\n在每个具体的 AST 节点类中,以类常量形式声明该类节点所拥有的基本属性(即基本的子节点)类别,并定义了存放属性值的域以及设置和访问属性的方法。例如,在一个 Java源程序文件中,有可选的 package 声明、0 个或多个 import 声明以及至少 1 个类型声明(可以是类声明或接口声明),从而在表示 Java 源程序文件(称为编译单元)的 AST 节点类CompilationUnit 中就声明有 final 类变量 PACKAGE_PROPERTY、IMPORTS_PROPERTY 和TYPES_PROPERTY,分别表示 package 属性、imports 属性和 types 属性,同时还定义有如下的访问方法:    \n\n    List imports( )\n    // 该节点的所有 import 声明,按在程序中的出现次序排列List types( )\n    // 该节点的所有顶层类型声明,按在程序中的出现次序排列\n    void setPackage(PackageDeclaration pkgDecl) // 设置该节点的 package 声明\n    PackageDeclaration getPackage( )\n    // 取得该节点的 package 声明\n其中,类型相同的子节点组成的序列以 java.util.List 接口类来表示,这个接口类包含 add、get、set、remove 等方法用于访问和修改序列。在实际构造和访问 AST 树时,需要注意统一所使用的 List 接口类的实现类,例如,可以统一使用类 java.util.LinkedList 或者统一使用类java.util.ArrayList 来表示序列。   \n在 AST 节点类中,只提供获取父节点的方法,即     \n\n    ASTNode getParent( )\n而没有提供设置父节点的方法,这是因为对节点的 parent 域的设置是伴随着将该节点设置为其他节点的子节点而自动进行的。一个新创建的 AST 节点是没有设置其父节点的。当节点A 通过形如 setCHILD 方法,如 A.setPackage(B)方法,或者通过序列的 add 或 set 方法,如A.types( ).add(B)方法,将节点 B 设为自己的孩子时,B 节点的 parent 域将自动设置为对 A节点的引用;对于那些因上述操作导致不再是 A 节点的子节点来说,其 parent 域将被自动设置为 null。    \n\n每个 AST 节点及其子节点只能归属于一棵 AST 树。如果将一棵 AST 树中的某个 AST节点添加到另一棵 AST 树中,则必须复制这个节点及其所有的子孙节点,以保证这些节点只属于一棵 AST 树。此外,AST 树中不能含有环,如果某些操作会导致 AST 有环,则这些操作将失败。   \n为支持对源程序的分析和类型检查等,每个 AST 节点还含有一组位标志(用一个 int用来传播与该节点有关的附加信息,这些位标志可以通过节点的以下方法来存取:   \n\n    void setFlags(int flags)\n    int getFlags( )\n此外,Eclipse AST 还支持访问者模式,每个 AST 节点都含有方法:    \n  \n    void accept(ASTVisitor visitor)\n用于统一表示对当前节点访问时所要执行的任务,这个任务由参数 visitor 来给定。你可以进一步了解 ASTVisitor 类以及访问者模式(见 2.7.2 节)来了解对 AST 树的访问。       \n####AST 类\norg.eclipse.jdt.core.dom.AST 是 AST 节点的工厂类,即它提供一系列形如\n\n    TYPE newTYPE( )\n的工厂方法,用来创建名为 TYPE 的 Eclipse AST 节点类的实例,新创建的节点并没有设置父节点。例如,方法    \n\n    CompilationUnit newCompilationUnit( )\n用来创建由这个 AST 所拥有的一个编译单元节点。    \n要使用这些方法,首先需要创建 AST 类的实例:    \n\n    AST ast = AST.newAST(AST.JLS3);\n其中,参数 AST.JLS3 指示所生成的 ast 包含处理 JLS3(Java 语言规范第 3 版)的 AST API。\nJLS3 是 Java 语言所有早期版本的超集,JLS3 API 可以用来处理直到 Java SE 6(即 JDK1.6)\n的 Java 程序。    \n####ASTVisitor 类\norg.eclipse.jdt.core.dom.ASTVisitor 是 AST 树的访问者类,它提供一套方法来实现对给定节点的访问。\n这套方法中有两组是与具体的 AST 节点类 T 相关的,即 visit 方法和 endVisit方法,有两个是与具体的 AST 节点类无关的,即 preVisit 方法和 postVisit 方法。这些方法都通过参数接收一个 AST 节点 node,然后对这个节点进行访问以执行一些操作。   \n\n- public boolean visit(T node) 如果返回 true,则接着访问 node 的子节点;如果返回false,则不再访问 node 的子节点。ASTVisitor 类提供的各个 visit 方法的缺省实现是:什么也不做,直接返回 true。子类可以根据需要重新实现这些方法中的部分或全部。\n-public void endVisit(T node) 这类方法在节点 node 的子节点已经被访问或者是在visit(node)返回为 false 之后被调用ASTVisitor 类提供的各个 endVisit 方法的缺省实现是什么也不做。子类可以根据需要重新实现这些方法中的部分或全部。\n- public void preVisit(ASTNode node)\n- public void postVisit(ASTNode node) 这个方法在 endVisit(node)之后被调用。\n这个方法在 visit(node)之前被调用。   \nASTVisitor 类提供的 preVisit 方法和 postVisit 方法的缺省实现是什么也不做。子类可以根据需要来重新实现它们。   \n\n在 Eclipse AST 中,结合 AST 节点的 accept( )方法和 ASTVisitor 实例,假设待访问的AST 树的根节点为 root,\n则调用 root.accept( )就可以启动对这棵 AST 树的遍历。遍历是以深度优先搜索为基础的,你可以进一步查看 Eclipse JDT 的源代码来确认这一点,你也可以从<http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html> 上查看相关的源代码。为帮\n助大家理解对 AST 树的遍历过程,这里简要给出 accept 方法的实现。    \n所有的 AST 节点都执行在 ASTNode 类中定义的 accept 方法:    \n\n    public final void accept(ASTVisitor visitor) {\n    if (visitor == null) { throw new IllegalArgumentException(); }\n    visitor.preVisit(this);\n    // 执行与节点类型无关的 preVisit 方法\n    accept0(visitor); // 调用 accept0,执行与节点类型相关的 visit/endVisit 方法\n    visitor.postVisit(this); // 执行与节点类型无关的 postVisit 方法\n    }\nASTNode 类中的 accept0 方法是一个抽象的方法:     \n\n    abstract void accept0(ASTVisitor visitor);\n每个具体的 AST 节点类中都必须实现 accept0 方法,实现该方法的通用模板如下:   \n\n    boolean visitChildren = visitor.visit(this);\n    if (visitChildren) {\n    // 调用 visit( )访问本节点\n    // 如果 visit( )返回 true,则访问子节点acceptChild(visitor, getProperty1()); // 访问非序列型属性\n    acceptChildren(visitor, rawListProperty); // 访问序列型属性\n    acceptChild(visitor, getProperty2());\n    }\n    visitor.endVisit(this);// 调用 endVisit( )执行一些节点访问后的操作\n从上面的模板可以看出,如果节点包含多个属性,如 CompilationUnit 节点中有 imports属性和 types 属性等,则按这些属性在源程序中的先后次序来依次访问;如果一个属性为序列型,如 CompilationUnit 节点中的 types 属性,则调用 acceptChildren 方法来依次访问序列中的各个子节点;如果一个属性是非序列的,则调用 acceptChild 方法来访问。acceptChild和 acceptChildren 这两个方法的实现都与 AST 节点的具体类型无关,故放在 ASTNode 类中:     \n\n    final void acceptChild(ASTVisitor visitor, ASTNode child) {\n    if (child == null) { return; }\n    child.accept(visitor);\n    }\n    final void acceptChildren(ASTVisitor visitor, ASTNode.NodeList children) {\n    NodeList.Cursor cursor = children.newCursor();\n    try {\n    while (cursor.hasNext()) {\n    ASTNode child = (ASTNode) cursor.next();\n    child.accept(visitor);\n    }\n    } finally {\n    children.releaseCursor(cursor);\n    }\n    }\n基于上述的实现机制,当你需要对 AST 树实现特定的访问功能时,你只需要结合实际需求设计和实现 ASTVisitor 类的子类就可以了。例如,在本章的课程设计中,你需要实现ASTVisitor 类的派生类 InterpVisitor,在其中重写(override)与需要解释执行的语法结构相对应的 visit( )方法。        \n####SimpleMiniJOOL 语言涉及的 AST 节点类\n虽然 Eclipse AST 有为数众多的 AST 节点类,但是为表示 SimpleMiniJOOL 语言只会用到其中的一小部分,下面简要描述 SimpleMiniJOOL 语言所涉及到的 AST 节点类,重点介绍在使用这些类时所关注的成员。    \n#####整体结构\n1、CompilationUnit 类(编译单元)    \n它用来表示一个 Java 源程序文件,本书中用来表示一个 MiniJOOL 语言或其子语言程序的全部,是所对应的 AST 树的根节点。虽然这类节点有 package 声明、import 声明列表和类型声明列表等基本属性,但是在表示 SimpleMiniJOOL 程序时就只有一个类声明子节点。   \n**主要成员**   \n\n    List types( )// 返回该编译单元的顶层类型声明所对应的节点序列\n2、TypeDeclaration 类(类型声明)   \n它用于表示 Java 语言中的类声明或接口声明,本书中用来表示 MiniJOOL 语言或其子语言中的类声明。在 SimpleMiniJOOL 程序中,仅有一个名为 Program 的类声明。    \n**主要成员**\n\n    MethodDeclaration[] getMethods( )\n    // 返回类声明的方法声明序列\n    以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:\n    FieldDeclaration[] getFields( ) // 返回类声明的域声明序列\n    Type getSuperclassType( ) // 返回该类声明的超类类型或 null\n    void setSuperclassType(Type superclassType)\n    // 设置或清除超类\n3、MethodDeclaration 类(方法声明)     \n它用于表示 Java 语言中的方法声明或者是构造器声明(注意:在 Java 语言规范中,并不是将构造器看成是一个方法。因为后者视为是类中的成员,可以被子类继承;而前者不能被子类继承)。这类节点的基本属性包括:方法或构造器名、方法或构造器的体、返回类型、形参列表等。在一个 SimpleMiniJOOL 程序里的唯一的类中,只有一个名为 main 的无参方法,这个方法声明表示为一个 MethodDeclaration 实例。    \n**主要成员**\n\n    Block getBody( ) // 返回该方法声明的方法体,如果没有体则为 null\n    void setBody(Block body) // 设置或清除该方法声明的方法体\n    SimpleName getName( ) // 返回所声明的方法名\n    void setName(SimpleName methodName)\n    Type getReturnType2( )\n    // 设置方法名\n    // 返回所声明的方法的返回类型\n    void setReturnType2(Type type)\n    // 设置返回类型\n以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:     \n\n    List parameters( ) // 返回所声明的方法的参数声明序列\n    boolean isConstructor( ) // 返回该声明是否是在声明构造器\n    void setConstructor(boolean isConstructor)\n    // 设置是否是在声明构造器\n#####语句\nStatement 类是所有 Eclipse AST 中语句节点类的基类,由它派生出许多具体的语句节点类。在表示 SimpleMiniJOOL 程序时,只涉及到 Block、ExpressionStatement、IfStatement、WhileStatement、EmptyStatement、BreakStatement、ContinueStatement、ReturnStatement 等语句节点类。     \n1、Block 类(语句块)    \n它表示用花括号括起来的语句序列,可以用来表示一个方法体。其基本属性是语句序列。     \n**主要成员**\n\n    List statements( )\n    // 返回该语句块中的语句序列\n2、ExpressionStatement 类(表达式语句)    \n它表示由表达式形成的合法语句,包括表达式这一基本属性。在 SimpleMiniJOOL 语言中,可以用这个类来表示 print/read 语句或赋值表达式语句。   \n**主要成员**\n\n    Expression getExpression( ) // 返回该语句中的表达式\n    void setExpression(Expression expression) // 设置该语句中的表达式\n3、IfStatement(if 语句)    \n它表示 if 或 if-else 语句,节点中包括 if 语句的表达式、then 分支以及可选的 else 分支\n这些基本属性。    \n**主要成员**\n\n    Expression getExpression( ) // 返回 if 语句的表达式\n    void setExpression(Expression expression) // 设置 if 语句的表达式\n    Statement getThenStatement( ) // 返回 if 语句的 then 分支\n    void setThenStatement(Statement statement) // 设置 then 分支\n    Statement getElseStatement( ) // 返回 if 语句的 else 分支\n    void setElseStatement(Statement statement) // 设置 else 分支\n4、WhileStatement 类(while 语句)    \n它表示 while 语句,节点中包括 while 语句的表达式和体这些基本属性。    \n**主要成员**\n\n    Expression getExpression( ) // 返回 while 语句的表达式\n    void setExpression(Expression expression) // 设置 while 语句的表达式\n    Statement getBody( ) // 返回 while 语句的体\n    void setBody(Statement statement) // 设置 while 语句的体\n5、EmptyStatement 类(空语句)   \n它表示由分号组成的语句。   \n6、BreakStatement 类和 ContinueStatement 类   \n这两个类分别表示 break 语句和 continue 语句。在 Java 语言中,这两个语句是允许带有标号的,即形如“break label; ”或“continue label;”,因此提供 getLabel( )和 setLabel( )成员来访问标号。但是,在 MiniJOOL 语言或其子语言中,不支持标号。     \n7、ReturnStatement 类    \n它表示 return 语句。SimpleMiniJOOL 语言中的 return 语句是不允许含有表达式的,但是 MiniJOOL 语言和 SkipOOMiniJOOL 语言中的 return 语句允许含有表达式以支持返回值。故以下成员在表示 MiniJOOL 语言和 SkipOOMiniJOOL 语言时才会用到:    \n**主要成员**\n\n    Expression getExpression( ) // 返回 return 语句的表达式\n    void setExpression(Expression expression) // 设置 return 语句的表达式\n#####表达式\nExpression 类是所有 Eclipse AST 中表达式节点类的基类,由它派生出许多类。在表示SimpleMiniJOOL 程 序 时 , 只 涉 及 到 MethodInvocation 、 Assignment 、 InfixExpression 、PrefixExpression、ParenthesizedExpression、NumberLiteral、Name 这些表达式节点类。    \n1、MethodInvocation 类(方法调用)   \n它用来表示 Java 程序中的方法调用。MiniJOOL 语言中的方法调用形如:    \n\n    [ Expression . ] Identifier ( [ Expression { , Expression } ] )\n开头的“Expression .”是限制被调用方法的受限表达式,可以是类名、实例表达式或者没有。在 SkipOOMiniJOOL 语言中,方法调用不存在受限表达式。虽然 SimpleMiniJOOL 语言中没有方法调用,但是程序中的“print/read( <参数>)”用方法调用节点来表示。    \n**主要成员**   \n\n    // 返回所调用的方法名\n    SimpleName getName( )\n    void setName(SimpleName methodName) // 设置方法名\n    List arguments( )\n    // 返回方法调用表达式中的实参表达式序列\n以下成员在表示 MiniJOOL 程序时才会用到:   \n\n    Expression getExpression( ) // 返回方法调用的受限表达式\n    void setExpression(Expression expression) // 设置方法调用的受限表达式\n2、Assignment 类(赋值表达式)    \n它用于表示赋值表达式,包含运算符、左部和右部等基本属性。赋值运算符是在内部类Assignment.Operator 中义。MiniJOOL 语言或其子语言中支持的赋值运算符包括 =、+=、-=、*=、/=、%=。   \n**主要成员**\n\n    Expression getLeftHandSide( )\n    // 返回赋值表达式的左部\n    void setLeftHandSide(Expression expr)\n    getRightHandSide( )\n    // 设 置 赋 值 表 达 式 的 左 部 Expression\n    // 返回赋值表达式的右部\n    void setRightHandSide(Expression expr)\n    // 设置赋值表达式的右部\n    Assignment.Operator getOperator( ) // 返回赋值表达式的运算符\n    void setOperator(Assignment.Operator op) // 设置赋值表达式的运算符\n**赋值运算符**\n在内部类 Assignment.Operator 中,定义有许多类型为 static Assignment.Operator 的赋值运算符,其中与 MiniJOOL 语言及其子语言有关的有:   \n\n    ASSIGN:表示 =,可以用 Assignment.Operator.ASSIGN 来访问,以下类似\n    PLUS_ASSIGN:表示+=\n    MINUS_ASSIGN:表示 -=\n    TIMES_ASSIGN:表示 *=\n    DIVIDE_ASSIGN:表示 /=\n    REMAINDER_ASSIGN:表示 %=\n3、InfixExpression 类(中缀表达式)    \n它用于表示中缀表达式,包含运算符、左操作数和右操作数等基本属性。运算符是在内部类 InfixExpression.Operator 中定义。MiniJOOL 语言或其子语言中支持的中缀运算符包括包括+、-、*、/、%、==、!=、<、<=、>、>=、&&、||等。   \n**主要成员**\n\n    // 返回中缀表达式的左操作数\n    Expression getLeftOperand( )\n    void setLeftOperand(Expression expr) // 设置左操作数\n    Expression getRightOperand( ) // 返回中缀表达式的右操作数\n    void setRightOperand(Expression expr) // 设置右操作数\n    InfixExpression.Operator getOperator( ) // 返回中缀表达式的运算符\n    void setOperator(InfixExpression.Operator op) // 设置运算符\n**中缀运算符**\n本书涉及内部类 InfixExpression.Operator 中定义的以下 static InfixExpression.Operator 类型的实例:      \n\n    + PLUS\n    % REMAINDER\n    < LESS\n    &&\n    -\n    MINUS\n    ==\n    > GREATER\n    CONDITIONAL_AND\n    *\n    TIMES\n    / DIVIDE\n    EQUALS != NOT_EQUALS\n    <= >=\n    ||\n    LESS_EQUALS\n    GREATER_EQUALS\n    CONDITIONAL_OR\n4、PrefixExpression 类(前缀表达式)    \n它用于表示前缀表达式,包含运算符、操作数等基本属性。运算符是在内部类PrefixExpression.Operator 中定义。在 SimpleMiniJOOL 中,包括-、+、!等前缀运算符。   \n**主要成员**\n\n    Expression getOperand( )\n    // 返回前缀表达式的操作数\n    void setOperand(Expression expr)\n    // 设置操作数\n    PrefixExpression.Operator getOperator( ) // 返回前缀表达式的运算符\n    void setOperator(PrefixExpression.Operator op) // 设置运算符\n**前缀运算符**\n本书涉及内部类 PrefixExpression.Operator 中定义的以下 static PrefixExpression.Operator类型的实例:   \n\n    +PLUS\n    - MINUS\n    ! NOT\n5、ParenthesizedExpression 类(带括号的表达式)\n**主要成员**\n\n    Expression getExpression( )\n    // 返回括号内的表达式\n    void setExpression(Expression expression) // 设置括号内的表达式\n6、NumberLiteral 类(整数)    \n**主要成员**\n\n    String getToken( )\n    // 返回对应的整数串\n    void setToken(String token) // 设置整数串\n7、Name 类    \n它用于表示一个名字,由它派生出 QualifiedName 和 SimpleName 两个类,前者表示一个形如 a.b 的受限名,后者表示一个简单名。在 SimpleMiniJOOL 程序中只会出现简单名。   \n**SimpleName 的主要成员**\n\n    String getIdentifier( ) // 返回标识符\n    void setIdentifier(String expression) // 设置标识符\n    boolean isDeclaration( ) // 该标识符是否定义过\n**QualifiedName 的主要成员**\n\n    SimpleName getName( ) // 返回受限名中的名字部分\n    void setName(SimpleName name ) // 设置受限名中的名字部分\n    Name getQualifier( ) // 返回受限名中的受限部分\n    void setQualifier(Name qualifier) // 设置受限名中的受限部分\n####Eclipse AST 使用示例\n在这一节中,我们将演示如何利用 Eclipse AST 手工构建如下的 SimpleMiniJOOL 程序的 AST 中间表示。   \n    class Program {\n    static void main() {\n    i = 10;\n    }\n    }\n首先,你需要通过 Eclipse AST 工厂类中的方法 newAST()建立一个 AST 实例:    \n\n    AST ast = AST.newAST(JLS3);\n利用这个 AST 实例,就可以按如下的方法创建各种 AST 节点,并构建完整的抽象语法树。然后,利用 Eclipse AST 工厂类中的各种创建方法按如下步骤创建所需要的 AST 节点:    \n1) 整个 SimpleMiniJOOL 程序构成一个 CompilationUnit:    \n\n    CompilationUnit cu = ast.newCompilationUnit();\n2) 在 CompilationUnit 实例中包含一个 TypeDeclaration,表示程序中的类 Program:    \n\n    TypeDeclaration type = ast.newTypeDeclaration( );\n    type.setName(ast.newSimpleName(“Program”));\n    // 定义类的名字\n3) 在这个 TypeDeclaration 实例中添加类 Program 中的方法 main():    \n\n    MethodDeclaration method = ast.newMethodDeclaration( );\n    method.setName(ast.newSimpleName(“main”));\n    type.bodyDeclarations().add(method);\n    // 设置方法 main()的 modifier 为 static\n    method.modifiers().add(\n    ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n    // 设置方法 main()的返回类型为 void\n    method.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n4) 构造 main 函数的函数体 mainBody     \n\n    Block mainBody = ast.newBlock();\n    method.setBody(mainBody);\n5) 向方法 main 函数体 mainBody 中添加语句    \n\n    // 构建赋值表达式\n    Assignment assign = ast.newAssignment();\n    // 设置赋值表达式的左值为 i\n    assign.setLeftHandSide(ast.newSimpleName(\"i\"));\n    // 设置赋值表达式的赋值算符为=\n    assign.setOperator(Assignment.Operator.ASSIGN);\n    // 设置赋值表达式的右值为数字 10\n    assign.setRightHandSide(ast.newNumberLiteral(\"10\"));\n    // 由赋值表达式构建语句,并把这个语句加入方法 Main()的函数体\n    ExpressionStatement statement = ast.newExpressionStatement(assign);\n    mainBody.statements().add(statement);\n至此,用 Eclipse AST 表示的 SimpleMiniJOOL 程序的抽象语法树就构建完毕了。   \n在 lab1/src/edu/ustc/cs/compile/interpreter/TestCase.java 中的 createSampleAST( )方法给出了构建一个简单 SimpleMiniJOOL 程序对应的 AST 的完整示例。   \n需要再次强调的是,使用 Eclipse AST 构建的抽象语法树在拓扑结构上必须是无环的。无论是手工构建 AST 还是自动构建 AST,你都需要小心的检查自己的代码,避免违反这个原则。   ","source":"_posts/2013-06-07-eclipse-ast.markdown","raw":"---\nlayout: post\ntitle: \"Eclipse AST抽象语法树API\"\ndate: 2013-06-07 20:29\ncomments: true\ncategories: java\ntags: [ eclipse, ast]\n---\n###Eclipse AST\nEclipse AST 是 Eclipse JDT 的一个重要组成部分,定义在包 org.eclipse.jdt.core.dom 中,用来表示 Java 语言中的所有语法结构。   \nEclipse AST 采用工厂方法模式和访问者模式   (见 2.7节)来设计和实现,这样可以减轻用户深入了解其内部结构的压力,并且方便用户利用它们构建并处理 AST。你可以打开 Eclipse 帮助页面,通过鼠标依次点击窗口左边的目录“JDT Plug-in Developer Guide”Æ“Reference”Æ“API Reference” Æ“org.eclipse.jdt.core.dom”,即可打开这个包的详细说明。本节将对这个包中重要的类作简要说明,为简便起见,这里省去这些类的包名,即org.eclipse.jdt.core.dom。    \n在 Eclipse AST 中,与本书的课程设计相关的类主要有以下三部分:    \n\n- ASTNode 类及其派生类:用于描述各种 AST 节点的类,每个 AST 节点表示一个Java 源程序中的一个语法结构,例如,一个名字、类型、表达式、语句或声明等。\n- AST 类:创建 AST 节点的工厂类,类中包含许多创建各类 AST 节点的工厂方法,用户可以利用这些方法来构建 AST。\n- ASTVisitor 类:\nAST 的访问者抽象类,类中声明了一组访问各类 AST 节点的 visit( )方法、endVisit( )方法和 preVisit( )方法。   \n\n<!--more-->\n####AST 节点类\n在 Eclipse AST 中,Java 源程序中的每个语法结构对应为一个 AST 节点,所有的 AST节点按其在语法上的关系连接形成一棵 AST 树。类 ASTNode 是 AST 树中各类节点的抽象基类,其余的 AST 节点类都由它派生。在 ASTNode 类中声明有各个具体的 AST 节点类所对应的类型标识,如 ASTNode.COMPILATION_UNIT 代表 Compilation_Unit 节点类,这类节点用来表示一个 Java 源程序文件。    \n为便于自顶向下(从父节点到子节点)或者自底向上(从子节点到父节点)访问 AST树,AST 节点含有指向其父节点的 parent 域以及若干关联的子节点域。在 AST 节点类中,以属性(property)来统一处理子节点以及用户自定义的节点属性,属性的访问方法有:   \n\n    void setProperty(String propertyName, Object data) // 设置指定属性的值\n    Object getProperty(String propertyName) // 取得指定属性的值\n    Map properties( )// 返回节点的所有属性表,这个表是不可修改的\n在每个具体的 AST 节点类中,以类常量形式声明该类节点所拥有的基本属性(即基本的子节点)类别,并定义了存放属性值的域以及设置和访问属性的方法。例如,在一个 Java源程序文件中,有可选的 package 声明、0 个或多个 import 声明以及至少 1 个类型声明(可以是类声明或接口声明),从而在表示 Java 源程序文件(称为编译单元)的 AST 节点类CompilationUnit 中就声明有 final 类变量 PACKAGE_PROPERTY、IMPORTS_PROPERTY 和TYPES_PROPERTY,分别表示 package 属性、imports 属性和 types 属性,同时还定义有如下的访问方法:    \n\n    List imports( )\n    // 该节点的所有 import 声明,按在程序中的出现次序排列List types( )\n    // 该节点的所有顶层类型声明,按在程序中的出现次序排列\n    void setPackage(PackageDeclaration pkgDecl) // 设置该节点的 package 声明\n    PackageDeclaration getPackage( )\n    // 取得该节点的 package 声明\n其中,类型相同的子节点组成的序列以 java.util.List 接口类来表示,这个接口类包含 add、get、set、remove 等方法用于访问和修改序列。在实际构造和访问 AST 树时,需要注意统一所使用的 List 接口类的实现类,例如,可以统一使用类 java.util.LinkedList 或者统一使用类java.util.ArrayList 来表示序列。   \n在 AST 节点类中,只提供获取父节点的方法,即     \n\n    ASTNode getParent( )\n而没有提供设置父节点的方法,这是因为对节点的 parent 域的设置是伴随着将该节点设置为其他节点的子节点而自动进行的。一个新创建的 AST 节点是没有设置其父节点的。当节点A 通过形如 setCHILD 方法,如 A.setPackage(B)方法,或者通过序列的 add 或 set 方法,如A.types( ).add(B)方法,将节点 B 设为自己的孩子时,B 节点的 parent 域将自动设置为对 A节点的引用;对于那些因上述操作导致不再是 A 节点的子节点来说,其 parent 域将被自动设置为 null。    \n\n每个 AST 节点及其子节点只能归属于一棵 AST 树。如果将一棵 AST 树中的某个 AST节点添加到另一棵 AST 树中,则必须复制这个节点及其所有的子孙节点,以保证这些节点只属于一棵 AST 树。此外,AST 树中不能含有环,如果某些操作会导致 AST 有环,则这些操作将失败。   \n为支持对源程序的分析和类型检查等,每个 AST 节点还含有一组位标志(用一个 int用来传播与该节点有关的附加信息,这些位标志可以通过节点的以下方法来存取:   \n\n    void setFlags(int flags)\n    int getFlags( )\n此外,Eclipse AST 还支持访问者模式,每个 AST 节点都含有方法:    \n  \n    void accept(ASTVisitor visitor)\n用于统一表示对当前节点访问时所要执行的任务,这个任务由参数 visitor 来给定。你可以进一步了解 ASTVisitor 类以及访问者模式(见 2.7.2 节)来了解对 AST 树的访问。       \n####AST 类\norg.eclipse.jdt.core.dom.AST 是 AST 节点的工厂类,即它提供一系列形如\n\n    TYPE newTYPE( )\n的工厂方法,用来创建名为 TYPE 的 Eclipse AST 节点类的实例,新创建的节点并没有设置父节点。例如,方法    \n\n    CompilationUnit newCompilationUnit( )\n用来创建由这个 AST 所拥有的一个编译单元节点。    \n要使用这些方法,首先需要创建 AST 类的实例:    \n\n    AST ast = AST.newAST(AST.JLS3);\n其中,参数 AST.JLS3 指示所生成的 ast 包含处理 JLS3(Java 语言规范第 3 版)的 AST API。\nJLS3 是 Java 语言所有早期版本的超集,JLS3 API 可以用来处理直到 Java SE 6(即 JDK1.6)\n的 Java 程序。    \n####ASTVisitor 类\norg.eclipse.jdt.core.dom.ASTVisitor 是 AST 树的访问者类,它提供一套方法来实现对给定节点的访问。\n这套方法中有两组是与具体的 AST 节点类 T 相关的,即 visit 方法和 endVisit方法,有两个是与具体的 AST 节点类无关的,即 preVisit 方法和 postVisit 方法。这些方法都通过参数接收一个 AST 节点 node,然后对这个节点进行访问以执行一些操作。   \n\n- public boolean visit(T node) 如果返回 true,则接着访问 node 的子节点;如果返回false,则不再访问 node 的子节点。ASTVisitor 类提供的各个 visit 方法的缺省实现是:什么也不做,直接返回 true。子类可以根据需要重新实现这些方法中的部分或全部。\n-public void endVisit(T node) 这类方法在节点 node 的子节点已经被访问或者是在visit(node)返回为 false 之后被调用ASTVisitor 类提供的各个 endVisit 方法的缺省实现是什么也不做。子类可以根据需要重新实现这些方法中的部分或全部。\n- public void preVisit(ASTNode node)\n- public void postVisit(ASTNode node) 这个方法在 endVisit(node)之后被调用。\n这个方法在 visit(node)之前被调用。   \nASTVisitor 类提供的 preVisit 方法和 postVisit 方法的缺省实现是什么也不做。子类可以根据需要来重新实现它们。   \n\n在 Eclipse AST 中,结合 AST 节点的 accept( )方法和 ASTVisitor 实例,假设待访问的AST 树的根节点为 root,\n则调用 root.accept( )就可以启动对这棵 AST 树的遍历。遍历是以深度优先搜索为基础的,你可以进一步查看 Eclipse JDT 的源代码来确认这一点,你也可以从<http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html> 上查看相关的源代码。为帮\n助大家理解对 AST 树的遍历过程,这里简要给出 accept 方法的实现。    \n所有的 AST 节点都执行在 ASTNode 类中定义的 accept 方法:    \n\n    public final void accept(ASTVisitor visitor) {\n    if (visitor == null) { throw new IllegalArgumentException(); }\n    visitor.preVisit(this);\n    // 执行与节点类型无关的 preVisit 方法\n    accept0(visitor); // 调用 accept0,执行与节点类型相关的 visit/endVisit 方法\n    visitor.postVisit(this); // 执行与节点类型无关的 postVisit 方法\n    }\nASTNode 类中的 accept0 方法是一个抽象的方法:     \n\n    abstract void accept0(ASTVisitor visitor);\n每个具体的 AST 节点类中都必须实现 accept0 方法,实现该方法的通用模板如下:   \n\n    boolean visitChildren = visitor.visit(this);\n    if (visitChildren) {\n    // 调用 visit( )访问本节点\n    // 如果 visit( )返回 true,则访问子节点acceptChild(visitor, getProperty1()); // 访问非序列型属性\n    acceptChildren(visitor, rawListProperty); // 访问序列型属性\n    acceptChild(visitor, getProperty2());\n    }\n    visitor.endVisit(this);// 调用 endVisit( )执行一些节点访问后的操作\n从上面的模板可以看出,如果节点包含多个属性,如 CompilationUnit 节点中有 imports属性和 types 属性等,则按这些属性在源程序中的先后次序来依次访问;如果一个属性为序列型,如 CompilationUnit 节点中的 types 属性,则调用 acceptChildren 方法来依次访问序列中的各个子节点;如果一个属性是非序列的,则调用 acceptChild 方法来访问。acceptChild和 acceptChildren 这两个方法的实现都与 AST 节点的具体类型无关,故放在 ASTNode 类中:     \n\n    final void acceptChild(ASTVisitor visitor, ASTNode child) {\n    if (child == null) { return; }\n    child.accept(visitor);\n    }\n    final void acceptChildren(ASTVisitor visitor, ASTNode.NodeList children) {\n    NodeList.Cursor cursor = children.newCursor();\n    try {\n    while (cursor.hasNext()) {\n    ASTNode child = (ASTNode) cursor.next();\n    child.accept(visitor);\n    }\n    } finally {\n    children.releaseCursor(cursor);\n    }\n    }\n基于上述的实现机制,当你需要对 AST 树实现特定的访问功能时,你只需要结合实际需求设计和实现 ASTVisitor 类的子类就可以了。例如,在本章的课程设计中,你需要实现ASTVisitor 类的派生类 InterpVisitor,在其中重写(override)与需要解释执行的语法结构相对应的 visit( )方法。        \n####SimpleMiniJOOL 语言涉及的 AST 节点类\n虽然 Eclipse AST 有为数众多的 AST 节点类,但是为表示 SimpleMiniJOOL 语言只会用到其中的一小部分,下面简要描述 SimpleMiniJOOL 语言所涉及到的 AST 节点类,重点介绍在使用这些类时所关注的成员。    \n#####整体结构\n1、CompilationUnit 类(编译单元)    \n它用来表示一个 Java 源程序文件,本书中用来表示一个 MiniJOOL 语言或其子语言程序的全部,是所对应的 AST 树的根节点。虽然这类节点有 package 声明、import 声明列表和类型声明列表等基本属性,但是在表示 SimpleMiniJOOL 程序时就只有一个类声明子节点。   \n**主要成员**   \n\n    List types( )// 返回该编译单元的顶层类型声明所对应的节点序列\n2、TypeDeclaration 类(类型声明)   \n它用于表示 Java 语言中的类声明或接口声明,本书中用来表示 MiniJOOL 语言或其子语言中的类声明。在 SimpleMiniJOOL 程序中,仅有一个名为 Program 的类声明。    \n**主要成员**\n\n    MethodDeclaration[] getMethods( )\n    // 返回类声明的方法声明序列\n    以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:\n    FieldDeclaration[] getFields( ) // 返回类声明的域声明序列\n    Type getSuperclassType( ) // 返回该类声明的超类类型或 null\n    void setSuperclassType(Type superclassType)\n    // 设置或清除超类\n3、MethodDeclaration 类(方法声明)     \n它用于表示 Java 语言中的方法声明或者是构造器声明(注意:在 Java 语言规范中,并不是将构造器看成是一个方法。因为后者视为是类中的成员,可以被子类继承;而前者不能被子类继承)。这类节点的基本属性包括:方法或构造器名、方法或构造器的体、返回类型、形参列表等。在一个 SimpleMiniJOOL 程序里的唯一的类中,只有一个名为 main 的无参方法,这个方法声明表示为一个 MethodDeclaration 实例。    \n**主要成员**\n\n    Block getBody( ) // 返回该方法声明的方法体,如果没有体则为 null\n    void setBody(Block body) // 设置或清除该方法声明的方法体\n    SimpleName getName( ) // 返回所声明的方法名\n    void setName(SimpleName methodName)\n    Type getReturnType2( )\n    // 设置方法名\n    // 返回所声明的方法的返回类型\n    void setReturnType2(Type type)\n    // 设置返回类型\n以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:     \n\n    List parameters( ) // 返回所声明的方法的参数声明序列\n    boolean isConstructor( ) // 返回该声明是否是在声明构造器\n    void setConstructor(boolean isConstructor)\n    // 设置是否是在声明构造器\n#####语句\nStatement 类是所有 Eclipse AST 中语句节点类的基类,由它派生出许多具体的语句节点类。在表示 SimpleMiniJOOL 程序时,只涉及到 Block、ExpressionStatement、IfStatement、WhileStatement、EmptyStatement、BreakStatement、ContinueStatement、ReturnStatement 等语句节点类。     \n1、Block 类(语句块)    \n它表示用花括号括起来的语句序列,可以用来表示一个方法体。其基本属性是语句序列。     \n**主要成员**\n\n    List statements( )\n    // 返回该语句块中的语句序列\n2、ExpressionStatement 类(表达式语句)    \n它表示由表达式形成的合法语句,包括表达式这一基本属性。在 SimpleMiniJOOL 语言中,可以用这个类来表示 print/read 语句或赋值表达式语句。   \n**主要成员**\n\n    Expression getExpression( ) // 返回该语句中的表达式\n    void setExpression(Expression expression) // 设置该语句中的表达式\n3、IfStatement(if 语句)    \n它表示 if 或 if-else 语句,节点中包括 if 语句的表达式、then 分支以及可选的 else 分支\n这些基本属性。    \n**主要成员**\n\n    Expression getExpression( ) // 返回 if 语句的表达式\n    void setExpression(Expression expression) // 设置 if 语句的表达式\n    Statement getThenStatement( ) // 返回 if 语句的 then 分支\n    void setThenStatement(Statement statement) // 设置 then 分支\n    Statement getElseStatement( ) // 返回 if 语句的 else 分支\n    void setElseStatement(Statement statement) // 设置 else 分支\n4、WhileStatement 类(while 语句)    \n它表示 while 语句,节点中包括 while 语句的表达式和体这些基本属性。    \n**主要成员**\n\n    Expression getExpression( ) // 返回 while 语句的表达式\n    void setExpression(Expression expression) // 设置 while 语句的表达式\n    Statement getBody( ) // 返回 while 语句的体\n    void setBody(Statement statement) // 设置 while 语句的体\n5、EmptyStatement 类(空语句)   \n它表示由分号组成的语句。   \n6、BreakStatement 类和 ContinueStatement 类   \n这两个类分别表示 break 语句和 continue 语句。在 Java 语言中,这两个语句是允许带有标号的,即形如“break label; ”或“continue label;”,因此提供 getLabel( )和 setLabel( )成员来访问标号。但是,在 MiniJOOL 语言或其子语言中,不支持标号。     \n7、ReturnStatement 类    \n它表示 return 语句。SimpleMiniJOOL 语言中的 return 语句是不允许含有表达式的,但是 MiniJOOL 语言和 SkipOOMiniJOOL 语言中的 return 语句允许含有表达式以支持返回值。故以下成员在表示 MiniJOOL 语言和 SkipOOMiniJOOL 语言时才会用到:    \n**主要成员**\n\n    Expression getExpression( ) // 返回 return 语句的表达式\n    void setExpression(Expression expression) // 设置 return 语句的表达式\n#####表达式\nExpression 类是所有 Eclipse AST 中表达式节点类的基类,由它派生出许多类。在表示SimpleMiniJOOL 程 序 时 , 只 涉 及 到 MethodInvocation 、 Assignment 、 InfixExpression 、PrefixExpression、ParenthesizedExpression、NumberLiteral、Name 这些表达式节点类。    \n1、MethodInvocation 类(方法调用)   \n它用来表示 Java 程序中的方法调用。MiniJOOL 语言中的方法调用形如:    \n\n    [ Expression . ] Identifier ( [ Expression { , Expression } ] )\n开头的“Expression .”是限制被调用方法的受限表达式,可以是类名、实例表达式或者没有。在 SkipOOMiniJOOL 语言中,方法调用不存在受限表达式。虽然 SimpleMiniJOOL 语言中没有方法调用,但是程序中的“print/read( <参数>)”用方法调用节点来表示。    \n**主要成员**   \n\n    // 返回所调用的方法名\n    SimpleName getName( )\n    void setName(SimpleName methodName) // 设置方法名\n    List arguments( )\n    // 返回方法调用表达式中的实参表达式序列\n以下成员在表示 MiniJOOL 程序时才会用到:   \n\n    Expression getExpression( ) // 返回方法调用的受限表达式\n    void setExpression(Expression expression) // 设置方法调用的受限表达式\n2、Assignment 类(赋值表达式)    \n它用于表示赋值表达式,包含运算符、左部和右部等基本属性。赋值运算符是在内部类Assignment.Operator 中义。MiniJOOL 语言或其子语言中支持的赋值运算符包括 =、+=、-=、*=、/=、%=。   \n**主要成员**\n\n    Expression getLeftHandSide( )\n    // 返回赋值表达式的左部\n    void setLeftHandSide(Expression expr)\n    getRightHandSide( )\n    // 设 置 赋 值 表 达 式 的 左 部 Expression\n    // 返回赋值表达式的右部\n    void setRightHandSide(Expression expr)\n    // 设置赋值表达式的右部\n    Assignment.Operator getOperator( ) // 返回赋值表达式的运算符\n    void setOperator(Assignment.Operator op) // 设置赋值表达式的运算符\n**赋值运算符**\n在内部类 Assignment.Operator 中,定义有许多类型为 static Assignment.Operator 的赋值运算符,其中与 MiniJOOL 语言及其子语言有关的有:   \n\n    ASSIGN:表示 =,可以用 Assignment.Operator.ASSIGN 来访问,以下类似\n    PLUS_ASSIGN:表示+=\n    MINUS_ASSIGN:表示 -=\n    TIMES_ASSIGN:表示 *=\n    DIVIDE_ASSIGN:表示 /=\n    REMAINDER_ASSIGN:表示 %=\n3、InfixExpression 类(中缀表达式)    \n它用于表示中缀表达式,包含运算符、左操作数和右操作数等基本属性。运算符是在内部类 InfixExpression.Operator 中定义。MiniJOOL 语言或其子语言中支持的中缀运算符包括包括+、-、*、/、%、==、!=、<、<=、>、>=、&&、||等。   \n**主要成员**\n\n    // 返回中缀表达式的左操作数\n    Expression getLeftOperand( )\n    void setLeftOperand(Expression expr) // 设置左操作数\n    Expression getRightOperand( ) // 返回中缀表达式的右操作数\n    void setRightOperand(Expression expr) // 设置右操作数\n    InfixExpression.Operator getOperator( ) // 返回中缀表达式的运算符\n    void setOperator(InfixExpression.Operator op) // 设置运算符\n**中缀运算符**\n本书涉及内部类 InfixExpression.Operator 中定义的以下 static InfixExpression.Operator 类型的实例:      \n\n    + PLUS\n    % REMAINDER\n    < LESS\n    &&\n    -\n    MINUS\n    ==\n    > GREATER\n    CONDITIONAL_AND\n    *\n    TIMES\n    / DIVIDE\n    EQUALS != NOT_EQUALS\n    <= >=\n    ||\n    LESS_EQUALS\n    GREATER_EQUALS\n    CONDITIONAL_OR\n4、PrefixExpression 类(前缀表达式)    \n它用于表示前缀表达式,包含运算符、操作数等基本属性。运算符是在内部类PrefixExpression.Operator 中定义。在 SimpleMiniJOOL 中,包括-、+、!等前缀运算符。   \n**主要成员**\n\n    Expression getOperand( )\n    // 返回前缀表达式的操作数\n    void setOperand(Expression expr)\n    // 设置操作数\n    PrefixExpression.Operator getOperator( ) // 返回前缀表达式的运算符\n    void setOperator(PrefixExpression.Operator op) // 设置运算符\n**前缀运算符**\n本书涉及内部类 PrefixExpression.Operator 中定义的以下 static PrefixExpression.Operator类型的实例:   \n\n    +PLUS\n    - MINUS\n    ! NOT\n5、ParenthesizedExpression 类(带括号的表达式)\n**主要成员**\n\n    Expression getExpression( )\n    // 返回括号内的表达式\n    void setExpression(Expression expression) // 设置括号内的表达式\n6、NumberLiteral 类(整数)    \n**主要成员**\n\n    String getToken( )\n    // 返回对应的整数串\n    void setToken(String token) // 设置整数串\n7、Name 类    \n它用于表示一个名字,由它派生出 QualifiedName 和 SimpleName 两个类,前者表示一个形如 a.b 的受限名,后者表示一个简单名。在 SimpleMiniJOOL 程序中只会出现简单名。   \n**SimpleName 的主要成员**\n\n    String getIdentifier( ) // 返回标识符\n    void setIdentifier(String expression) // 设置标识符\n    boolean isDeclaration( ) // 该标识符是否定义过\n**QualifiedName 的主要成员**\n\n    SimpleName getName( ) // 返回受限名中的名字部分\n    void setName(SimpleName name ) // 设置受限名中的名字部分\n    Name getQualifier( ) // 返回受限名中的受限部分\n    void setQualifier(Name qualifier) // 设置受限名中的受限部分\n####Eclipse AST 使用示例\n在这一节中,我们将演示如何利用 Eclipse AST 手工构建如下的 SimpleMiniJOOL 程序的 AST 中间表示。   \n    class Program {\n    static void main() {\n    i = 10;\n    }\n    }\n首先,你需要通过 Eclipse AST 工厂类中的方法 newAST()建立一个 AST 实例:    \n\n    AST ast = AST.newAST(JLS3);\n利用这个 AST 实例,就可以按如下的方法创建各种 AST 节点,并构建完整的抽象语法树。然后,利用 Eclipse AST 工厂类中的各种创建方法按如下步骤创建所需要的 AST 节点:    \n1) 整个 SimpleMiniJOOL 程序构成一个 CompilationUnit:    \n\n    CompilationUnit cu = ast.newCompilationUnit();\n2) 在 CompilationUnit 实例中包含一个 TypeDeclaration,表示程序中的类 Program:    \n\n    TypeDeclaration type = ast.newTypeDeclaration( );\n    type.setName(ast.newSimpleName(“Program”));\n    // 定义类的名字\n3) 在这个 TypeDeclaration 实例中添加类 Program 中的方法 main():    \n\n    MethodDeclaration method = ast.newMethodDeclaration( );\n    method.setName(ast.newSimpleName(“main”));\n    type.bodyDeclarations().add(method);\n    // 设置方法 main()的 modifier 为 static\n    method.modifiers().add(\n    ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n    // 设置方法 main()的返回类型为 void\n    method.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n4) 构造 main 函数的函数体 mainBody     \n\n    Block mainBody = ast.newBlock();\n    method.setBody(mainBody);\n5) 向方法 main 函数体 mainBody 中添加语句    \n\n    // 构建赋值表达式\n    Assignment assign = ast.newAssignment();\n    // 设置赋值表达式的左值为 i\n    assign.setLeftHandSide(ast.newSimpleName(\"i\"));\n    // 设置赋值表达式的赋值算符为=\n    assign.setOperator(Assignment.Operator.ASSIGN);\n    // 设置赋值表达式的右值为数字 10\n    assign.setRightHandSide(ast.newNumberLiteral(\"10\"));\n    // 由赋值表达式构建语句,并把这个语句加入方法 Main()的函数体\n    ExpressionStatement statement = ast.newExpressionStatement(assign);\n    mainBody.statements().add(statement);\n至此,用 Eclipse AST 表示的 SimpleMiniJOOL 程序的抽象语法树就构建完毕了。   \n在 lab1/src/edu/ustc/cs/compile/interpreter/TestCase.java 中的 createSampleAST( )方法给出了构建一个简单 SimpleMiniJOOL 程序对应的 AST 的完整示例。   \n需要再次强调的是,使用 Eclipse AST 构建的抽象语法树在拓扑结构上必须是无环的。无论是手工构建 AST 还是自动构建 AST,你都需要小心的检查自己的代码,避免违反这个原则。   ","slug":"2013-06-07-eclipse-ast","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop69006vv8fy9klufdlb","content":"<p>###Eclipse AST<br>Eclipse AST 是 Eclipse JDT 的一个重要组成部分,定义在包 org.eclipse.jdt.core.dom 中,用来表示 Java 语言中的所有语法结构。<br>Eclipse AST 采用工厂方法模式和访问者模式   (见 2.7节)来设计和实现,这样可以减轻用户深入了解其内部结构的压力,并且方便用户利用它们构建并处理 AST。你可以打开 Eclipse 帮助页面,通过鼠标依次点击窗口左边的目录“JDT Plug-in Developer Guide”Æ“Reference”Æ“API Reference” Æ“org.eclipse.jdt.core.dom”,即可打开这个包的详细说明。本节将对这个包中重要的类作简要说明,为简便起见,这里省去这些类的包名,即org.eclipse.jdt.core.dom。<br>在 Eclipse AST 中,与本书的课程设计相关的类主要有以下三部分:    </p>\n<ul>\n<li>ASTNode 类及其派生类:用于描述各种 AST 节点的类,每个 AST 节点表示一个Java 源程序中的一个语法结构,例如,一个名字、类型、表达式、语句或声明等。</li>\n<li>AST 类:创建 AST 节点的工厂类,类中包含许多创建各类 AST 节点的工厂方法,用户可以利用这些方法来构建 AST。</li>\n<li>ASTVisitor 类:<br>AST 的访问者抽象类,类中声明了一组访问各类 AST 节点的 visit( )方法、endVisit( )方法和 preVisit( )方法。   </li>\n</ul>\n<a id=\"more\"></a>\n<p>####AST 节点类<br>在 Eclipse AST 中,Java 源程序中的每个语法结构对应为一个 AST 节点,所有的 AST节点按其在语法上的关系连接形成一棵 AST 树。类 ASTNode 是 AST 树中各类节点的抽象基类,其余的 AST 节点类都由它派生。在 ASTNode 类中声明有各个具体的 AST 节点类所对应的类型标识,如 ASTNode.COMPILATION_UNIT 代表 Compilation_Unit 节点类,这类节点用来表示一个 Java 源程序文件。<br>为便于自顶向下(从父节点到子节点)或者自底向上(从子节点到父节点)访问 AST树,AST 节点含有指向其父节点的 parent 域以及若干关联的子节点域。在 AST 节点类中,以属性(property)来统一处理子节点以及用户自定义的节点属性,属性的访问方法有:   </p>\n<pre><code>void setProperty(String propertyName, Object data) // 设置指定属性的值\nObject getProperty(String propertyName) // 取得指定属性的值\nMap properties( )// 返回节点的所有属性表,这个表是不可修改的\n</code></pre><p>在每个具体的 AST 节点类中,以类常量形式声明该类节点所拥有的基本属性(即基本的子节点)类别,并定义了存放属性值的域以及设置和访问属性的方法。例如,在一个 Java源程序文件中,有可选的 package 声明、0 个或多个 import 声明以及至少 1 个类型声明(可以是类声明或接口声明),从而在表示 Java 源程序文件(称为编译单元)的 AST 节点类CompilationUnit 中就声明有 final 类变量 PACKAGE_PROPERTY、IMPORTS_PROPERTY 和TYPES_PROPERTY,分别表示 package 属性、imports 属性和 types 属性,同时还定义有如下的访问方法:    </p>\n<pre><code>List imports( )\n// 该节点的所有 import 声明,按在程序中的出现次序排列List types( )\n// 该节点的所有顶层类型声明,按在程序中的出现次序排列\nvoid setPackage(PackageDeclaration pkgDecl) // 设置该节点的 package 声明\nPackageDeclaration getPackage( )\n// 取得该节点的 package 声明\n</code></pre><p>其中,类型相同的子节点组成的序列以 java.util.List 接口类来表示,这个接口类包含 add、get、set、remove 等方法用于访问和修改序列。在实际构造和访问 AST 树时,需要注意统一所使用的 List 接口类的实现类,例如,可以统一使用类 java.util.LinkedList 或者统一使用类java.util.ArrayList 来表示序列。<br>在 AST 节点类中,只提供获取父节点的方法,即     </p>\n<pre><code>ASTNode getParent( )\n</code></pre><p>而没有提供设置父节点的方法,这是因为对节点的 parent 域的设置是伴随着将该节点设置为其他节点的子节点而自动进行的。一个新创建的 AST 节点是没有设置其父节点的。当节点A 通过形如 setCHILD 方法,如 A.setPackage(B)方法,或者通过序列的 add 或 set 方法,如A.types( ).add(B)方法,将节点 B 设为自己的孩子时,B 节点的 parent 域将自动设置为对 A节点的引用;对于那些因上述操作导致不再是 A 节点的子节点来说,其 parent 域将被自动设置为 null。    </p>\n<p>每个 AST 节点及其子节点只能归属于一棵 AST 树。如果将一棵 AST 树中的某个 AST节点添加到另一棵 AST 树中,则必须复制这个节点及其所有的子孙节点,以保证这些节点只属于一棵 AST 树。此外,AST 树中不能含有环,如果某些操作会导致 AST 有环,则这些操作将失败。<br>为支持对源程序的分析和类型检查等,每个 AST 节点还含有一组位标志(用一个 int用来传播与该节点有关的附加信息,这些位标志可以通过节点的以下方法来存取:   </p>\n<pre><code>void setFlags(int flags)\nint getFlags( )\n</code></pre><p>此外,Eclipse AST 还支持访问者模式,每个 AST 节点都含有方法:    </p>\n<pre><code>void accept(ASTVisitor visitor)\n</code></pre><p>用于统一表示对当前节点访问时所要执行的任务,这个任务由参数 visitor 来给定。你可以进一步了解 ASTVisitor 类以及访问者模式(见 2.7.2 节)来了解对 AST 树的访问。       </p>\n<p>####AST 类<br>org.eclipse.jdt.core.dom.AST 是 AST 节点的工厂类,即它提供一系列形如</p>\n<pre><code>TYPE newTYPE( )\n</code></pre><p>的工厂方法,用来创建名为 TYPE 的 Eclipse AST 节点类的实例,新创建的节点并没有设置父节点。例如,方法    </p>\n<pre><code>CompilationUnit newCompilationUnit( )\n</code></pre><p>用来创建由这个 AST 所拥有的一个编译单元节点。<br>要使用这些方法,首先需要创建 AST 类的实例:    </p>\n<pre><code>AST ast = AST.newAST(AST.JLS3);\n</code></pre><p>其中,参数 AST.JLS3 指示所生成的 ast 包含处理 JLS3(Java 语言规范第 3 版)的 AST API。<br>JLS3 是 Java 语言所有早期版本的超集,JLS3 API 可以用来处理直到 Java SE 6(即 JDK1.6)<br>的 Java 程序。    </p>\n<p>####ASTVisitor 类<br>org.eclipse.jdt.core.dom.ASTVisitor 是 AST 树的访问者类,它提供一套方法来实现对给定节点的访问。<br>这套方法中有两组是与具体的 AST 节点类 T 相关的,即 visit 方法和 endVisit方法,有两个是与具体的 AST 节点类无关的,即 preVisit 方法和 postVisit 方法。这些方法都通过参数接收一个 AST 节点 node,然后对这个节点进行访问以执行一些操作。   </p>\n<ul>\n<li>public boolean visit(T node) 如果返回 true,则接着访问 node 的子节点;如果返回false,则不再访问 node 的子节点。ASTVisitor 类提供的各个 visit 方法的缺省实现是:什么也不做,直接返回 true。子类可以根据需要重新实现这些方法中的部分或全部。<br>-public void endVisit(T node) 这类方法在节点 node 的子节点已经被访问或者是在visit(node)返回为 false 之后被调用ASTVisitor 类提供的各个 endVisit 方法的缺省实现是什么也不做。子类可以根据需要重新实现这些方法中的部分或全部。</li>\n<li>public void preVisit(ASTNode node)</li>\n<li>public void postVisit(ASTNode node) 这个方法在 endVisit(node)之后被调用。<br>这个方法在 visit(node)之前被调用。<br>ASTVisitor 类提供的 preVisit 方法和 postVisit 方法的缺省实现是什么也不做。子类可以根据需要来重新实现它们。   </li>\n</ul>\n<p>在 Eclipse AST 中,结合 AST 节点的 accept( )方法和 ASTVisitor 实例,假设待访问的AST 树的根节点为 root,<br>则调用 root.accept( )就可以启动对这棵 AST 树的遍历。遍历是以深度优先搜索为基础的,你可以进一步查看 Eclipse JDT 的源代码来确认这一点,你也可以从<a href=\"http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html\" target=\"_blank\" rel=\"external\">http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html</a> 上查看相关的源代码。为帮<br>助大家理解对 AST 树的遍历过程,这里简要给出 accept 方法的实现。<br>所有的 AST 节点都执行在 ASTNode 类中定义的 accept 方法:    </p>\n<pre><code>public final void accept(ASTVisitor visitor) {\nif (visitor == null) { throw new IllegalArgumentException(); }\nvisitor.preVisit(this);\n// 执行与节点类型无关的 preVisit 方法\naccept0(visitor); // 调用 accept0,执行与节点类型相关的 visit/endVisit 方法\nvisitor.postVisit(this); // 执行与节点类型无关的 postVisit 方法\n}\n</code></pre><p>ASTNode 类中的 accept0 方法是一个抽象的方法:     </p>\n<pre><code>abstract void accept0(ASTVisitor visitor);\n</code></pre><p>每个具体的 AST 节点类中都必须实现 accept0 方法,实现该方法的通用模板如下:   </p>\n<pre><code>boolean visitChildren = visitor.visit(this);\nif (visitChildren) {\n// 调用 visit( )访问本节点\n// 如果 visit( )返回 true,则访问子节点acceptChild(visitor, getProperty1()); // 访问非序列型属性\nacceptChildren(visitor, rawListProperty); // 访问序列型属性\nacceptChild(visitor, getProperty2());\n}\nvisitor.endVisit(this);// 调用 endVisit( )执行一些节点访问后的操作\n</code></pre><p>从上面的模板可以看出,如果节点包含多个属性,如 CompilationUnit 节点中有 imports属性和 types 属性等,则按这些属性在源程序中的先后次序来依次访问;如果一个属性为序列型,如 CompilationUnit 节点中的 types 属性,则调用 acceptChildren 方法来依次访问序列中的各个子节点;如果一个属性是非序列的,则调用 acceptChild 方法来访问。acceptChild和 acceptChildren 这两个方法的实现都与 AST 节点的具体类型无关,故放在 ASTNode 类中:     </p>\n<pre><code>final void acceptChild(ASTVisitor visitor, ASTNode child) {\nif (child == null) { return; }\nchild.accept(visitor);\n}\nfinal void acceptChildren(ASTVisitor visitor, ASTNode.NodeList children) {\nNodeList.Cursor cursor = children.newCursor();\ntry {\nwhile (cursor.hasNext()) {\nASTNode child = (ASTNode) cursor.next();\nchild.accept(visitor);\n}\n} finally {\nchildren.releaseCursor(cursor);\n}\n}\n</code></pre><p>基于上述的实现机制,当你需要对 AST 树实现特定的访问功能时,你只需要结合实际需求设计和实现 ASTVisitor 类的子类就可以了。例如,在本章的课程设计中,你需要实现ASTVisitor 类的派生类 InterpVisitor,在其中重写(override)与需要解释执行的语法结构相对应的 visit( )方法。        </p>\n<p>####SimpleMiniJOOL 语言涉及的 AST 节点类<br>虽然 Eclipse AST 有为数众多的 AST 节点类,但是为表示 SimpleMiniJOOL 语言只会用到其中的一小部分,下面简要描述 SimpleMiniJOOL 语言所涉及到的 AST 节点类,重点介绍在使用这些类时所关注的成员。    </p>\n<p>#####整体结构<br>1、CompilationUnit 类(编译单元)<br>它用来表示一个 Java 源程序文件,本书中用来表示一个 MiniJOOL 语言或其子语言程序的全部,是所对应的 AST 树的根节点。虽然这类节点有 package 声明、import 声明列表和类型声明列表等基本属性,但是在表示 SimpleMiniJOOL 程序时就只有一个类声明子节点。<br><strong>主要成员</strong>   </p>\n<pre><code>List types( )// 返回该编译单元的顶层类型声明所对应的节点序列\n</code></pre><p>2、TypeDeclaration 类(类型声明)<br>它用于表示 Java 语言中的类声明或接口声明,本书中用来表示 MiniJOOL 语言或其子语言中的类声明。在 SimpleMiniJOOL 程序中,仅有一个名为 Program 的类声明。<br><strong>主要成员</strong></p>\n<pre><code>MethodDeclaration[] getMethods( )\n// 返回类声明的方法声明序列\n以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:\nFieldDeclaration[] getFields( ) // 返回类声明的域声明序列\nType getSuperclassType( ) // 返回该类声明的超类类型或 null\nvoid setSuperclassType(Type superclassType)\n// 设置或清除超类\n</code></pre><p>3、MethodDeclaration 类(方法声明)<br>它用于表示 Java 语言中的方法声明或者是构造器声明(注意:在 Java 语言规范中,并不是将构造器看成是一个方法。因为后者视为是类中的成员,可以被子类继承;而前者不能被子类继承)。这类节点的基本属性包括:方法或构造器名、方法或构造器的体、返回类型、形参列表等。在一个 SimpleMiniJOOL 程序里的唯一的类中,只有一个名为 main 的无参方法,这个方法声明表示为一个 MethodDeclaration 实例。<br><strong>主要成员</strong></p>\n<pre><code>Block getBody( ) // 返回该方法声明的方法体,如果没有体则为 null\nvoid setBody(Block body) // 设置或清除该方法声明的方法体\nSimpleName getName( ) // 返回所声明的方法名\nvoid setName(SimpleName methodName)\nType getReturnType2( )\n// 设置方法名\n// 返回所声明的方法的返回类型\nvoid setReturnType2(Type type)\n// 设置返回类型\n</code></pre><p>以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:     </p>\n<pre><code>List parameters( ) // 返回所声明的方法的参数声明序列\nboolean isConstructor( ) // 返回该声明是否是在声明构造器\nvoid setConstructor(boolean isConstructor)\n// 设置是否是在声明构造器\n</code></pre><p>#####语句<br>Statement 类是所有 Eclipse AST 中语句节点类的基类,由它派生出许多具体的语句节点类。在表示 SimpleMiniJOOL 程序时,只涉及到 Block、ExpressionStatement、IfStatement、WhileStatement、EmptyStatement、BreakStatement、ContinueStatement、ReturnStatement 等语句节点类。<br>1、Block 类(语句块)<br>它表示用花括号括起来的语句序列,可以用来表示一个方法体。其基本属性是语句序列。<br><strong>主要成员</strong></p>\n<pre><code>List statements( )\n// 返回该语句块中的语句序列\n</code></pre><p>2、ExpressionStatement 类(表达式语句)<br>它表示由表达式形成的合法语句,包括表达式这一基本属性。在 SimpleMiniJOOL 语言中,可以用这个类来表示 print/read 语句或赋值表达式语句。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回该语句中的表达式\nvoid setExpression(Expression expression) // 设置该语句中的表达式\n</code></pre><p>3、IfStatement(if 语句)<br>它表示 if 或 if-else 语句,节点中包括 if 语句的表达式、then 分支以及可选的 else 分支<br>这些基本属性。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 if 语句的表达式\nvoid setExpression(Expression expression) // 设置 if 语句的表达式\nStatement getThenStatement( ) // 返回 if 语句的 then 分支\nvoid setThenStatement(Statement statement) // 设置 then 分支\nStatement getElseStatement( ) // 返回 if 语句的 else 分支\nvoid setElseStatement(Statement statement) // 设置 else 分支\n</code></pre><p>4、WhileStatement 类(while 语句)<br>它表示 while 语句,节点中包括 while 语句的表达式和体这些基本属性。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 while 语句的表达式\nvoid setExpression(Expression expression) // 设置 while 语句的表达式\nStatement getBody( ) // 返回 while 语句的体\nvoid setBody(Statement statement) // 设置 while 语句的体\n</code></pre><p>5、EmptyStatement 类(空语句)<br>它表示由分号组成的语句。<br>6、BreakStatement 类和 ContinueStatement 类<br>这两个类分别表示 break 语句和 continue 语句。在 Java 语言中,这两个语句是允许带有标号的,即形如“break label; ”或“continue label;”,因此提供 getLabel( )和 setLabel( )成员来访问标号。但是,在 MiniJOOL 语言或其子语言中,不支持标号。<br>7、ReturnStatement 类<br>它表示 return 语句。SimpleMiniJOOL 语言中的 return 语句是不允许含有表达式的,但是 MiniJOOL 语言和 SkipOOMiniJOOL 语言中的 return 语句允许含有表达式以支持返回值。故以下成员在表示 MiniJOOL 语言和 SkipOOMiniJOOL 语言时才会用到:<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 return 语句的表达式\nvoid setExpression(Expression expression) // 设置 return 语句的表达式\n</code></pre><p>#####表达式<br>Expression 类是所有 Eclipse AST 中表达式节点类的基类,由它派生出许多类。在表示SimpleMiniJOOL 程 序 时 , 只 涉 及 到 MethodInvocation 、 Assignment 、 InfixExpression 、PrefixExpression、ParenthesizedExpression、NumberLiteral、Name 这些表达式节点类。<br>1、MethodInvocation 类(方法调用)<br>它用来表示 Java 程序中的方法调用。MiniJOOL 语言中的方法调用形如:    </p>\n<pre><code>[ Expression . ] Identifier ( [ Expression { , Expression } ] )\n</code></pre><p>开头的“Expression .”是限制被调用方法的受限表达式,可以是类名、实例表达式或者没有。在 SkipOOMiniJOOL 语言中,方法调用不存在受限表达式。虽然 SimpleMiniJOOL 语言中没有方法调用,但是程序中的“print/read( &lt;参数&gt;)”用方法调用节点来表示。<br><strong>主要成员</strong>   </p>\n<pre><code>// 返回所调用的方法名\nSimpleName getName( )\nvoid setName(SimpleName methodName) // 设置方法名\nList arguments( )\n// 返回方法调用表达式中的实参表达式序列\n</code></pre><p>以下成员在表示 MiniJOOL 程序时才会用到:   </p>\n<pre><code>Expression getExpression( ) // 返回方法调用的受限表达式\nvoid setExpression(Expression expression) // 设置方法调用的受限表达式\n</code></pre><p>2、Assignment 类(赋值表达式)<br>它用于表示赋值表达式,包含运算符、左部和右部等基本属性。赋值运算符是在内部类Assignment.Operator 中义。MiniJOOL 语言或其子语言中支持的赋值运算符包括 =、+=、-=、<em>=、/=、%=。<br><em>*主要成员</em></em></p>\n<pre><code>Expression getLeftHandSide( )\n// 返回赋值表达式的左部\nvoid setLeftHandSide(Expression expr)\ngetRightHandSide( )\n// 设 置 赋 值 表 达 式 的 左 部 Expression\n// 返回赋值表达式的右部\nvoid setRightHandSide(Expression expr)\n// 设置赋值表达式的右部\nAssignment.Operator getOperator( ) // 返回赋值表达式的运算符\nvoid setOperator(Assignment.Operator op) // 设置赋值表达式的运算符\n</code></pre><p><strong>赋值运算符</strong><br>在内部类 Assignment.Operator 中,定义有许多类型为 static Assignment.Operator 的赋值运算符,其中与 MiniJOOL 语言及其子语言有关的有:   </p>\n<pre><code>ASSIGN:表示 =,可以用 Assignment.Operator.ASSIGN 来访问,以下类似\nPLUS_ASSIGN:表示+=\nMINUS_ASSIGN:表示 -=\nTIMES_ASSIGN:表示 *=\nDIVIDE_ASSIGN:表示 /=\nREMAINDER_ASSIGN:表示 %=\n</code></pre><p>3、InfixExpression 类(中缀表达式)<br>它用于表示中缀表达式,包含运算符、左操作数和右操作数等基本属性。运算符是在内部类 InfixExpression.Operator 中定义。MiniJOOL 语言或其子语言中支持的中缀运算符包括包括+、-、<em>、/、%、==、!=、&lt;、&lt;=、&gt;、&gt;=、&amp;&amp;、||等。<br><em>*主要成员</em></em></p>\n<pre><code>// 返回中缀表达式的左操作数\nExpression getLeftOperand( )\nvoid setLeftOperand(Expression expr) // 设置左操作数\nExpression getRightOperand( ) // 返回中缀表达式的右操作数\nvoid setRightOperand(Expression expr) // 设置右操作数\nInfixExpression.Operator getOperator( ) // 返回中缀表达式的运算符\nvoid setOperator(InfixExpression.Operator op) // 设置运算符\n</code></pre><p><strong>中缀运算符</strong><br>本书涉及内部类 InfixExpression.Operator 中定义的以下 static InfixExpression.Operator 类型的实例:      </p>\n<pre><code>+ PLUS\n% REMAINDER\n&lt; LESS\n&amp;&amp;\n-\nMINUS\n==\n&gt; GREATER\nCONDITIONAL_AND\n*\nTIMES\n/ DIVIDE\nEQUALS != NOT_EQUALS\n&lt;= &gt;=\n||\nLESS_EQUALS\nGREATER_EQUALS\nCONDITIONAL_OR\n</code></pre><p>4、PrefixExpression 类(前缀表达式)<br>它用于表示前缀表达式,包含运算符、操作数等基本属性。运算符是在内部类PrefixExpression.Operator 中定义。在 SimpleMiniJOOL 中,包括-、+、!等前缀运算符。<br><strong>主要成员</strong></p>\n<pre><code>Expression getOperand( )\n// 返回前缀表达式的操作数\nvoid setOperand(Expression expr)\n// 设置操作数\nPrefixExpression.Operator getOperator( ) // 返回前缀表达式的运算符\nvoid setOperator(PrefixExpression.Operator op) // 设置运算符\n</code></pre><p><strong>前缀运算符</strong><br>本书涉及内部类 PrefixExpression.Operator 中定义的以下 static PrefixExpression.Operator类型的实例:   </p>\n<pre><code>+PLUS\n- MINUS\n! NOT\n</code></pre><p>5、ParenthesizedExpression 类(带括号的表达式)<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( )\n// 返回括号内的表达式\nvoid setExpression(Expression expression) // 设置括号内的表达式\n</code></pre><p>6、NumberLiteral 类(整数)<br><strong>主要成员</strong></p>\n<pre><code>String getToken( )\n// 返回对应的整数串\nvoid setToken(String token) // 设置整数串\n</code></pre><p>7、Name 类<br>它用于表示一个名字,由它派生出 QualifiedName 和 SimpleName 两个类,前者表示一个形如 a.b 的受限名,后者表示一个简单名。在 SimpleMiniJOOL 程序中只会出现简单名。<br><strong>SimpleName 的主要成员</strong></p>\n<pre><code>String getIdentifier( ) // 返回标识符\nvoid setIdentifier(String expression) // 设置标识符\nboolean isDeclaration( ) // 该标识符是否定义过\n</code></pre><p><strong>QualifiedName 的主要成员</strong></p>\n<pre><code>SimpleName getName( ) // 返回受限名中的名字部分\nvoid setName(SimpleName name ) // 设置受限名中的名字部分\nName getQualifier( ) // 返回受限名中的受限部分\nvoid setQualifier(Name qualifier) // 设置受限名中的受限部分\n</code></pre><p>####Eclipse AST 使用示例<br>在这一节中,我们将演示如何利用 Eclipse AST 手工构建如下的 SimpleMiniJOOL 程序的 AST 中间表示。<br>    class Program {<br>    static void main() {<br>    i = 10;<br>    }<br>    }<br>首先,你需要通过 Eclipse AST 工厂类中的方法 newAST()建立一个 AST 实例:    </p>\n<pre><code>AST ast = AST.newAST(JLS3);\n</code></pre><p>利用这个 AST 实例,就可以按如下的方法创建各种 AST 节点,并构建完整的抽象语法树。然后,利用 Eclipse AST 工厂类中的各种创建方法按如下步骤创建所需要的 AST 节点:<br>1) 整个 SimpleMiniJOOL 程序构成一个 CompilationUnit:    </p>\n<pre><code>CompilationUnit cu = ast.newCompilationUnit();\n</code></pre><p>2) 在 CompilationUnit 实例中包含一个 TypeDeclaration,表示程序中的类 Program:    </p>\n<pre><code>TypeDeclaration type = ast.newTypeDeclaration( );\ntype.setName(ast.newSimpleName(“Program”));\n// 定义类的名字\n</code></pre><p>3) 在这个 TypeDeclaration 实例中添加类 Program 中的方法 main():    </p>\n<pre><code>MethodDeclaration method = ast.newMethodDeclaration( );\nmethod.setName(ast.newSimpleName(“main”));\ntype.bodyDeclarations().add(method);\n// 设置方法 main()的 modifier 为 static\nmethod.modifiers().add(\nast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n// 设置方法 main()的返回类型为 void\nmethod.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n</code></pre><p>4) 构造 main 函数的函数体 mainBody     </p>\n<pre><code>Block mainBody = ast.newBlock();\nmethod.setBody(mainBody);\n</code></pre><p>5) 向方法 main 函数体 mainBody 中添加语句    </p>\n<pre><code>// 构建赋值表达式\nAssignment assign = ast.newAssignment();\n// 设置赋值表达式的左值为 i\nassign.setLeftHandSide(ast.newSimpleName(&quot;i&quot;));\n// 设置赋值表达式的赋值算符为=\nassign.setOperator(Assignment.Operator.ASSIGN);\n// 设置赋值表达式的右值为数字 10\nassign.setRightHandSide(ast.newNumberLiteral(&quot;10&quot;));\n// 由赋值表达式构建语句,并把这个语句加入方法 Main()的函数体\nExpressionStatement statement = ast.newExpressionStatement(assign);\nmainBody.statements().add(statement);\n</code></pre><p>至此,用 Eclipse AST 表示的 SimpleMiniJOOL 程序的抽象语法树就构建完毕了。<br>在 lab1/src/edu/ustc/cs/compile/interpreter/TestCase.java 中的 createSampleAST( )方法给出了构建一个简单 SimpleMiniJOOL 程序对应的 AST 的完整示例。<br>需要再次强调的是,使用 Eclipse AST 构建的抽象语法树在拓扑结构上必须是无环的。无论是手工构建 AST 还是自动构建 AST,你都需要小心的检查自己的代码,避免违反这个原则。   </p>\n","excerpt":"<p>###Eclipse AST<br>Eclipse AST 是 Eclipse JDT 的一个重要组成部分,定义在包 org.eclipse.jdt.core.dom 中,用来表示 Java 语言中的所有语法结构。<br>Eclipse AST 采用工厂方法模式和访问者模式   (见 2.7节)来设计和实现,这样可以减轻用户深入了解其内部结构的压力,并且方便用户利用它们构建并处理 AST。你可以打开 Eclipse 帮助页面,通过鼠标依次点击窗口左边的目录“JDT Plug-in Developer Guide”Æ“Reference”Æ“API Reference” Æ“org.eclipse.jdt.core.dom”,即可打开这个包的详细说明。本节将对这个包中重要的类作简要说明,为简便起见,这里省去这些类的包名,即org.eclipse.jdt.core.dom。<br>在 Eclipse AST 中,与本书的课程设计相关的类主要有以下三部分:    </p>\n<ul>\n<li>ASTNode 类及其派生类:用于描述各种 AST 节点的类,每个 AST 节点表示一个Java 源程序中的一个语法结构,例如,一个名字、类型、表达式、语句或声明等。</li>\n<li>AST 类:创建 AST 节点的工厂类,类中包含许多创建各类 AST 节点的工厂方法,用户可以利用这些方法来构建 AST。</li>\n<li>ASTVisitor 类:<br>AST 的访问者抽象类,类中声明了一组访问各类 AST 节点的 visit( )方法、endVisit( )方法和 preVisit( )方法。   </li>\n</ul>","more":"<p>####AST 节点类<br>在 Eclipse AST 中,Java 源程序中的每个语法结构对应为一个 AST 节点,所有的 AST节点按其在语法上的关系连接形成一棵 AST 树。类 ASTNode 是 AST 树中各类节点的抽象基类,其余的 AST 节点类都由它派生。在 ASTNode 类中声明有各个具体的 AST 节点类所对应的类型标识,如 ASTNode.COMPILATION_UNIT 代表 Compilation_Unit 节点类,这类节点用来表示一个 Java 源程序文件。<br>为便于自顶向下(从父节点到子节点)或者自底向上(从子节点到父节点)访问 AST树,AST 节点含有指向其父节点的 parent 域以及若干关联的子节点域。在 AST 节点类中,以属性(property)来统一处理子节点以及用户自定义的节点属性,属性的访问方法有:   </p>\n<pre><code>void setProperty(String propertyName, Object data) // 设置指定属性的值\nObject getProperty(String propertyName) // 取得指定属性的值\nMap properties( )// 返回节点的所有属性表,这个表是不可修改的\n</code></pre><p>在每个具体的 AST 节点类中,以类常量形式声明该类节点所拥有的基本属性(即基本的子节点)类别,并定义了存放属性值的域以及设置和访问属性的方法。例如,在一个 Java源程序文件中,有可选的 package 声明、0 个或多个 import 声明以及至少 1 个类型声明(可以是类声明或接口声明),从而在表示 Java 源程序文件(称为编译单元)的 AST 节点类CompilationUnit 中就声明有 final 类变量 PACKAGE_PROPERTY、IMPORTS_PROPERTY 和TYPES_PROPERTY,分别表示 package 属性、imports 属性和 types 属性,同时还定义有如下的访问方法:    </p>\n<pre><code>List imports( )\n// 该节点的所有 import 声明,按在程序中的出现次序排列List types( )\n// 该节点的所有顶层类型声明,按在程序中的出现次序排列\nvoid setPackage(PackageDeclaration pkgDecl) // 设置该节点的 package 声明\nPackageDeclaration getPackage( )\n// 取得该节点的 package 声明\n</code></pre><p>其中,类型相同的子节点组成的序列以 java.util.List 接口类来表示,这个接口类包含 add、get、set、remove 等方法用于访问和修改序列。在实际构造和访问 AST 树时,需要注意统一所使用的 List 接口类的实现类,例如,可以统一使用类 java.util.LinkedList 或者统一使用类java.util.ArrayList 来表示序列。<br>在 AST 节点类中,只提供获取父节点的方法,即     </p>\n<pre><code>ASTNode getParent( )\n</code></pre><p>而没有提供设置父节点的方法,这是因为对节点的 parent 域的设置是伴随着将该节点设置为其他节点的子节点而自动进行的。一个新创建的 AST 节点是没有设置其父节点的。当节点A 通过形如 setCHILD 方法,如 A.setPackage(B)方法,或者通过序列的 add 或 set 方法,如A.types( ).add(B)方法,将节点 B 设为自己的孩子时,B 节点的 parent 域将自动设置为对 A节点的引用;对于那些因上述操作导致不再是 A 节点的子节点来说,其 parent 域将被自动设置为 null。    </p>\n<p>每个 AST 节点及其子节点只能归属于一棵 AST 树。如果将一棵 AST 树中的某个 AST节点添加到另一棵 AST 树中,则必须复制这个节点及其所有的子孙节点,以保证这些节点只属于一棵 AST 树。此外,AST 树中不能含有环,如果某些操作会导致 AST 有环,则这些操作将失败。<br>为支持对源程序的分析和类型检查等,每个 AST 节点还含有一组位标志(用一个 int用来传播与该节点有关的附加信息,这些位标志可以通过节点的以下方法来存取:   </p>\n<pre><code>void setFlags(int flags)\nint getFlags( )\n</code></pre><p>此外,Eclipse AST 还支持访问者模式,每个 AST 节点都含有方法:    </p>\n<pre><code>void accept(ASTVisitor visitor)\n</code></pre><p>用于统一表示对当前节点访问时所要执行的任务,这个任务由参数 visitor 来给定。你可以进一步了解 ASTVisitor 类以及访问者模式(见 2.7.2 节)来了解对 AST 树的访问。       </p>\n<p>####AST 类<br>org.eclipse.jdt.core.dom.AST 是 AST 节点的工厂类,即它提供一系列形如</p>\n<pre><code>TYPE newTYPE( )\n</code></pre><p>的工厂方法,用来创建名为 TYPE 的 Eclipse AST 节点类的实例,新创建的节点并没有设置父节点。例如,方法    </p>\n<pre><code>CompilationUnit newCompilationUnit( )\n</code></pre><p>用来创建由这个 AST 所拥有的一个编译单元节点。<br>要使用这些方法,首先需要创建 AST 类的实例:    </p>\n<pre><code>AST ast = AST.newAST(AST.JLS3);\n</code></pre><p>其中,参数 AST.JLS3 指示所生成的 ast 包含处理 JLS3(Java 语言规范第 3 版)的 AST API。<br>JLS3 是 Java 语言所有早期版本的超集,JLS3 API 可以用来处理直到 Java SE 6(即 JDK1.6)<br>的 Java 程序。    </p>\n<p>####ASTVisitor 类<br>org.eclipse.jdt.core.dom.ASTVisitor 是 AST 树的访问者类,它提供一套方法来实现对给定节点的访问。<br>这套方法中有两组是与具体的 AST 节点类 T 相关的,即 visit 方法和 endVisit方法,有两个是与具体的 AST 节点类无关的,即 preVisit 方法和 postVisit 方法。这些方法都通过参数接收一个 AST 节点 node,然后对这个节点进行访问以执行一些操作。   </p>\n<ul>\n<li>public boolean visit(T node) 如果返回 true,则接着访问 node 的子节点;如果返回false,则不再访问 node 的子节点。ASTVisitor 类提供的各个 visit 方法的缺省实现是:什么也不做,直接返回 true。子类可以根据需要重新实现这些方法中的部分或全部。<br>-public void endVisit(T node) 这类方法在节点 node 的子节点已经被访问或者是在visit(node)返回为 false 之后被调用ASTVisitor 类提供的各个 endVisit 方法的缺省实现是什么也不做。子类可以根据需要重新实现这些方法中的部分或全部。</li>\n<li>public void preVisit(ASTNode node)</li>\n<li>public void postVisit(ASTNode node) 这个方法在 endVisit(node)之后被调用。<br>这个方法在 visit(node)之前被调用。<br>ASTVisitor 类提供的 preVisit 方法和 postVisit 方法的缺省实现是什么也不做。子类可以根据需要来重新实现它们。   </li>\n</ul>\n<p>在 Eclipse AST 中,结合 AST 节点的 accept( )方法和 ASTVisitor 实例,假设待访问的AST 树的根节点为 root,<br>则调用 root.accept( )就可以启动对这棵 AST 树的遍历。遍历是以深度优先搜索为基础的,你可以进一步查看 Eclipse JDT 的源代码来确认这一点,你也可以从<a href=\"http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html\">http://www.docjar.com/docs/api/org/eclipse/jdt/core/dom/index.html</a> 上查看相关的源代码。为帮<br>助大家理解对 AST 树的遍历过程,这里简要给出 accept 方法的实现。<br>所有的 AST 节点都执行在 ASTNode 类中定义的 accept 方法:    </p>\n<pre><code>public final void accept(ASTVisitor visitor) {\nif (visitor == null) { throw new IllegalArgumentException(); }\nvisitor.preVisit(this);\n// 执行与节点类型无关的 preVisit 方法\naccept0(visitor); // 调用 accept0,执行与节点类型相关的 visit/endVisit 方法\nvisitor.postVisit(this); // 执行与节点类型无关的 postVisit 方法\n}\n</code></pre><p>ASTNode 类中的 accept0 方法是一个抽象的方法:     </p>\n<pre><code>abstract void accept0(ASTVisitor visitor);\n</code></pre><p>每个具体的 AST 节点类中都必须实现 accept0 方法,实现该方法的通用模板如下:   </p>\n<pre><code>boolean visitChildren = visitor.visit(this);\nif (visitChildren) {\n// 调用 visit( )访问本节点\n// 如果 visit( )返回 true,则访问子节点acceptChild(visitor, getProperty1()); // 访问非序列型属性\nacceptChildren(visitor, rawListProperty); // 访问序列型属性\nacceptChild(visitor, getProperty2());\n}\nvisitor.endVisit(this);// 调用 endVisit( )执行一些节点访问后的操作\n</code></pre><p>从上面的模板可以看出,如果节点包含多个属性,如 CompilationUnit 节点中有 imports属性和 types 属性等,则按这些属性在源程序中的先后次序来依次访问;如果一个属性为序列型,如 CompilationUnit 节点中的 types 属性,则调用 acceptChildren 方法来依次访问序列中的各个子节点;如果一个属性是非序列的,则调用 acceptChild 方法来访问。acceptChild和 acceptChildren 这两个方法的实现都与 AST 节点的具体类型无关,故放在 ASTNode 类中:     </p>\n<pre><code>final void acceptChild(ASTVisitor visitor, ASTNode child) {\nif (child == null) { return; }\nchild.accept(visitor);\n}\nfinal void acceptChildren(ASTVisitor visitor, ASTNode.NodeList children) {\nNodeList.Cursor cursor = children.newCursor();\ntry {\nwhile (cursor.hasNext()) {\nASTNode child = (ASTNode) cursor.next();\nchild.accept(visitor);\n}\n} finally {\nchildren.releaseCursor(cursor);\n}\n}\n</code></pre><p>基于上述的实现机制,当你需要对 AST 树实现特定的访问功能时,你只需要结合实际需求设计和实现 ASTVisitor 类的子类就可以了。例如,在本章的课程设计中,你需要实现ASTVisitor 类的派生类 InterpVisitor,在其中重写(override)与需要解释执行的语法结构相对应的 visit( )方法。        </p>\n<p>####SimpleMiniJOOL 语言涉及的 AST 节点类<br>虽然 Eclipse AST 有为数众多的 AST 节点类,但是为表示 SimpleMiniJOOL 语言只会用到其中的一小部分,下面简要描述 SimpleMiniJOOL 语言所涉及到的 AST 节点类,重点介绍在使用这些类时所关注的成员。    </p>\n<p>#####整体结构<br>1、CompilationUnit 类(编译单元)<br>它用来表示一个 Java 源程序文件,本书中用来表示一个 MiniJOOL 语言或其子语言程序的全部,是所对应的 AST 树的根节点。虽然这类节点有 package 声明、import 声明列表和类型声明列表等基本属性,但是在表示 SimpleMiniJOOL 程序时就只有一个类声明子节点。<br><strong>主要成员</strong>   </p>\n<pre><code>List types( )// 返回该编译单元的顶层类型声明所对应的节点序列\n</code></pre><p>2、TypeDeclaration 类(类型声明)<br>它用于表示 Java 语言中的类声明或接口声明,本书中用来表示 MiniJOOL 语言或其子语言中的类声明。在 SimpleMiniJOOL 程序中,仅有一个名为 Program 的类声明。<br><strong>主要成员</strong></p>\n<pre><code>MethodDeclaration[] getMethods( )\n// 返回类声明的方法声明序列\n以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:\nFieldDeclaration[] getFields( ) // 返回类声明的域声明序列\nType getSuperclassType( ) // 返回该类声明的超类类型或 null\nvoid setSuperclassType(Type superclassType)\n// 设置或清除超类\n</code></pre><p>3、MethodDeclaration 类(方法声明)<br>它用于表示 Java 语言中的方法声明或者是构造器声明(注意:在 Java 语言规范中,并不是将构造器看成是一个方法。因为后者视为是类中的成员,可以被子类继承;而前者不能被子类继承)。这类节点的基本属性包括:方法或构造器名、方法或构造器的体、返回类型、形参列表等。在一个 SimpleMiniJOOL 程序里的唯一的类中,只有一个名为 main 的无参方法,这个方法声明表示为一个 MethodDeclaration 实例。<br><strong>主要成员</strong></p>\n<pre><code>Block getBody( ) // 返回该方法声明的方法体,如果没有体则为 null\nvoid setBody(Block body) // 设置或清除该方法声明的方法体\nSimpleName getName( ) // 返回所声明的方法名\nvoid setName(SimpleName methodName)\nType getReturnType2( )\n// 设置方法名\n// 返回所声明的方法的返回类型\nvoid setReturnType2(Type type)\n// 设置返回类型\n</code></pre><p>以下成员在表示 SkipOOMiniJOOL 或 MiniJOOL 程序时才会用到:     </p>\n<pre><code>List parameters( ) // 返回所声明的方法的参数声明序列\nboolean isConstructor( ) // 返回该声明是否是在声明构造器\nvoid setConstructor(boolean isConstructor)\n// 设置是否是在声明构造器\n</code></pre><p>#####语句<br>Statement 类是所有 Eclipse AST 中语句节点类的基类,由它派生出许多具体的语句节点类。在表示 SimpleMiniJOOL 程序时,只涉及到 Block、ExpressionStatement、IfStatement、WhileStatement、EmptyStatement、BreakStatement、ContinueStatement、ReturnStatement 等语句节点类。<br>1、Block 类(语句块)<br>它表示用花括号括起来的语句序列,可以用来表示一个方法体。其基本属性是语句序列。<br><strong>主要成员</strong></p>\n<pre><code>List statements( )\n// 返回该语句块中的语句序列\n</code></pre><p>2、ExpressionStatement 类(表达式语句)<br>它表示由表达式形成的合法语句,包括表达式这一基本属性。在 SimpleMiniJOOL 语言中,可以用这个类来表示 print/read 语句或赋值表达式语句。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回该语句中的表达式\nvoid setExpression(Expression expression) // 设置该语句中的表达式\n</code></pre><p>3、IfStatement(if 语句)<br>它表示 if 或 if-else 语句,节点中包括 if 语句的表达式、then 分支以及可选的 else 分支<br>这些基本属性。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 if 语句的表达式\nvoid setExpression(Expression expression) // 设置 if 语句的表达式\nStatement getThenStatement( ) // 返回 if 语句的 then 分支\nvoid setThenStatement(Statement statement) // 设置 then 分支\nStatement getElseStatement( ) // 返回 if 语句的 else 分支\nvoid setElseStatement(Statement statement) // 设置 else 分支\n</code></pre><p>4、WhileStatement 类(while 语句)<br>它表示 while 语句,节点中包括 while 语句的表达式和体这些基本属性。<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 while 语句的表达式\nvoid setExpression(Expression expression) // 设置 while 语句的表达式\nStatement getBody( ) // 返回 while 语句的体\nvoid setBody(Statement statement) // 设置 while 语句的体\n</code></pre><p>5、EmptyStatement 类(空语句)<br>它表示由分号组成的语句。<br>6、BreakStatement 类和 ContinueStatement 类<br>这两个类分别表示 break 语句和 continue 语句。在 Java 语言中,这两个语句是允许带有标号的,即形如“break label; ”或“continue label;”,因此提供 getLabel( )和 setLabel( )成员来访问标号。但是,在 MiniJOOL 语言或其子语言中,不支持标号。<br>7、ReturnStatement 类<br>它表示 return 语句。SimpleMiniJOOL 语言中的 return 语句是不允许含有表达式的,但是 MiniJOOL 语言和 SkipOOMiniJOOL 语言中的 return 语句允许含有表达式以支持返回值。故以下成员在表示 MiniJOOL 语言和 SkipOOMiniJOOL 语言时才会用到:<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( ) // 返回 return 语句的表达式\nvoid setExpression(Expression expression) // 设置 return 语句的表达式\n</code></pre><p>#####表达式<br>Expression 类是所有 Eclipse AST 中表达式节点类的基类,由它派生出许多类。在表示SimpleMiniJOOL 程 序 时 , 只 涉 及 到 MethodInvocation 、 Assignment 、 InfixExpression 、PrefixExpression、ParenthesizedExpression、NumberLiteral、Name 这些表达式节点类。<br>1、MethodInvocation 类(方法调用)<br>它用来表示 Java 程序中的方法调用。MiniJOOL 语言中的方法调用形如:    </p>\n<pre><code>[ Expression . ] Identifier ( [ Expression { , Expression } ] )\n</code></pre><p>开头的“Expression .”是限制被调用方法的受限表达式,可以是类名、实例表达式或者没有。在 SkipOOMiniJOOL 语言中,方法调用不存在受限表达式。虽然 SimpleMiniJOOL 语言中没有方法调用,但是程序中的“print/read( &lt;参数&gt;)”用方法调用节点来表示。<br><strong>主要成员</strong>   </p>\n<pre><code>// 返回所调用的方法名\nSimpleName getName( )\nvoid setName(SimpleName methodName) // 设置方法名\nList arguments( )\n// 返回方法调用表达式中的实参表达式序列\n</code></pre><p>以下成员在表示 MiniJOOL 程序时才会用到:   </p>\n<pre><code>Expression getExpression( ) // 返回方法调用的受限表达式\nvoid setExpression(Expression expression) // 设置方法调用的受限表达式\n</code></pre><p>2、Assignment 类(赋值表达式)<br>它用于表示赋值表达式,包含运算符、左部和右部等基本属性。赋值运算符是在内部类Assignment.Operator 中义。MiniJOOL 语言或其子语言中支持的赋值运算符包括 =、+=、-=、<em>=、/=、%=。<br><em>*主要成员</em></em></p>\n<pre><code>Expression getLeftHandSide( )\n// 返回赋值表达式的左部\nvoid setLeftHandSide(Expression expr)\ngetRightHandSide( )\n// 设 置 赋 值 表 达 式 的 左 部 Expression\n// 返回赋值表达式的右部\nvoid setRightHandSide(Expression expr)\n// 设置赋值表达式的右部\nAssignment.Operator getOperator( ) // 返回赋值表达式的运算符\nvoid setOperator(Assignment.Operator op) // 设置赋值表达式的运算符\n</code></pre><p><strong>赋值运算符</strong><br>在内部类 Assignment.Operator 中,定义有许多类型为 static Assignment.Operator 的赋值运算符,其中与 MiniJOOL 语言及其子语言有关的有:   </p>\n<pre><code>ASSIGN:表示 =,可以用 Assignment.Operator.ASSIGN 来访问,以下类似\nPLUS_ASSIGN:表示+=\nMINUS_ASSIGN:表示 -=\nTIMES_ASSIGN:表示 *=\nDIVIDE_ASSIGN:表示 /=\nREMAINDER_ASSIGN:表示 %=\n</code></pre><p>3、InfixExpression 类(中缀表达式)<br>它用于表示中缀表达式,包含运算符、左操作数和右操作数等基本属性。运算符是在内部类 InfixExpression.Operator 中定义。MiniJOOL 语言或其子语言中支持的中缀运算符包括包括+、-、<em>、/、%、==、!=、&lt;、&lt;=、&gt;、&gt;=、&amp;&amp;、||等。<br><em>*主要成员</em></em></p>\n<pre><code>// 返回中缀表达式的左操作数\nExpression getLeftOperand( )\nvoid setLeftOperand(Expression expr) // 设置左操作数\nExpression getRightOperand( ) // 返回中缀表达式的右操作数\nvoid setRightOperand(Expression expr) // 设置右操作数\nInfixExpression.Operator getOperator( ) // 返回中缀表达式的运算符\nvoid setOperator(InfixExpression.Operator op) // 设置运算符\n</code></pre><p><strong>中缀运算符</strong><br>本书涉及内部类 InfixExpression.Operator 中定义的以下 static InfixExpression.Operator 类型的实例:      </p>\n<pre><code>+ PLUS\n% REMAINDER\n&lt; LESS\n&amp;&amp;\n-\nMINUS\n==\n&gt; GREATER\nCONDITIONAL_AND\n*\nTIMES\n/ DIVIDE\nEQUALS != NOT_EQUALS\n&lt;= &gt;=\n||\nLESS_EQUALS\nGREATER_EQUALS\nCONDITIONAL_OR\n</code></pre><p>4、PrefixExpression 类(前缀表达式)<br>它用于表示前缀表达式,包含运算符、操作数等基本属性。运算符是在内部类PrefixExpression.Operator 中定义。在 SimpleMiniJOOL 中,包括-、+、!等前缀运算符。<br><strong>主要成员</strong></p>\n<pre><code>Expression getOperand( )\n// 返回前缀表达式的操作数\nvoid setOperand(Expression expr)\n// 设置操作数\nPrefixExpression.Operator getOperator( ) // 返回前缀表达式的运算符\nvoid setOperator(PrefixExpression.Operator op) // 设置运算符\n</code></pre><p><strong>前缀运算符</strong><br>本书涉及内部类 PrefixExpression.Operator 中定义的以下 static PrefixExpression.Operator类型的实例:   </p>\n<pre><code>+PLUS\n- MINUS\n! NOT\n</code></pre><p>5、ParenthesizedExpression 类(带括号的表达式)<br><strong>主要成员</strong></p>\n<pre><code>Expression getExpression( )\n// 返回括号内的表达式\nvoid setExpression(Expression expression) // 设置括号内的表达式\n</code></pre><p>6、NumberLiteral 类(整数)<br><strong>主要成员</strong></p>\n<pre><code>String getToken( )\n// 返回对应的整数串\nvoid setToken(String token) // 设置整数串\n</code></pre><p>7、Name 类<br>它用于表示一个名字,由它派生出 QualifiedName 和 SimpleName 两个类,前者表示一个形如 a.b 的受限名,后者表示一个简单名。在 SimpleMiniJOOL 程序中只会出现简单名。<br><strong>SimpleName 的主要成员</strong></p>\n<pre><code>String getIdentifier( ) // 返回标识符\nvoid setIdentifier(String expression) // 设置标识符\nboolean isDeclaration( ) // 该标识符是否定义过\n</code></pre><p><strong>QualifiedName 的主要成员</strong></p>\n<pre><code>SimpleName getName( ) // 返回受限名中的名字部分\nvoid setName(SimpleName name ) // 设置受限名中的名字部分\nName getQualifier( ) // 返回受限名中的受限部分\nvoid setQualifier(Name qualifier) // 设置受限名中的受限部分\n</code></pre><p>####Eclipse AST 使用示例<br>在这一节中,我们将演示如何利用 Eclipse AST 手工构建如下的 SimpleMiniJOOL 程序的 AST 中间表示。<br>    class Program {<br>    static void main() {<br>    i = 10;<br>    }<br>    }<br>首先,你需要通过 Eclipse AST 工厂类中的方法 newAST()建立一个 AST 实例:    </p>\n<pre><code>AST ast = AST.newAST(JLS3);\n</code></pre><p>利用这个 AST 实例,就可以按如下的方法创建各种 AST 节点,并构建完整的抽象语法树。然后,利用 Eclipse AST 工厂类中的各种创建方法按如下步骤创建所需要的 AST 节点:<br>1) 整个 SimpleMiniJOOL 程序构成一个 CompilationUnit:    </p>\n<pre><code>CompilationUnit cu = ast.newCompilationUnit();\n</code></pre><p>2) 在 CompilationUnit 实例中包含一个 TypeDeclaration,表示程序中的类 Program:    </p>\n<pre><code>TypeDeclaration type = ast.newTypeDeclaration( );\ntype.setName(ast.newSimpleName(“Program”));\n// 定义类的名字\n</code></pre><p>3) 在这个 TypeDeclaration 实例中添加类 Program 中的方法 main():    </p>\n<pre><code>MethodDeclaration method = ast.newMethodDeclaration( );\nmethod.setName(ast.newSimpleName(“main”));\ntype.bodyDeclarations().add(method);\n// 设置方法 main()的 modifier 为 static\nmethod.modifiers().add(\nast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));\n// 设置方法 main()的返回类型为 void\nmethod.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));\n</code></pre><p>4) 构造 main 函数的函数体 mainBody     </p>\n<pre><code>Block mainBody = ast.newBlock();\nmethod.setBody(mainBody);\n</code></pre><p>5) 向方法 main 函数体 mainBody 中添加语句    </p>\n<pre><code>// 构建赋值表达式\nAssignment assign = ast.newAssignment();\n// 设置赋值表达式的左值为 i\nassign.setLeftHandSide(ast.newSimpleName(&quot;i&quot;));\n// 设置赋值表达式的赋值算符为=\nassign.setOperator(Assignment.Operator.ASSIGN);\n// 设置赋值表达式的右值为数字 10\nassign.setRightHandSide(ast.newNumberLiteral(&quot;10&quot;));\n// 由赋值表达式构建语句,并把这个语句加入方法 Main()的函数体\nExpressionStatement statement = ast.newExpressionStatement(assign);\nmainBody.statements().add(statement);\n</code></pre><p>至此,用 Eclipse AST 表示的 SimpleMiniJOOL 程序的抽象语法树就构建完毕了。<br>在 lab1/src/edu/ustc/cs/compile/interpreter/TestCase.java 中的 createSampleAST( )方法给出了构建一个简单 SimpleMiniJOOL 程序对应的 AST 的完整示例。<br>需要再次强调的是,使用 Eclipse AST 构建的抽象语法树在拓扑结构上必须是无环的。无论是手工构建 AST 还是自动构建 AST,你都需要小心的检查自己的代码,避免违反这个原则。   </p>"},{"layout":"post","title":"从Github发布jar包到Maven Central","date":"2013-06-19T11:50:00.000Z","comments":1,"_content":"\n除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。  \n\n下面介绍下如何做：   \n\n###准备工作\n\n1.添加source code management信息到pom.xml:\n\n    <scm>\n        <connection>scm:git:git@github.com:blueshen/ut-maven-plugin.git</connection>\n        <developerConnection>scm:git:git@github.com:blueshen/ut-maven-plugin.git</developerConnection>\n        <url>git@github.com:blueshen/ut-maven-plugin.git</url>\n    </scm>\n2.创建GPG的密钥对并发布公钥。参看[Sonatype documentation](https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven)的具体步骤.推荐使用Linux,Mac来发布。    \n>`gpg --gen-key` 创建key    \n`gpg --list-keys` 查看所有的key   \n`gpg --send-keys --keyserver pool.sks-keyservers.net yourkey`   发布你的key到服务器上\n\n3.确保你的工程POM符合[要求](https://docs.sonatype.org/display/Repository/Central+Sync+Requirements)  \n4.创建一个[Sonatype JIRA](https://issues.sonatype.org/)账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。        \n<!--more-->\n###使用Maven来发布到Sonatype Nexus repository\n####pom.xml配置有2种方法：   \n   \n1.添加maven-release-plugin到pom.xml:\n\n\n    <plugin>\n    \t<groupId>org.apache.maven.plugins</groupId>\n    \t<artifactId>maven-release-plugin</artifactId>\n    \t<version>2.2.2</version>\n    \t<configuration>\n    \t\t<arguments>-Dgpg.passphrase=${gpg.passphrase}</arguments>\n    \t</configuration>\n    </plugin>\n\n添加Sonatype repositories:\n\n    <distributionManagement>\n    \t<snapshotRepository>\n    \t\t<id>sonatype-nexus-snapshots</id>\n    \t\t<name>Sonatype Nexus snapshot repository</name>\n    \t\t<url>https://oss.sonatype.org/content/repositories/snapshots</url>\n    \t</snapshotRepository>\n    \t<repository>\n    \t\t<id>sonatype-nexus-staging</id>\n    \t\t<name>Sonatype Nexus release repository</name>\n    \t\t<url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n    \t</repository>\n    </distributionManagement>\n\n设置artifact signing:\n\n    <profiles>\n    \t<profile>\n    \t\t<id>release-sign-artifacts</id>\n    \t\t<activation>\n    \t\t\t<property>\n    \t\t\t\t<name>performRelease</name>\n    \t\t\t\t<value>true</value>\n    \t\t\t</property>\n    \t\t</activation>\n    \t\t<build>\n    \t\t\t<plugins>\n    \t\t\t\t<plugin>\n    \t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n    \t\t\t\t\t<artifactId>maven-gpg-plugin</artifactId>\n    \t\t\t\t\t<version>1.4</version>\n    \t\t\t\t\t<configuration>\n    \t\t\t\t\t\t<passphrase>${gpg.passphrase}</passphrase>\n    \t\t\t\t\t</configuration>\n    \t\t\t\t\t<executions>\n    \t\t\t\t\t\t<execution>\n    \t\t\t\t\t\t\t<id>sign-artifacts</id>\n    \t\t\t\t\t\t\t<phase>verify</phase>\n    \t\t\t\t\t\t\t<goals>\n    \t\t\t\t\t\t\t\t<goal>sign</goal>\n    \t\t\t\t\t\t\t</goals>\n    \t\t\t\t\t\t</execution>\n    \t\t\t\t\t</executions>\n    \t\t\t\t</plugin>\n    \t\t\t</plugins>\n    \t\t</build>\n    \t</profile>\n    </profiles>\n2.直接添加sonatype parent到POM.XML（推荐）\n\n    <parent>\n        <groupId>org.sonatype.oss</groupId>\n        <artifactId>oss-parent</artifactId>\n        <version>7</version>\n    </parent>\n\n####maven settings.xml配置\n编辑或者创建~/.m2/settings.xml并包含验证信息:\n\n    <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0\n                          http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n    \t<servers>\n    \t\t<server>\n    \t\t\t<id>sonatype-nexus-snapshots</id>\n    \t\t\t<username>myusername</username>\n    \t\t\t<password>mypassword</password>\n    \t\t</server>\n    \t\t<server>\n    \t\t\t<id>sonatype-nexus-staging</id>\n    \t\t\t<username>myusername</username>\n    \t\t\t<password>mypassword</password>\n    \t\t</server>\n    \t</servers>\n     \n    \t<profiles>\n    \t\t<profile>\n    \t\t\t<id>sign</id>\n    \t\t\t<activation>\n    \t\t\t\t<activeByDefault>true</activeByDefault>\n    \t\t\t</activation>\n    \t\t\t<properties>\n    \t\t\t\t<gpg.passphrase>mypassphrase</gpg.passphrase>\n    \t\t\t</properties>\n    \t\t</profile>\n    \t</profiles>\n    </settings>\n\nMaven有一个[避免使用明文的方法](http://maven.apache.org/guides/mini/guide-encryption.html),但我还没试用过。    \n\n###准备一个release版本    \n\n为了准备一个release版本, 执行:    \n\n    $ mvn release:clean    \n    $ mvn release:prepare\n[参考这个](http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html).这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.\n\n如果你要撤销release,可以使用`git reset --hard HEAD~2`进行[回退](http://stackoverflow.com/a/6866485/150884),使用`git tag -d ut-maven-plugin-0.1`[删除Tag](http://nathanhoad.net/how-to-delete-a-remote-git-tag),然后使用`git push origin :refs/tags/ut-maven-plugin-0.1`提交.\n\n###发布到Sonatype\n\n1.如果一切OK，你就可以使用[mvn release:perform](http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html)来发布工程到Sonatype。  \n2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。   \n3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些[很好的指引](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt). 你可以使用[Maven repository management plugin](http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html)来自动化这些步骤,尽管我自己还没有试过。     \n4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。\n\n参考文档<http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html>","source":"_posts/2013-06-19-publishing-from-github-to-maven-central.markdown","raw":"---\nlayout: post\ntitle: \"从Github发布jar包到Maven Central\"\ndate: 2013-06-19 19:50\ncomments: true\ncategories: maven\ntags: [ maven, github, jar, sonatype ]\n---\n\n除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。  \n\n下面介绍下如何做：   \n\n###准备工作\n\n1.添加source code management信息到pom.xml:\n\n    <scm>\n        <connection>scm:git:git@github.com:blueshen/ut-maven-plugin.git</connection>\n        <developerConnection>scm:git:git@github.com:blueshen/ut-maven-plugin.git</developerConnection>\n        <url>git@github.com:blueshen/ut-maven-plugin.git</url>\n    </scm>\n2.创建GPG的密钥对并发布公钥。参看[Sonatype documentation](https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven)的具体步骤.推荐使用Linux,Mac来发布。    \n>`gpg --gen-key` 创建key    \n`gpg --list-keys` 查看所有的key   \n`gpg --send-keys --keyserver pool.sks-keyservers.net yourkey`   发布你的key到服务器上\n\n3.确保你的工程POM符合[要求](https://docs.sonatype.org/display/Repository/Central+Sync+Requirements)  \n4.创建一个[Sonatype JIRA](https://issues.sonatype.org/)账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。        \n<!--more-->\n###使用Maven来发布到Sonatype Nexus repository\n####pom.xml配置有2种方法：   \n   \n1.添加maven-release-plugin到pom.xml:\n\n\n    <plugin>\n    \t<groupId>org.apache.maven.plugins</groupId>\n    \t<artifactId>maven-release-plugin</artifactId>\n    \t<version>2.2.2</version>\n    \t<configuration>\n    \t\t<arguments>-Dgpg.passphrase=${gpg.passphrase}</arguments>\n    \t</configuration>\n    </plugin>\n\n添加Sonatype repositories:\n\n    <distributionManagement>\n    \t<snapshotRepository>\n    \t\t<id>sonatype-nexus-snapshots</id>\n    \t\t<name>Sonatype Nexus snapshot repository</name>\n    \t\t<url>https://oss.sonatype.org/content/repositories/snapshots</url>\n    \t</snapshotRepository>\n    \t<repository>\n    \t\t<id>sonatype-nexus-staging</id>\n    \t\t<name>Sonatype Nexus release repository</name>\n    \t\t<url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n    \t</repository>\n    </distributionManagement>\n\n设置artifact signing:\n\n    <profiles>\n    \t<profile>\n    \t\t<id>release-sign-artifacts</id>\n    \t\t<activation>\n    \t\t\t<property>\n    \t\t\t\t<name>performRelease</name>\n    \t\t\t\t<value>true</value>\n    \t\t\t</property>\n    \t\t</activation>\n    \t\t<build>\n    \t\t\t<plugins>\n    \t\t\t\t<plugin>\n    \t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n    \t\t\t\t\t<artifactId>maven-gpg-plugin</artifactId>\n    \t\t\t\t\t<version>1.4</version>\n    \t\t\t\t\t<configuration>\n    \t\t\t\t\t\t<passphrase>${gpg.passphrase}</passphrase>\n    \t\t\t\t\t</configuration>\n    \t\t\t\t\t<executions>\n    \t\t\t\t\t\t<execution>\n    \t\t\t\t\t\t\t<id>sign-artifacts</id>\n    \t\t\t\t\t\t\t<phase>verify</phase>\n    \t\t\t\t\t\t\t<goals>\n    \t\t\t\t\t\t\t\t<goal>sign</goal>\n    \t\t\t\t\t\t\t</goals>\n    \t\t\t\t\t\t</execution>\n    \t\t\t\t\t</executions>\n    \t\t\t\t</plugin>\n    \t\t\t</plugins>\n    \t\t</build>\n    \t</profile>\n    </profiles>\n2.直接添加sonatype parent到POM.XML（推荐）\n\n    <parent>\n        <groupId>org.sonatype.oss</groupId>\n        <artifactId>oss-parent</artifactId>\n        <version>7</version>\n    </parent>\n\n####maven settings.xml配置\n编辑或者创建~/.m2/settings.xml并包含验证信息:\n\n    <settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0\n                          http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n    \t<servers>\n    \t\t<server>\n    \t\t\t<id>sonatype-nexus-snapshots</id>\n    \t\t\t<username>myusername</username>\n    \t\t\t<password>mypassword</password>\n    \t\t</server>\n    \t\t<server>\n    \t\t\t<id>sonatype-nexus-staging</id>\n    \t\t\t<username>myusername</username>\n    \t\t\t<password>mypassword</password>\n    \t\t</server>\n    \t</servers>\n     \n    \t<profiles>\n    \t\t<profile>\n    \t\t\t<id>sign</id>\n    \t\t\t<activation>\n    \t\t\t\t<activeByDefault>true</activeByDefault>\n    \t\t\t</activation>\n    \t\t\t<properties>\n    \t\t\t\t<gpg.passphrase>mypassphrase</gpg.passphrase>\n    \t\t\t</properties>\n    \t\t</profile>\n    \t</profiles>\n    </settings>\n\nMaven有一个[避免使用明文的方法](http://maven.apache.org/guides/mini/guide-encryption.html),但我还没试用过。    \n\n###准备一个release版本    \n\n为了准备一个release版本, 执行:    \n\n    $ mvn release:clean    \n    $ mvn release:prepare\n[参考这个](http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html).这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.\n\n如果你要撤销release,可以使用`git reset --hard HEAD~2`进行[回退](http://stackoverflow.com/a/6866485/150884),使用`git tag -d ut-maven-plugin-0.1`[删除Tag](http://nathanhoad.net/how-to-delete-a-remote-git-tag),然后使用`git push origin :refs/tags/ut-maven-plugin-0.1`提交.\n\n###发布到Sonatype\n\n1.如果一切OK，你就可以使用[mvn release:perform](http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html)来发布工程到Sonatype。  \n2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。   \n3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些[很好的指引](https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt). 你可以使用[Maven repository management plugin](http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html)来自动化这些步骤,尽管我自己还没有试过。     \n4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。\n\n参考文档<http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html>","slug":"2013-06-19-publishing-from-github-to-maven-central","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6b006xv8fyvlftxjid","content":"<p>除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。  </p>\n<p>下面介绍下如何做：   </p>\n<p>###准备工作</p>\n<p>1.添加source code management信息到pom.xml:</p>\n<pre><code>&lt;scm&gt;\n    &lt;connection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/connection&gt;\n    &lt;developerConnection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/developerConnection&gt;\n    &lt;url&gt;git@github.com:blueshen/ut-maven-plugin.git&lt;/url&gt;\n&lt;/scm&gt;\n</code></pre><p>2.创建GPG的密钥对并发布公钥。参看<a href=\"https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven\" target=\"_blank\" rel=\"external\">Sonatype documentation</a>的具体步骤.推荐使用Linux,Mac来发布。    </p>\n<blockquote>\n<p><code>gpg --gen-key</code> 创建key<br><code>gpg --list-keys</code> 查看所有的key<br><code>gpg --send-keys --keyserver pool.sks-keyservers.net yourkey</code>   发布你的key到服务器上</p>\n</blockquote>\n<p>3.确保你的工程POM符合<a href=\"https://docs.sonatype.org/display/Repository/Central+Sync+Requirements\" target=\"_blank\" rel=\"external\">要求</a><br>4.创建一个<a href=\"https://issues.sonatype.org/\" target=\"_blank\" rel=\"external\">Sonatype JIRA</a>账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。<br><a id=\"more\"></a></p>\n<p>###使用Maven来发布到Sonatype Nexus repository</p>\n<p>####pom.xml配置有2种方法：   </p>\n<p>1.添加maven-release-plugin到pom.xml:</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;arguments&gt;-Dgpg.passphrase=${gpg.passphrase}&lt;/arguments&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><p>添加Sonatype repositories:</p>\n<pre><code>&lt;distributionManagement&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;\n        &lt;name&gt;Sonatype Nexus snapshot repository&lt;/name&gt;\n        &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n    &lt;repository&gt;\n        &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;\n        &lt;name&gt;Sonatype Nexus release repository&lt;/name&gt;\n        &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/distributionManagement&gt;\n</code></pre><p>设置artifact signing:</p>\n<pre><code>&lt;profiles&gt;\n    &lt;profile&gt;\n        &lt;id&gt;release-sign-artifacts&lt;/id&gt;\n        &lt;activation&gt;\n            &lt;property&gt;\n                &lt;name&gt;performRelease&lt;/name&gt;\n                &lt;value&gt;true&lt;/value&gt;\n            &lt;/property&gt;\n        &lt;/activation&gt;\n        &lt;build&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;\n                    &lt;version&gt;1.4&lt;/version&gt;\n                    &lt;configuration&gt;\n                        &lt;passphrase&gt;${gpg.passphrase}&lt;/passphrase&gt;\n                    &lt;/configuration&gt;\n                    &lt;executions&gt;\n                        &lt;execution&gt;\n                            &lt;id&gt;sign-artifacts&lt;/id&gt;\n                            &lt;phase&gt;verify&lt;/phase&gt;\n                            &lt;goals&gt;\n                                &lt;goal&gt;sign&lt;/goal&gt;\n                            &lt;/goals&gt;\n                        &lt;/execution&gt;\n                    &lt;/executions&gt;\n                &lt;/plugin&gt;\n            &lt;/plugins&gt;\n        &lt;/build&gt;\n    &lt;/profile&gt;\n&lt;/profiles&gt;\n</code></pre><p>2.直接添加sonatype parent到POM.XML（推荐）</p>\n<pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.sonatype.oss&lt;/groupId&gt;\n    &lt;artifactId&gt;oss-parent&lt;/artifactId&gt;\n    &lt;version&gt;7&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre><p>####maven settings.xml配置<br>编辑或者创建~/.m2/settings.xml并包含验证信息:</p>\n<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0\n                      http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;\n    &lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;\n            &lt;username&gt;myusername&lt;/username&gt;\n            &lt;password&gt;mypassword&lt;/password&gt;\n        &lt;/server&gt;\n        &lt;server&gt;\n            &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;\n            &lt;username&gt;myusername&lt;/username&gt;\n            &lt;password&gt;mypassword&lt;/password&gt;\n        &lt;/server&gt;\n    &lt;/servers&gt;\n\n    &lt;profiles&gt;\n        &lt;profile&gt;\n            &lt;id&gt;sign&lt;/id&gt;\n            &lt;activation&gt;\n                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n            &lt;/activation&gt;\n            &lt;properties&gt;\n                &lt;gpg.passphrase&gt;mypassphrase&lt;/gpg.passphrase&gt;\n            &lt;/properties&gt;\n        &lt;/profile&gt;\n    &lt;/profiles&gt;\n&lt;/settings&gt;\n</code></pre><p>Maven有一个<a href=\"http://maven.apache.org/guides/mini/guide-encryption.html\" target=\"_blank\" rel=\"external\">避免使用明文的方法</a>,但我还没试用过。    </p>\n<p>###准备一个release版本    </p>\n<p>为了准备一个release版本, 执行:    </p>\n<pre><code>$ mvn release:clean    \n$ mvn release:prepare\n</code></pre><p><a href=\"http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html\" target=\"_blank\" rel=\"external\">参考这个</a>.这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.</p>\n<p>如果你要撤销release,可以使用<code>git reset --hard HEAD~2</code>进行<a href=\"http://stackoverflow.com/a/6866485/150884\" target=\"_blank\" rel=\"external\">回退</a>,使用<code>git tag -d ut-maven-plugin-0.1</code><a href=\"http://nathanhoad.net/how-to-delete-a-remote-git-tag\" target=\"_blank\" rel=\"external\">删除Tag</a>,然后使用<code>git push origin :refs/tags/ut-maven-plugin-0.1</code>提交.</p>\n<p>###发布到Sonatype</p>\n<p>1.如果一切OK，你就可以使用<a href=\"http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html\" target=\"_blank\" rel=\"external\">mvn release:perform</a>来发布工程到Sonatype。<br>2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。<br>3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些<a href=\"https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt\" target=\"_blank\" rel=\"external\">很好的指引</a>. 你可以使用<a href=\"http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html\" target=\"_blank\" rel=\"external\">Maven repository management plugin</a>来自动化这些步骤,尽管我自己还没有试过。<br>4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。</p>\n<p>参考文档<a href=\"http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html\" target=\"_blank\" rel=\"external\">http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html</a></p>\n","excerpt":"<p>除非你的项目是Apache或者Codehaus管理的，否则你是不可能直接把artifacts发布到Maven Central的。然而，Sonatype提供了它们的Nexus repositories,我们可以将开源项目提交上去，然后会自动同步到Maven Central。  </p>\n<p>下面介绍下如何做：   </p>\n<p>###准备工作</p>\n<p>1.添加source code management信息到pom.xml:</p>\n<pre><code>&lt;scm&gt;\n    &lt;connection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/connection&gt;\n    &lt;developerConnection&gt;scm:git:git@github.com:blueshen/ut-maven-plugin.git&lt;/developerConnection&gt;\n    &lt;url&gt;git@github.com:blueshen/ut-maven-plugin.git&lt;/url&gt;\n&lt;/scm&gt;\n</code></pre><p>2.创建GPG的密钥对并发布公钥。参看<a href=\"https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven\">Sonatype documentation</a>的具体步骤.推荐使用Linux,Mac来发布。    </p>\n<blockquote>\n<p><code>gpg --gen-key</code> 创建key<br><code>gpg --list-keys</code> 查看所有的key<br><code>gpg --send-keys --keyserver pool.sks-keyservers.net yourkey</code>   发布你的key到服务器上</p>\n</blockquote>\n<p>3.确保你的工程POM符合<a href=\"https://docs.sonatype.org/display/Repository/Central+Sync+Requirements\">要求</a><br>4.创建一个<a href=\"https://issues.sonatype.org/\">Sonatype JIRA</a>账户，并发布一个ticket来让Nexus repository建立。用户名，密码后面要用的。这中间牵涉到人工操作，会花费一些时间。<br>","more":"</p>\n<p>###使用Maven来发布到Sonatype Nexus repository</p>\n<p>####pom.xml配置有2种方法：   </p>\n<p>1.添加maven-release-plugin到pom.xml:</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;arguments&gt;-Dgpg.passphrase=${gpg.passphrase}&lt;/arguments&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><p>添加Sonatype repositories:</p>\n<pre><code>&lt;distributionManagement&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;\n        &lt;name&gt;Sonatype Nexus snapshot repository&lt;/name&gt;\n        &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n    &lt;repository&gt;\n        &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;\n        &lt;name&gt;Sonatype Nexus release repository&lt;/name&gt;\n        &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/distributionManagement&gt;\n</code></pre><p>设置artifact signing:</p>\n<pre><code>&lt;profiles&gt;\n    &lt;profile&gt;\n        &lt;id&gt;release-sign-artifacts&lt;/id&gt;\n        &lt;activation&gt;\n            &lt;property&gt;\n                &lt;name&gt;performRelease&lt;/name&gt;\n                &lt;value&gt;true&lt;/value&gt;\n            &lt;/property&gt;\n        &lt;/activation&gt;\n        &lt;build&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                    &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;\n                    &lt;version&gt;1.4&lt;/version&gt;\n                    &lt;configuration&gt;\n                        &lt;passphrase&gt;${gpg.passphrase}&lt;/passphrase&gt;\n                    &lt;/configuration&gt;\n                    &lt;executions&gt;\n                        &lt;execution&gt;\n                            &lt;id&gt;sign-artifacts&lt;/id&gt;\n                            &lt;phase&gt;verify&lt;/phase&gt;\n                            &lt;goals&gt;\n                                &lt;goal&gt;sign&lt;/goal&gt;\n                            &lt;/goals&gt;\n                        &lt;/execution&gt;\n                    &lt;/executions&gt;\n                &lt;/plugin&gt;\n            &lt;/plugins&gt;\n        &lt;/build&gt;\n    &lt;/profile&gt;\n&lt;/profiles&gt;\n</code></pre><p>2.直接添加sonatype parent到POM.XML（推荐）</p>\n<pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.sonatype.oss&lt;/groupId&gt;\n    &lt;artifactId&gt;oss-parent&lt;/artifactId&gt;\n    &lt;version&gt;7&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre><p>####maven settings.xml配置<br>编辑或者创建~/.m2/settings.xml并包含验证信息:</p>\n<pre><code>&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0\n                      http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;\n    &lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;\n            &lt;username&gt;myusername&lt;/username&gt;\n            &lt;password&gt;mypassword&lt;/password&gt;\n        &lt;/server&gt;\n        &lt;server&gt;\n            &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;\n            &lt;username&gt;myusername&lt;/username&gt;\n            &lt;password&gt;mypassword&lt;/password&gt;\n        &lt;/server&gt;\n    &lt;/servers&gt;\n\n    &lt;profiles&gt;\n        &lt;profile&gt;\n            &lt;id&gt;sign&lt;/id&gt;\n            &lt;activation&gt;\n                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n            &lt;/activation&gt;\n            &lt;properties&gt;\n                &lt;gpg.passphrase&gt;mypassphrase&lt;/gpg.passphrase&gt;\n            &lt;/properties&gt;\n        &lt;/profile&gt;\n    &lt;/profiles&gt;\n&lt;/settings&gt;\n</code></pre><p>Maven有一个<a href=\"http://maven.apache.org/guides/mini/guide-encryption.html\">避免使用明文的方法</a>,但我还没试用过。    </p>\n<p>###准备一个release版本    </p>\n<p>为了准备一个release版本, 执行:    </p>\n<pre><code>$ mvn release:clean    \n$ mvn release:prepare\n</code></pre><p><a href=\"http://maven.apache.org/plugins/maven-release-plugin/examples/prepare-release.html\">参考这个</a>.这里具体做了以下工作：如果你的工程的版本是0.1-SNAPSHOT. 准备一个发布版本会去掉-SNAPSHOT后缀，然后提交到github，并将这时的代码打一个tag。同时，更新本地项目到0.2-SNAPSHOT版本.</p>\n<p>如果你要撤销release,可以使用<code>git reset --hard HEAD~2</code>进行<a href=\"http://stackoverflow.com/a/6866485/150884\">回退</a>,使用<code>git tag -d ut-maven-plugin-0.1</code><a href=\"http://nathanhoad.net/how-to-delete-a-remote-git-tag\">删除Tag</a>,然后使用<code>git push origin :refs/tags/ut-maven-plugin-0.1</code>提交.</p>\n<p>###发布到Sonatype</p>\n<p>1.如果一切OK，你就可以使用<a href=\"http://maven.apache.org/plugins/maven-release-plugin/examples/perform-release.html\">mvn release:perform</a>来发布工程到Sonatype。<br>2.登录到Sonatype Nexus，在Staging Repositories找到你的artifacts。<br>3.点击close,关闭后，点击Release发布artifacts。Sonatype有一些<a href=\"https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide#SonatypeOSSMavenRepositoryUsageGuide-8.ReleaseIt\">很好的指引</a>. 你可以使用<a href=\"http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html\">Maven repository management plugin</a>来自动化这些步骤,尽管我自己还没有试过。<br>4.在你的JIRA ticket下添加一个评论，说你已经推了release版本。下次Sonatype同步的时候，就会将你的artifacts放到Maven Central了。以后再发布新版本的时候，就不用添加评论了，会自动同步的。</p>\n<p>参考文档<a href=\"http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html\">http://datumedge.blogspot.jp/2012/05/publishing-from-github-to-maven-central.html</a></p>"},{"layout":"post","title":"TestNG深入理解","date":"2013-06-05T12:10:00.000Z","comments":1,"_content":"###TestNG annotaion:\n- @DataProvider\n- @ExpectedExceptions\n- @Factory\n- @Test\n- @Parameters  \n\n---\n\n    <suite name=\"ParametersTest\">\n    　　<test name=\"Regression1\">\n    　　　　<classes>\n    　　　　　　<class name=\"com.example.ParameterSample\" />\n    　　　　　　<class name=\"com.example.ParameterTest\">\n    　　　　　　　　<mtehods>\n    　　　　　　　　　　<include name=\"database.*\" />\n    　　　　　　　　　　<exclude name=\"inProgress\" />\n    　　　　　　　　</methods>\n    　　　　　　</class>\n    　　　　</classes>\n    　　</test>    \n    　　<test name=\"Parameters\">\n    　　　　<packages>\n    　　　　　　<package name=\"test.parameters.Parameter*\" />\n    　　　　</packages>\n    　　</test>   \n    </suite>    \n    \n一个suite(套件) 由一个或多个测试组成。   \n一个test(测试) 由一个或多个类组成    \n一个class(类) 由一个或多个方法组成。   \n\n@BeforeSuite/@AfterSuite 在某个测试套件开始之前/在某个套件所有测试方法执行之后    \n@BeforeTest/@AfterTest 在某个测试开始之前/在某个测试所有测试方法执行之后     \n@BeforeClass/@AfterClass 在某个测试类开始之前/在某个类的所有测试方法执行之后     \n@BeforeMethod/@AfterMethod 在某个测试方法之前/在某个测试方法执行之后   \n@BeforeGroup/@AfterGroup 在某个组的所有测试方法之前/在某个组的所有测试方法执行之后\n<!--more-->\n\n####1、分组\n\n    @Test(groups = {\"fast\", \"unit\", \"database\"})\n    public void rowShouldBeInserted() {}\n    \n    java org.testng.TestNG -groups fast com.example.MyTest\n测试的一个目标就是确保代码按照预期的方式工作。这种测试要么在用户层面上进行，要么在编程层面上进行。这两种类型的测试分别是通过功能测试和单元测试来实现的。    \n\n针对失败而测试     \n\nJava提供了两种不同类型的异常：从java.lang.RuntimeException派生的运行时刻异常和从java.lang.Exception派生的被检查的异常。   \n\n抛出被检查的异常的经验法则：调用者可以为这个异常做什么吗？如果答案是肯定的，那么可能应该是用被检查的异常，否则，最好是选择运行时刻异常。   \n\n\n    @Test(expectedExceptions = {ReservationException.class, FlightCanceledException.class})\n    public void shouldThrowIfPlaneIsFull() \n    {\n    　　Plane plane = createPlane();\n    　　plane.bookAllSeats();\n    　　plane.bookPlane(createValidItinerary(), null);\n    }\n\n属性expectedExceptions是一组类，包含了这个测试方法中预期会抛出的异常列表。如果没有抛出异常，或抛出的异常不再该属性的类表中，那么TestNG就会认为这个测试方法失败了。\n\n单一职责：\n\n    public class BookingTest\n    {\n    　　private Plane plane;\n    \n    　　@BeforeMethod\n    　　public void init() { plane = createPlane(); }\n    \n    　　@Test(expectedException = PlaneFullException.class)\n    　　public void shouldThrowIfPlaneIsFull()\n    　　{\n    　　　　plane.bookAllseats();\n    　　　　plane.bookPlane(createValidItinerary(), null);\n    　　}\n    \n    　　@Test(expectedException = FlightCanceledException.class)\n    　　public void shouldThrowIfFlightIsCanceled()\n    　　{\n    　　　　cancelFlight(/* ... */);\n    　　　　plane.bookPlane(createValidItinerary(), null);\n    　　}\n    }\n    \n \ntestng-failed.xml\n\n当您执行包涵失败的测试套件时，TestNG会在输出目录(默认是test-output/)下自动生成一个名为testng-failded.xml的问他件。这个XML文件包含了原来的testng.xml中失败的方法所构成的子集。 \n\n    java org.testng.TestNG test.xml\n    java org.testng.TestNG test-output/testng-failed.xml\n \n\n####2、工厂\nTestNG让您可以选择自己将测试类实例化。这是通过@Factory annotation来实现的，他必须放在返回一个对象数组方法的顶部。所有这些对象都必须是包含TestNG annotation的类的实例。如果有@Factory annotation，那么这个循环会继续下去，知道TestNG拿到的都是没有@Factory annotation实例，或者@Factory方法都已被调用过的实例。\n\n    public class ExpectedAttributes\n    {\n    　　private Image image;\n    　　private int width;\n    　　private height;\n    　　private String path;\n    　　\n    　　@Test\n    　　public void testWidth() {}\n    \n    　　@Test\n    　　public void testHeight() {}\n    \n    　　public PictureTest(String path, int width, int height, int depth) throws IOException\n    　　{\n    　　　　File f = new File(path);\n    　　　　this.path = path;\n    　　　　this.image = ImageIO.read(f);\n    　　　　this.width = width;\n    　　　　this.height = height;\n    　　}\n    \n    　　private static String[] findImageFileNames() {}\n    \n    　　@Factory\n    　　public static Object[] create() throws IOException\n    　　{\n    　　　　List result = new ArrayList();\n    \n    　　　　String[] paths = findImageFileNames();\n    \n    　　　　for (String path : paths) {\n    　　　　　　ExpectedAttributes ea = findAttributes(path);\n    　　　　　　result.add(new PictureTest(path, ea.width, ea.height, ea.depth));\n    　　　　}\n    \n    　　　　return result.toArray();\n    　　}\n    \n    　　public class ExpectedAttributes \n    　　{\n    　　　　public int width;\n    　　　　public int height;\n    　　　　public int depth;\n    　　}\n    \n    　　private static ExpectedAttributes findExpectedAttributes(String path)\n    　　{\n    　　　　// ...... \n    　　}\n    }\n\n可以安全的在同一个类包含@Factory和@Test annotation，因为TestNG确保@Factory方法只被调用一次。\n\n\norg.testng.ITest接口\n\n    public interface ITest \n    {\n    public String getTestName(); \n    }\n当TestNG遇到实现了这个接口的测试类时，他会在生成各种报告中包含getTestName()方法返回的信息。\n\n\n    public class PictureTest implements ITest\n    {\n    　　public String getTestName() \n    　　{\n    　　　　return \"[Picture: \" + name + \"]\";\n    　　} \n    }\n\n \n数据驱动测试\n\n测试需要针对许多具有类似结构的数据来执行。    \n实际的测试逻辑是一样的，仅仅发生改变的是数据。   \n数据可以被一组不同的人修改。    \n\n参数测试方法    \n测试逻辑可以非常简单或不易改变，而提供給他的数据肯定会随着时间增长。    \n\n\nTestNG可以通过两种方式向测试方法传递参数：  \n\n- 利用testng.xml\n- 利用DataProviders\n\n1、利用testng.xml传递参数\n\n    <suite name=\"Parameters\">\n    　　<parameter name=\"xml-file\" value=\"accounts.xml\" />\n    　　<parameter name=\"hostname\" value=\"arkonis.example.com\" />\n    \n    　　<test name=\"ParameterTest\">\n    　　　　<parameter name=\"hostname\" value=\"terra.example.com\" />\n    　　　　...\n    　　</test>\n    　　...\n    </suite>\n在测试方法中指定参数\n\n    @Test(parameters = {\"xml-file\"})\n    public void validateFile(String xmlFile)\n    {\n    　　// xmlFile has the value \"accounts.xml\"\n    }\n\n如果犯下以下错误之一，TestNG将抛出一个异常：\n\n- 在testng.xml中指定了一个参数，但不能转换为对应方法参数的类型。\n- 声明了一个@Parameters annotation，但引用的参数名称在testng.xml中没有声明。\n\n \n\n2.利用@DataProvider传递参数   \n\n如果需要向测试方法传递的参数不是基本的Java类型，或者如果需要的值智能在运行时刻创建，那么我们应该考虑使用@DataProvider annotation。   \n\n数据提供者是用@Dataprovider标注的方法。这个annotation只有一个字符串属性：他的名称，如果没有提供名称，数据提供者的名称就默认采用方法的名称。   \n\n数据提供者同时实现两个目的：  \n\n向测试方法传递任意数目的参数   \n根据需要，允许利用不同的参数集合对他的测试方法进行多次调用。   \n\n    @Test(dataProvider = \"range-provider\")\n    public void testIsBetWeen(int n, int lower, int upper, boolean expected)\n    {\n    　　println(\"Received \" + n + \" \" + lower + \"-\" + upper + \" expected: \" + expected);\n    　　assert.assertEquals(expected, isBetween(n, lower, upper));\n    }\n    \n    @DataProvider(name = \"range-provider\")\n    public Object[][] rangeData()\n    {\n    　　int lower = 5;\n    　　int upper = 10;\n    \n    　　return new Object[][] {\n    　　　　{ lower-1, lower, upper, false},\n    　　　　{ lower, lower, upper, true},\n    　　　　{ lower+1, lower, upper, true},\n    　　　　{ upper, lower, upper, true},\n    　　　　{ upper+1, lower, upper, false},\n    　　};\n    }\n\n由于数据提供者是测试类中的一个方法，他可以属于一个超类，然后被一些测试方法复用。我们也可以有几个数据提供者，只要他们定义在测试类或者他的一个子类上。当我们像在合适的地方记录数据源，并在几个测试方法中复用他时，这种方法是很方边的。    \n\n针对数据提供者的参数     \n数据提供者本身可以接受两个类型的参数：Method和ITestContext      \n\n\n    @DataProvider\n    public void craete() { ... }\n    \n    @DataProvider\n    public void create(Method method) { ... }\n    \n    @DataProvider\n    public void create(ITestContext context) { ... }\n    \n    @DataProvider\n    public void create(Method method, ITestContext context) { ... }\n    \n\nMethod参数     \n如果数据提供者的第一个参数是java.lang.reflect.Method，TestNG传递这个将调用的测试方法。如果您希望数据提供者根据不同的测试方法返回不同的数据，那么这种做法就非常有用。    \n\n    @DataProvider\n    public Object[][] provideNumbers(Method method)\n    {\n    　　String methodName = method.getName();\n    \n    　　if (methodName.equals(\"tow\")) {\n    　　　　return new Object[][] { new Object[] {2} };\n    　　}\n    　　if (methodName.equals(\"three\")) {\n    　　　　return new Object[][] { new Object[] {3} };\n    　　}\n    }\n    \n    @Test(dataProvider = \"provideNumbers\")\n    public void two(int param)\n    {\n    　　System.out.println(\"Two received: \" + param); \n    }\n    \n    @Test(dataProvider = \"provideNumbers\")\n    public void three(int param)\n    {\n    　　System.out.println(\"Three received: \" + param);\n    }\n\n使用同一个数据提供者的地方：   \n\n数据提供者代码相当复杂，应该保存在一个地方，这样维护起来更方便。    \n我们要传入数据的那些测试方法具有许多参数，其中只有少数参数是不一样的。    \n我们引入了某个方法的特殊情况。      \n\nITestContext参数    \n如果一个数据提供者在方法签名中声名了一个ITestContext类型的参数，TestNG就会将当前的测试上下文设置给它，这使得数据提供者能够知道当前测试执行的运行时刻参数。     \n\n    @DataProvider\n    public Object[][] randomIntegers(ITestContext context)\n    {\n    　　String[] groups = context.getIncludeGroups();\n    \n    　　int size = 2;\n    　　for (String group : groups) {\n    　　　　if (group.equals(\"functional-test\")) {\n    　　　　　　size = 10; \n    　　　　　　break;\n    　　　　}\n    　　}\n    \n    　　Object[][] result = new Object[size][];\n    　　Random r = new Random();\n    　　for (int i = 0; i < size; i++) {\n    　　　　result[i] = new Object[] { new Integer(r.nextInt()) };\n    　　}\n    \n    　　return result;\n    }\n    \n    @Test(dataProvider = \"randomIntegers\", groups = {\"unit-test\", \"functional-test\"})\n    public void random(Integer n)\n    {\n    　　// ......\n    } \n\nITestContext对象中的数据是运行时刻的信息，不是静态的信息：这个测试方法即属于unit-test组，也属于functional-test组，但在运行时刻，我们决定只执行functional-test组，这个值由ITestContext#getIncludeGroups方法返回。    \n\n延迟数据提供者   \n\n为了实现这种方法，TestNG允许我们从数据提供者返回一个Iterator，而不是一个二维对象数组。    \n\n这种方法与数组不同之处在于，当TestNG需要从数据提供者取得下一组参数时，他会调用Iterator的next方法，这样就有机会在最后一刻实例化相应的对象，即刚好在需要这些参数的测试方法被调用之前。    \n\n    @DataProvider(name = \"generate-accounts-lazy\")\n    public Iterator generateAccountsLazy\n    {\n    　　return new AccountIterator();\n    }\n    \n    @Test(dataProvider = \"generate-accounts-lazy\")\n    public void testAccount(Account a)\n    {\n    　　System.out.println(\"Testing account \" + a);\n    }\n    \n    class AccountIterator implements Iterator\n    {\n    　　private static final int MAX = 4;\n    　　private int index = 0;\n    \n    　　public boolean hasNext()\n    　　{\n    　　　　return index < MAX;\n    　　}\n    \n    　　public Object next()\n    　　{\n    　　　　return new Object[] { new Account(index++); } \n    　　}\n    \n    　　public void remove()\n    　　{\n    　　　　throw new UnsupportedOperationException(); \n    　　}\n    }\n    \n如果传递的参数是简单类型的常数，利用testng.xml的方法是很好的。档我们需要更多灵活性，并知道参数的数目和值将随时间增加时，我们可能应该选择@DataProvider。  \n\n\n提供数据    \n数据的位置可能是：硬编码在Java源码中、再文本文件中、在属性文件中、在Excel表格中、在数据库中、在网络中...。   \n\n数据提供者还是工厂     \n数据提供者向测试方法传递参数，而工厂像构造方法传递参数。   \n\n不如不能确定使用哪种方法，那么就看看测试方法所使用的参数。是否有几个测试方法需要接收同样的参数？如果是这样，您可能最好是将这些参数保存在一个字段中，然后在几个方法中复用这个字段，这就意味着最好是选择工厂。反之，如果所有的测试方法都需要传入不同的参数，那么数据提供者可能是最好的选择。    \n\n \n\n异步测试    \n异步代码通常出现在下列领域：    \n\n- 基于消息的框架，其中发送者和接收者是解耦合的。(JMS)\n- 由java.util.concurrent提供的异步机制(FutureTask)\n- 由SWT或Swing这样的工具集开发的图形用户界面，其中代码与主要的图形部分运行在不同的线程中。\n \n\n测试异步代码比测试同步代码的问题更多：\n\n- 无法确定异步调用何时质性。\n- 无法确定异步调用是否会完成。\n \n\n当调用异步时有三种可能的结果：\n\n- 调用完成并成功。\n- 调用完成并失败。\n- 调用没有完成。\n基本上，异步编程遵循着一种非常简单的模式：在发出一个请求时指定一个对象或一个函数，当收到响应时系统会调用回调。\n\n测试异步代码也同样遵循下面的模式：     \n   \n发出异步调用，他会立即返回。如果可能，制定一个回调对象。     \n\n \n\n如果有回调方法：    \n\n等待结果，在接到结果是设置布尔变量，反应结果是否是您的预期。    \n\n在测试方法中，监视那个布尔变量，等到他被设置或过了一段时间。   \n\n如果没有回调方法：    \n\n在测试方法中，定期检查预期的值。如果过了一段时间还没有检查到预期值，就失败并退出。\n\n不指定回调方法    \n\n    private volatile boolean success = false;\n    \n    @BeforeClass\n    public void sendMessage()\n    {\n    　　// send the message;\n    　　// Successful completion should eventually set success to true;\n    }\n    \n    @Test(timeOut = 10000)\n    public void waitForAnswer()\n    {\n    　　while (!success) {\n    　　　　Thead.sleep(1000);\n    　　}\n    }\n\n在这个测试中，消息是作为测试初始化的一部分，利用@BeforeClass发出的，这保证了这段代码在测试方法调用之前执行并且只执行一次。在初始化后TestNG将调用waitForAswer测试方法，他将进行不完全忙等。   \n\n有回调方法：\n\n    @Test(groups = “send”)\n    public void sendMessage()\n    {\n    　　// send the message\n    }\n    \n    @Test(timeOut = 10000, dependsOnGroups = {“send”})\n    public void waitForAnswer()\n    {\n    　　while (!success) {\n    　　　　Thread.sleep(1000);\n    　　}\n    }\n\n现在sendMessage()是一个@Test方法，他将包含在最终的报告中，如果发送消息失败，TestNG将跳过waitForAnswer测试方法，并把他表示为SKIP。    \n\n    @Test(timeOut = 10000, invocationCount=100, successPercentage = 98)\n    public void waitForAnswer ……\nTestNG调用该方法100次，如果98%的调用成功，就认为总体测试通过。    \n\n测试多线程代码     \n并发测试     \n\n    private Singleton singleton;\n    \n    @Test(invocationCount = 100, threadPoolSize = 10)\n    public void testSingleton()\n    {\n    　　Thread.yield();\n    　　Singleton p = Singleton.getInstance();\n    }\n    \n    public static Singleton getInstance()\n    {\n    　　if (instance == null) {\n    　　　　Thread.yield();\n    　　　　Assert.assertNull(instance);\n    　　　　instance = new Singleton();\n    　　}\n    　　return instance;\n    }\n\n@invocationCount相当简单，在不考虑并发时也可以使用：他决定了TestNG调用一个测试方法的次数。    \n\n@threadPoolSize要求TestNG分配一定数量的线程，并使用这些线程来调用这个测试方法，当一个测试完成之后，执行他的线程将归还给线程池，然后可以用于下一次调用。   \n\n并发执行    \n    <suite name=”TestNG JDK 1.5” verbose=“1” parallel=“methods” thread-count = “2”>......</suite>\nthread-count属性指定了线程数目，TestNG将使用这些线程来执行这个测试套件中的所有测试方法，parallel属性告诉TestNG您在执行这些测试时希望采用的并行模式。    \n\nparallel=”methods” 在这种模式下，每个测试方法将在他自己的一个线程中执行。    \n\nparallel=”test” 在这种模式下，在某个<test>标签内的所有测试方法将在他们自己的一个线程中执行。   \n\n在tests模式中，TestNG保证每个<test>将在他自己的线程中执行。如果希望测试不安全的代码，这一点是非常重要的。在method模式中，所有限制都被取消，无法预测哪些方法将在同一个线程中执行，哪些方法将在不同的测试中执行。    \n\n为可模拟性设计    \n为了能够成功地使用模拟模拟对象或桩，重要得失要确保代码的设计能让使用模拟对象或桩变得简单而直接。   \n这种设计最重要的方面就是正确的确定组件之间的交互，从而确定组件的交互接口。    \n\n如果我们有2个组件A和B，A需要用到B，那么应该通过B的接口来完成，而不是通过B的具体实现。   \n\nSingleton查找    \n\n    public void doWork1()\n    {\n    　　C c = C.getInstance();\n    　　c.doSomething();\n    }\n对于某个对象智能由一个实例，这在项目生命周期的后期产生阻碍效果。   \n\nJNDI定位服务     \n\n    public void doWork2()\n    {\n    　　C c = (C) new InitialContext().lockup(\"C\");\n    　　c.Something();\n    }\n不能够向A提供一个受控制的B的实例。只有一个全局实例，A只能取得这个实例。     \n\n\n依赖注入    \n\n    private C c;\n    \n    public void setC(C c)\n    {\n    　　this.c = c; \n    }\n\n从外部通知A应该使用哪个B的实例。这让我们能够根据实际情况灵活地决定向A提供B的哪个实例。   \n\nEasyMock\n\n    import static org.easymock.EasyMock.*;\n    \n    public class EasyMockUserManagerTest\n    {\n    　　@Test\n    　　public void createUser()\n    　　{\n    　　　　UserManager manager = new UserManagerImpl();\n    　　　　UserDao dao = createMock(UserDao.class);\n    　　　　Mailer mailer = createMock(Mailer.class);\n    \n    　　　　manager.setDao(dao);\n    　　　　manager.setMailer(mailer);\n    \n    　　　　expect(dao.saveUser(\"tester\")).andReturn(true);\n    　　　　expect(mailer.sendMail(eq(\"tester\"), (String) notNull(), (String) notNull())).addReturn(true);\n    \n    　　　　replay(dao, mailer);\n    \n    　　　　manager.createUser(\"tester\");\n    　　　　verify(mailer, dao);\n    　　}\n    }\n    \n\n1创建模拟对象    \n这是通过createMock方法完成的，传入希望模拟的类作为参数。    \n\n2纪录预期行为    \n只要在模拟对象上调用我们预期会被调用的方法，就能纪录预期的行为。当用到某些具体的参数时，只要将这些参数传入就可以了。\n\n3调用主要被测对象    \n在主要的被测对象上调用一个方法或一组方法，预期这次调用将倒置被测对象调用模拟对象的那些预期的方法。    \n\n4验证预期行为   \n最后调用verify，检查所有的模拟对象。   \n\nJMock    \njMock是一个模拟库，她让我们通过编成的方式来之行约束条件。     \n\n\n选择正确的策略    \n\n缺少接口     \n有时候，我们面对的是庞大臃肿的遗留系统，没有向期望的那样有很好的设计。    \n大多数模拟库现在都允许替换类，而不仅是接口。这些库会在运行时刻生成一个新类，通过字节码操作来实现指定的契约。    \n\n复杂的类    \n如果我们得到了一些类，他们拥有20多个方法，与许多其他组件交互，而且随着是间的推移变得越来越复杂。    \n这种情况下，使用动态的模拟对象库效果会比较好，因为他们能够定义单个方法的行为，而不是考虑所有的方法。    \n\n契约纪录    \n使用模拟对象让我们记录更多的契约信息，而不止是方法签名。我们可以随时验证器乐的。    \n\n测试目标    \n根据经验法则，如果希望测试组件之间交互，模拟对象可能优于桩对象。模拟库能够以一种准确的方式来指定交互。而桩该作为被测试组件使用的那些次要的组件。在这种情况下，测试的目标是测试被测试组件本身，而不是他与其他组件之间的交互。   \n\n模拟易犯的错误    \n依赖模拟对象会导至许多问题，所以重要的是要知道使用模拟对象不利的一面：     \n\n- 模拟外部API行   \n- 虚假的安全感\n- 维护开销\n- 继承与复杂性\n\n依赖的测试   \n层叠失败：一个测试的失败导致一组测试的失败。   \n\n依赖的代码\n只要测时方法依赖于其他测试方法，就很难以隔离的方式执行这些测试方法。    \n彼此依赖的测试方法通常会出现这样的情况，因为他们共享了一些状态，而在测试之间共享状态是不好的。   \n\n\n利用TestNG进行依赖的测试     \nTestNG通过@Test annotation的两个属性(dependsOnGroups和dependsOnMethods)赖支持依赖的测试。    \n\n\n    @Test\n    public void launchServer() {}\n    \n    @Test(dependsOnMethods = \"launchServer\")\n    public void deploy() {}\n    \n    @Test(dependsOnMethods = \"deploy\")\n    public void test1() {}\n    \n    @Test(dependsOnMethods = \"deploy\")\n    public void test2() {}\n\n\ndependsOnMethods的问题:    \n通过字符串来执行方法名称，如果将来对他进行重构，代码就有可能失效。方法名称违反了\"不要重复自己\"的原则，方法名称即在Java方法中用到，也在字符串中使用，另外，等我们不断添加新的测试方法时，这个测试用例伸缩性也不好。    \n\n    @Test(groups = \"init\")\n    public void launchServer() {}\n    \n    @Test(dependsOnGroups = \"init\", groups = \"deploy-apps\")\n    public void deploy() {}\n    \n    @Test(dependsOnGroups = \"init\", groups = \"deploy-apps\")\n    public void deployAuthenticationServer() {}\n    \n    @Test(dependsOnGroups = \"deploy-apps\")\n    public void test1() {}\n    \n    @Test(dependsOnGroups = \"deploy-apps\")\n    public void test2() {}\n    \n利用组来指定依赖关系可以解决我们遇到的所有问题：   \n\n- 不在遇到重构问题，可以任意秀该方法的名称。\n- 不再违反DRY原则。\n- 当新方法须要加入到依赖关系中时，只要将他放到适当的组中，并确保他依赖于正确的组。\n\n依赖的测试和线程   \n当打算并行执行测试时，要记住，线程池中的一个或多个线程将用于依次执行每个方法。所以，如果打算在不同的线程中执行一些测试，过渡的使用依赖的测试将影像执行性能。    \n\n配置方法的失败    \n依赖测试方法和配置方法之间唯一的不同就是，测试方法隐式的依赖于配置方法。   \n\n虽然dependsOnMethods可以处理简单的测试或之由一个测试方法依赖于另一个测试方法的情况，但是在大多数情况下，您都应该使用dependsOnGroups，这种方式的伸缩性好，面对将来的重构也更为健壮。   \n\n既然我们提供了准去的依赖信息，那么TestNG就能够按照于骑的顺序来执行测试。    \n\n测试隔离并没有因此而受到影响。    \n\n如果出现层叠式的错误，依赖测试可以加快测试执行速读。    \n\n\n继承和annotation范围\n    \n    public class CreditCardTest\n    {\n    　　@Test(groups = \"web.credit-card\")\n    　　public void test1() {}\n    \n    　　@Test(groups = \"web.credit-card\")\n    　　public void test2() {}\n    }\n\n他违反了\"不要重复自己\"的原则     \n他为将来添加测试方法的开发者带来了负担。     \n\n    @Target({METHOD, TYPE, CONSTRUCTOR})\n    public @interface Test{}\n    \n    \n    @Test(groups = \"web.credit-card\")\n    public class CreditCardTest\n    {\n    　　public void test1() {}\n    　　public void test2() {}\n    }\n\nannotation继承     \n\n\n    @Test(groups = \"web.credit-card\")\n    class BaseWebTest {}\n    \n    public class WebTest extends BaseWebTest \n    {\n    　　public test1() {}\n    　　public test2() {}\n    }\n    \n\n所有扩展自BaseWebTest的类都会看到，他们所有的工有方法都自动成为web.credit-card组的成员。    \nWebTest变成了一个普通的传统Java对象(POJO),不带任何annotation。    \n\n集成易犯的错误    \n由于TestNG的测试方法必须是公有的，在基类中声明的方法会自动在子类中可见，所以他们永远也不需要作为测试类显式的列出(不要将测试基类列在testng.xml文件中)     \n\n测试分组\n分组解决了上面提到的局限性，实际上，他们进一步提升了TesgNG的一个设计目标：在静态模型(测试代码)和动态模型(执行哪些测试)之间实现清晰的分离。    \n\n语法\n@Test annotation和配置annotation(@BeforeClass, @AfterClass, @BeforeMethod...)都可以属于分组\n\n    @Test(groups = {\"group1\"})\n    @Test(groups = {\"group1\", \"group2\"})\n    @Test(groups = \"group1\")\n    \n    @Test(groups = \"group2\")\n    public class B\n    {\n    　　@Test\n    　　public test1() {}\n    \n    　　@Test(groups = \"group3\")\n    　　public test2() {}\n    }\n\ntest1属于group2组，test2同时属于group2组和group3组\n\n\n分组与运行时刻\n\n    <suite name=\"Simple suite\">\n    　　<test name=\"GroupTest\">\n    　　　　<groups>\n    　　　　　　<run>\n    　　　　　　　　<include name=\"group1\" />\n    　　　　　　</run>\n    　　　　</groups>\n    　　　　<classes>\n    　　　　　　<class name=\"com.example.A\" />\n    　　　　</classes>\n    　　</test>\n    </suite>\n这个testng.xml告诉TestNG执行com.example.A类中所有属于group1组的测试方法。    \n\n    <include name=\"database\" />\n    <exclude name=\"gui\" />\n\n如果某个方法即属于包含的组，又属于排除的组，那么排除的组优先。     \n如果既没有include，也没有exclude，那么TestNG将忽略组，执行所有的测试方法。   \n\n另一个功能就是可以在testng.xml中利用正则表达式来指定组。\n\n\n    <groups>\n    　　<define name=\"all-web\">\n    　　　　<include name=\"jsp\" />\n    　　　　<include name=\"servlet\" />\n    　　</define>\n    　　<run>\n    　　　　<include name=\"all-web\">\n    　　</run>\n    </groups>\n\n在设计组的层次关系时，能够在testng.xml中定义新组带来灵活性：    \n可以在代码中使用粒度非常小的分组，然后在运行时刻将这些小分组合并成大分组。     \n\n执行分组    \n利用命令行执行      \n\n    java org.testng.TestNG -groups jsp -groups servlet -excludegroups broken com.example.MytestClass\n\n利用ant     \n\n    <testng groups=\"jsp, servlet\" excludegroups=\"broken\">\n    　　<classfileset>\n    　　　　<include name=\"com/example/MyTestClass.class\" />\n    　　</classfileset>\n    </testng>\n\n利用Maven     \n\n    <dependencies>\n    　　<dependency>\n    　　　　<groupId>org.testng</groupId>\n    　　　　<artifactId>testng</artifactId>\n    　　　　<version>5.10</version>\n    　　　　<classifier>jdk15</classifier>\n    　　</dependency>\n    </dependencies>\n    \n    <build>\n    　　<plugins>\n    　　　　<plugin>\n    　　　　　　<groupId>org.apache.maven.plugins</groupId>\n    　　　　　　<artifactId>maven-surefire-plugin</artifactId>\n    　　　　　　<version>2.5</version>\n    \n    　　　　　　<configuration>\n    　　　　　　　　<suiteXmlFiles>\n    　　　　　　　　　　<suiteXmlFile>testng.xml</suiteXmlFile>\n    　　　　　　　　<suiteXmlFiles>\n    　　　　　　</configuration>\n    　　　　</plugin>\n    　　</plugins>\n    </build>\n\n\n利用Java API    \n\n    TestNG tng = new TestNG();\n    tng.setGroups(\"jsp, servlet\");\n    tng.setExcludeGroups(\"broken\")\n\n排除失败的测试    \n创建一个特书的组如broken\n\n    @Test(groups = { \"web\", \"broken\"})\n然后在运行时刻排除这个组。    \n\n    <exclude name=\"broken\" />\n    \n\n组分类    \n\n测试类型:单元测试、继承测试    \n测试规模:小规模、大规模    \n功能描述:数据库、界面    \n测试速度:慢测试、快测试    \n过程描述:冒烟测试、发布测试    \n \n让开发者能够指定方法的分组，主要的好处在于开发者因此能够很容易找出他们需要执行哪些测试。(如刚刚修改了数据库代码，可能只需要执行fast和database组测试)     \n\n组命名    \n\n    @Test(groups = {\"os.linux.debian\"})\n    @Test(groups = {\"database.table.ACCOUNTS\"})\n    @Test(groups = {\"database.ejb3.connection\"})\n    \nTestNG能够利用正则表达式来之定要执行的组，如果与这项功能配合使用，这种命名方式就很有用了。    \n\n    <groups>\n    　　<run>\n    　　　　<include name=\"database.*\" />\n    　　</run>\n    </groups>\n\n代码覆盖率     \n类的覆盖率：类覆盖描熟了项目中多少类已被测试套件访问。　   \n方法覆盖率：方法覆盖率是被访问的方法的百分比。   \n语句覆盖率：语句覆盖率追踪单条源代码语句的调用。   \n语句块覆盖率：语句快覆盖率将语句块作为基本的覆盖律单元。   \n分支覆盖率：分支覆盖率也被称为判断覆盖率。指标计算哪些代码分支被执行。    \n \n覆盖律工具    \nClover、EMMA和Cobertura    \n\n成功使用覆盖率的建议   \n覆盖率报告的信息何音的解读不同   \n覆盖率很难   \n百分比没有意义   \n为覆盖率而设计是错误得   \n有一点好过没有   \n覆盖律工具不会测试不存在的代码   \n覆盖率的历史讲述了自己的故事   \n \n企业级测试     \n单元测试：单元测试对系统中的一个单元进行独立的测试。    \n\n功能测试：功能测试关注一项功能。通常涉及不同组件之间的交互。    \n\n继承测试：继承测试是一种端到端的测试，他会执行整个应用栈，包括所有的外部依赖关系或系统。    \n\n一个具体的例子    \n系统中有一个相当典型的组件，他接收一条JMS消息，其中包含一段有效的XML文本。这段XML文本相当长，描述了一笔财务交易。这个组件的工作是读出这条消息，解析XML，根据消息的内容条填充一些数据库的表，然后调用一个存储过程来处理这些表。    \n\n测试内容     \n\n我们将创建一个成功测试。希望确保，如果收到一条有效的XML消息，我们会正确地处理他，并更新正确的数据表，然后存储过程的调用也成功。     \n我们将摹拟不同的场景。希望能够为测试替工不同的XML文本，这样就能够很容易地不断添加测试粒子数据。     \n我们提供明确的失败测试。失败的行为将被记录和测试，这样当组件内部出现失败时，他的状态就可以与测，并且很容易记录下来。    \n\n非测试内容    \n\n我们不测试JMS provider的功能。假定他是一个完全兼容的实现，已经正确的进行了配置，将成功地提交我们期望的消息。\n我们不执行捕捉所有错误得测试。失败测试应该针对明确的、可重现的失败场景。\n我们不测试API。例如，JDBC去冬的行为不是测试的主题。确保所有的测试都贯注业务功能，要避免对Java语言的语义进行测试。     \n \n测试成功场景    \n对于JMS API的接口    \n利用模拟对象(或桩)对象，创建TextMessage实现，用一个简单的POJO来表现，带有消息内容和其他属性的设置方法。\n重构该组件，解除业务功能与JMS API的耦合。    \n\n    public void onMessage(Message message)\n    {\n        TextMEssage tm = (TextMessage) message;\n        processDocument(tm.getText());\n    }\n    \n    public void processDocument(String xml)\n    {\n        // code previously in onMessage that updates DB\n    }\n    \n    @Test\n    public void componentUpdateDatabase() throws Exception {}\n    \n\n构件测试数据\n\n    @Test(dataProvider = \"\")\n    public void componentUpdateDatabase() throws Exception  {}\n    \n    @DataProvider(name = \"component-data-files\")\n    public Iterator<Object[]> loadXML() throws Exception {}\n\n我们的测试现在接受一个参数，不再需要自己考虑测试数据的来源，也不需要考虑如何加载测试数据。他要做的只是指定数据提供者。加载XML的实际工作现在代理给了一段独立的加载程序。    \n\n    @DataProvider(name = \"component-data-files\")\n    public Iterator<Object[]> loadXML() throws Exception\n    {\n        File[] f = new File(\"filepath\").listFiles();\n        final Iterator<File> files = Arrays.asList(f).iterator();\n    \n        return new Iterator<Object[]>() {\n            public boolean hasNext()\n            {\n                return files.hasNext();   \n            }\n    \n            public Object[] next()\n            {\n                return new Object[] { IOUtils.readFile(files.next()) };\n            }\n    \n            public void remove()\n            {\n                throw new UnsupportedOperationException(); \n            }\n        };\n    }\n\n当然，可以从数据提供者返回一个Object[]的数组，但是，这种方法意味着我们必需将所有的文件的数据都一次性加载到内存中，因为数组必须事先填充。    \n\n\n测试准备问题    \n\n幂等的测试是指，这个测试执行一次和执行多次的结果是一样的。如果某个东西是幂等的，那么说明他在多次调用时状态不会改变。    \n\n不仅需要测试是幂等的，而且测试的次序应该无关紧要。所以除了需要是是幂等的之外，测试不应该在状态或数据方面影像其他测试。   \n\n对于一些写操作，成功执行之后很容易会对再次执行产生影响，下面方法有助于我们对付这个问题：    \n\n嵌入式数据    \n    有一些基于Java的数据库引擎，在设计时专门考虑了嵌入式支持。这些数据库可以在测试过程中临时创建并进行初始化。他们开销很小，通常性能不错。   \n    不足之处在于，它们与应用程序实际执行的环境差别非常大。通常在数据库特征上存在巨大的诧异。   \n\n在测试准备时初始化数据    \n    测试数据库总加载一定数量的已知测试数据。其中包含希望操作的所有数据，以及组件所依赖的所有外部引用。   \n    不足之处在于，很难维护一个健壮的数据集，使他对测试有足够的意义。   \n\n事务回滚   \n    另一种方法就是利用Java API来防止数据写入到持久数据存储中。总的方法是开是一个事务，执行所有的写操作，验证一切正常，然后让事务回滚。    \n    不足之处在于，如果没有复杂的嵌套事务准备，就不能测试参与事务的代码或开始自己的事务的代码。   \n\n\n选择正确的策略   \n\n\n    private WrappedConnection wrappedConnection;    \n    \n    @BeforeMethod   \n    public void connection() throws SQLException\n    {\n        connection = DatabaseHelper.getConnection();\n        connection.setAutoCommit(false);\n        wrappedConnection = new WrappedConnection(connection);\n        wrappedConnection.setSuppressCommit(true);\n    }\n    \n    @AfterMethod\n    public void rollback() throws SQLException\n    {\n        wrappedConnection.rollback(); \n    }\n    \n    public class WrappedConnection implements Connection\n    {\n        private Connection connection;\n        private boolean suppressClose;\n        private boolean suppressCommit;\n    \n        public WrappedConnection(Connection connection)\n        {\n            this.connection = connection;    \n        }\n    \n        public void commit() throws SQLException\n        {\n            if (!suppressCommit)    \n                connection.commit();\n        }\n    \n        // ......\n    }\n    \n\n错误处理    \n\n\n\n    @Test(dataProvider = \"component-data-files\")\n    public void componentupdateDatabase(String xml) throws Exception\n    {\n        Component component = new Component();\n        try {\n            component.processDocument(xml);\n        }\n        catch (InvalidTradeException e) {\n            return;\n        }\n        // rest of test code\n    }\n\n这种方法在于，他们没能让我们区分失败是否是预期的。相反，我们应该能够区分预期的成功和预期的失败。这个测时目前在两种情况下会通过：要么遇到好的数据时会通过，要么遇到坏数据时会通过。在每种情况下，我们都不能确定会发生些什么。   \n\n一个测试不应该在两种或两种以上的情况下都通过。如果测试验证了不同的失败情况，这没问题，但如果测试在好数据和坏数据的情况下都通过，那就会导致一些微妙的错误，这类错误难以被发现。(因此我们定义了另一个目录和数据提供者来处理失败的情况)     \n\n    @Test(dataProvider = \"component-invalid-data-files\", expectedException = InvalidTradeException.class)\n    public void componentInvalidInput(String xml) throws Exception\n    {\n        Component component = new Component();\n        component.processDocument(xml);\n        // rest of test code\n    }\n逐渐出现的单元测试    \n单元测试不一定是在其它测试之前编写的，他们可以是功能测试驱动的。特别是对于大型项目或原有的代码来说，一开始就编写有用的单元测试可能很困难，因为在不了解全局的情况下，单元测试可能太琐碎或不太重要。相反，单元测试可以从有意义的继承测试中推导出来，因为调试开发功能测试和集成测试的过程揭示他们所需的单元测试。    \n\n对于例子来说我们需要将XML验证与数据库处理放到各自独立的方法中。这样就能对他们进行测试    \n\n    public void processDocument(String xml) throws InvalidDocumentException\n    {\n        Document doc = XMLHelper.parseDocument(xml);\n        validateDocument(doc);\n        // ......\n    }\n    \n    public void validateDocument(Document doc) throws InvalidDocumentException\n    {\n        // perform constraint checks that can't be captured by XML\n    }\n    \n这测重构的结果是我们得到了一个简单的单元测试。   \n\n不论测试编写的次序如何，功能测试和单元测试都是互不的。功能测试是更为水平化的测试，涉及许多不同的组件，执行代码的很多部分。相反，单元测试是更为垂直化的测试，他关注范围狭窄的主题，比功能测试要彻底得多。   \n\n竞争消费者模式    \n消费者的执行是并发的，所以我们必须在测试中进行某种程度的模拟，生产环境中的真实情况。在我们这样作了之后，也希望验证结果。不论哪个消费者先开始，也不论哪个消费者先结束，都没有关系。我们希望确定对于给定数量的消费者，我们将得道一组已知的结果，可以进行验证。   \n\n    private final List<Object[]> data = Collections.synchronizedList(new ArrayList<Object[]>());\n    \n    @BeforeClass\n    public void populateData()\n    {\n        data.add(new Object[] {\"value1\", \"prop1\"});\n        data.add(new Object[] {\"value2\", \"prop2\"});\n        data.add(new Object[] {\"value3\", \"prop3\"});\n    }\n    \n    @Test(threadPoolSize = 3, invocationCount = 3, dataProvider = \"concurrent-processor\")\n    public void runConcurrentProcessors(String value, String someProp)\n    {    \n        MessageProcessor processor = new MessageProcessor();\n        processor.process(value, someProp);\n    }\n    \n    @Test(dependsOnMethods = \"runConcurrentProcessors\")\n    public void verifyConcurrentProcessors()\n    {\n        // load data from db\n        // verify that we have 3 results\n        // verify that each of the 3 result matches our 3 input\n    }\n    \n    @DataProvider(name = \"concurrent-processor\")\n    public Object[][] getProcessorData()\n    {\n        return new Object[][] {data.remove(data.size() - 1)};\n    }\n\n我们的测试被分成两个，一个负责执行消费者，另一个负责验证结果。原因是runConcurrentProcessors会被调用多次，而我们只需要在所有方法调用完成之后，对结果验证一次。为了表示这种次序，我们利用了dependsOnMethods这个annotation属性。   \n\n当TestNG发现一个数据提供者时，他将针对数据提供者返回的每一条数据调用一次测试。类似的，当我们指定调用次数时，TestNG会按照指定的次数调用测试。因此，如果我们返回数据提供者中准备好的3条数据，那么每个线程都会执行3次测试。    \n\n因此解决方案是使用一个栈结构，每次调用数据提供者时，返回一条数据，并将这条数据从列表中清除。数据提供者将被调用3次，每次都将为数据返回不一样的数据。    \n\n\n原则：将数据的考虑和功能的考虑分开来是很关键的。    \n在这个例子中，消费者需要的数据应该和实际的测试没有依赖关系。这种方法意味着，随着我们对数据的需求不断变化，变得更为复杂，测试本身却不需要被修改。    \n\n\n一个具体的例子   \n我们希望测试一个登录servlet。这个servlet接受一个请求，检查用户名和口令，如果他们有效，就在会话中加入一个标记。表明用户已登录。   \n\n这个例子展示了重构在测试方面起到的重要辅助作用，说明了即使对于看上去很麻烦、需要一很复杂地方是进行交互的API，页可以通过抽象去掉依赖关系。这种抽象意味着 在测试过程中，我们可以利用更简单的对象，这些对象更容易构造，因此也更容易测试。    \n\n增加可测试性的一个副作用就是改进了设计。为提高可测试性而进行重构，可以帮助我们以一种实际的、代码中的方式来确定职责和考虑，而这种效果通过画设计图是很难达到的。   \n\nJava EE测试    \n容器内测试与容器外测试的对比    \n\n容器内测试    \n优点：    \n    完全符合运行时环境   \n\n缺点：    \n    启动消耗大    \n    难以部署新的测试    \n    难以自动化    \n    夸平台测试的复杂性增加    \n\n容器外测试    \n优点：    \n    提供了相对较快的启动    \n    可以完全控制环境    \n    可以自动化    \n    容易测试    \n缺点：   \n    没有符合运行时环境   \n    测试所用的实现可能与运行时的实现来自不同的提供商。   \n\n\n容器内测试    \n测试步骤：   \n\n创建一个测试环境的实例。   \n确定测试。   \n在测试框架中注册测试。   \n注册一个监听者来接收搜测试结果。   \n \n\n创建测试环境    \n    \n    TestNG tester = new TestNG();\n    tester.setDeafultSuiteName(\"container-tests\");\n\n确定测试    \n假定所有的测试类都在WEB-INF/classes目录下，我们可以递归地读入这个目录，找到其中所有的类文件。    \n\n    public static Class[] scan(ServletContext context)\n    {\n        String root = context.getReadPath();\n        ClassScanner scanner = new ClassScanner(new File(root));\n        scanner.setClassLoader(ClassScanner.class.getClassLoader());\n        final File testDir = new File(root, \"com/foo/tests\");\n        scanner.setFilter(new FileFilter() {\n            public boolean accept(File pathname) {\n                return pathname.getPath().startsWith(testDir.getPath());\n            }    \n        });\n        Class[] classes = scanner.getClasses();\n        return classes;\n    }\n\ncontext是一个ServletContext实例，他是通过调用servlet或JSP页面得到的。   \n\n注册测试    \n注册测试类的动作告诉了TestNG他要查看的一组类，TestNG将在这组类中查找需要执行哪些测试。他将检查每个指定的类，确定他是否包涵测试方法或配置方法。当所有类都检查过后，TestNG内部会生成一个依赖关系图，以决定照到的这些测试的执行次序。    \n\n    tester.setTestClasses(classes);\n\n注册结果监听者    \n\nTestNG自代了3个默认的报告类：    \n\nSuiteHTMLRepoter 默认报告类，他在一个目录下输出交叉引用HTML文件，让您能看到某个具体测试的结果。   \n\nFailedReporter: 这个报高生成一个TestNG执行配置，该配置包含了所有前一次运行时失败的测试。他也是默认运行的。   \n\nEmailableReporter: 这个报告类生成一个报告文件，可以很容易地通过电子邮件发送，显示测试的结果。   \n\n\n默认情况下，EmailableReporter在磁盘上生成一个文件。    \n\n\n    public class SinglePageReporter extends EmailableReporter\n    {\n        private Writer writer;\n    \n        public SinglePageReporter()\n        {\n            this.writer = writer;\n        }\n    \n        protected PrintWriter createWriter(String out)\n        {\n            return new PrintWriter(writer);\n        }\n    }\n    \n\n调用TestNG的JSP页面    \n\n\n    <%@ page import=\"org.testng.*, java.io.*\" %>\n    <%\n        TestNG tester = new TestNG();\n        tester.setDefaultSuiteName(\"container-tests\");\n    \n        String root = application.getRealPath(\"/WEB-INF/classes\");\n        ClassScanner scanner = new ClassScanner(new File(root));\n        scanner.setLoader(getClass().getClassLoader());\n        scanner.setFilter(new FileFilter() {\n            public boolean accept(File pathname) {\n                return pathname.getPath().indexOf(Test) > -1;\n            }\n        });\n    \n        Class[] classes = scanner.getClasses();\n        tester.setTestClasses(classes);\n    \n        IReporter reporter = new SinglePageReporter(out);\n        tester.addListener(reporter);\n    \n        tester.run();\n    %>\n\nJava命名和目录接(JNDI)    \nJNDI是一个在全局目录中查找资源的API。可以把他看成是一个很大的树型结构，我们在其中按照名称查找某个节点。    \n\n    new InitialContext().lockup(\"someObject\");     \n上面创建一个InitialContext对象，如果在执行容器内执行，会利用供应商提供的API实现，来查找容器内部命名目录结构。创建了上下文之后，我们在其中查找对象，列出他的内容，或遍历这棵树。所有这些都是通过JNDI API来完成的。InitialContext的构造方法由一个重载的版本，接受一个Hashtable对象作为参数，其中包含不同的环境变量值，决定了上下文应该如何创建。    \n\n    Hashtable env = new Hashtable();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"\");\n    env.put(Context.PROVIDER_URL, \"smqp://localhost:4001\");\n    Object topic = new InitialContext(env).lookup(\"myTopic\");\n\n避免JNDI    \n组件依赖关系要么通过服务定位(通常是JNDI)来实现，要么通过注入来实现。如果您可以选择，就采用注入的方式，因为这样测试的开销最小，并且这种方式带来了更大的灵活性。   \n\nJava消息服务(JMS)   \n\n    private Session session;\n    private Destination destination;\n    \n    @BeforeClass(groups = \"jms\")\n    public void setupJMS() throws NamingException, JMSException\n    {\n        Hashtable env = new Hashtable();\n        // populate environmet for out specific provider\n        InitialContext context = new InitialContext(env);\n    \n        ConnectionFactory factory = (ConnectionFactory) context.lookup(\"QueueConnectionFactory\");\n        Connection connection = factory.createConnection();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = (Detination) context.lookup(\"TestQueue@router1\");\n    }\n    \n    \n    @Test(groups = \"jms\")\n    public void sendMessage() throws JMSException\n    {\n        TextMessage msg = session.createTextMessage();\n        msg.setText(\"hello!\");\n        msg.setStringProperty(\"test\", \"test1\");\n        session.createProducer(destination).send(msg);\n    }\n    \n    @Test(groups = \"jms\", dependsOnMethods = \"sendMessage\", timeOut = 1000)\n    public void receiveMessage() throws JMSException\n    {\n        MessageConsumer consumer = session.createConsumer(destination, \"test\", \"test1\");\n        TextMessage msg = (TextMessage) consumer.receive();\n        assert \"hello!\".equals(msg.getText());\n    }\n\n \n\n在测试中使用ActiveMQ   \n\n    @BeforeClass(groups = \"jms\")\n    public void setupActiveMQ() throws Exception\n    {\n        BrokerService broker = new BrokerService();\n        broker.setPersistent(false);\n        broker.setUseJmx(false);\n        broker.start();\n    \n        URI uri = broker.gettVmCnnectionURI();\n        ConnectionFactory factory = new ActiveMQConnectionFactory(uri);\n        Connection connection = factory.createConnection();\n        connection.start();\n    \n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"TestQueue@router1\");\n    }\n\n \n\n \n\n处理状态     \n在JMS的例子中，当我们拥有多个测试时，会引发一个有趣的问题。因为测试是由一对方法组成的，所以让我们假定同一个类中还有另一对发送/接收测试。    \n\n一种方法是将发送和接受者放在一个测试中，并在每个测试方法之前初始化消息代理。请注意两点都要做到，因为让消息代里在一对测试方法之前初始化是比较麻烦的。    \n\n另一种方法是使用消息分捡器。JMS消息分捡器让我们能够过滤接收到的消息，这样可以只接收与分捡器匹配的消息。   \n\nSpring   \nSpring的测试包功能     \n\nTestNG通过自己的一组针对Spring的类来解决这些问题，这些类作为扩展提供。org.testng.spring.test包中包含了所有Spring在其测试包中提供的类，这些类已修改过，可以用在基于TestNG的测试中。   \n\nAbstractSpringContextTests   \n这是所有Spring测试的基类。他的主要职责是提供上下文的管理。这个类包含一个静态map，其中包含所有注册的Spring上下文。   \n\nAbstractSingleSpringContextTests    \n这个类扩展了AbstractSpringContextTests，提供了装入一个ApplicationContext对象的钩子。他的子类应该实现getConfigLocation(String[] paths)方法。这个方法返回一个字符串数组，指出了Spring配置文件的位置，通常是从classpath加载的。    \n\n    \n    import org.testng.annotation.Test;\n    import org.testng.spring.test.AbstractSingleSpringContextTests;\n    \n    public class SpringContextTests extends AbstractSingleSpringContextTests\n    {\n        protected String[] getConfigLocations()\n        {\n            return new String[] {\"/spring.xml\"};    \n        }\n    \n        @Test\n        public void beanDefined()\n        {\n            assert applicationContext.getBean(\"myBean\") != null;\n        }\n    }\n\n\nSpring的配置方法被声明在名为Spring-init的TestNG分组中。我们不必依赖于单个的onSetUp或ontearDown方法，可以根据需要声明任意多个@BeforeMethod/@AfterMethod配置方法，只要指定他们依赖于spring-init，就可以确保他们在Spring执行完准备工作之后得到调用。    \n\n\nAbstractDependencyInjectionSpringContextTests   \n这个类提供的最有趣的功能就是向测试注入依赖。测试依赖关系可以表现为设值方法或成员字断。测试也可以指定Spring应该对他们的树性执行哪种类型的自动编织。    \n\n    public class SpringInjectionTests extends AbstractDependncyInjectionSpringContextTests\n    {\n        private PersonManager manager;\n    \n        protected String[] getConfigLocation()\n        {\n            return new String[] {\"/spring.xml\"};     \n        }\n        \n        public void setManager(PersonManager manager)\n        {\n            this.manager = manager; \n        }\n    \n        @Test\n        public void verifyManager()\n        {\n            assert manager != null;    \n        }\n    }\n\n这个类有一个事务管理器属性。因为他派生自支持注入的类，配置文件中必需指定一个PlatforTransactionManager，以便注入。     \n\n    public class StrpingTranscationTests extends AbstractTransactionalSpringContextTests\n    {\n        private PersonManager manager;\n    \n        public void setManager(PersonManager manager)\n        {\n            this.manager = manager\n        }\n    \n        protected String[] getConfigLocation()\n        {\n            return new String[] {\"/spring.xml\"};\n        }\n        \n        @Test\n        public void savePerson()\n        {\n            Person p = new Person();\n            manager.savePerson(p);\n    \n            assert p.getId() != null;\n            // setComplete();\n        }\n    }\n\n\n我们没有在测试中指定任何事务行为，超类自动处理了事务方面的问题，让每个测试在他自己的事务中执行，这个十五将在该测试完成之后回滚。    \n\n增加的调用setComplete通知超类在测试执行之后应该提交这个事务，而不是回滚。调用这个方法由一个有趣的副作用：这个类中所有后续测试都会提交事务，而不是依赖于默认行为。   \n\n答案在于JUnit和TestNG之间的一个微妙区别。Spring测试假定采用了JUnit的语义。每个测试类对每个测试方法都会重新实例化。因此，所有的测试都假定每个测试开始时，测试时里的状态都会复原，但TestNG不是这样的。   \n\nAbstractTransactionalDataSouceSpringContextTests    \n这个类添加了一些JDBC相关的便利方法。   \n\nAbstractAnnotationAwareTransactionalTests    \n这个类支持超类提供的所有功能之外，这个类允许我们在测试方法上指定Spring特有的事务annotation，而不是通过编程的方式来指定事务行为。    \n\nGuice   \n第2章中的例子，对于每个接口，我们都有两个实现。一个是实际的产品实现，他会与一些外部的依赖关系进行交互，如UserDAO对象会与数据库交互，Mailer对象会与SMTP邮件服务器交互。我们还有桩对象实现。    \n\n\n    @Test\n    public void verifyCreateUser()\n    {\n        UserManager manager = new UserManagerImpl();\n        MailerStub mailer = new MailerStub();\n    \n        manager.setMailer(mailer);\n        manager.setDao(new UserDAOStub());\n    \n        manager.createUser(\"tester\");\n        assert mailer.getMails().size() == 1;\n    }\n\n\nGuice注入测试    \n\n\n    @Inject private UserManager manager;\n    @Inject private MailerStub mailer;\n    \n    @Test\n    public void verifyCreateUser()\n    {\n        manager.createUser(\"tester\");    \n        assert mailer.getMails().size() == 1;\n    }\n\n \n\n \n\nSpring注入测试    \n\n\n    private UserManager manager;\n    private MailerStub mailer;\n    \n    public void verifyCreateUser()\n    {\n        manager.createUser(\"tester\");\n        assert mailer.getMails().size() == 1;\n    }\n    \n    public void setManager(UserManager manager)\n    {\n        this.manager = manager;\n    }\n    \n    public void setMailer(MailerStub mailer)\n    {\n        this.mailer = mailer;    \n    }\n\n\n对象工厂 \n\n杂谈   \n关注和提供异常    \n一层遇到了一个没有预料到的错误，不知道如何处理。所以这一层就快乐地向上一层抛出一个异常，希望这个可怜的异常最终会遇到知道怎么作的人。  \n\n\n吞掉抛出异常    \n\n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        throw new BackendException(\"Error in backed\");\n    }\n这种方法问题在于，实际上我们丢试了真实错误的有意义的信息。当我们最后有机会处理这个异常的时候，我们得到的信息仅仅是某一层中出了问题，但我们不知道是在这一曾本身出了问题，还是更低的层出了问题。    \n\n\n记日志并抛出    \n\n\n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        log.error(\"Error calling backend\", ex);\n        throw ex;\n    }\n\n问题在于调用栈经常发生的情况：信息隐藏。假定一个应用程序有三层或四层，每一层都在日志中记录他处里的异常，查遍8页的调用栈信息并不是最有效地方式。    \n\n\n嵌套抛出    \n    \n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        throw new BackendException(\"Error in backend\", ex);\n    }\n当这个调用栈显示的时候，没有丝毫暗示表明背后的原因是什么。您必须编写一个帮助方法，从外面的包装中取出背后实际的异常。   \n\n\n我们建议两种解决方案    \n\n避免需检察异常。运行时异常很合适这样的情况。   \n包装异常。假如您非常肯定在调用栈打印时，背后的原因会显示出来，那么包装的异常也很好。    \n \n\n有状态测试    \n有两种截然不同的状态分类：不可修改的状态和可修改的状态   \n\n不可修改的状态    \n访问共享的不可修改的状态的测试方法，相互之间是独立的。   \n因为这些方法都不能修改他们读到的状态，所以调用顺序可以是任意的，因此他们没有违反测试访法应该彼此肚里的原则。    \n\n可修改的状态    \n\n\n    public class MyTest extends TestCase\n    {\n        private int count = 0;\n    \n        public void test1()\n        {\n            count++;\n            assertEquals(1, count);\n        }\n    \n        public void test2()\n        {\n            count++;\n            assertEquals(2, count);\n        }\n    }\n\nJUnit会让这个测试通过，但TestNG不会。   \n只有当您知道测试方法被调用的顺序时，共享可修改的状态才有意义。   \n\n\n安全的共享数   \n安全          不可修改的状态    \n\n安全　　　可修改的状态与完全指定的依赖关系    \n\n不安全　　可修改的状态与不确定的依赖关系   \n\n\n测试驱动开发的缺点    \n他注重微观设计超过宏观测试    \n\n他在实践中难以应用   \n\nTDD注重微观设计超过宏观设计    \n\n测试驱动开发可以得到更健壮的软件，但他也可能导致不必要的反复和过度重构的趋势，这可能对饮的软件、设计和最后期限产生负面影响。   \n\nTDD难以应用    \n\n这种方式得到的代码本身并不会优先于传统方法测试的代码。    \n\n如何创建测试并不重要，重要的是确实要创建测试    \n\n测试私有方法   \n如果他有可能出问题，您就应该测试他。    \n\n测试私有方法的比较好的方法是提升方法的可见性，例如，让他变成保护可见，或者包可见。后者更好一些，因为您可以把测试和被测类放在同一个包中，然后您就可以访问他的所有字段。如果这些方法都不可取，我们测试私有方法的方式就是利用反射。   \n    public class LoginController\n    {\n        private String userName;\n    \n        private void init()\n        {\n            this.username = getUserNameFromCookie();\n        }\n    }\n    \n    @Test\n    public void verifyInit()\n    {\n        LoginController lc = new LoginController();\n    \n        Field f = lc.getClass().getField(\"username\");\n        Object valueBefore = f.get(lc);\n        Assert.assertNull(valueBefore);\n    \n        Method m = lc.getClass().getDeclaredMethod(\"init\", null);\n        m.setAccessible(true);\n        m.invock(lc);\n    \n        Object valueAfter = f.get(lc);\n        Assert.assertNotNull(vlaueAfter);\n    }\n\n\n我们利用字符串来描述Java元素。如果您对这些元素进行重命名，这种危险的实践肯定会失效。    \n\n我们利用了该类危险的私有信息。我们不仅假定存在一些私有方法和属性，而且也假定这个方法将以某种方式修改一个字段。    \n\n\n测试与封装    \n如果让代码更可测试，不要担心破坏封装。可测试星应该胜过封装。   \n\n让一个私有方法(或字段)成为包可见的、保护可见的或公有的。    \n \n去掉方法的final限定符。这让测试勒能够扩展这些类，或重写这些方法，模拟或稍微改变他们的实现，从而让系统的其它部分更可测试。    \n\n\n记日志的最佳实践    \n在出错时，输出错误或警告是合理的。但是对於警告的情况，重要的是确定这是不是该做的事情。我们添加的每一条无用的日志信息都会干扰有用的信息，所已精心选择是有意义的。   \n\n对于调试需求，记日志是有用的。但是，只要有一个开关能打开或关闭，绝大多数的记日志需求都能够满足了，不需要复杂的解决方案。   \n\n参考文档：<http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html>","source":"_posts/2013-06-05-deep-in-testng.markdown","raw":"---\nlayout: post\ntitle: \"TestNG深入理解\"\ndate: 2013-06-05 20:10\ncomments: true\ncategories: testng\ntags: [ testng ]\n---\n###TestNG annotaion:\n- @DataProvider\n- @ExpectedExceptions\n- @Factory\n- @Test\n- @Parameters  \n\n---\n\n    <suite name=\"ParametersTest\">\n    　　<test name=\"Regression1\">\n    　　　　<classes>\n    　　　　　　<class name=\"com.example.ParameterSample\" />\n    　　　　　　<class name=\"com.example.ParameterTest\">\n    　　　　　　　　<mtehods>\n    　　　　　　　　　　<include name=\"database.*\" />\n    　　　　　　　　　　<exclude name=\"inProgress\" />\n    　　　　　　　　</methods>\n    　　　　　　</class>\n    　　　　</classes>\n    　　</test>    \n    　　<test name=\"Parameters\">\n    　　　　<packages>\n    　　　　　　<package name=\"test.parameters.Parameter*\" />\n    　　　　</packages>\n    　　</test>   \n    </suite>    \n    \n一个suite(套件) 由一个或多个测试组成。   \n一个test(测试) 由一个或多个类组成    \n一个class(类) 由一个或多个方法组成。   \n\n@BeforeSuite/@AfterSuite 在某个测试套件开始之前/在某个套件所有测试方法执行之后    \n@BeforeTest/@AfterTest 在某个测试开始之前/在某个测试所有测试方法执行之后     \n@BeforeClass/@AfterClass 在某个测试类开始之前/在某个类的所有测试方法执行之后     \n@BeforeMethod/@AfterMethod 在某个测试方法之前/在某个测试方法执行之后   \n@BeforeGroup/@AfterGroup 在某个组的所有测试方法之前/在某个组的所有测试方法执行之后\n<!--more-->\n\n####1、分组\n\n    @Test(groups = {\"fast\", \"unit\", \"database\"})\n    public void rowShouldBeInserted() {}\n    \n    java org.testng.TestNG -groups fast com.example.MyTest\n测试的一个目标就是确保代码按照预期的方式工作。这种测试要么在用户层面上进行，要么在编程层面上进行。这两种类型的测试分别是通过功能测试和单元测试来实现的。    \n\n针对失败而测试     \n\nJava提供了两种不同类型的异常：从java.lang.RuntimeException派生的运行时刻异常和从java.lang.Exception派生的被检查的异常。   \n\n抛出被检查的异常的经验法则：调用者可以为这个异常做什么吗？如果答案是肯定的，那么可能应该是用被检查的异常，否则，最好是选择运行时刻异常。   \n\n\n    @Test(expectedExceptions = {ReservationException.class, FlightCanceledException.class})\n    public void shouldThrowIfPlaneIsFull() \n    {\n    　　Plane plane = createPlane();\n    　　plane.bookAllSeats();\n    　　plane.bookPlane(createValidItinerary(), null);\n    }\n\n属性expectedExceptions是一组类，包含了这个测试方法中预期会抛出的异常列表。如果没有抛出异常，或抛出的异常不再该属性的类表中，那么TestNG就会认为这个测试方法失败了。\n\n单一职责：\n\n    public class BookingTest\n    {\n    　　private Plane plane;\n    \n    　　@BeforeMethod\n    　　public void init() { plane = createPlane(); }\n    \n    　　@Test(expectedException = PlaneFullException.class)\n    　　public void shouldThrowIfPlaneIsFull()\n    　　{\n    　　　　plane.bookAllseats();\n    　　　　plane.bookPlane(createValidItinerary(), null);\n    　　}\n    \n    　　@Test(expectedException = FlightCanceledException.class)\n    　　public void shouldThrowIfFlightIsCanceled()\n    　　{\n    　　　　cancelFlight(/* ... */);\n    　　　　plane.bookPlane(createValidItinerary(), null);\n    　　}\n    }\n    \n \ntestng-failed.xml\n\n当您执行包涵失败的测试套件时，TestNG会在输出目录(默认是test-output/)下自动生成一个名为testng-failded.xml的问他件。这个XML文件包含了原来的testng.xml中失败的方法所构成的子集。 \n\n    java org.testng.TestNG test.xml\n    java org.testng.TestNG test-output/testng-failed.xml\n \n\n####2、工厂\nTestNG让您可以选择自己将测试类实例化。这是通过@Factory annotation来实现的，他必须放在返回一个对象数组方法的顶部。所有这些对象都必须是包含TestNG annotation的类的实例。如果有@Factory annotation，那么这个循环会继续下去，知道TestNG拿到的都是没有@Factory annotation实例，或者@Factory方法都已被调用过的实例。\n\n    public class ExpectedAttributes\n    {\n    　　private Image image;\n    　　private int width;\n    　　private height;\n    　　private String path;\n    　　\n    　　@Test\n    　　public void testWidth() {}\n    \n    　　@Test\n    　　public void testHeight() {}\n    \n    　　public PictureTest(String path, int width, int height, int depth) throws IOException\n    　　{\n    　　　　File f = new File(path);\n    　　　　this.path = path;\n    　　　　this.image = ImageIO.read(f);\n    　　　　this.width = width;\n    　　　　this.height = height;\n    　　}\n    \n    　　private static String[] findImageFileNames() {}\n    \n    　　@Factory\n    　　public static Object[] create() throws IOException\n    　　{\n    　　　　List result = new ArrayList();\n    \n    　　　　String[] paths = findImageFileNames();\n    \n    　　　　for (String path : paths) {\n    　　　　　　ExpectedAttributes ea = findAttributes(path);\n    　　　　　　result.add(new PictureTest(path, ea.width, ea.height, ea.depth));\n    　　　　}\n    \n    　　　　return result.toArray();\n    　　}\n    \n    　　public class ExpectedAttributes \n    　　{\n    　　　　public int width;\n    　　　　public int height;\n    　　　　public int depth;\n    　　}\n    \n    　　private static ExpectedAttributes findExpectedAttributes(String path)\n    　　{\n    　　　　// ...... \n    　　}\n    }\n\n可以安全的在同一个类包含@Factory和@Test annotation，因为TestNG确保@Factory方法只被调用一次。\n\n\norg.testng.ITest接口\n\n    public interface ITest \n    {\n    public String getTestName(); \n    }\n当TestNG遇到实现了这个接口的测试类时，他会在生成各种报告中包含getTestName()方法返回的信息。\n\n\n    public class PictureTest implements ITest\n    {\n    　　public String getTestName() \n    　　{\n    　　　　return \"[Picture: \" + name + \"]\";\n    　　} \n    }\n\n \n数据驱动测试\n\n测试需要针对许多具有类似结构的数据来执行。    \n实际的测试逻辑是一样的，仅仅发生改变的是数据。   \n数据可以被一组不同的人修改。    \n\n参数测试方法    \n测试逻辑可以非常简单或不易改变，而提供給他的数据肯定会随着时间增长。    \n\n\nTestNG可以通过两种方式向测试方法传递参数：  \n\n- 利用testng.xml\n- 利用DataProviders\n\n1、利用testng.xml传递参数\n\n    <suite name=\"Parameters\">\n    　　<parameter name=\"xml-file\" value=\"accounts.xml\" />\n    　　<parameter name=\"hostname\" value=\"arkonis.example.com\" />\n    \n    　　<test name=\"ParameterTest\">\n    　　　　<parameter name=\"hostname\" value=\"terra.example.com\" />\n    　　　　...\n    　　</test>\n    　　...\n    </suite>\n在测试方法中指定参数\n\n    @Test(parameters = {\"xml-file\"})\n    public void validateFile(String xmlFile)\n    {\n    　　// xmlFile has the value \"accounts.xml\"\n    }\n\n如果犯下以下错误之一，TestNG将抛出一个异常：\n\n- 在testng.xml中指定了一个参数，但不能转换为对应方法参数的类型。\n- 声明了一个@Parameters annotation，但引用的参数名称在testng.xml中没有声明。\n\n \n\n2.利用@DataProvider传递参数   \n\n如果需要向测试方法传递的参数不是基本的Java类型，或者如果需要的值智能在运行时刻创建，那么我们应该考虑使用@DataProvider annotation。   \n\n数据提供者是用@Dataprovider标注的方法。这个annotation只有一个字符串属性：他的名称，如果没有提供名称，数据提供者的名称就默认采用方法的名称。   \n\n数据提供者同时实现两个目的：  \n\n向测试方法传递任意数目的参数   \n根据需要，允许利用不同的参数集合对他的测试方法进行多次调用。   \n\n    @Test(dataProvider = \"range-provider\")\n    public void testIsBetWeen(int n, int lower, int upper, boolean expected)\n    {\n    　　println(\"Received \" + n + \" \" + lower + \"-\" + upper + \" expected: \" + expected);\n    　　assert.assertEquals(expected, isBetween(n, lower, upper));\n    }\n    \n    @DataProvider(name = \"range-provider\")\n    public Object[][] rangeData()\n    {\n    　　int lower = 5;\n    　　int upper = 10;\n    \n    　　return new Object[][] {\n    　　　　{ lower-1, lower, upper, false},\n    　　　　{ lower, lower, upper, true},\n    　　　　{ lower+1, lower, upper, true},\n    　　　　{ upper, lower, upper, true},\n    　　　　{ upper+1, lower, upper, false},\n    　　};\n    }\n\n由于数据提供者是测试类中的一个方法，他可以属于一个超类，然后被一些测试方法复用。我们也可以有几个数据提供者，只要他们定义在测试类或者他的一个子类上。当我们像在合适的地方记录数据源，并在几个测试方法中复用他时，这种方法是很方边的。    \n\n针对数据提供者的参数     \n数据提供者本身可以接受两个类型的参数：Method和ITestContext      \n\n\n    @DataProvider\n    public void craete() { ... }\n    \n    @DataProvider\n    public void create(Method method) { ... }\n    \n    @DataProvider\n    public void create(ITestContext context) { ... }\n    \n    @DataProvider\n    public void create(Method method, ITestContext context) { ... }\n    \n\nMethod参数     \n如果数据提供者的第一个参数是java.lang.reflect.Method，TestNG传递这个将调用的测试方法。如果您希望数据提供者根据不同的测试方法返回不同的数据，那么这种做法就非常有用。    \n\n    @DataProvider\n    public Object[][] provideNumbers(Method method)\n    {\n    　　String methodName = method.getName();\n    \n    　　if (methodName.equals(\"tow\")) {\n    　　　　return new Object[][] { new Object[] {2} };\n    　　}\n    　　if (methodName.equals(\"three\")) {\n    　　　　return new Object[][] { new Object[] {3} };\n    　　}\n    }\n    \n    @Test(dataProvider = \"provideNumbers\")\n    public void two(int param)\n    {\n    　　System.out.println(\"Two received: \" + param); \n    }\n    \n    @Test(dataProvider = \"provideNumbers\")\n    public void three(int param)\n    {\n    　　System.out.println(\"Three received: \" + param);\n    }\n\n使用同一个数据提供者的地方：   \n\n数据提供者代码相当复杂，应该保存在一个地方，这样维护起来更方便。    \n我们要传入数据的那些测试方法具有许多参数，其中只有少数参数是不一样的。    \n我们引入了某个方法的特殊情况。      \n\nITestContext参数    \n如果一个数据提供者在方法签名中声名了一个ITestContext类型的参数，TestNG就会将当前的测试上下文设置给它，这使得数据提供者能够知道当前测试执行的运行时刻参数。     \n\n    @DataProvider\n    public Object[][] randomIntegers(ITestContext context)\n    {\n    　　String[] groups = context.getIncludeGroups();\n    \n    　　int size = 2;\n    　　for (String group : groups) {\n    　　　　if (group.equals(\"functional-test\")) {\n    　　　　　　size = 10; \n    　　　　　　break;\n    　　　　}\n    　　}\n    \n    　　Object[][] result = new Object[size][];\n    　　Random r = new Random();\n    　　for (int i = 0; i < size; i++) {\n    　　　　result[i] = new Object[] { new Integer(r.nextInt()) };\n    　　}\n    \n    　　return result;\n    }\n    \n    @Test(dataProvider = \"randomIntegers\", groups = {\"unit-test\", \"functional-test\"})\n    public void random(Integer n)\n    {\n    　　// ......\n    } \n\nITestContext对象中的数据是运行时刻的信息，不是静态的信息：这个测试方法即属于unit-test组，也属于functional-test组，但在运行时刻，我们决定只执行functional-test组，这个值由ITestContext#getIncludeGroups方法返回。    \n\n延迟数据提供者   \n\n为了实现这种方法，TestNG允许我们从数据提供者返回一个Iterator，而不是一个二维对象数组。    \n\n这种方法与数组不同之处在于，当TestNG需要从数据提供者取得下一组参数时，他会调用Iterator的next方法，这样就有机会在最后一刻实例化相应的对象，即刚好在需要这些参数的测试方法被调用之前。    \n\n    @DataProvider(name = \"generate-accounts-lazy\")\n    public Iterator generateAccountsLazy\n    {\n    　　return new AccountIterator();\n    }\n    \n    @Test(dataProvider = \"generate-accounts-lazy\")\n    public void testAccount(Account a)\n    {\n    　　System.out.println(\"Testing account \" + a);\n    }\n    \n    class AccountIterator implements Iterator\n    {\n    　　private static final int MAX = 4;\n    　　private int index = 0;\n    \n    　　public boolean hasNext()\n    　　{\n    　　　　return index < MAX;\n    　　}\n    \n    　　public Object next()\n    　　{\n    　　　　return new Object[] { new Account(index++); } \n    　　}\n    \n    　　public void remove()\n    　　{\n    　　　　throw new UnsupportedOperationException(); \n    　　}\n    }\n    \n如果传递的参数是简单类型的常数，利用testng.xml的方法是很好的。档我们需要更多灵活性，并知道参数的数目和值将随时间增加时，我们可能应该选择@DataProvider。  \n\n\n提供数据    \n数据的位置可能是：硬编码在Java源码中、再文本文件中、在属性文件中、在Excel表格中、在数据库中、在网络中...。   \n\n数据提供者还是工厂     \n数据提供者向测试方法传递参数，而工厂像构造方法传递参数。   \n\n不如不能确定使用哪种方法，那么就看看测试方法所使用的参数。是否有几个测试方法需要接收同样的参数？如果是这样，您可能最好是将这些参数保存在一个字段中，然后在几个方法中复用这个字段，这就意味着最好是选择工厂。反之，如果所有的测试方法都需要传入不同的参数，那么数据提供者可能是最好的选择。    \n\n \n\n异步测试    \n异步代码通常出现在下列领域：    \n\n- 基于消息的框架，其中发送者和接收者是解耦合的。(JMS)\n- 由java.util.concurrent提供的异步机制(FutureTask)\n- 由SWT或Swing这样的工具集开发的图形用户界面，其中代码与主要的图形部分运行在不同的线程中。\n \n\n测试异步代码比测试同步代码的问题更多：\n\n- 无法确定异步调用何时质性。\n- 无法确定异步调用是否会完成。\n \n\n当调用异步时有三种可能的结果：\n\n- 调用完成并成功。\n- 调用完成并失败。\n- 调用没有完成。\n基本上，异步编程遵循着一种非常简单的模式：在发出一个请求时指定一个对象或一个函数，当收到响应时系统会调用回调。\n\n测试异步代码也同样遵循下面的模式：     \n   \n发出异步调用，他会立即返回。如果可能，制定一个回调对象。     \n\n \n\n如果有回调方法：    \n\n等待结果，在接到结果是设置布尔变量，反应结果是否是您的预期。    \n\n在测试方法中，监视那个布尔变量，等到他被设置或过了一段时间。   \n\n如果没有回调方法：    \n\n在测试方法中，定期检查预期的值。如果过了一段时间还没有检查到预期值，就失败并退出。\n\n不指定回调方法    \n\n    private volatile boolean success = false;\n    \n    @BeforeClass\n    public void sendMessage()\n    {\n    　　// send the message;\n    　　// Successful completion should eventually set success to true;\n    }\n    \n    @Test(timeOut = 10000)\n    public void waitForAnswer()\n    {\n    　　while (!success) {\n    　　　　Thead.sleep(1000);\n    　　}\n    }\n\n在这个测试中，消息是作为测试初始化的一部分，利用@BeforeClass发出的，这保证了这段代码在测试方法调用之前执行并且只执行一次。在初始化后TestNG将调用waitForAswer测试方法，他将进行不完全忙等。   \n\n有回调方法：\n\n    @Test(groups = “send”)\n    public void sendMessage()\n    {\n    　　// send the message\n    }\n    \n    @Test(timeOut = 10000, dependsOnGroups = {“send”})\n    public void waitForAnswer()\n    {\n    　　while (!success) {\n    　　　　Thread.sleep(1000);\n    　　}\n    }\n\n现在sendMessage()是一个@Test方法，他将包含在最终的报告中，如果发送消息失败，TestNG将跳过waitForAnswer测试方法，并把他表示为SKIP。    \n\n    @Test(timeOut = 10000, invocationCount=100, successPercentage = 98)\n    public void waitForAnswer ……\nTestNG调用该方法100次，如果98%的调用成功，就认为总体测试通过。    \n\n测试多线程代码     \n并发测试     \n\n    private Singleton singleton;\n    \n    @Test(invocationCount = 100, threadPoolSize = 10)\n    public void testSingleton()\n    {\n    　　Thread.yield();\n    　　Singleton p = Singleton.getInstance();\n    }\n    \n    public static Singleton getInstance()\n    {\n    　　if (instance == null) {\n    　　　　Thread.yield();\n    　　　　Assert.assertNull(instance);\n    　　　　instance = new Singleton();\n    　　}\n    　　return instance;\n    }\n\n@invocationCount相当简单，在不考虑并发时也可以使用：他决定了TestNG调用一个测试方法的次数。    \n\n@threadPoolSize要求TestNG分配一定数量的线程，并使用这些线程来调用这个测试方法，当一个测试完成之后，执行他的线程将归还给线程池，然后可以用于下一次调用。   \n\n并发执行    \n    <suite name=”TestNG JDK 1.5” verbose=“1” parallel=“methods” thread-count = “2”>......</suite>\nthread-count属性指定了线程数目，TestNG将使用这些线程来执行这个测试套件中的所有测试方法，parallel属性告诉TestNG您在执行这些测试时希望采用的并行模式。    \n\nparallel=”methods” 在这种模式下，每个测试方法将在他自己的一个线程中执行。    \n\nparallel=”test” 在这种模式下，在某个<test>标签内的所有测试方法将在他们自己的一个线程中执行。   \n\n在tests模式中，TestNG保证每个<test>将在他自己的线程中执行。如果希望测试不安全的代码，这一点是非常重要的。在method模式中，所有限制都被取消，无法预测哪些方法将在同一个线程中执行，哪些方法将在不同的测试中执行。    \n\n为可模拟性设计    \n为了能够成功地使用模拟模拟对象或桩，重要得失要确保代码的设计能让使用模拟对象或桩变得简单而直接。   \n这种设计最重要的方面就是正确的确定组件之间的交互，从而确定组件的交互接口。    \n\n如果我们有2个组件A和B，A需要用到B，那么应该通过B的接口来完成，而不是通过B的具体实现。   \n\nSingleton查找    \n\n    public void doWork1()\n    {\n    　　C c = C.getInstance();\n    　　c.doSomething();\n    }\n对于某个对象智能由一个实例，这在项目生命周期的后期产生阻碍效果。   \n\nJNDI定位服务     \n\n    public void doWork2()\n    {\n    　　C c = (C) new InitialContext().lockup(\"C\");\n    　　c.Something();\n    }\n不能够向A提供一个受控制的B的实例。只有一个全局实例，A只能取得这个实例。     \n\n\n依赖注入    \n\n    private C c;\n    \n    public void setC(C c)\n    {\n    　　this.c = c; \n    }\n\n从外部通知A应该使用哪个B的实例。这让我们能够根据实际情况灵活地决定向A提供B的哪个实例。   \n\nEasyMock\n\n    import static org.easymock.EasyMock.*;\n    \n    public class EasyMockUserManagerTest\n    {\n    　　@Test\n    　　public void createUser()\n    　　{\n    　　　　UserManager manager = new UserManagerImpl();\n    　　　　UserDao dao = createMock(UserDao.class);\n    　　　　Mailer mailer = createMock(Mailer.class);\n    \n    　　　　manager.setDao(dao);\n    　　　　manager.setMailer(mailer);\n    \n    　　　　expect(dao.saveUser(\"tester\")).andReturn(true);\n    　　　　expect(mailer.sendMail(eq(\"tester\"), (String) notNull(), (String) notNull())).addReturn(true);\n    \n    　　　　replay(dao, mailer);\n    \n    　　　　manager.createUser(\"tester\");\n    　　　　verify(mailer, dao);\n    　　}\n    }\n    \n\n1创建模拟对象    \n这是通过createMock方法完成的，传入希望模拟的类作为参数。    \n\n2纪录预期行为    \n只要在模拟对象上调用我们预期会被调用的方法，就能纪录预期的行为。当用到某些具体的参数时，只要将这些参数传入就可以了。\n\n3调用主要被测对象    \n在主要的被测对象上调用一个方法或一组方法，预期这次调用将倒置被测对象调用模拟对象的那些预期的方法。    \n\n4验证预期行为   \n最后调用verify，检查所有的模拟对象。   \n\nJMock    \njMock是一个模拟库，她让我们通过编成的方式来之行约束条件。     \n\n\n选择正确的策略    \n\n缺少接口     \n有时候，我们面对的是庞大臃肿的遗留系统，没有向期望的那样有很好的设计。    \n大多数模拟库现在都允许替换类，而不仅是接口。这些库会在运行时刻生成一个新类，通过字节码操作来实现指定的契约。    \n\n复杂的类    \n如果我们得到了一些类，他们拥有20多个方法，与许多其他组件交互，而且随着是间的推移变得越来越复杂。    \n这种情况下，使用动态的模拟对象库效果会比较好，因为他们能够定义单个方法的行为，而不是考虑所有的方法。    \n\n契约纪录    \n使用模拟对象让我们记录更多的契约信息，而不止是方法签名。我们可以随时验证器乐的。    \n\n测试目标    \n根据经验法则，如果希望测试组件之间交互，模拟对象可能优于桩对象。模拟库能够以一种准确的方式来指定交互。而桩该作为被测试组件使用的那些次要的组件。在这种情况下，测试的目标是测试被测试组件本身，而不是他与其他组件之间的交互。   \n\n模拟易犯的错误    \n依赖模拟对象会导至许多问题，所以重要的是要知道使用模拟对象不利的一面：     \n\n- 模拟外部API行   \n- 虚假的安全感\n- 维护开销\n- 继承与复杂性\n\n依赖的测试   \n层叠失败：一个测试的失败导致一组测试的失败。   \n\n依赖的代码\n只要测时方法依赖于其他测试方法，就很难以隔离的方式执行这些测试方法。    \n彼此依赖的测试方法通常会出现这样的情况，因为他们共享了一些状态，而在测试之间共享状态是不好的。   \n\n\n利用TestNG进行依赖的测试     \nTestNG通过@Test annotation的两个属性(dependsOnGroups和dependsOnMethods)赖支持依赖的测试。    \n\n\n    @Test\n    public void launchServer() {}\n    \n    @Test(dependsOnMethods = \"launchServer\")\n    public void deploy() {}\n    \n    @Test(dependsOnMethods = \"deploy\")\n    public void test1() {}\n    \n    @Test(dependsOnMethods = \"deploy\")\n    public void test2() {}\n\n\ndependsOnMethods的问题:    \n通过字符串来执行方法名称，如果将来对他进行重构，代码就有可能失效。方法名称违反了\"不要重复自己\"的原则，方法名称即在Java方法中用到，也在字符串中使用，另外，等我们不断添加新的测试方法时，这个测试用例伸缩性也不好。    \n\n    @Test(groups = \"init\")\n    public void launchServer() {}\n    \n    @Test(dependsOnGroups = \"init\", groups = \"deploy-apps\")\n    public void deploy() {}\n    \n    @Test(dependsOnGroups = \"init\", groups = \"deploy-apps\")\n    public void deployAuthenticationServer() {}\n    \n    @Test(dependsOnGroups = \"deploy-apps\")\n    public void test1() {}\n    \n    @Test(dependsOnGroups = \"deploy-apps\")\n    public void test2() {}\n    \n利用组来指定依赖关系可以解决我们遇到的所有问题：   \n\n- 不在遇到重构问题，可以任意秀该方法的名称。\n- 不再违反DRY原则。\n- 当新方法须要加入到依赖关系中时，只要将他放到适当的组中，并确保他依赖于正确的组。\n\n依赖的测试和线程   \n当打算并行执行测试时，要记住，线程池中的一个或多个线程将用于依次执行每个方法。所以，如果打算在不同的线程中执行一些测试，过渡的使用依赖的测试将影像执行性能。    \n\n配置方法的失败    \n依赖测试方法和配置方法之间唯一的不同就是，测试方法隐式的依赖于配置方法。   \n\n虽然dependsOnMethods可以处理简单的测试或之由一个测试方法依赖于另一个测试方法的情况，但是在大多数情况下，您都应该使用dependsOnGroups，这种方式的伸缩性好，面对将来的重构也更为健壮。   \n\n既然我们提供了准去的依赖信息，那么TestNG就能够按照于骑的顺序来执行测试。    \n\n测试隔离并没有因此而受到影响。    \n\n如果出现层叠式的错误，依赖测试可以加快测试执行速读。    \n\n\n继承和annotation范围\n    \n    public class CreditCardTest\n    {\n    　　@Test(groups = \"web.credit-card\")\n    　　public void test1() {}\n    \n    　　@Test(groups = \"web.credit-card\")\n    　　public void test2() {}\n    }\n\n他违反了\"不要重复自己\"的原则     \n他为将来添加测试方法的开发者带来了负担。     \n\n    @Target({METHOD, TYPE, CONSTRUCTOR})\n    public @interface Test{}\n    \n    \n    @Test(groups = \"web.credit-card\")\n    public class CreditCardTest\n    {\n    　　public void test1() {}\n    　　public void test2() {}\n    }\n\nannotation继承     \n\n\n    @Test(groups = \"web.credit-card\")\n    class BaseWebTest {}\n    \n    public class WebTest extends BaseWebTest \n    {\n    　　public test1() {}\n    　　public test2() {}\n    }\n    \n\n所有扩展自BaseWebTest的类都会看到，他们所有的工有方法都自动成为web.credit-card组的成员。    \nWebTest变成了一个普通的传统Java对象(POJO),不带任何annotation。    \n\n集成易犯的错误    \n由于TestNG的测试方法必须是公有的，在基类中声明的方法会自动在子类中可见，所以他们永远也不需要作为测试类显式的列出(不要将测试基类列在testng.xml文件中)     \n\n测试分组\n分组解决了上面提到的局限性，实际上，他们进一步提升了TesgNG的一个设计目标：在静态模型(测试代码)和动态模型(执行哪些测试)之间实现清晰的分离。    \n\n语法\n@Test annotation和配置annotation(@BeforeClass, @AfterClass, @BeforeMethod...)都可以属于分组\n\n    @Test(groups = {\"group1\"})\n    @Test(groups = {\"group1\", \"group2\"})\n    @Test(groups = \"group1\")\n    \n    @Test(groups = \"group2\")\n    public class B\n    {\n    　　@Test\n    　　public test1() {}\n    \n    　　@Test(groups = \"group3\")\n    　　public test2() {}\n    }\n\ntest1属于group2组，test2同时属于group2组和group3组\n\n\n分组与运行时刻\n\n    <suite name=\"Simple suite\">\n    　　<test name=\"GroupTest\">\n    　　　　<groups>\n    　　　　　　<run>\n    　　　　　　　　<include name=\"group1\" />\n    　　　　　　</run>\n    　　　　</groups>\n    　　　　<classes>\n    　　　　　　<class name=\"com.example.A\" />\n    　　　　</classes>\n    　　</test>\n    </suite>\n这个testng.xml告诉TestNG执行com.example.A类中所有属于group1组的测试方法。    \n\n    <include name=\"database\" />\n    <exclude name=\"gui\" />\n\n如果某个方法即属于包含的组，又属于排除的组，那么排除的组优先。     \n如果既没有include，也没有exclude，那么TestNG将忽略组，执行所有的测试方法。   \n\n另一个功能就是可以在testng.xml中利用正则表达式来指定组。\n\n\n    <groups>\n    　　<define name=\"all-web\">\n    　　　　<include name=\"jsp\" />\n    　　　　<include name=\"servlet\" />\n    　　</define>\n    　　<run>\n    　　　　<include name=\"all-web\">\n    　　</run>\n    </groups>\n\n在设计组的层次关系时，能够在testng.xml中定义新组带来灵活性：    \n可以在代码中使用粒度非常小的分组，然后在运行时刻将这些小分组合并成大分组。     \n\n执行分组    \n利用命令行执行      \n\n    java org.testng.TestNG -groups jsp -groups servlet -excludegroups broken com.example.MytestClass\n\n利用ant     \n\n    <testng groups=\"jsp, servlet\" excludegroups=\"broken\">\n    　　<classfileset>\n    　　　　<include name=\"com/example/MyTestClass.class\" />\n    　　</classfileset>\n    </testng>\n\n利用Maven     \n\n    <dependencies>\n    　　<dependency>\n    　　　　<groupId>org.testng</groupId>\n    　　　　<artifactId>testng</artifactId>\n    　　　　<version>5.10</version>\n    　　　　<classifier>jdk15</classifier>\n    　　</dependency>\n    </dependencies>\n    \n    <build>\n    　　<plugins>\n    　　　　<plugin>\n    　　　　　　<groupId>org.apache.maven.plugins</groupId>\n    　　　　　　<artifactId>maven-surefire-plugin</artifactId>\n    　　　　　　<version>2.5</version>\n    \n    　　　　　　<configuration>\n    　　　　　　　　<suiteXmlFiles>\n    　　　　　　　　　　<suiteXmlFile>testng.xml</suiteXmlFile>\n    　　　　　　　　<suiteXmlFiles>\n    　　　　　　</configuration>\n    　　　　</plugin>\n    　　</plugins>\n    </build>\n\n\n利用Java API    \n\n    TestNG tng = new TestNG();\n    tng.setGroups(\"jsp, servlet\");\n    tng.setExcludeGroups(\"broken\")\n\n排除失败的测试    \n创建一个特书的组如broken\n\n    @Test(groups = { \"web\", \"broken\"})\n然后在运行时刻排除这个组。    \n\n    <exclude name=\"broken\" />\n    \n\n组分类    \n\n测试类型:单元测试、继承测试    \n测试规模:小规模、大规模    \n功能描述:数据库、界面    \n测试速度:慢测试、快测试    \n过程描述:冒烟测试、发布测试    \n \n让开发者能够指定方法的分组，主要的好处在于开发者因此能够很容易找出他们需要执行哪些测试。(如刚刚修改了数据库代码，可能只需要执行fast和database组测试)     \n\n组命名    \n\n    @Test(groups = {\"os.linux.debian\"})\n    @Test(groups = {\"database.table.ACCOUNTS\"})\n    @Test(groups = {\"database.ejb3.connection\"})\n    \nTestNG能够利用正则表达式来之定要执行的组，如果与这项功能配合使用，这种命名方式就很有用了。    \n\n    <groups>\n    　　<run>\n    　　　　<include name=\"database.*\" />\n    　　</run>\n    </groups>\n\n代码覆盖率     \n类的覆盖率：类覆盖描熟了项目中多少类已被测试套件访问。　   \n方法覆盖率：方法覆盖率是被访问的方法的百分比。   \n语句覆盖率：语句覆盖率追踪单条源代码语句的调用。   \n语句块覆盖率：语句快覆盖率将语句块作为基本的覆盖律单元。   \n分支覆盖率：分支覆盖率也被称为判断覆盖率。指标计算哪些代码分支被执行。    \n \n覆盖律工具    \nClover、EMMA和Cobertura    \n\n成功使用覆盖率的建议   \n覆盖率报告的信息何音的解读不同   \n覆盖率很难   \n百分比没有意义   \n为覆盖率而设计是错误得   \n有一点好过没有   \n覆盖律工具不会测试不存在的代码   \n覆盖率的历史讲述了自己的故事   \n \n企业级测试     \n单元测试：单元测试对系统中的一个单元进行独立的测试。    \n\n功能测试：功能测试关注一项功能。通常涉及不同组件之间的交互。    \n\n继承测试：继承测试是一种端到端的测试，他会执行整个应用栈，包括所有的外部依赖关系或系统。    \n\n一个具体的例子    \n系统中有一个相当典型的组件，他接收一条JMS消息，其中包含一段有效的XML文本。这段XML文本相当长，描述了一笔财务交易。这个组件的工作是读出这条消息，解析XML，根据消息的内容条填充一些数据库的表，然后调用一个存储过程来处理这些表。    \n\n测试内容     \n\n我们将创建一个成功测试。希望确保，如果收到一条有效的XML消息，我们会正确地处理他，并更新正确的数据表，然后存储过程的调用也成功。     \n我们将摹拟不同的场景。希望能够为测试替工不同的XML文本，这样就能够很容易地不断添加测试粒子数据。     \n我们提供明确的失败测试。失败的行为将被记录和测试，这样当组件内部出现失败时，他的状态就可以与测，并且很容易记录下来。    \n\n非测试内容    \n\n我们不测试JMS provider的功能。假定他是一个完全兼容的实现，已经正确的进行了配置，将成功地提交我们期望的消息。\n我们不执行捕捉所有错误得测试。失败测试应该针对明确的、可重现的失败场景。\n我们不测试API。例如，JDBC去冬的行为不是测试的主题。确保所有的测试都贯注业务功能，要避免对Java语言的语义进行测试。     \n \n测试成功场景    \n对于JMS API的接口    \n利用模拟对象(或桩)对象，创建TextMessage实现，用一个简单的POJO来表现，带有消息内容和其他属性的设置方法。\n重构该组件，解除业务功能与JMS API的耦合。    \n\n    public void onMessage(Message message)\n    {\n        TextMEssage tm = (TextMessage) message;\n        processDocument(tm.getText());\n    }\n    \n    public void processDocument(String xml)\n    {\n        // code previously in onMessage that updates DB\n    }\n    \n    @Test\n    public void componentUpdateDatabase() throws Exception {}\n    \n\n构件测试数据\n\n    @Test(dataProvider = \"\")\n    public void componentUpdateDatabase() throws Exception  {}\n    \n    @DataProvider(name = \"component-data-files\")\n    public Iterator<Object[]> loadXML() throws Exception {}\n\n我们的测试现在接受一个参数，不再需要自己考虑测试数据的来源，也不需要考虑如何加载测试数据。他要做的只是指定数据提供者。加载XML的实际工作现在代理给了一段独立的加载程序。    \n\n    @DataProvider(name = \"component-data-files\")\n    public Iterator<Object[]> loadXML() throws Exception\n    {\n        File[] f = new File(\"filepath\").listFiles();\n        final Iterator<File> files = Arrays.asList(f).iterator();\n    \n        return new Iterator<Object[]>() {\n            public boolean hasNext()\n            {\n                return files.hasNext();   \n            }\n    \n            public Object[] next()\n            {\n                return new Object[] { IOUtils.readFile(files.next()) };\n            }\n    \n            public void remove()\n            {\n                throw new UnsupportedOperationException(); \n            }\n        };\n    }\n\n当然，可以从数据提供者返回一个Object[]的数组，但是，这种方法意味着我们必需将所有的文件的数据都一次性加载到内存中，因为数组必须事先填充。    \n\n\n测试准备问题    \n\n幂等的测试是指，这个测试执行一次和执行多次的结果是一样的。如果某个东西是幂等的，那么说明他在多次调用时状态不会改变。    \n\n不仅需要测试是幂等的，而且测试的次序应该无关紧要。所以除了需要是是幂等的之外，测试不应该在状态或数据方面影像其他测试。   \n\n对于一些写操作，成功执行之后很容易会对再次执行产生影响，下面方法有助于我们对付这个问题：    \n\n嵌入式数据    \n    有一些基于Java的数据库引擎，在设计时专门考虑了嵌入式支持。这些数据库可以在测试过程中临时创建并进行初始化。他们开销很小，通常性能不错。   \n    不足之处在于，它们与应用程序实际执行的环境差别非常大。通常在数据库特征上存在巨大的诧异。   \n\n在测试准备时初始化数据    \n    测试数据库总加载一定数量的已知测试数据。其中包含希望操作的所有数据，以及组件所依赖的所有外部引用。   \n    不足之处在于，很难维护一个健壮的数据集，使他对测试有足够的意义。   \n\n事务回滚   \n    另一种方法就是利用Java API来防止数据写入到持久数据存储中。总的方法是开是一个事务，执行所有的写操作，验证一切正常，然后让事务回滚。    \n    不足之处在于，如果没有复杂的嵌套事务准备，就不能测试参与事务的代码或开始自己的事务的代码。   \n\n\n选择正确的策略   \n\n\n    private WrappedConnection wrappedConnection;    \n    \n    @BeforeMethod   \n    public void connection() throws SQLException\n    {\n        connection = DatabaseHelper.getConnection();\n        connection.setAutoCommit(false);\n        wrappedConnection = new WrappedConnection(connection);\n        wrappedConnection.setSuppressCommit(true);\n    }\n    \n    @AfterMethod\n    public void rollback() throws SQLException\n    {\n        wrappedConnection.rollback(); \n    }\n    \n    public class WrappedConnection implements Connection\n    {\n        private Connection connection;\n        private boolean suppressClose;\n        private boolean suppressCommit;\n    \n        public WrappedConnection(Connection connection)\n        {\n            this.connection = connection;    \n        }\n    \n        public void commit() throws SQLException\n        {\n            if (!suppressCommit)    \n                connection.commit();\n        }\n    \n        // ......\n    }\n    \n\n错误处理    \n\n\n\n    @Test(dataProvider = \"component-data-files\")\n    public void componentupdateDatabase(String xml) throws Exception\n    {\n        Component component = new Component();\n        try {\n            component.processDocument(xml);\n        }\n        catch (InvalidTradeException e) {\n            return;\n        }\n        // rest of test code\n    }\n\n这种方法在于，他们没能让我们区分失败是否是预期的。相反，我们应该能够区分预期的成功和预期的失败。这个测时目前在两种情况下会通过：要么遇到好的数据时会通过，要么遇到坏数据时会通过。在每种情况下，我们都不能确定会发生些什么。   \n\n一个测试不应该在两种或两种以上的情况下都通过。如果测试验证了不同的失败情况，这没问题，但如果测试在好数据和坏数据的情况下都通过，那就会导致一些微妙的错误，这类错误难以被发现。(因此我们定义了另一个目录和数据提供者来处理失败的情况)     \n\n    @Test(dataProvider = \"component-invalid-data-files\", expectedException = InvalidTradeException.class)\n    public void componentInvalidInput(String xml) throws Exception\n    {\n        Component component = new Component();\n        component.processDocument(xml);\n        // rest of test code\n    }\n逐渐出现的单元测试    \n单元测试不一定是在其它测试之前编写的，他们可以是功能测试驱动的。特别是对于大型项目或原有的代码来说，一开始就编写有用的单元测试可能很困难，因为在不了解全局的情况下，单元测试可能太琐碎或不太重要。相反，单元测试可以从有意义的继承测试中推导出来，因为调试开发功能测试和集成测试的过程揭示他们所需的单元测试。    \n\n对于例子来说我们需要将XML验证与数据库处理放到各自独立的方法中。这样就能对他们进行测试    \n\n    public void processDocument(String xml) throws InvalidDocumentException\n    {\n        Document doc = XMLHelper.parseDocument(xml);\n        validateDocument(doc);\n        // ......\n    }\n    \n    public void validateDocument(Document doc) throws InvalidDocumentException\n    {\n        // perform constraint checks that can't be captured by XML\n    }\n    \n这测重构的结果是我们得到了一个简单的单元测试。   \n\n不论测试编写的次序如何，功能测试和单元测试都是互不的。功能测试是更为水平化的测试，涉及许多不同的组件，执行代码的很多部分。相反，单元测试是更为垂直化的测试，他关注范围狭窄的主题，比功能测试要彻底得多。   \n\n竞争消费者模式    \n消费者的执行是并发的，所以我们必须在测试中进行某种程度的模拟，生产环境中的真实情况。在我们这样作了之后，也希望验证结果。不论哪个消费者先开始，也不论哪个消费者先结束，都没有关系。我们希望确定对于给定数量的消费者，我们将得道一组已知的结果，可以进行验证。   \n\n    private final List<Object[]> data = Collections.synchronizedList(new ArrayList<Object[]>());\n    \n    @BeforeClass\n    public void populateData()\n    {\n        data.add(new Object[] {\"value1\", \"prop1\"});\n        data.add(new Object[] {\"value2\", \"prop2\"});\n        data.add(new Object[] {\"value3\", \"prop3\"});\n    }\n    \n    @Test(threadPoolSize = 3, invocationCount = 3, dataProvider = \"concurrent-processor\")\n    public void runConcurrentProcessors(String value, String someProp)\n    {    \n        MessageProcessor processor = new MessageProcessor();\n        processor.process(value, someProp);\n    }\n    \n    @Test(dependsOnMethods = \"runConcurrentProcessors\")\n    public void verifyConcurrentProcessors()\n    {\n        // load data from db\n        // verify that we have 3 results\n        // verify that each of the 3 result matches our 3 input\n    }\n    \n    @DataProvider(name = \"concurrent-processor\")\n    public Object[][] getProcessorData()\n    {\n        return new Object[][] {data.remove(data.size() - 1)};\n    }\n\n我们的测试被分成两个，一个负责执行消费者，另一个负责验证结果。原因是runConcurrentProcessors会被调用多次，而我们只需要在所有方法调用完成之后，对结果验证一次。为了表示这种次序，我们利用了dependsOnMethods这个annotation属性。   \n\n当TestNG发现一个数据提供者时，他将针对数据提供者返回的每一条数据调用一次测试。类似的，当我们指定调用次数时，TestNG会按照指定的次数调用测试。因此，如果我们返回数据提供者中准备好的3条数据，那么每个线程都会执行3次测试。    \n\n因此解决方案是使用一个栈结构，每次调用数据提供者时，返回一条数据，并将这条数据从列表中清除。数据提供者将被调用3次，每次都将为数据返回不一样的数据。    \n\n\n原则：将数据的考虑和功能的考虑分开来是很关键的。    \n在这个例子中，消费者需要的数据应该和实际的测试没有依赖关系。这种方法意味着，随着我们对数据的需求不断变化，变得更为复杂，测试本身却不需要被修改。    \n\n\n一个具体的例子   \n我们希望测试一个登录servlet。这个servlet接受一个请求，检查用户名和口令，如果他们有效，就在会话中加入一个标记。表明用户已登录。   \n\n这个例子展示了重构在测试方面起到的重要辅助作用，说明了即使对于看上去很麻烦、需要一很复杂地方是进行交互的API，页可以通过抽象去掉依赖关系。这种抽象意味着 在测试过程中，我们可以利用更简单的对象，这些对象更容易构造，因此也更容易测试。    \n\n增加可测试性的一个副作用就是改进了设计。为提高可测试性而进行重构，可以帮助我们以一种实际的、代码中的方式来确定职责和考虑，而这种效果通过画设计图是很难达到的。   \n\nJava EE测试    \n容器内测试与容器外测试的对比    \n\n容器内测试    \n优点：    \n    完全符合运行时环境   \n\n缺点：    \n    启动消耗大    \n    难以部署新的测试    \n    难以自动化    \n    夸平台测试的复杂性增加    \n\n容器外测试    \n优点：    \n    提供了相对较快的启动    \n    可以完全控制环境    \n    可以自动化    \n    容易测试    \n缺点：   \n    没有符合运行时环境   \n    测试所用的实现可能与运行时的实现来自不同的提供商。   \n\n\n容器内测试    \n测试步骤：   \n\n创建一个测试环境的实例。   \n确定测试。   \n在测试框架中注册测试。   \n注册一个监听者来接收搜测试结果。   \n \n\n创建测试环境    \n    \n    TestNG tester = new TestNG();\n    tester.setDeafultSuiteName(\"container-tests\");\n\n确定测试    \n假定所有的测试类都在WEB-INF/classes目录下，我们可以递归地读入这个目录，找到其中所有的类文件。    \n\n    public static Class[] scan(ServletContext context)\n    {\n        String root = context.getReadPath();\n        ClassScanner scanner = new ClassScanner(new File(root));\n        scanner.setClassLoader(ClassScanner.class.getClassLoader());\n        final File testDir = new File(root, \"com/foo/tests\");\n        scanner.setFilter(new FileFilter() {\n            public boolean accept(File pathname) {\n                return pathname.getPath().startsWith(testDir.getPath());\n            }    \n        });\n        Class[] classes = scanner.getClasses();\n        return classes;\n    }\n\ncontext是一个ServletContext实例，他是通过调用servlet或JSP页面得到的。   \n\n注册测试    \n注册测试类的动作告诉了TestNG他要查看的一组类，TestNG将在这组类中查找需要执行哪些测试。他将检查每个指定的类，确定他是否包涵测试方法或配置方法。当所有类都检查过后，TestNG内部会生成一个依赖关系图，以决定照到的这些测试的执行次序。    \n\n    tester.setTestClasses(classes);\n\n注册结果监听者    \n\nTestNG自代了3个默认的报告类：    \n\nSuiteHTMLRepoter 默认报告类，他在一个目录下输出交叉引用HTML文件，让您能看到某个具体测试的结果。   \n\nFailedReporter: 这个报高生成一个TestNG执行配置，该配置包含了所有前一次运行时失败的测试。他也是默认运行的。   \n\nEmailableReporter: 这个报告类生成一个报告文件，可以很容易地通过电子邮件发送，显示测试的结果。   \n\n\n默认情况下，EmailableReporter在磁盘上生成一个文件。    \n\n\n    public class SinglePageReporter extends EmailableReporter\n    {\n        private Writer writer;\n    \n        public SinglePageReporter()\n        {\n            this.writer = writer;\n        }\n    \n        protected PrintWriter createWriter(String out)\n        {\n            return new PrintWriter(writer);\n        }\n    }\n    \n\n调用TestNG的JSP页面    \n\n\n    <%@ page import=\"org.testng.*, java.io.*\" %>\n    <%\n        TestNG tester = new TestNG();\n        tester.setDefaultSuiteName(\"container-tests\");\n    \n        String root = application.getRealPath(\"/WEB-INF/classes\");\n        ClassScanner scanner = new ClassScanner(new File(root));\n        scanner.setLoader(getClass().getClassLoader());\n        scanner.setFilter(new FileFilter() {\n            public boolean accept(File pathname) {\n                return pathname.getPath().indexOf(Test) > -1;\n            }\n        });\n    \n        Class[] classes = scanner.getClasses();\n        tester.setTestClasses(classes);\n    \n        IReporter reporter = new SinglePageReporter(out);\n        tester.addListener(reporter);\n    \n        tester.run();\n    %>\n\nJava命名和目录接(JNDI)    \nJNDI是一个在全局目录中查找资源的API。可以把他看成是一个很大的树型结构，我们在其中按照名称查找某个节点。    \n\n    new InitialContext().lockup(\"someObject\");     \n上面创建一个InitialContext对象，如果在执行容器内执行，会利用供应商提供的API实现，来查找容器内部命名目录结构。创建了上下文之后，我们在其中查找对象，列出他的内容，或遍历这棵树。所有这些都是通过JNDI API来完成的。InitialContext的构造方法由一个重载的版本，接受一个Hashtable对象作为参数，其中包含不同的环境变量值，决定了上下文应该如何创建。    \n\n    Hashtable env = new Hashtable();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"\");\n    env.put(Context.PROVIDER_URL, \"smqp://localhost:4001\");\n    Object topic = new InitialContext(env).lookup(\"myTopic\");\n\n避免JNDI    \n组件依赖关系要么通过服务定位(通常是JNDI)来实现，要么通过注入来实现。如果您可以选择，就采用注入的方式，因为这样测试的开销最小，并且这种方式带来了更大的灵活性。   \n\nJava消息服务(JMS)   \n\n    private Session session;\n    private Destination destination;\n    \n    @BeforeClass(groups = \"jms\")\n    public void setupJMS() throws NamingException, JMSException\n    {\n        Hashtable env = new Hashtable();\n        // populate environmet for out specific provider\n        InitialContext context = new InitialContext(env);\n    \n        ConnectionFactory factory = (ConnectionFactory) context.lookup(\"QueueConnectionFactory\");\n        Connection connection = factory.createConnection();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = (Detination) context.lookup(\"TestQueue@router1\");\n    }\n    \n    \n    @Test(groups = \"jms\")\n    public void sendMessage() throws JMSException\n    {\n        TextMessage msg = session.createTextMessage();\n        msg.setText(\"hello!\");\n        msg.setStringProperty(\"test\", \"test1\");\n        session.createProducer(destination).send(msg);\n    }\n    \n    @Test(groups = \"jms\", dependsOnMethods = \"sendMessage\", timeOut = 1000)\n    public void receiveMessage() throws JMSException\n    {\n        MessageConsumer consumer = session.createConsumer(destination, \"test\", \"test1\");\n        TextMessage msg = (TextMessage) consumer.receive();\n        assert \"hello!\".equals(msg.getText());\n    }\n\n \n\n在测试中使用ActiveMQ   \n\n    @BeforeClass(groups = \"jms\")\n    public void setupActiveMQ() throws Exception\n    {\n        BrokerService broker = new BrokerService();\n        broker.setPersistent(false);\n        broker.setUseJmx(false);\n        broker.start();\n    \n        URI uri = broker.gettVmCnnectionURI();\n        ConnectionFactory factory = new ActiveMQConnectionFactory(uri);\n        Connection connection = factory.createConnection();\n        connection.start();\n    \n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"TestQueue@router1\");\n    }\n\n \n\n \n\n处理状态     \n在JMS的例子中，当我们拥有多个测试时，会引发一个有趣的问题。因为测试是由一对方法组成的，所以让我们假定同一个类中还有另一对发送/接收测试。    \n\n一种方法是将发送和接受者放在一个测试中，并在每个测试方法之前初始化消息代理。请注意两点都要做到，因为让消息代里在一对测试方法之前初始化是比较麻烦的。    \n\n另一种方法是使用消息分捡器。JMS消息分捡器让我们能够过滤接收到的消息，这样可以只接收与分捡器匹配的消息。   \n\nSpring   \nSpring的测试包功能     \n\nTestNG通过自己的一组针对Spring的类来解决这些问题，这些类作为扩展提供。org.testng.spring.test包中包含了所有Spring在其测试包中提供的类，这些类已修改过，可以用在基于TestNG的测试中。   \n\nAbstractSpringContextTests   \n这是所有Spring测试的基类。他的主要职责是提供上下文的管理。这个类包含一个静态map，其中包含所有注册的Spring上下文。   \n\nAbstractSingleSpringContextTests    \n这个类扩展了AbstractSpringContextTests，提供了装入一个ApplicationContext对象的钩子。他的子类应该实现getConfigLocation(String[] paths)方法。这个方法返回一个字符串数组，指出了Spring配置文件的位置，通常是从classpath加载的。    \n\n    \n    import org.testng.annotation.Test;\n    import org.testng.spring.test.AbstractSingleSpringContextTests;\n    \n    public class SpringContextTests extends AbstractSingleSpringContextTests\n    {\n        protected String[] getConfigLocations()\n        {\n            return new String[] {\"/spring.xml\"};    \n        }\n    \n        @Test\n        public void beanDefined()\n        {\n            assert applicationContext.getBean(\"myBean\") != null;\n        }\n    }\n\n\nSpring的配置方法被声明在名为Spring-init的TestNG分组中。我们不必依赖于单个的onSetUp或ontearDown方法，可以根据需要声明任意多个@BeforeMethod/@AfterMethod配置方法，只要指定他们依赖于spring-init，就可以确保他们在Spring执行完准备工作之后得到调用。    \n\n\nAbstractDependencyInjectionSpringContextTests   \n这个类提供的最有趣的功能就是向测试注入依赖。测试依赖关系可以表现为设值方法或成员字断。测试也可以指定Spring应该对他们的树性执行哪种类型的自动编织。    \n\n    public class SpringInjectionTests extends AbstractDependncyInjectionSpringContextTests\n    {\n        private PersonManager manager;\n    \n        protected String[] getConfigLocation()\n        {\n            return new String[] {\"/spring.xml\"};     \n        }\n        \n        public void setManager(PersonManager manager)\n        {\n            this.manager = manager; \n        }\n    \n        @Test\n        public void verifyManager()\n        {\n            assert manager != null;    \n        }\n    }\n\n这个类有一个事务管理器属性。因为他派生自支持注入的类，配置文件中必需指定一个PlatforTransactionManager，以便注入。     \n\n    public class StrpingTranscationTests extends AbstractTransactionalSpringContextTests\n    {\n        private PersonManager manager;\n    \n        public void setManager(PersonManager manager)\n        {\n            this.manager = manager\n        }\n    \n        protected String[] getConfigLocation()\n        {\n            return new String[] {\"/spring.xml\"};\n        }\n        \n        @Test\n        public void savePerson()\n        {\n            Person p = new Person();\n            manager.savePerson(p);\n    \n            assert p.getId() != null;\n            // setComplete();\n        }\n    }\n\n\n我们没有在测试中指定任何事务行为，超类自动处理了事务方面的问题，让每个测试在他自己的事务中执行，这个十五将在该测试完成之后回滚。    \n\n增加的调用setComplete通知超类在测试执行之后应该提交这个事务，而不是回滚。调用这个方法由一个有趣的副作用：这个类中所有后续测试都会提交事务，而不是依赖于默认行为。   \n\n答案在于JUnit和TestNG之间的一个微妙区别。Spring测试假定采用了JUnit的语义。每个测试类对每个测试方法都会重新实例化。因此，所有的测试都假定每个测试开始时，测试时里的状态都会复原，但TestNG不是这样的。   \n\nAbstractTransactionalDataSouceSpringContextTests    \n这个类添加了一些JDBC相关的便利方法。   \n\nAbstractAnnotationAwareTransactionalTests    \n这个类支持超类提供的所有功能之外，这个类允许我们在测试方法上指定Spring特有的事务annotation，而不是通过编程的方式来指定事务行为。    \n\nGuice   \n第2章中的例子，对于每个接口，我们都有两个实现。一个是实际的产品实现，他会与一些外部的依赖关系进行交互，如UserDAO对象会与数据库交互，Mailer对象会与SMTP邮件服务器交互。我们还有桩对象实现。    \n\n\n    @Test\n    public void verifyCreateUser()\n    {\n        UserManager manager = new UserManagerImpl();\n        MailerStub mailer = new MailerStub();\n    \n        manager.setMailer(mailer);\n        manager.setDao(new UserDAOStub());\n    \n        manager.createUser(\"tester\");\n        assert mailer.getMails().size() == 1;\n    }\n\n\nGuice注入测试    \n\n\n    @Inject private UserManager manager;\n    @Inject private MailerStub mailer;\n    \n    @Test\n    public void verifyCreateUser()\n    {\n        manager.createUser(\"tester\");    \n        assert mailer.getMails().size() == 1;\n    }\n\n \n\n \n\nSpring注入测试    \n\n\n    private UserManager manager;\n    private MailerStub mailer;\n    \n    public void verifyCreateUser()\n    {\n        manager.createUser(\"tester\");\n        assert mailer.getMails().size() == 1;\n    }\n    \n    public void setManager(UserManager manager)\n    {\n        this.manager = manager;\n    }\n    \n    public void setMailer(MailerStub mailer)\n    {\n        this.mailer = mailer;    \n    }\n\n\n对象工厂 \n\n杂谈   \n关注和提供异常    \n一层遇到了一个没有预料到的错误，不知道如何处理。所以这一层就快乐地向上一层抛出一个异常，希望这个可怜的异常最终会遇到知道怎么作的人。  \n\n\n吞掉抛出异常    \n\n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        throw new BackendException(\"Error in backed\");\n    }\n这种方法问题在于，实际上我们丢试了真实错误的有意义的信息。当我们最后有机会处理这个异常的时候，我们得到的信息仅仅是某一层中出了问题，但我们不知道是在这一曾本身出了问题，还是更低的层出了问题。    \n\n\n记日志并抛出    \n\n\n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        log.error(\"Error calling backend\", ex);\n        throw ex;\n    }\n\n问题在于调用栈经常发生的情况：信息隐藏。假定一个应用程序有三层或四层，每一层都在日志中记录他处里的异常，查遍8页的调用栈信息并不是最有效地方式。    \n\n\n嵌套抛出    \n    \n    try {\n        callBackend();\n    }\n    catch (SQLException ex) {\n        throw new BackendException(\"Error in backend\", ex);\n    }\n当这个调用栈显示的时候，没有丝毫暗示表明背后的原因是什么。您必须编写一个帮助方法，从外面的包装中取出背后实际的异常。   \n\n\n我们建议两种解决方案    \n\n避免需检察异常。运行时异常很合适这样的情况。   \n包装异常。假如您非常肯定在调用栈打印时，背后的原因会显示出来，那么包装的异常也很好。    \n \n\n有状态测试    \n有两种截然不同的状态分类：不可修改的状态和可修改的状态   \n\n不可修改的状态    \n访问共享的不可修改的状态的测试方法，相互之间是独立的。   \n因为这些方法都不能修改他们读到的状态，所以调用顺序可以是任意的，因此他们没有违反测试访法应该彼此肚里的原则。    \n\n可修改的状态    \n\n\n    public class MyTest extends TestCase\n    {\n        private int count = 0;\n    \n        public void test1()\n        {\n            count++;\n            assertEquals(1, count);\n        }\n    \n        public void test2()\n        {\n            count++;\n            assertEquals(2, count);\n        }\n    }\n\nJUnit会让这个测试通过，但TestNG不会。   \n只有当您知道测试方法被调用的顺序时，共享可修改的状态才有意义。   \n\n\n安全的共享数   \n安全          不可修改的状态    \n\n安全　　　可修改的状态与完全指定的依赖关系    \n\n不安全　　可修改的状态与不确定的依赖关系   \n\n\n测试驱动开发的缺点    \n他注重微观设计超过宏观测试    \n\n他在实践中难以应用   \n\nTDD注重微观设计超过宏观设计    \n\n测试驱动开发可以得到更健壮的软件，但他也可能导致不必要的反复和过度重构的趋势，这可能对饮的软件、设计和最后期限产生负面影响。   \n\nTDD难以应用    \n\n这种方式得到的代码本身并不会优先于传统方法测试的代码。    \n\n如何创建测试并不重要，重要的是确实要创建测试    \n\n测试私有方法   \n如果他有可能出问题，您就应该测试他。    \n\n测试私有方法的比较好的方法是提升方法的可见性，例如，让他变成保护可见，或者包可见。后者更好一些，因为您可以把测试和被测类放在同一个包中，然后您就可以访问他的所有字段。如果这些方法都不可取，我们测试私有方法的方式就是利用反射。   \n    public class LoginController\n    {\n        private String userName;\n    \n        private void init()\n        {\n            this.username = getUserNameFromCookie();\n        }\n    }\n    \n    @Test\n    public void verifyInit()\n    {\n        LoginController lc = new LoginController();\n    \n        Field f = lc.getClass().getField(\"username\");\n        Object valueBefore = f.get(lc);\n        Assert.assertNull(valueBefore);\n    \n        Method m = lc.getClass().getDeclaredMethod(\"init\", null);\n        m.setAccessible(true);\n        m.invock(lc);\n    \n        Object valueAfter = f.get(lc);\n        Assert.assertNotNull(vlaueAfter);\n    }\n\n\n我们利用字符串来描述Java元素。如果您对这些元素进行重命名，这种危险的实践肯定会失效。    \n\n我们利用了该类危险的私有信息。我们不仅假定存在一些私有方法和属性，而且也假定这个方法将以某种方式修改一个字段。    \n\n\n测试与封装    \n如果让代码更可测试，不要担心破坏封装。可测试星应该胜过封装。   \n\n让一个私有方法(或字段)成为包可见的、保护可见的或公有的。    \n \n去掉方法的final限定符。这让测试勒能够扩展这些类，或重写这些方法，模拟或稍微改变他们的实现，从而让系统的其它部分更可测试。    \n\n\n记日志的最佳实践    \n在出错时，输出错误或警告是合理的。但是对於警告的情况，重要的是确定这是不是该做的事情。我们添加的每一条无用的日志信息都会干扰有用的信息，所已精心选择是有意义的。   \n\n对于调试需求，记日志是有用的。但是，只要有一个开关能打开或关闭，绝大多数的记日志需求都能够满足了，不需要复杂的解决方案。   \n\n参考文档：<http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html>","slug":"2013-06-05-deep-in-testng","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6d0072v8fyh4uokgp9","content":"<p>###TestNG annotaion:</p>\n<ul>\n<li>@DataProvider</li>\n<li>@ExpectedExceptions</li>\n<li>@Factory</li>\n<li>@Test</li>\n<li>@Parameters  </li>\n</ul>\n<hr>\n<pre><code>&lt;suite name=&quot;ParametersTest&quot;&gt;\n　　&lt;test name=&quot;Regression1&quot;&gt;\n　　　　&lt;classes&gt;\n　　　　　　&lt;class name=&quot;com.example.ParameterSample&quot; /&gt;\n　　　　　　&lt;class name=&quot;com.example.ParameterTest&quot;&gt;\n　　　　　　　　&lt;mtehods&gt;\n　　　　　　　　　　&lt;include name=&quot;database.*&quot; /&gt;\n　　　　　　　　　　&lt;exclude name=&quot;inProgress&quot; /&gt;\n　　　　　　　　&lt;/methods&gt;\n　　　　　　&lt;/class&gt;\n　　　　&lt;/classes&gt;\n　　&lt;/test&gt;    \n　　&lt;test name=&quot;Parameters&quot;&gt;\n　　　　&lt;packages&gt;\n　　　　　　&lt;package name=&quot;test.parameters.Parameter*&quot; /&gt;\n　　　　&lt;/packages&gt;\n　　&lt;/test&gt;   \n&lt;/suite&gt;    \n</code></pre><p>一个suite(套件) 由一个或多个测试组成。<br>一个test(测试) 由一个或多个类组成<br>一个class(类) 由一个或多个方法组成。   </p>\n<p>@BeforeSuite/@AfterSuite 在某个测试套件开始之前/在某个套件所有测试方法执行之后<br>@BeforeTest/@AfterTest 在某个测试开始之前/在某个测试所有测试方法执行之后<br>@BeforeClass/@AfterClass 在某个测试类开始之前/在某个类的所有测试方法执行之后<br>@BeforeMethod/@AfterMethod 在某个测试方法之前/在某个测试方法执行之后<br>@BeforeGroup/@AfterGroup 在某个组的所有测试方法之前/在某个组的所有测试方法执行之后<br><a id=\"more\"></a></p>\n<p>####1、分组</p>\n<pre><code>@Test(groups = {&quot;fast&quot;, &quot;unit&quot;, &quot;database&quot;})\npublic void rowShouldBeInserted() {}\n\njava org.testng.TestNG -groups fast com.example.MyTest\n</code></pre><p>测试的一个目标就是确保代码按照预期的方式工作。这种测试要么在用户层面上进行，要么在编程层面上进行。这两种类型的测试分别是通过功能测试和单元测试来实现的。    </p>\n<p>针对失败而测试     </p>\n<p>Java提供了两种不同类型的异常：从java.lang.RuntimeException派生的运行时刻异常和从java.lang.Exception派生的被检查的异常。   </p>\n<p>抛出被检查的异常的经验法则：调用者可以为这个异常做什么吗？如果答案是肯定的，那么可能应该是用被检查的异常，否则，最好是选择运行时刻异常。   </p>\n<pre><code>@Test(expectedExceptions = {ReservationException.class, FlightCanceledException.class})\npublic void shouldThrowIfPlaneIsFull() \n{\n　　Plane plane = createPlane();\n　　plane.bookAllSeats();\n　　plane.bookPlane(createValidItinerary(), null);\n}\n</code></pre><p>属性expectedExceptions是一组类，包含了这个测试方法中预期会抛出的异常列表。如果没有抛出异常，或抛出的异常不再该属性的类表中，那么TestNG就会认为这个测试方法失败了。</p>\n<p>单一职责：</p>\n<pre><code>public class BookingTest\n{\n　　private Plane plane;\n\n　　@BeforeMethod\n　　public void init() { plane = createPlane(); }\n\n　　@Test(expectedException = PlaneFullException.class)\n　　public void shouldThrowIfPlaneIsFull()\n　　{\n　　　　plane.bookAllseats();\n　　　　plane.bookPlane(createValidItinerary(), null);\n　　}\n\n　　@Test(expectedException = FlightCanceledException.class)\n　　public void shouldThrowIfFlightIsCanceled()\n　　{\n　　　　cancelFlight(/* ... */);\n　　　　plane.bookPlane(createValidItinerary(), null);\n　　}\n}\n</code></pre><p>testng-failed.xml</p>\n<p>当您执行包涵失败的测试套件时，TestNG会在输出目录(默认是test-output/)下自动生成一个名为testng-failded.xml的问他件。这个XML文件包含了原来的testng.xml中失败的方法所构成的子集。 </p>\n<pre><code>java org.testng.TestNG test.xml\njava org.testng.TestNG test-output/testng-failed.xml\n</code></pre><p>####2、工厂<br>TestNG让您可以选择自己将测试类实例化。这是通过@Factory annotation来实现的，他必须放在返回一个对象数组方法的顶部。所有这些对象都必须是包含TestNG annotation的类的实例。如果有@Factory annotation，那么这个循环会继续下去，知道TestNG拿到的都是没有@Factory annotation实例，或者@Factory方法都已被调用过的实例。</p>\n<pre><code>public class ExpectedAttributes\n{\n　　private Image image;\n　　private int width;\n　　private height;\n　　private String path;\n　　\n　　@Test\n　　public void testWidth() {}\n\n　　@Test\n　　public void testHeight() {}\n\n　　public PictureTest(String path, int width, int height, int depth) throws IOException\n　　{\n　　　　File f = new File(path);\n　　　　this.path = path;\n　　　　this.image = ImageIO.read(f);\n　　　　this.width = width;\n　　　　this.height = height;\n　　}\n\n　　private static String[] findImageFileNames() {}\n\n　　@Factory\n　　public static Object[] create() throws IOException\n　　{\n　　　　List result = new ArrayList();\n\n　　　　String[] paths = findImageFileNames();\n\n　　　　for (String path : paths) {\n　　　　　　ExpectedAttributes ea = findAttributes(path);\n　　　　　　result.add(new PictureTest(path, ea.width, ea.height, ea.depth));\n　　　　}\n\n　　　　return result.toArray();\n　　}\n\n　　public class ExpectedAttributes \n　　{\n　　　　public int width;\n　　　　public int height;\n　　　　public int depth;\n　　}\n\n　　private static ExpectedAttributes findExpectedAttributes(String path)\n　　{\n　　　　// ...... \n　　}\n}\n</code></pre><p>可以安全的在同一个类包含@Factory和@Test annotation，因为TestNG确保@Factory方法只被调用一次。</p>\n<p>org.testng.ITest接口</p>\n<pre><code>public interface ITest \n{\npublic String getTestName(); \n}\n</code></pre><p>当TestNG遇到实现了这个接口的测试类时，他会在生成各种报告中包含getTestName()方法返回的信息。</p>\n<pre><code>public class PictureTest implements ITest\n{\n　　public String getTestName() \n　　{\n　　　　return &quot;[Picture: &quot; + name + &quot;]&quot;;\n　　} \n}\n</code></pre><p>数据驱动测试</p>\n<p>测试需要针对许多具有类似结构的数据来执行。<br>实际的测试逻辑是一样的，仅仅发生改变的是数据。<br>数据可以被一组不同的人修改。    </p>\n<p>参数测试方法<br>测试逻辑可以非常简单或不易改变，而提供給他的数据肯定会随着时间增长。    </p>\n<p>TestNG可以通过两种方式向测试方法传递参数：  </p>\n<ul>\n<li>利用testng.xml</li>\n<li>利用DataProviders</li>\n</ul>\n<p>1、利用testng.xml传递参数</p>\n<pre><code>&lt;suite name=&quot;Parameters&quot;&gt;\n　　&lt;parameter name=&quot;xml-file&quot; value=&quot;accounts.xml&quot; /&gt;\n　　&lt;parameter name=&quot;hostname&quot; value=&quot;arkonis.example.com&quot; /&gt;\n\n　　&lt;test name=&quot;ParameterTest&quot;&gt;\n　　　　&lt;parameter name=&quot;hostname&quot; value=&quot;terra.example.com&quot; /&gt;\n　　　　...\n　　&lt;/test&gt;\n　　...\n&lt;/suite&gt;\n</code></pre><p>在测试方法中指定参数</p>\n<pre><code>@Test(parameters = {&quot;xml-file&quot;})\npublic void validateFile(String xmlFile)\n{\n　　// xmlFile has the value &quot;accounts.xml&quot;\n}\n</code></pre><p>如果犯下以下错误之一，TestNG将抛出一个异常：</p>\n<ul>\n<li>在testng.xml中指定了一个参数，但不能转换为对应方法参数的类型。</li>\n<li>声明了一个@Parameters annotation，但引用的参数名称在testng.xml中没有声明。</li>\n</ul>\n<p>2.利用@DataProvider传递参数   </p>\n<p>如果需要向测试方法传递的参数不是基本的Java类型，或者如果需要的值智能在运行时刻创建，那么我们应该考虑使用@DataProvider annotation。   </p>\n<p>数据提供者是用@Dataprovider标注的方法。这个annotation只有一个字符串属性：他的名称，如果没有提供名称，数据提供者的名称就默认采用方法的名称。   </p>\n<p>数据提供者同时实现两个目的：  </p>\n<p>向测试方法传递任意数目的参数<br>根据需要，允许利用不同的参数集合对他的测试方法进行多次调用。   </p>\n<pre><code>@Test(dataProvider = &quot;range-provider&quot;)\npublic void testIsBetWeen(int n, int lower, int upper, boolean expected)\n{\n　　println(&quot;Received &quot; + n + &quot; &quot; + lower + &quot;-&quot; + upper + &quot; expected: &quot; + expected);\n　　assert.assertEquals(expected, isBetween(n, lower, upper));\n}\n\n@DataProvider(name = &quot;range-provider&quot;)\npublic Object[][] rangeData()\n{\n　　int lower = 5;\n　　int upper = 10;\n\n　　return new Object[][] {\n　　　　{ lower-1, lower, upper, false},\n　　　　{ lower, lower, upper, true},\n　　　　{ lower+1, lower, upper, true},\n　　　　{ upper, lower, upper, true},\n　　　　{ upper+1, lower, upper, false},\n　　};\n}\n</code></pre><p>由于数据提供者是测试类中的一个方法，他可以属于一个超类，然后被一些测试方法复用。我们也可以有几个数据提供者，只要他们定义在测试类或者他的一个子类上。当我们像在合适的地方记录数据源，并在几个测试方法中复用他时，这种方法是很方边的。    </p>\n<p>针对数据提供者的参数<br>数据提供者本身可以接受两个类型的参数：Method和ITestContext      </p>\n<pre><code>@DataProvider\npublic void craete() { ... }\n\n@DataProvider\npublic void create(Method method) { ... }\n\n@DataProvider\npublic void create(ITestContext context) { ... }\n\n@DataProvider\npublic void create(Method method, ITestContext context) { ... }\n</code></pre><p>Method参数<br>如果数据提供者的第一个参数是java.lang.reflect.Method，TestNG传递这个将调用的测试方法。如果您希望数据提供者根据不同的测试方法返回不同的数据，那么这种做法就非常有用。    </p>\n<pre><code>@DataProvider\npublic Object[][] provideNumbers(Method method)\n{\n　　String methodName = method.getName();\n\n　　if (methodName.equals(&quot;tow&quot;)) {\n　　　　return new Object[][] { new Object[] {2} };\n　　}\n　　if (methodName.equals(&quot;three&quot;)) {\n　　　　return new Object[][] { new Object[] {3} };\n　　}\n}\n\n@Test(dataProvider = &quot;provideNumbers&quot;)\npublic void two(int param)\n{\n　　System.out.println(&quot;Two received: &quot; + param); \n}\n\n@Test(dataProvider = &quot;provideNumbers&quot;)\npublic void three(int param)\n{\n　　System.out.println(&quot;Three received: &quot; + param);\n}\n</code></pre><p>使用同一个数据提供者的地方：   </p>\n<p>数据提供者代码相当复杂，应该保存在一个地方，这样维护起来更方便。<br>我们要传入数据的那些测试方法具有许多参数，其中只有少数参数是不一样的。<br>我们引入了某个方法的特殊情况。      </p>\n<p>ITestContext参数<br>如果一个数据提供者在方法签名中声名了一个ITestContext类型的参数，TestNG就会将当前的测试上下文设置给它，这使得数据提供者能够知道当前测试执行的运行时刻参数。     </p>\n<pre><code>@DataProvider\npublic Object[][] randomIntegers(ITestContext context)\n{\n　　String[] groups = context.getIncludeGroups();\n\n　　int size = 2;\n　　for (String group : groups) {\n　　　　if (group.equals(&quot;functional-test&quot;)) {\n　　　　　　size = 10; \n　　　　　　break;\n　　　　}\n　　}\n\n　　Object[][] result = new Object[size][];\n　　Random r = new Random();\n　　for (int i = 0; i &lt; size; i++) {\n　　　　result[i] = new Object[] { new Integer(r.nextInt()) };\n　　}\n\n　　return result;\n}\n\n@Test(dataProvider = &quot;randomIntegers&quot;, groups = {&quot;unit-test&quot;, &quot;functional-test&quot;})\npublic void random(Integer n)\n{\n　　// ......\n} \n</code></pre><p>ITestContext对象中的数据是运行时刻的信息，不是静态的信息：这个测试方法即属于unit-test组，也属于functional-test组，但在运行时刻，我们决定只执行functional-test组，这个值由ITestContext#getIncludeGroups方法返回。    </p>\n<p>延迟数据提供者   </p>\n<p>为了实现这种方法，TestNG允许我们从数据提供者返回一个Iterator，而不是一个二维对象数组。    </p>\n<p>这种方法与数组不同之处在于，当TestNG需要从数据提供者取得下一组参数时，他会调用Iterator的next方法，这样就有机会在最后一刻实例化相应的对象，即刚好在需要这些参数的测试方法被调用之前。    </p>\n<pre><code>@DataProvider(name = &quot;generate-accounts-lazy&quot;)\npublic Iterator generateAccountsLazy\n{\n　　return new AccountIterator();\n}\n\n@Test(dataProvider = &quot;generate-accounts-lazy&quot;)\npublic void testAccount(Account a)\n{\n　　System.out.println(&quot;Testing account &quot; + a);\n}\n\nclass AccountIterator implements Iterator\n{\n　　private static final int MAX = 4;\n　　private int index = 0;\n\n　　public boolean hasNext()\n　　{\n　　　　return index &lt; MAX;\n　　}\n\n　　public Object next()\n　　{\n　　　　return new Object[] { new Account(index++); } \n　　}\n\n　　public void remove()\n　　{\n　　　　throw new UnsupportedOperationException(); \n　　}\n}\n</code></pre><p>如果传递的参数是简单类型的常数，利用testng.xml的方法是很好的。档我们需要更多灵活性，并知道参数的数目和值将随时间增加时，我们可能应该选择@DataProvider。  </p>\n<p>提供数据<br>数据的位置可能是：硬编码在Java源码中、再文本文件中、在属性文件中、在Excel表格中、在数据库中、在网络中…。   </p>\n<p>数据提供者还是工厂<br>数据提供者向测试方法传递参数，而工厂像构造方法传递参数。   </p>\n<p>不如不能确定使用哪种方法，那么就看看测试方法所使用的参数。是否有几个测试方法需要接收同样的参数？如果是这样，您可能最好是将这些参数保存在一个字段中，然后在几个方法中复用这个字段，这就意味着最好是选择工厂。反之，如果所有的测试方法都需要传入不同的参数，那么数据提供者可能是最好的选择。    </p>\n<p>异步测试<br>异步代码通常出现在下列领域：    </p>\n<ul>\n<li>基于消息的框架，其中发送者和接收者是解耦合的。(JMS)</li>\n<li>由java.util.concurrent提供的异步机制(FutureTask)</li>\n<li>由SWT或Swing这样的工具集开发的图形用户界面，其中代码与主要的图形部分运行在不同的线程中。</li>\n</ul>\n<p>测试异步代码比测试同步代码的问题更多：</p>\n<ul>\n<li>无法确定异步调用何时质性。</li>\n<li>无法确定异步调用是否会完成。</li>\n</ul>\n<p>当调用异步时有三种可能的结果：</p>\n<ul>\n<li>调用完成并成功。</li>\n<li>调用完成并失败。</li>\n<li>调用没有完成。<br>基本上，异步编程遵循着一种非常简单的模式：在发出一个请求时指定一个对象或一个函数，当收到响应时系统会调用回调。</li>\n</ul>\n<p>测试异步代码也同样遵循下面的模式：     </p>\n<p>发出异步调用，他会立即返回。如果可能，制定一个回调对象。     </p>\n<p>如果有回调方法：    </p>\n<p>等待结果，在接到结果是设置布尔变量，反应结果是否是您的预期。    </p>\n<p>在测试方法中，监视那个布尔变量，等到他被设置或过了一段时间。   </p>\n<p>如果没有回调方法：    </p>\n<p>在测试方法中，定期检查预期的值。如果过了一段时间还没有检查到预期值，就失败并退出。</p>\n<p>不指定回调方法    </p>\n<pre><code>private volatile boolean success = false;\n\n@BeforeClass\npublic void sendMessage()\n{\n　　// send the message;\n　　// Successful completion should eventually set success to true;\n}\n\n@Test(timeOut = 10000)\npublic void waitForAnswer()\n{\n　　while (!success) {\n　　　　Thead.sleep(1000);\n　　}\n}\n</code></pre><p>在这个测试中，消息是作为测试初始化的一部分，利用@BeforeClass发出的，这保证了这段代码在测试方法调用之前执行并且只执行一次。在初始化后TestNG将调用waitForAswer测试方法，他将进行不完全忙等。   </p>\n<p>有回调方法：</p>\n<pre><code>@Test(groups = “send”)\npublic void sendMessage()\n{\n　　// send the message\n}\n\n@Test(timeOut = 10000, dependsOnGroups = {“send”})\npublic void waitForAnswer()\n{\n　　while (!success) {\n　　　　Thread.sleep(1000);\n　　}\n}\n</code></pre><p>现在sendMessage()是一个@Test方法，他将包含在最终的报告中，如果发送消息失败，TestNG将跳过waitForAnswer测试方法，并把他表示为SKIP。    </p>\n<pre><code>@Test(timeOut = 10000, invocationCount=100, successPercentage = 98)\npublic void waitForAnswer ……\n</code></pre><p>TestNG调用该方法100次，如果98%的调用成功，就认为总体测试通过。    </p>\n<p>测试多线程代码<br>并发测试     </p>\n<pre><code>private Singleton singleton;\n\n@Test(invocationCount = 100, threadPoolSize = 10)\npublic void testSingleton()\n{\n　　Thread.yield();\n　　Singleton p = Singleton.getInstance();\n}\n\npublic static Singleton getInstance()\n{\n　　if (instance == null) {\n　　　　Thread.yield();\n　　　　Assert.assertNull(instance);\n　　　　instance = new Singleton();\n　　}\n　　return instance;\n}\n</code></pre><p>@invocationCount相当简单，在不考虑并发时也可以使用：他决定了TestNG调用一个测试方法的次数。    </p>\n<p>@threadPoolSize要求TestNG分配一定数量的线程，并使用这些线程来调用这个测试方法，当一个测试完成之后，执行他的线程将归还给线程池，然后可以用于下一次调用。   </p>\n<p>并发执行<br>    <suite name=\"”TestNG\" jdk=\"\" 1.5”=\"\" verbose=\"“1”\" parallel=\"“methods”\" thread-count=\"“2”\">……</suite><br>thread-count属性指定了线程数目，TestNG将使用这些线程来执行这个测试套件中的所有测试方法，parallel属性告诉TestNG您在执行这些测试时希望采用的并行模式。    </p>\n<p>parallel=”methods” 在这种模式下，每个测试方法将在他自己的一个线程中执行。    </p>\n<p>parallel=”test” 在这种模式下，在某个<test>标签内的所有测试方法将在他们自己的一个线程中执行。   </test></p>\n<p>在tests模式中，TestNG保证每个<test>将在他自己的线程中执行。如果希望测试不安全的代码，这一点是非常重要的。在method模式中，所有限制都被取消，无法预测哪些方法将在同一个线程中执行，哪些方法将在不同的测试中执行。    </test></p>\n<p>为可模拟性设计<br>为了能够成功地使用模拟模拟对象或桩，重要得失要确保代码的设计能让使用模拟对象或桩变得简单而直接。<br>这种设计最重要的方面就是正确的确定组件之间的交互，从而确定组件的交互接口。    </p>\n<p>如果我们有2个组件A和B，A需要用到B，那么应该通过B的接口来完成，而不是通过B的具体实现。   </p>\n<p>Singleton查找    </p>\n<pre><code>public void doWork1()\n{\n　　C c = C.getInstance();\n　　c.doSomething();\n}\n</code></pre><p>对于某个对象智能由一个实例，这在项目生命周期的后期产生阻碍效果。   </p>\n<p>JNDI定位服务     </p>\n<pre><code>public void doWork2()\n{\n　　C c = (C) new InitialContext().lockup(&quot;C&quot;);\n　　c.Something();\n}\n</code></pre><p>不能够向A提供一个受控制的B的实例。只有一个全局实例，A只能取得这个实例。     </p>\n<p>依赖注入    </p>\n<pre><code>private C c;\n\npublic void setC(C c)\n{\n　　this.c = c; \n}\n</code></pre><p>从外部通知A应该使用哪个B的实例。这让我们能够根据实际情况灵活地决定向A提供B的哪个实例。   </p>\n<p>EasyMock</p>\n<pre><code>import static org.easymock.EasyMock.*;\n\npublic class EasyMockUserManagerTest\n{\n　　@Test\n　　public void createUser()\n　　{\n　　　　UserManager manager = new UserManagerImpl();\n　　　　UserDao dao = createMock(UserDao.class);\n　　　　Mailer mailer = createMock(Mailer.class);\n\n　　　　manager.setDao(dao);\n　　　　manager.setMailer(mailer);\n\n　　　　expect(dao.saveUser(&quot;tester&quot;)).andReturn(true);\n　　　　expect(mailer.sendMail(eq(&quot;tester&quot;), (String) notNull(), (String) notNull())).addReturn(true);\n\n　　　　replay(dao, mailer);\n\n　　　　manager.createUser(&quot;tester&quot;);\n　　　　verify(mailer, dao);\n　　}\n}\n</code></pre><p>1创建模拟对象<br>这是通过createMock方法完成的，传入希望模拟的类作为参数。    </p>\n<p>2纪录预期行为<br>只要在模拟对象上调用我们预期会被调用的方法，就能纪录预期的行为。当用到某些具体的参数时，只要将这些参数传入就可以了。</p>\n<p>3调用主要被测对象<br>在主要的被测对象上调用一个方法或一组方法，预期这次调用将倒置被测对象调用模拟对象的那些预期的方法。    </p>\n<p>4验证预期行为<br>最后调用verify，检查所有的模拟对象。   </p>\n<p>JMock<br>jMock是一个模拟库，她让我们通过编成的方式来之行约束条件。     </p>\n<p>选择正确的策略    </p>\n<p>缺少接口<br>有时候，我们面对的是庞大臃肿的遗留系统，没有向期望的那样有很好的设计。<br>大多数模拟库现在都允许替换类，而不仅是接口。这些库会在运行时刻生成一个新类，通过字节码操作来实现指定的契约。    </p>\n<p>复杂的类<br>如果我们得到了一些类，他们拥有20多个方法，与许多其他组件交互，而且随着是间的推移变得越来越复杂。<br>这种情况下，使用动态的模拟对象库效果会比较好，因为他们能够定义单个方法的行为，而不是考虑所有的方法。    </p>\n<p>契约纪录<br>使用模拟对象让我们记录更多的契约信息，而不止是方法签名。我们可以随时验证器乐的。    </p>\n<p>测试目标<br>根据经验法则，如果希望测试组件之间交互，模拟对象可能优于桩对象。模拟库能够以一种准确的方式来指定交互。而桩该作为被测试组件使用的那些次要的组件。在这种情况下，测试的目标是测试被测试组件本身，而不是他与其他组件之间的交互。   </p>\n<p>模拟易犯的错误<br>依赖模拟对象会导至许多问题，所以重要的是要知道使用模拟对象不利的一面：     </p>\n<ul>\n<li>模拟外部API行   </li>\n<li>虚假的安全感</li>\n<li>维护开销</li>\n<li>继承与复杂性</li>\n</ul>\n<p>依赖的测试<br>层叠失败：一个测试的失败导致一组测试的失败。   </p>\n<p>依赖的代码<br>只要测时方法依赖于其他测试方法，就很难以隔离的方式执行这些测试方法。<br>彼此依赖的测试方法通常会出现这样的情况，因为他们共享了一些状态，而在测试之间共享状态是不好的。   </p>\n<p>利用TestNG进行依赖的测试<br>TestNG通过@Test annotation的两个属性(dependsOnGroups和dependsOnMethods)赖支持依赖的测试。    </p>\n<pre><code>@Test\npublic void launchServer() {}\n\n@Test(dependsOnMethods = &quot;launchServer&quot;)\npublic void deploy() {}\n\n@Test(dependsOnMethods = &quot;deploy&quot;)\npublic void test1() {}\n\n@Test(dependsOnMethods = &quot;deploy&quot;)\npublic void test2() {}\n</code></pre><p>dependsOnMethods的问题:<br>通过字符串来执行方法名称，如果将来对他进行重构，代码就有可能失效。方法名称违反了”不要重复自己”的原则，方法名称即在Java方法中用到，也在字符串中使用，另外，等我们不断添加新的测试方法时，这个测试用例伸缩性也不好。    </p>\n<pre><code>@Test(groups = &quot;init&quot;)\npublic void launchServer() {}\n\n@Test(dependsOnGroups = &quot;init&quot;, groups = &quot;deploy-apps&quot;)\npublic void deploy() {}\n\n@Test(dependsOnGroups = &quot;init&quot;, groups = &quot;deploy-apps&quot;)\npublic void deployAuthenticationServer() {}\n\n@Test(dependsOnGroups = &quot;deploy-apps&quot;)\npublic void test1() {}\n\n@Test(dependsOnGroups = &quot;deploy-apps&quot;)\npublic void test2() {}\n</code></pre><p>利用组来指定依赖关系可以解决我们遇到的所有问题：   </p>\n<ul>\n<li>不在遇到重构问题，可以任意秀该方法的名称。</li>\n<li>不再违反DRY原则。</li>\n<li>当新方法须要加入到依赖关系中时，只要将他放到适当的组中，并确保他依赖于正确的组。</li>\n</ul>\n<p>依赖的测试和线程<br>当打算并行执行测试时，要记住，线程池中的一个或多个线程将用于依次执行每个方法。所以，如果打算在不同的线程中执行一些测试，过渡的使用依赖的测试将影像执行性能。    </p>\n<p>配置方法的失败<br>依赖测试方法和配置方法之间唯一的不同就是，测试方法隐式的依赖于配置方法。   </p>\n<p>虽然dependsOnMethods可以处理简单的测试或之由一个测试方法依赖于另一个测试方法的情况，但是在大多数情况下，您都应该使用dependsOnGroups，这种方式的伸缩性好，面对将来的重构也更为健壮。   </p>\n<p>既然我们提供了准去的依赖信息，那么TestNG就能够按照于骑的顺序来执行测试。    </p>\n<p>测试隔离并没有因此而受到影响。    </p>\n<p>如果出现层叠式的错误，依赖测试可以加快测试执行速读。    </p>\n<p>继承和annotation范围</p>\n<pre><code>public class CreditCardTest\n{\n　　@Test(groups = &quot;web.credit-card&quot;)\n　　public void test1() {}\n\n　　@Test(groups = &quot;web.credit-card&quot;)\n　　public void test2() {}\n}\n</code></pre><p>他违反了”不要重复自己”的原则<br>他为将来添加测试方法的开发者带来了负担。     </p>\n<pre><code>@Target({METHOD, TYPE, CONSTRUCTOR})\npublic @interface Test{}\n\n\n@Test(groups = &quot;web.credit-card&quot;)\npublic class CreditCardTest\n{\n　　public void test1() {}\n　　public void test2() {}\n}\n</code></pre><p>annotation继承     </p>\n<pre><code>@Test(groups = &quot;web.credit-card&quot;)\nclass BaseWebTest {}\n\npublic class WebTest extends BaseWebTest \n{\n　　public test1() {}\n　　public test2() {}\n}\n</code></pre><p>所有扩展自BaseWebTest的类都会看到，他们所有的工有方法都自动成为web.credit-card组的成员。<br>WebTest变成了一个普通的传统Java对象(POJO),不带任何annotation。    </p>\n<p>集成易犯的错误<br>由于TestNG的测试方法必须是公有的，在基类中声明的方法会自动在子类中可见，所以他们永远也不需要作为测试类显式的列出(不要将测试基类列在testng.xml文件中)     </p>\n<p>测试分组<br>分组解决了上面提到的局限性，实际上，他们进一步提升了TesgNG的一个设计目标：在静态模型(测试代码)和动态模型(执行哪些测试)之间实现清晰的分离。    </p>\n<p>语法<br>@Test annotation和配置annotation(@BeforeClass, @AfterClass, @BeforeMethod…)都可以属于分组</p>\n<pre><code>@Test(groups = {&quot;group1&quot;})\n@Test(groups = {&quot;group1&quot;, &quot;group2&quot;})\n@Test(groups = &quot;group1&quot;)\n\n@Test(groups = &quot;group2&quot;)\npublic class B\n{\n　　@Test\n　　public test1() {}\n\n　　@Test(groups = &quot;group3&quot;)\n　　public test2() {}\n}\n</code></pre><p>test1属于group2组，test2同时属于group2组和group3组</p>\n<p>分组与运行时刻</p>\n<pre><code>&lt;suite name=&quot;Simple suite&quot;&gt;\n　　&lt;test name=&quot;GroupTest&quot;&gt;\n　　　　&lt;groups&gt;\n　　　　　　&lt;run&gt;\n　　　　　　　　&lt;include name=&quot;group1&quot; /&gt;\n　　　　　　&lt;/run&gt;\n　　　　&lt;/groups&gt;\n　　　　&lt;classes&gt;\n　　　　　　&lt;class name=&quot;com.example.A&quot; /&gt;\n　　　　&lt;/classes&gt;\n　　&lt;/test&gt;\n&lt;/suite&gt;\n</code></pre><p>这个testng.xml告诉TestNG执行com.example.A类中所有属于group1组的测试方法。    </p>\n<pre><code>&lt;include name=&quot;database&quot; /&gt;\n&lt;exclude name=&quot;gui&quot; /&gt;\n</code></pre><p>如果某个方法即属于包含的组，又属于排除的组，那么排除的组优先。<br>如果既没有include，也没有exclude，那么TestNG将忽略组，执行所有的测试方法。   </p>\n<p>另一个功能就是可以在testng.xml中利用正则表达式来指定组。</p>\n<pre><code>&lt;groups&gt;\n　　&lt;define name=&quot;all-web&quot;&gt;\n　　　　&lt;include name=&quot;jsp&quot; /&gt;\n　　　　&lt;include name=&quot;servlet&quot; /&gt;\n　　&lt;/define&gt;\n　　&lt;run&gt;\n　　　　&lt;include name=&quot;all-web&quot;&gt;\n　　&lt;/run&gt;\n&lt;/groups&gt;\n</code></pre><p>在设计组的层次关系时，能够在testng.xml中定义新组带来灵活性：<br>可以在代码中使用粒度非常小的分组，然后在运行时刻将这些小分组合并成大分组。     </p>\n<p>执行分组<br>利用命令行执行      </p>\n<pre><code>java org.testng.TestNG -groups jsp -groups servlet -excludegroups broken com.example.MytestClass\n</code></pre><p>利用ant     </p>\n<pre><code>&lt;testng groups=&quot;jsp, servlet&quot; excludegroups=&quot;broken&quot;&gt;\n　　&lt;classfileset&gt;\n　　　　&lt;include name=&quot;com/example/MyTestClass.class&quot; /&gt;\n　　&lt;/classfileset&gt;\n&lt;/testng&gt;\n</code></pre><p>利用Maven     </p>\n<pre><code>&lt;dependencies&gt;\n　　&lt;dependency&gt;\n　　　　&lt;groupId&gt;org.testng&lt;/groupId&gt;\n　　　　&lt;artifactId&gt;testng&lt;/artifactId&gt;\n　　　　&lt;version&gt;5.10&lt;/version&gt;\n　　　　&lt;classifier&gt;jdk15&lt;/classifier&gt;\n　　&lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n　　&lt;plugins&gt;\n　　　　&lt;plugin&gt;\n　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n　　　　　　&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n　　　　　　&lt;version&gt;2.5&lt;/version&gt;\n\n　　　　　　&lt;configuration&gt;\n　　　　　　　　&lt;suiteXmlFiles&gt;\n　　　　　　　　　　&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;\n　　　　　　　　&lt;suiteXmlFiles&gt;\n　　　　　　&lt;/configuration&gt;\n　　　　&lt;/plugin&gt;\n　　&lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p>利用Java API    </p>\n<pre><code>TestNG tng = new TestNG();\ntng.setGroups(&quot;jsp, servlet&quot;);\ntng.setExcludeGroups(&quot;broken&quot;)\n</code></pre><p>排除失败的测试<br>创建一个特书的组如broken</p>\n<pre><code>@Test(groups = { &quot;web&quot;, &quot;broken&quot;})\n</code></pre><p>然后在运行时刻排除这个组。    </p>\n<pre><code>&lt;exclude name=&quot;broken&quot; /&gt;\n</code></pre><p>组分类    </p>\n<p>测试类型:单元测试、继承测试<br>测试规模:小规模、大规模<br>功能描述:数据库、界面<br>测试速度:慢测试、快测试<br>过程描述:冒烟测试、发布测试    </p>\n<p>让开发者能够指定方法的分组，主要的好处在于开发者因此能够很容易找出他们需要执行哪些测试。(如刚刚修改了数据库代码，可能只需要执行fast和database组测试)     </p>\n<p>组命名    </p>\n<pre><code>@Test(groups = {&quot;os.linux.debian&quot;})\n@Test(groups = {&quot;database.table.ACCOUNTS&quot;})\n@Test(groups = {&quot;database.ejb3.connection&quot;})\n</code></pre><p>TestNG能够利用正则表达式来之定要执行的组，如果与这项功能配合使用，这种命名方式就很有用了。    </p>\n<pre><code>&lt;groups&gt;\n　　&lt;run&gt;\n　　　　&lt;include name=&quot;database.*&quot; /&gt;\n　　&lt;/run&gt;\n&lt;/groups&gt;\n</code></pre><p>代码覆盖率<br>类的覆盖率：类覆盖描熟了项目中多少类已被测试套件访问。　<br>方法覆盖率：方法覆盖率是被访问的方法的百分比。<br>语句覆盖率：语句覆盖率追踪单条源代码语句的调用。<br>语句块覆盖率：语句快覆盖率将语句块作为基本的覆盖律单元。<br>分支覆盖率：分支覆盖率也被称为判断覆盖率。指标计算哪些代码分支被执行。    </p>\n<p>覆盖律工具<br>Clover、EMMA和Cobertura    </p>\n<p>成功使用覆盖率的建议<br>覆盖率报告的信息何音的解读不同<br>覆盖率很难<br>百分比没有意义<br>为覆盖率而设计是错误得<br>有一点好过没有<br>覆盖律工具不会测试不存在的代码<br>覆盖率的历史讲述了自己的故事   </p>\n<p>企业级测试<br>单元测试：单元测试对系统中的一个单元进行独立的测试。    </p>\n<p>功能测试：功能测试关注一项功能。通常涉及不同组件之间的交互。    </p>\n<p>继承测试：继承测试是一种端到端的测试，他会执行整个应用栈，包括所有的外部依赖关系或系统。    </p>\n<p>一个具体的例子<br>系统中有一个相当典型的组件，他接收一条JMS消息，其中包含一段有效的XML文本。这段XML文本相当长，描述了一笔财务交易。这个组件的工作是读出这条消息，解析XML，根据消息的内容条填充一些数据库的表，然后调用一个存储过程来处理这些表。    </p>\n<p>测试内容     </p>\n<p>我们将创建一个成功测试。希望确保，如果收到一条有效的XML消息，我们会正确地处理他，并更新正确的数据表，然后存储过程的调用也成功。<br>我们将摹拟不同的场景。希望能够为测试替工不同的XML文本，这样就能够很容易地不断添加测试粒子数据。<br>我们提供明确的失败测试。失败的行为将被记录和测试，这样当组件内部出现失败时，他的状态就可以与测，并且很容易记录下来。    </p>\n<p>非测试内容    </p>\n<p>我们不测试JMS provider的功能。假定他是一个完全兼容的实现，已经正确的进行了配置，将成功地提交我们期望的消息。<br>我们不执行捕捉所有错误得测试。失败测试应该针对明确的、可重现的失败场景。<br>我们不测试API。例如，JDBC去冬的行为不是测试的主题。确保所有的测试都贯注业务功能，要避免对Java语言的语义进行测试。     </p>\n<p>测试成功场景<br>对于JMS API的接口<br>利用模拟对象(或桩)对象，创建TextMessage实现，用一个简单的POJO来表现，带有消息内容和其他属性的设置方法。<br>重构该组件，解除业务功能与JMS API的耦合。    </p>\n<pre><code>public void onMessage(Message message)\n{\n    TextMEssage tm = (TextMessage) message;\n    processDocument(tm.getText());\n}\n\npublic void processDocument(String xml)\n{\n    // code previously in onMessage that updates DB\n}\n\n@Test\npublic void componentUpdateDatabase() throws Exception {}\n</code></pre><p>构件测试数据</p>\n<pre><code>@Test(dataProvider = &quot;&quot;)\npublic void componentUpdateDatabase() throws Exception  {}\n\n@DataProvider(name = &quot;component-data-files&quot;)\npublic Iterator&lt;Object[]&gt; loadXML() throws Exception {}\n</code></pre><p>我们的测试现在接受一个参数，不再需要自己考虑测试数据的来源，也不需要考虑如何加载测试数据。他要做的只是指定数据提供者。加载XML的实际工作现在代理给了一段独立的加载程序。    </p>\n<pre><code>@DataProvider(name = &quot;component-data-files&quot;)\npublic Iterator&lt;Object[]&gt; loadXML() throws Exception\n{\n    File[] f = new File(&quot;filepath&quot;).listFiles();\n    final Iterator&lt;File&gt; files = Arrays.asList(f).iterator();\n\n    return new Iterator&lt;Object[]&gt;() {\n        public boolean hasNext()\n        {\n            return files.hasNext();   \n        }\n\n        public Object[] next()\n        {\n            return new Object[] { IOUtils.readFile(files.next()) };\n        }\n\n        public void remove()\n        {\n            throw new UnsupportedOperationException(); \n        }\n    };\n}\n</code></pre><p>当然，可以从数据提供者返回一个Object[]的数组，但是，这种方法意味着我们必需将所有的文件的数据都一次性加载到内存中，因为数组必须事先填充。    </p>\n<p>测试准备问题    </p>\n<p>幂等的测试是指，这个测试执行一次和执行多次的结果是一样的。如果某个东西是幂等的，那么说明他在多次调用时状态不会改变。    </p>\n<p>不仅需要测试是幂等的，而且测试的次序应该无关紧要。所以除了需要是是幂等的之外，测试不应该在状态或数据方面影像其他测试。   </p>\n<p>对于一些写操作，成功执行之后很容易会对再次执行产生影响，下面方法有助于我们对付这个问题：    </p>\n<p>嵌入式数据<br>    有一些基于Java的数据库引擎，在设计时专门考虑了嵌入式支持。这些数据库可以在测试过程中临时创建并进行初始化。他们开销很小，通常性能不错。<br>    不足之处在于，它们与应用程序实际执行的环境差别非常大。通常在数据库特征上存在巨大的诧异。   </p>\n<p>在测试准备时初始化数据<br>    测试数据库总加载一定数量的已知测试数据。其中包含希望操作的所有数据，以及组件所依赖的所有外部引用。<br>    不足之处在于，很难维护一个健壮的数据集，使他对测试有足够的意义。   </p>\n<p>事务回滚<br>    另一种方法就是利用Java API来防止数据写入到持久数据存储中。总的方法是开是一个事务，执行所有的写操作，验证一切正常，然后让事务回滚。<br>    不足之处在于，如果没有复杂的嵌套事务准备，就不能测试参与事务的代码或开始自己的事务的代码。   </p>\n<p>选择正确的策略   </p>\n<pre><code>private WrappedConnection wrappedConnection;    \n\n@BeforeMethod   \npublic void connection() throws SQLException\n{\n    connection = DatabaseHelper.getConnection();\n    connection.setAutoCommit(false);\n    wrappedConnection = new WrappedConnection(connection);\n    wrappedConnection.setSuppressCommit(true);\n}\n\n@AfterMethod\npublic void rollback() throws SQLException\n{\n    wrappedConnection.rollback(); \n}\n\npublic class WrappedConnection implements Connection\n{\n    private Connection connection;\n    private boolean suppressClose;\n    private boolean suppressCommit;\n\n    public WrappedConnection(Connection connection)\n    {\n        this.connection = connection;    \n    }\n\n    public void commit() throws SQLException\n    {\n        if (!suppressCommit)    \n            connection.commit();\n    }\n\n    // ......\n}\n</code></pre><p>错误处理    </p>\n<pre><code>@Test(dataProvider = &quot;component-data-files&quot;)\npublic void componentupdateDatabase(String xml) throws Exception\n{\n    Component component = new Component();\n    try {\n        component.processDocument(xml);\n    }\n    catch (InvalidTradeException e) {\n        return;\n    }\n    // rest of test code\n}\n</code></pre><p>这种方法在于，他们没能让我们区分失败是否是预期的。相反，我们应该能够区分预期的成功和预期的失败。这个测时目前在两种情况下会通过：要么遇到好的数据时会通过，要么遇到坏数据时会通过。在每种情况下，我们都不能确定会发生些什么。   </p>\n<p>一个测试不应该在两种或两种以上的情况下都通过。如果测试验证了不同的失败情况，这没问题，但如果测试在好数据和坏数据的情况下都通过，那就会导致一些微妙的错误，这类错误难以被发现。(因此我们定义了另一个目录和数据提供者来处理失败的情况)     </p>\n<pre><code>@Test(dataProvider = &quot;component-invalid-data-files&quot;, expectedException = InvalidTradeException.class)\npublic void componentInvalidInput(String xml) throws Exception\n{\n    Component component = new Component();\n    component.processDocument(xml);\n    // rest of test code\n}\n</code></pre><p>逐渐出现的单元测试<br>单元测试不一定是在其它测试之前编写的，他们可以是功能测试驱动的。特别是对于大型项目或原有的代码来说，一开始就编写有用的单元测试可能很困难，因为在不了解全局的情况下，单元测试可能太琐碎或不太重要。相反，单元测试可以从有意义的继承测试中推导出来，因为调试开发功能测试和集成测试的过程揭示他们所需的单元测试。    </p>\n<p>对于例子来说我们需要将XML验证与数据库处理放到各自独立的方法中。这样就能对他们进行测试    </p>\n<pre><code>public void processDocument(String xml) throws InvalidDocumentException\n{\n    Document doc = XMLHelper.parseDocument(xml);\n    validateDocument(doc);\n    // ......\n}\n\npublic void validateDocument(Document doc) throws InvalidDocumentException\n{\n    // perform constraint checks that can&apos;t be captured by XML\n}\n</code></pre><p>这测重构的结果是我们得到了一个简单的单元测试。   </p>\n<p>不论测试编写的次序如何，功能测试和单元测试都是互不的。功能测试是更为水平化的测试，涉及许多不同的组件，执行代码的很多部分。相反，单元测试是更为垂直化的测试，他关注范围狭窄的主题，比功能测试要彻底得多。   </p>\n<p>竞争消费者模式<br>消费者的执行是并发的，所以我们必须在测试中进行某种程度的模拟，生产环境中的真实情况。在我们这样作了之后，也希望验证结果。不论哪个消费者先开始，也不论哪个消费者先结束，都没有关系。我们希望确定对于给定数量的消费者，我们将得道一组已知的结果，可以进行验证。   </p>\n<pre><code>private final List&lt;Object[]&gt; data = Collections.synchronizedList(new ArrayList&lt;Object[]&gt;());\n\n@BeforeClass\npublic void populateData()\n{\n    data.add(new Object[] {&quot;value1&quot;, &quot;prop1&quot;});\n    data.add(new Object[] {&quot;value2&quot;, &quot;prop2&quot;});\n    data.add(new Object[] {&quot;value3&quot;, &quot;prop3&quot;});\n}\n\n@Test(threadPoolSize = 3, invocationCount = 3, dataProvider = &quot;concurrent-processor&quot;)\npublic void runConcurrentProcessors(String value, String someProp)\n{    \n    MessageProcessor processor = new MessageProcessor();\n    processor.process(value, someProp);\n}\n\n@Test(dependsOnMethods = &quot;runConcurrentProcessors&quot;)\npublic void verifyConcurrentProcessors()\n{\n    // load data from db\n    // verify that we have 3 results\n    // verify that each of the 3 result matches our 3 input\n}\n\n@DataProvider(name = &quot;concurrent-processor&quot;)\npublic Object[][] getProcessorData()\n{\n    return new Object[][] {data.remove(data.size() - 1)};\n}\n</code></pre><p>我们的测试被分成两个，一个负责执行消费者，另一个负责验证结果。原因是runConcurrentProcessors会被调用多次，而我们只需要在所有方法调用完成之后，对结果验证一次。为了表示这种次序，我们利用了dependsOnMethods这个annotation属性。   </p>\n<p>当TestNG发现一个数据提供者时，他将针对数据提供者返回的每一条数据调用一次测试。类似的，当我们指定调用次数时，TestNG会按照指定的次数调用测试。因此，如果我们返回数据提供者中准备好的3条数据，那么每个线程都会执行3次测试。    </p>\n<p>因此解决方案是使用一个栈结构，每次调用数据提供者时，返回一条数据，并将这条数据从列表中清除。数据提供者将被调用3次，每次都将为数据返回不一样的数据。    </p>\n<p>原则：将数据的考虑和功能的考虑分开来是很关键的。<br>在这个例子中，消费者需要的数据应该和实际的测试没有依赖关系。这种方法意味着，随着我们对数据的需求不断变化，变得更为复杂，测试本身却不需要被修改。    </p>\n<p>一个具体的例子<br>我们希望测试一个登录servlet。这个servlet接受一个请求，检查用户名和口令，如果他们有效，就在会话中加入一个标记。表明用户已登录。   </p>\n<p>这个例子展示了重构在测试方面起到的重要辅助作用，说明了即使对于看上去很麻烦、需要一很复杂地方是进行交互的API，页可以通过抽象去掉依赖关系。这种抽象意味着 在测试过程中，我们可以利用更简单的对象，这些对象更容易构造，因此也更容易测试。    </p>\n<p>增加可测试性的一个副作用就是改进了设计。为提高可测试性而进行重构，可以帮助我们以一种实际的、代码中的方式来确定职责和考虑，而这种效果通过画设计图是很难达到的。   </p>\n<p>Java EE测试<br>容器内测试与容器外测试的对比    </p>\n<p>容器内测试<br>优点：<br>    完全符合运行时环境   </p>\n<p>缺点：<br>    启动消耗大<br>    难以部署新的测试<br>    难以自动化<br>    夸平台测试的复杂性增加    </p>\n<p>容器外测试<br>优点：<br>    提供了相对较快的启动<br>    可以完全控制环境<br>    可以自动化<br>    容易测试<br>缺点：<br>    没有符合运行时环境<br>    测试所用的实现可能与运行时的实现来自不同的提供商。   </p>\n<p>容器内测试<br>测试步骤：   </p>\n<p>创建一个测试环境的实例。<br>确定测试。<br>在测试框架中注册测试。<br>注册一个监听者来接收搜测试结果。   </p>\n<p>创建测试环境    </p>\n<pre><code>TestNG tester = new TestNG();\ntester.setDeafultSuiteName(&quot;container-tests&quot;);\n</code></pre><p>确定测试<br>假定所有的测试类都在WEB-INF/classes目录下，我们可以递归地读入这个目录，找到其中所有的类文件。    </p>\n<pre><code>public static Class[] scan(ServletContext context)\n{\n    String root = context.getReadPath();\n    ClassScanner scanner = new ClassScanner(new File(root));\n    scanner.setClassLoader(ClassScanner.class.getClassLoader());\n    final File testDir = new File(root, &quot;com/foo/tests&quot;);\n    scanner.setFilter(new FileFilter() {\n        public boolean accept(File pathname) {\n            return pathname.getPath().startsWith(testDir.getPath());\n        }    \n    });\n    Class[] classes = scanner.getClasses();\n    return classes;\n}\n</code></pre><p>context是一个ServletContext实例，他是通过调用servlet或JSP页面得到的。   </p>\n<p>注册测试<br>注册测试类的动作告诉了TestNG他要查看的一组类，TestNG将在这组类中查找需要执行哪些测试。他将检查每个指定的类，确定他是否包涵测试方法或配置方法。当所有类都检查过后，TestNG内部会生成一个依赖关系图，以决定照到的这些测试的执行次序。    </p>\n<pre><code>tester.setTestClasses(classes);\n</code></pre><p>注册结果监听者    </p>\n<p>TestNG自代了3个默认的报告类：    </p>\n<p>SuiteHTMLRepoter 默认报告类，他在一个目录下输出交叉引用HTML文件，让您能看到某个具体测试的结果。   </p>\n<p>FailedReporter: 这个报高生成一个TestNG执行配置，该配置包含了所有前一次运行时失败的测试。他也是默认运行的。   </p>\n<p>EmailableReporter: 这个报告类生成一个报告文件，可以很容易地通过电子邮件发送，显示测试的结果。   </p>\n<p>默认情况下，EmailableReporter在磁盘上生成一个文件。    </p>\n<pre><code>public class SinglePageReporter extends EmailableReporter\n{\n    private Writer writer;\n\n    public SinglePageReporter()\n    {\n        this.writer = writer;\n    }\n\n    protected PrintWriter createWriter(String out)\n    {\n        return new PrintWriter(writer);\n    }\n}\n</code></pre><p>调用TestNG的JSP页面    </p>\n<pre><code>&lt;%@ page import=&quot;org.testng.*, java.io.*&quot; %&gt;\n&lt;%\n    TestNG tester = new TestNG();\n    tester.setDefaultSuiteName(&quot;container-tests&quot;);\n\n    String root = application.getRealPath(&quot;/WEB-INF/classes&quot;);\n    ClassScanner scanner = new ClassScanner(new File(root));\n    scanner.setLoader(getClass().getClassLoader());\n    scanner.setFilter(new FileFilter() {\n        public boolean accept(File pathname) {\n            return pathname.getPath().indexOf(Test) &gt; -1;\n        }\n    });\n\n    Class[] classes = scanner.getClasses();\n    tester.setTestClasses(classes);\n\n    IReporter reporter = new SinglePageReporter(out);\n    tester.addListener(reporter);\n\n    tester.run();\n%&gt;\n</code></pre><p>Java命名和目录接(JNDI)<br>JNDI是一个在全局目录中查找资源的API。可以把他看成是一个很大的树型结构，我们在其中按照名称查找某个节点。    </p>\n<pre><code>new InitialContext().lockup(&quot;someObject&quot;);     \n</code></pre><p>上面创建一个InitialContext对象，如果在执行容器内执行，会利用供应商提供的API实现，来查找容器内部命名目录结构。创建了上下文之后，我们在其中查找对象，列出他的内容，或遍历这棵树。所有这些都是通过JNDI API来完成的。InitialContext的构造方法由一个重载的版本，接受一个Hashtable对象作为参数，其中包含不同的环境变量值，决定了上下文应该如何创建。    </p>\n<pre><code>Hashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;&quot;);\nenv.put(Context.PROVIDER_URL, &quot;smqp://localhost:4001&quot;);\nObject topic = new InitialContext(env).lookup(&quot;myTopic&quot;);\n</code></pre><p>避免JNDI<br>组件依赖关系要么通过服务定位(通常是JNDI)来实现，要么通过注入来实现。如果您可以选择，就采用注入的方式，因为这样测试的开销最小，并且这种方式带来了更大的灵活性。   </p>\n<p>Java消息服务(JMS)   </p>\n<pre><code>private Session session;\nprivate Destination destination;\n\n@BeforeClass(groups = &quot;jms&quot;)\npublic void setupJMS() throws NamingException, JMSException\n{\n    Hashtable env = new Hashtable();\n    // populate environmet for out specific provider\n    InitialContext context = new InitialContext(env);\n\n    ConnectionFactory factory = (ConnectionFactory) context.lookup(&quot;QueueConnectionFactory&quot;);\n    Connection connection = factory.createConnection();\n    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    destination = (Detination) context.lookup(&quot;TestQueue@router1&quot;);\n}\n\n\n@Test(groups = &quot;jms&quot;)\npublic void sendMessage() throws JMSException\n{\n    TextMessage msg = session.createTextMessage();\n    msg.setText(&quot;hello!&quot;);\n    msg.setStringProperty(&quot;test&quot;, &quot;test1&quot;);\n    session.createProducer(destination).send(msg);\n}\n\n@Test(groups = &quot;jms&quot;, dependsOnMethods = &quot;sendMessage&quot;, timeOut = 1000)\npublic void receiveMessage() throws JMSException\n{\n    MessageConsumer consumer = session.createConsumer(destination, &quot;test&quot;, &quot;test1&quot;);\n    TextMessage msg = (TextMessage) consumer.receive();\n    assert &quot;hello!&quot;.equals(msg.getText());\n}\n</code></pre><p>在测试中使用ActiveMQ   </p>\n<pre><code>@BeforeClass(groups = &quot;jms&quot;)\npublic void setupActiveMQ() throws Exception\n{\n    BrokerService broker = new BrokerService();\n    broker.setPersistent(false);\n    broker.setUseJmx(false);\n    broker.start();\n\n    URI uri = broker.gettVmCnnectionURI();\n    ConnectionFactory factory = new ActiveMQConnectionFactory(uri);\n    Connection connection = factory.createConnection();\n    connection.start();\n\n    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    destination = session.createQueue(&quot;TestQueue@router1&quot;);\n}\n</code></pre><p>处理状态<br>在JMS的例子中，当我们拥有多个测试时，会引发一个有趣的问题。因为测试是由一对方法组成的，所以让我们假定同一个类中还有另一对发送/接收测试。    </p>\n<p>一种方法是将发送和接受者放在一个测试中，并在每个测试方法之前初始化消息代理。请注意两点都要做到，因为让消息代里在一对测试方法之前初始化是比较麻烦的。    </p>\n<p>另一种方法是使用消息分捡器。JMS消息分捡器让我们能够过滤接收到的消息，这样可以只接收与分捡器匹配的消息。   </p>\n<p>Spring<br>Spring的测试包功能     </p>\n<p>TestNG通过自己的一组针对Spring的类来解决这些问题，这些类作为扩展提供。org.testng.spring.test包中包含了所有Spring在其测试包中提供的类，这些类已修改过，可以用在基于TestNG的测试中。   </p>\n<p>AbstractSpringContextTests<br>这是所有Spring测试的基类。他的主要职责是提供上下文的管理。这个类包含一个静态map，其中包含所有注册的Spring上下文。   </p>\n<p>AbstractSingleSpringContextTests<br>这个类扩展了AbstractSpringContextTests，提供了装入一个ApplicationContext对象的钩子。他的子类应该实现getConfigLocation(String[] paths)方法。这个方法返回一个字符串数组，指出了Spring配置文件的位置，通常是从classpath加载的。    </p>\n<pre><code>import org.testng.annotation.Test;\nimport org.testng.spring.test.AbstractSingleSpringContextTests;\n\npublic class SpringContextTests extends AbstractSingleSpringContextTests\n{\n    protected String[] getConfigLocations()\n    {\n        return new String[] {&quot;/spring.xml&quot;};    \n    }\n\n    @Test\n    public void beanDefined()\n    {\n        assert applicationContext.getBean(&quot;myBean&quot;) != null;\n    }\n}\n</code></pre><p>Spring的配置方法被声明在名为Spring-init的TestNG分组中。我们不必依赖于单个的onSetUp或ontearDown方法，可以根据需要声明任意多个@BeforeMethod/@AfterMethod配置方法，只要指定他们依赖于spring-init，就可以确保他们在Spring执行完准备工作之后得到调用。    </p>\n<p>AbstractDependencyInjectionSpringContextTests<br>这个类提供的最有趣的功能就是向测试注入依赖。测试依赖关系可以表现为设值方法或成员字断。测试也可以指定Spring应该对他们的树性执行哪种类型的自动编织。    </p>\n<pre><code>public class SpringInjectionTests extends AbstractDependncyInjectionSpringContextTests\n{\n    private PersonManager manager;\n\n    protected String[] getConfigLocation()\n    {\n        return new String[] {&quot;/spring.xml&quot;};     \n    }\n\n    public void setManager(PersonManager manager)\n    {\n        this.manager = manager; \n    }\n\n    @Test\n    public void verifyManager()\n    {\n        assert manager != null;    \n    }\n}\n</code></pre><p>这个类有一个事务管理器属性。因为他派生自支持注入的类，配置文件中必需指定一个PlatforTransactionManager，以便注入。     </p>\n<pre><code>public class StrpingTranscationTests extends AbstractTransactionalSpringContextTests\n{\n    private PersonManager manager;\n\n    public void setManager(PersonManager manager)\n    {\n        this.manager = manager\n    }\n\n    protected String[] getConfigLocation()\n    {\n        return new String[] {&quot;/spring.xml&quot;};\n    }\n\n    @Test\n    public void savePerson()\n    {\n        Person p = new Person();\n        manager.savePerson(p);\n\n        assert p.getId() != null;\n        // setComplete();\n    }\n}\n</code></pre><p>我们没有在测试中指定任何事务行为，超类自动处理了事务方面的问题，让每个测试在他自己的事务中执行，这个十五将在该测试完成之后回滚。    </p>\n<p>增加的调用setComplete通知超类在测试执行之后应该提交这个事务，而不是回滚。调用这个方法由一个有趣的副作用：这个类中所有后续测试都会提交事务，而不是依赖于默认行为。   </p>\n<p>答案在于JUnit和TestNG之间的一个微妙区别。Spring测试假定采用了JUnit的语义。每个测试类对每个测试方法都会重新实例化。因此，所有的测试都假定每个测试开始时，测试时里的状态都会复原，但TestNG不是这样的。   </p>\n<p>AbstractTransactionalDataSouceSpringContextTests<br>这个类添加了一些JDBC相关的便利方法。   </p>\n<p>AbstractAnnotationAwareTransactionalTests<br>这个类支持超类提供的所有功能之外，这个类允许我们在测试方法上指定Spring特有的事务annotation，而不是通过编程的方式来指定事务行为。    </p>\n<p>Guice<br>第2章中的例子，对于每个接口，我们都有两个实现。一个是实际的产品实现，他会与一些外部的依赖关系进行交互，如UserDAO对象会与数据库交互，Mailer对象会与SMTP邮件服务器交互。我们还有桩对象实现。    </p>\n<pre><code>@Test\npublic void verifyCreateUser()\n{\n    UserManager manager = new UserManagerImpl();\n    MailerStub mailer = new MailerStub();\n\n    manager.setMailer(mailer);\n    manager.setDao(new UserDAOStub());\n\n    manager.createUser(&quot;tester&quot;);\n    assert mailer.getMails().size() == 1;\n}\n</code></pre><p>Guice注入测试    </p>\n<pre><code>@Inject private UserManager manager;\n@Inject private MailerStub mailer;\n\n@Test\npublic void verifyCreateUser()\n{\n    manager.createUser(&quot;tester&quot;);    \n    assert mailer.getMails().size() == 1;\n}\n</code></pre><p>Spring注入测试    </p>\n<pre><code>private UserManager manager;\nprivate MailerStub mailer;\n\npublic void verifyCreateUser()\n{\n    manager.createUser(&quot;tester&quot;);\n    assert mailer.getMails().size() == 1;\n}\n\npublic void setManager(UserManager manager)\n{\n    this.manager = manager;\n}\n\npublic void setMailer(MailerStub mailer)\n{\n    this.mailer = mailer;    \n}\n</code></pre><p>对象工厂 </p>\n<p>杂谈<br>关注和提供异常<br>一层遇到了一个没有预料到的错误，不知道如何处理。所以这一层就快乐地向上一层抛出一个异常，希望这个可怜的异常最终会遇到知道怎么作的人。  </p>\n<p>吞掉抛出异常    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    throw new BackendException(&quot;Error in backed&quot;);\n}\n</code></pre><p>这种方法问题在于，实际上我们丢试了真实错误的有意义的信息。当我们最后有机会处理这个异常的时候，我们得到的信息仅仅是某一层中出了问题，但我们不知道是在这一曾本身出了问题，还是更低的层出了问题。    </p>\n<p>记日志并抛出    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    log.error(&quot;Error calling backend&quot;, ex);\n    throw ex;\n}\n</code></pre><p>问题在于调用栈经常发生的情况：信息隐藏。假定一个应用程序有三层或四层，每一层都在日志中记录他处里的异常，查遍8页的调用栈信息并不是最有效地方式。    </p>\n<p>嵌套抛出    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    throw new BackendException(&quot;Error in backend&quot;, ex);\n}\n</code></pre><p>当这个调用栈显示的时候，没有丝毫暗示表明背后的原因是什么。您必须编写一个帮助方法，从外面的包装中取出背后实际的异常。   </p>\n<p>我们建议两种解决方案    </p>\n<p>避免需检察异常。运行时异常很合适这样的情况。<br>包装异常。假如您非常肯定在调用栈打印时，背后的原因会显示出来，那么包装的异常也很好。    </p>\n<p>有状态测试<br>有两种截然不同的状态分类：不可修改的状态和可修改的状态   </p>\n<p>不可修改的状态<br>访问共享的不可修改的状态的测试方法，相互之间是独立的。<br>因为这些方法都不能修改他们读到的状态，所以调用顺序可以是任意的，因此他们没有违反测试访法应该彼此肚里的原则。    </p>\n<p>可修改的状态    </p>\n<pre><code>public class MyTest extends TestCase\n{\n    private int count = 0;\n\n    public void test1()\n    {\n        count++;\n        assertEquals(1, count);\n    }\n\n    public void test2()\n    {\n        count++;\n        assertEquals(2, count);\n    }\n}\n</code></pre><p>JUnit会让这个测试通过，但TestNG不会。<br>只有当您知道测试方法被调用的顺序时，共享可修改的状态才有意义。   </p>\n<p>安全的共享数<br>安全          不可修改的状态    </p>\n<p>安全　　　可修改的状态与完全指定的依赖关系    </p>\n<p>不安全　　可修改的状态与不确定的依赖关系   </p>\n<p>测试驱动开发的缺点<br>他注重微观设计超过宏观测试    </p>\n<p>他在实践中难以应用   </p>\n<p>TDD注重微观设计超过宏观设计    </p>\n<p>测试驱动开发可以得到更健壮的软件，但他也可能导致不必要的反复和过度重构的趋势，这可能对饮的软件、设计和最后期限产生负面影响。   </p>\n<p>TDD难以应用    </p>\n<p>这种方式得到的代码本身并不会优先于传统方法测试的代码。    </p>\n<p>如何创建测试并不重要，重要的是确实要创建测试    </p>\n<p>测试私有方法<br>如果他有可能出问题，您就应该测试他。    </p>\n<p>测试私有方法的比较好的方法是提升方法的可见性，例如，让他变成保护可见，或者包可见。后者更好一些，因为您可以把测试和被测类放在同一个包中，然后您就可以访问他的所有字段。如果这些方法都不可取，我们测试私有方法的方式就是利用反射。<br>    public class LoginController<br>    {<br>        private String userName;</p>\n<pre><code>    private void init()\n    {\n        this.username = getUserNameFromCookie();\n    }\n}\n\n@Test\npublic void verifyInit()\n{\n    LoginController lc = new LoginController();\n\n    Field f = lc.getClass().getField(&quot;username&quot;);\n    Object valueBefore = f.get(lc);\n    Assert.assertNull(valueBefore);\n\n    Method m = lc.getClass().getDeclaredMethod(&quot;init&quot;, null);\n    m.setAccessible(true);\n    m.invock(lc);\n\n    Object valueAfter = f.get(lc);\n    Assert.assertNotNull(vlaueAfter);\n}\n</code></pre><p>我们利用字符串来描述Java元素。如果您对这些元素进行重命名，这种危险的实践肯定会失效。    </p>\n<p>我们利用了该类危险的私有信息。我们不仅假定存在一些私有方法和属性，而且也假定这个方法将以某种方式修改一个字段。    </p>\n<p>测试与封装<br>如果让代码更可测试，不要担心破坏封装。可测试星应该胜过封装。   </p>\n<p>让一个私有方法(或字段)成为包可见的、保护可见的或公有的。    </p>\n<p>去掉方法的final限定符。这让测试勒能够扩展这些类，或重写这些方法，模拟或稍微改变他们的实现，从而让系统的其它部分更可测试。    </p>\n<p>记日志的最佳实践<br>在出错时，输出错误或警告是合理的。但是对於警告的情况，重要的是确定这是不是该做的事情。我们添加的每一条无用的日志信息都会干扰有用的信息，所已精心选择是有意义的。   </p>\n<p>对于调试需求，记日志是有用的。但是，只要有一个开关能打开或关闭，绝大多数的记日志需求都能够满足了，不需要复杂的解决方案。   </p>\n<p>参考文档：<a href=\"http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html</a></p>\n","excerpt":"<p>###TestNG annotaion:</p>\n<ul>\n<li>@DataProvider</li>\n<li>@ExpectedExceptions</li>\n<li>@Factory</li>\n<li>@Test</li>\n<li>@Parameters  </li>\n</ul>\n<hr>\n<pre><code>&lt;suite name=&quot;ParametersTest&quot;&gt;\n　　&lt;test name=&quot;Regression1&quot;&gt;\n　　　　&lt;classes&gt;\n　　　　　　&lt;class name=&quot;com.example.ParameterSample&quot; /&gt;\n　　　　　　&lt;class name=&quot;com.example.ParameterTest&quot;&gt;\n　　　　　　　　&lt;mtehods&gt;\n　　　　　　　　　　&lt;include name=&quot;database.*&quot; /&gt;\n　　　　　　　　　　&lt;exclude name=&quot;inProgress&quot; /&gt;\n　　　　　　　　&lt;/methods&gt;\n　　　　　　&lt;/class&gt;\n　　　　&lt;/classes&gt;\n　　&lt;/test&gt;    \n　　&lt;test name=&quot;Parameters&quot;&gt;\n　　　　&lt;packages&gt;\n　　　　　　&lt;package name=&quot;test.parameters.Parameter*&quot; /&gt;\n　　　　&lt;/packages&gt;\n　　&lt;/test&gt;   \n&lt;/suite&gt;    \n</code></pre><p>一个suite(套件) 由一个或多个测试组成。<br>一个test(测试) 由一个或多个类组成<br>一个class(类) 由一个或多个方法组成。   </p>\n<p>@BeforeSuite/@AfterSuite 在某个测试套件开始之前/在某个套件所有测试方法执行之后<br>@BeforeTest/@AfterTest 在某个测试开始之前/在某个测试所有测试方法执行之后<br>@BeforeClass/@AfterClass 在某个测试类开始之前/在某个类的所有测试方法执行之后<br>@BeforeMethod/@AfterMethod 在某个测试方法之前/在某个测试方法执行之后<br>@BeforeGroup/@AfterGroup 在某个组的所有测试方法之前/在某个组的所有测试方法执行之后<br>","more":"</p>\n<p>####1、分组</p>\n<pre><code>@Test(groups = {&quot;fast&quot;, &quot;unit&quot;, &quot;database&quot;})\npublic void rowShouldBeInserted() {}\n\njava org.testng.TestNG -groups fast com.example.MyTest\n</code></pre><p>测试的一个目标就是确保代码按照预期的方式工作。这种测试要么在用户层面上进行，要么在编程层面上进行。这两种类型的测试分别是通过功能测试和单元测试来实现的。    </p>\n<p>针对失败而测试     </p>\n<p>Java提供了两种不同类型的异常：从java.lang.RuntimeException派生的运行时刻异常和从java.lang.Exception派生的被检查的异常。   </p>\n<p>抛出被检查的异常的经验法则：调用者可以为这个异常做什么吗？如果答案是肯定的，那么可能应该是用被检查的异常，否则，最好是选择运行时刻异常。   </p>\n<pre><code>@Test(expectedExceptions = {ReservationException.class, FlightCanceledException.class})\npublic void shouldThrowIfPlaneIsFull() \n{\n　　Plane plane = createPlane();\n　　plane.bookAllSeats();\n　　plane.bookPlane(createValidItinerary(), null);\n}\n</code></pre><p>属性expectedExceptions是一组类，包含了这个测试方法中预期会抛出的异常列表。如果没有抛出异常，或抛出的异常不再该属性的类表中，那么TestNG就会认为这个测试方法失败了。</p>\n<p>单一职责：</p>\n<pre><code>public class BookingTest\n{\n　　private Plane plane;\n\n　　@BeforeMethod\n　　public void init() { plane = createPlane(); }\n\n　　@Test(expectedException = PlaneFullException.class)\n　　public void shouldThrowIfPlaneIsFull()\n　　{\n　　　　plane.bookAllseats();\n　　　　plane.bookPlane(createValidItinerary(), null);\n　　}\n\n　　@Test(expectedException = FlightCanceledException.class)\n　　public void shouldThrowIfFlightIsCanceled()\n　　{\n　　　　cancelFlight(/* ... */);\n　　　　plane.bookPlane(createValidItinerary(), null);\n　　}\n}\n</code></pre><p>testng-failed.xml</p>\n<p>当您执行包涵失败的测试套件时，TestNG会在输出目录(默认是test-output/)下自动生成一个名为testng-failded.xml的问他件。这个XML文件包含了原来的testng.xml中失败的方法所构成的子集。 </p>\n<pre><code>java org.testng.TestNG test.xml\njava org.testng.TestNG test-output/testng-failed.xml\n</code></pre><p>####2、工厂<br>TestNG让您可以选择自己将测试类实例化。这是通过@Factory annotation来实现的，他必须放在返回一个对象数组方法的顶部。所有这些对象都必须是包含TestNG annotation的类的实例。如果有@Factory annotation，那么这个循环会继续下去，知道TestNG拿到的都是没有@Factory annotation实例，或者@Factory方法都已被调用过的实例。</p>\n<pre><code>public class ExpectedAttributes\n{\n　　private Image image;\n　　private int width;\n　　private height;\n　　private String path;\n　　\n　　@Test\n　　public void testWidth() {}\n\n　　@Test\n　　public void testHeight() {}\n\n　　public PictureTest(String path, int width, int height, int depth) throws IOException\n　　{\n　　　　File f = new File(path);\n　　　　this.path = path;\n　　　　this.image = ImageIO.read(f);\n　　　　this.width = width;\n　　　　this.height = height;\n　　}\n\n　　private static String[] findImageFileNames() {}\n\n　　@Factory\n　　public static Object[] create() throws IOException\n　　{\n　　　　List result = new ArrayList();\n\n　　　　String[] paths = findImageFileNames();\n\n　　　　for (String path : paths) {\n　　　　　　ExpectedAttributes ea = findAttributes(path);\n　　　　　　result.add(new PictureTest(path, ea.width, ea.height, ea.depth));\n　　　　}\n\n　　　　return result.toArray();\n　　}\n\n　　public class ExpectedAttributes \n　　{\n　　　　public int width;\n　　　　public int height;\n　　　　public int depth;\n　　}\n\n　　private static ExpectedAttributes findExpectedAttributes(String path)\n　　{\n　　　　// ...... \n　　}\n}\n</code></pre><p>可以安全的在同一个类包含@Factory和@Test annotation，因为TestNG确保@Factory方法只被调用一次。</p>\n<p>org.testng.ITest接口</p>\n<pre><code>public interface ITest \n{\npublic String getTestName(); \n}\n</code></pre><p>当TestNG遇到实现了这个接口的测试类时，他会在生成各种报告中包含getTestName()方法返回的信息。</p>\n<pre><code>public class PictureTest implements ITest\n{\n　　public String getTestName() \n　　{\n　　　　return &quot;[Picture: &quot; + name + &quot;]&quot;;\n　　} \n}\n</code></pre><p>数据驱动测试</p>\n<p>测试需要针对许多具有类似结构的数据来执行。<br>实际的测试逻辑是一样的，仅仅发生改变的是数据。<br>数据可以被一组不同的人修改。    </p>\n<p>参数测试方法<br>测试逻辑可以非常简单或不易改变，而提供給他的数据肯定会随着时间增长。    </p>\n<p>TestNG可以通过两种方式向测试方法传递参数：  </p>\n<ul>\n<li>利用testng.xml</li>\n<li>利用DataProviders</li>\n</ul>\n<p>1、利用testng.xml传递参数</p>\n<pre><code>&lt;suite name=&quot;Parameters&quot;&gt;\n　　&lt;parameter name=&quot;xml-file&quot; value=&quot;accounts.xml&quot; /&gt;\n　　&lt;parameter name=&quot;hostname&quot; value=&quot;arkonis.example.com&quot; /&gt;\n\n　　&lt;test name=&quot;ParameterTest&quot;&gt;\n　　　　&lt;parameter name=&quot;hostname&quot; value=&quot;terra.example.com&quot; /&gt;\n　　　　...\n　　&lt;/test&gt;\n　　...\n&lt;/suite&gt;\n</code></pre><p>在测试方法中指定参数</p>\n<pre><code>@Test(parameters = {&quot;xml-file&quot;})\npublic void validateFile(String xmlFile)\n{\n　　// xmlFile has the value &quot;accounts.xml&quot;\n}\n</code></pre><p>如果犯下以下错误之一，TestNG将抛出一个异常：</p>\n<ul>\n<li>在testng.xml中指定了一个参数，但不能转换为对应方法参数的类型。</li>\n<li>声明了一个@Parameters annotation，但引用的参数名称在testng.xml中没有声明。</li>\n</ul>\n<p>2.利用@DataProvider传递参数   </p>\n<p>如果需要向测试方法传递的参数不是基本的Java类型，或者如果需要的值智能在运行时刻创建，那么我们应该考虑使用@DataProvider annotation。   </p>\n<p>数据提供者是用@Dataprovider标注的方法。这个annotation只有一个字符串属性：他的名称，如果没有提供名称，数据提供者的名称就默认采用方法的名称。   </p>\n<p>数据提供者同时实现两个目的：  </p>\n<p>向测试方法传递任意数目的参数<br>根据需要，允许利用不同的参数集合对他的测试方法进行多次调用。   </p>\n<pre><code>@Test(dataProvider = &quot;range-provider&quot;)\npublic void testIsBetWeen(int n, int lower, int upper, boolean expected)\n{\n　　println(&quot;Received &quot; + n + &quot; &quot; + lower + &quot;-&quot; + upper + &quot; expected: &quot; + expected);\n　　assert.assertEquals(expected, isBetween(n, lower, upper));\n}\n\n@DataProvider(name = &quot;range-provider&quot;)\npublic Object[][] rangeData()\n{\n　　int lower = 5;\n　　int upper = 10;\n\n　　return new Object[][] {\n　　　　{ lower-1, lower, upper, false},\n　　　　{ lower, lower, upper, true},\n　　　　{ lower+1, lower, upper, true},\n　　　　{ upper, lower, upper, true},\n　　　　{ upper+1, lower, upper, false},\n　　};\n}\n</code></pre><p>由于数据提供者是测试类中的一个方法，他可以属于一个超类，然后被一些测试方法复用。我们也可以有几个数据提供者，只要他们定义在测试类或者他的一个子类上。当我们像在合适的地方记录数据源，并在几个测试方法中复用他时，这种方法是很方边的。    </p>\n<p>针对数据提供者的参数<br>数据提供者本身可以接受两个类型的参数：Method和ITestContext      </p>\n<pre><code>@DataProvider\npublic void craete() { ... }\n\n@DataProvider\npublic void create(Method method) { ... }\n\n@DataProvider\npublic void create(ITestContext context) { ... }\n\n@DataProvider\npublic void create(Method method, ITestContext context) { ... }\n</code></pre><p>Method参数<br>如果数据提供者的第一个参数是java.lang.reflect.Method，TestNG传递这个将调用的测试方法。如果您希望数据提供者根据不同的测试方法返回不同的数据，那么这种做法就非常有用。    </p>\n<pre><code>@DataProvider\npublic Object[][] provideNumbers(Method method)\n{\n　　String methodName = method.getName();\n\n　　if (methodName.equals(&quot;tow&quot;)) {\n　　　　return new Object[][] { new Object[] {2} };\n　　}\n　　if (methodName.equals(&quot;three&quot;)) {\n　　　　return new Object[][] { new Object[] {3} };\n　　}\n}\n\n@Test(dataProvider = &quot;provideNumbers&quot;)\npublic void two(int param)\n{\n　　System.out.println(&quot;Two received: &quot; + param); \n}\n\n@Test(dataProvider = &quot;provideNumbers&quot;)\npublic void three(int param)\n{\n　　System.out.println(&quot;Three received: &quot; + param);\n}\n</code></pre><p>使用同一个数据提供者的地方：   </p>\n<p>数据提供者代码相当复杂，应该保存在一个地方，这样维护起来更方便。<br>我们要传入数据的那些测试方法具有许多参数，其中只有少数参数是不一样的。<br>我们引入了某个方法的特殊情况。      </p>\n<p>ITestContext参数<br>如果一个数据提供者在方法签名中声名了一个ITestContext类型的参数，TestNG就会将当前的测试上下文设置给它，这使得数据提供者能够知道当前测试执行的运行时刻参数。     </p>\n<pre><code>@DataProvider\npublic Object[][] randomIntegers(ITestContext context)\n{\n　　String[] groups = context.getIncludeGroups();\n\n　　int size = 2;\n　　for (String group : groups) {\n　　　　if (group.equals(&quot;functional-test&quot;)) {\n　　　　　　size = 10; \n　　　　　　break;\n　　　　}\n　　}\n\n　　Object[][] result = new Object[size][];\n　　Random r = new Random();\n　　for (int i = 0; i &lt; size; i++) {\n　　　　result[i] = new Object[] { new Integer(r.nextInt()) };\n　　}\n\n　　return result;\n}\n\n@Test(dataProvider = &quot;randomIntegers&quot;, groups = {&quot;unit-test&quot;, &quot;functional-test&quot;})\npublic void random(Integer n)\n{\n　　// ......\n} \n</code></pre><p>ITestContext对象中的数据是运行时刻的信息，不是静态的信息：这个测试方法即属于unit-test组，也属于functional-test组，但在运行时刻，我们决定只执行functional-test组，这个值由ITestContext#getIncludeGroups方法返回。    </p>\n<p>延迟数据提供者   </p>\n<p>为了实现这种方法，TestNG允许我们从数据提供者返回一个Iterator，而不是一个二维对象数组。    </p>\n<p>这种方法与数组不同之处在于，当TestNG需要从数据提供者取得下一组参数时，他会调用Iterator的next方法，这样就有机会在最后一刻实例化相应的对象，即刚好在需要这些参数的测试方法被调用之前。    </p>\n<pre><code>@DataProvider(name = &quot;generate-accounts-lazy&quot;)\npublic Iterator generateAccountsLazy\n{\n　　return new AccountIterator();\n}\n\n@Test(dataProvider = &quot;generate-accounts-lazy&quot;)\npublic void testAccount(Account a)\n{\n　　System.out.println(&quot;Testing account &quot; + a);\n}\n\nclass AccountIterator implements Iterator\n{\n　　private static final int MAX = 4;\n　　private int index = 0;\n\n　　public boolean hasNext()\n　　{\n　　　　return index &lt; MAX;\n　　}\n\n　　public Object next()\n　　{\n　　　　return new Object[] { new Account(index++); } \n　　}\n\n　　public void remove()\n　　{\n　　　　throw new UnsupportedOperationException(); \n　　}\n}\n</code></pre><p>如果传递的参数是简单类型的常数，利用testng.xml的方法是很好的。档我们需要更多灵活性，并知道参数的数目和值将随时间增加时，我们可能应该选择@DataProvider。  </p>\n<p>提供数据<br>数据的位置可能是：硬编码在Java源码中、再文本文件中、在属性文件中、在Excel表格中、在数据库中、在网络中…。   </p>\n<p>数据提供者还是工厂<br>数据提供者向测试方法传递参数，而工厂像构造方法传递参数。   </p>\n<p>不如不能确定使用哪种方法，那么就看看测试方法所使用的参数。是否有几个测试方法需要接收同样的参数？如果是这样，您可能最好是将这些参数保存在一个字段中，然后在几个方法中复用这个字段，这就意味着最好是选择工厂。反之，如果所有的测试方法都需要传入不同的参数，那么数据提供者可能是最好的选择。    </p>\n<p>异步测试<br>异步代码通常出现在下列领域：    </p>\n<ul>\n<li>基于消息的框架，其中发送者和接收者是解耦合的。(JMS)</li>\n<li>由java.util.concurrent提供的异步机制(FutureTask)</li>\n<li>由SWT或Swing这样的工具集开发的图形用户界面，其中代码与主要的图形部分运行在不同的线程中。</li>\n</ul>\n<p>测试异步代码比测试同步代码的问题更多：</p>\n<ul>\n<li>无法确定异步调用何时质性。</li>\n<li>无法确定异步调用是否会完成。</li>\n</ul>\n<p>当调用异步时有三种可能的结果：</p>\n<ul>\n<li>调用完成并成功。</li>\n<li>调用完成并失败。</li>\n<li>调用没有完成。<br>基本上，异步编程遵循着一种非常简单的模式：在发出一个请求时指定一个对象或一个函数，当收到响应时系统会调用回调。</li>\n</ul>\n<p>测试异步代码也同样遵循下面的模式：     </p>\n<p>发出异步调用，他会立即返回。如果可能，制定一个回调对象。     </p>\n<p>如果有回调方法：    </p>\n<p>等待结果，在接到结果是设置布尔变量，反应结果是否是您的预期。    </p>\n<p>在测试方法中，监视那个布尔变量，等到他被设置或过了一段时间。   </p>\n<p>如果没有回调方法：    </p>\n<p>在测试方法中，定期检查预期的值。如果过了一段时间还没有检查到预期值，就失败并退出。</p>\n<p>不指定回调方法    </p>\n<pre><code>private volatile boolean success = false;\n\n@BeforeClass\npublic void sendMessage()\n{\n　　// send the message;\n　　// Successful completion should eventually set success to true;\n}\n\n@Test(timeOut = 10000)\npublic void waitForAnswer()\n{\n　　while (!success) {\n　　　　Thead.sleep(1000);\n　　}\n}\n</code></pre><p>在这个测试中，消息是作为测试初始化的一部分，利用@BeforeClass发出的，这保证了这段代码在测试方法调用之前执行并且只执行一次。在初始化后TestNG将调用waitForAswer测试方法，他将进行不完全忙等。   </p>\n<p>有回调方法：</p>\n<pre><code>@Test(groups = “send”)\npublic void sendMessage()\n{\n　　// send the message\n}\n\n@Test(timeOut = 10000, dependsOnGroups = {“send”})\npublic void waitForAnswer()\n{\n　　while (!success) {\n　　　　Thread.sleep(1000);\n　　}\n}\n</code></pre><p>现在sendMessage()是一个@Test方法，他将包含在最终的报告中，如果发送消息失败，TestNG将跳过waitForAnswer测试方法，并把他表示为SKIP。    </p>\n<pre><code>@Test(timeOut = 10000, invocationCount=100, successPercentage = 98)\npublic void waitForAnswer ……\n</code></pre><p>TestNG调用该方法100次，如果98%的调用成功，就认为总体测试通过。    </p>\n<p>测试多线程代码<br>并发测试     </p>\n<pre><code>private Singleton singleton;\n\n@Test(invocationCount = 100, threadPoolSize = 10)\npublic void testSingleton()\n{\n　　Thread.yield();\n　　Singleton p = Singleton.getInstance();\n}\n\npublic static Singleton getInstance()\n{\n　　if (instance == null) {\n　　　　Thread.yield();\n　　　　Assert.assertNull(instance);\n　　　　instance = new Singleton();\n　　}\n　　return instance;\n}\n</code></pre><p>@invocationCount相当简单，在不考虑并发时也可以使用：他决定了TestNG调用一个测试方法的次数。    </p>\n<p>@threadPoolSize要求TestNG分配一定数量的线程，并使用这些线程来调用这个测试方法，当一个测试完成之后，执行他的线程将归还给线程池，然后可以用于下一次调用。   </p>\n<p>并发执行<br>    <suite name=”TestNG JDK 1.5” verbose=“1” parallel=“methods” thread-count = “2”>……</suite><br>thread-count属性指定了线程数目，TestNG将使用这些线程来执行这个测试套件中的所有测试方法，parallel属性告诉TestNG您在执行这些测试时希望采用的并行模式。    </p>\n<p>parallel=”methods” 在这种模式下，每个测试方法将在他自己的一个线程中执行。    </p>\n<p>parallel=”test” 在这种模式下，在某个<test>标签内的所有测试方法将在他们自己的一个线程中执行。   </p>\n<p>在tests模式中，TestNG保证每个<test>将在他自己的线程中执行。如果希望测试不安全的代码，这一点是非常重要的。在method模式中，所有限制都被取消，无法预测哪些方法将在同一个线程中执行，哪些方法将在不同的测试中执行。    </p>\n<p>为可模拟性设计<br>为了能够成功地使用模拟模拟对象或桩，重要得失要确保代码的设计能让使用模拟对象或桩变得简单而直接。<br>这种设计最重要的方面就是正确的确定组件之间的交互，从而确定组件的交互接口。    </p>\n<p>如果我们有2个组件A和B，A需要用到B，那么应该通过B的接口来完成，而不是通过B的具体实现。   </p>\n<p>Singleton查找    </p>\n<pre><code>public void doWork1()\n{\n　　C c = C.getInstance();\n　　c.doSomething();\n}\n</code></pre><p>对于某个对象智能由一个实例，这在项目生命周期的后期产生阻碍效果。   </p>\n<p>JNDI定位服务     </p>\n<pre><code>public void doWork2()\n{\n　　C c = (C) new InitialContext().lockup(&quot;C&quot;);\n　　c.Something();\n}\n</code></pre><p>不能够向A提供一个受控制的B的实例。只有一个全局实例，A只能取得这个实例。     </p>\n<p>依赖注入    </p>\n<pre><code>private C c;\n\npublic void setC(C c)\n{\n　　this.c = c; \n}\n</code></pre><p>从外部通知A应该使用哪个B的实例。这让我们能够根据实际情况灵活地决定向A提供B的哪个实例。   </p>\n<p>EasyMock</p>\n<pre><code>import static org.easymock.EasyMock.*;\n\npublic class EasyMockUserManagerTest\n{\n　　@Test\n　　public void createUser()\n　　{\n　　　　UserManager manager = new UserManagerImpl();\n　　　　UserDao dao = createMock(UserDao.class);\n　　　　Mailer mailer = createMock(Mailer.class);\n\n　　　　manager.setDao(dao);\n　　　　manager.setMailer(mailer);\n\n　　　　expect(dao.saveUser(&quot;tester&quot;)).andReturn(true);\n　　　　expect(mailer.sendMail(eq(&quot;tester&quot;), (String) notNull(), (String) notNull())).addReturn(true);\n\n　　　　replay(dao, mailer);\n\n　　　　manager.createUser(&quot;tester&quot;);\n　　　　verify(mailer, dao);\n　　}\n}\n</code></pre><p>1创建模拟对象<br>这是通过createMock方法完成的，传入希望模拟的类作为参数。    </p>\n<p>2纪录预期行为<br>只要在模拟对象上调用我们预期会被调用的方法，就能纪录预期的行为。当用到某些具体的参数时，只要将这些参数传入就可以了。</p>\n<p>3调用主要被测对象<br>在主要的被测对象上调用一个方法或一组方法，预期这次调用将倒置被测对象调用模拟对象的那些预期的方法。    </p>\n<p>4验证预期行为<br>最后调用verify，检查所有的模拟对象。   </p>\n<p>JMock<br>jMock是一个模拟库，她让我们通过编成的方式来之行约束条件。     </p>\n<p>选择正确的策略    </p>\n<p>缺少接口<br>有时候，我们面对的是庞大臃肿的遗留系统，没有向期望的那样有很好的设计。<br>大多数模拟库现在都允许替换类，而不仅是接口。这些库会在运行时刻生成一个新类，通过字节码操作来实现指定的契约。    </p>\n<p>复杂的类<br>如果我们得到了一些类，他们拥有20多个方法，与许多其他组件交互，而且随着是间的推移变得越来越复杂。<br>这种情况下，使用动态的模拟对象库效果会比较好，因为他们能够定义单个方法的行为，而不是考虑所有的方法。    </p>\n<p>契约纪录<br>使用模拟对象让我们记录更多的契约信息，而不止是方法签名。我们可以随时验证器乐的。    </p>\n<p>测试目标<br>根据经验法则，如果希望测试组件之间交互，模拟对象可能优于桩对象。模拟库能够以一种准确的方式来指定交互。而桩该作为被测试组件使用的那些次要的组件。在这种情况下，测试的目标是测试被测试组件本身，而不是他与其他组件之间的交互。   </p>\n<p>模拟易犯的错误<br>依赖模拟对象会导至许多问题，所以重要的是要知道使用模拟对象不利的一面：     </p>\n<ul>\n<li>模拟外部API行   </li>\n<li>虚假的安全感</li>\n<li>维护开销</li>\n<li>继承与复杂性</li>\n</ul>\n<p>依赖的测试<br>层叠失败：一个测试的失败导致一组测试的失败。   </p>\n<p>依赖的代码<br>只要测时方法依赖于其他测试方法，就很难以隔离的方式执行这些测试方法。<br>彼此依赖的测试方法通常会出现这样的情况，因为他们共享了一些状态，而在测试之间共享状态是不好的。   </p>\n<p>利用TestNG进行依赖的测试<br>TestNG通过@Test annotation的两个属性(dependsOnGroups和dependsOnMethods)赖支持依赖的测试。    </p>\n<pre><code>@Test\npublic void launchServer() {}\n\n@Test(dependsOnMethods = &quot;launchServer&quot;)\npublic void deploy() {}\n\n@Test(dependsOnMethods = &quot;deploy&quot;)\npublic void test1() {}\n\n@Test(dependsOnMethods = &quot;deploy&quot;)\npublic void test2() {}\n</code></pre><p>dependsOnMethods的问题:<br>通过字符串来执行方法名称，如果将来对他进行重构，代码就有可能失效。方法名称违反了”不要重复自己”的原则，方法名称即在Java方法中用到，也在字符串中使用，另外，等我们不断添加新的测试方法时，这个测试用例伸缩性也不好。    </p>\n<pre><code>@Test(groups = &quot;init&quot;)\npublic void launchServer() {}\n\n@Test(dependsOnGroups = &quot;init&quot;, groups = &quot;deploy-apps&quot;)\npublic void deploy() {}\n\n@Test(dependsOnGroups = &quot;init&quot;, groups = &quot;deploy-apps&quot;)\npublic void deployAuthenticationServer() {}\n\n@Test(dependsOnGroups = &quot;deploy-apps&quot;)\npublic void test1() {}\n\n@Test(dependsOnGroups = &quot;deploy-apps&quot;)\npublic void test2() {}\n</code></pre><p>利用组来指定依赖关系可以解决我们遇到的所有问题：   </p>\n<ul>\n<li>不在遇到重构问题，可以任意秀该方法的名称。</li>\n<li>不再违反DRY原则。</li>\n<li>当新方法须要加入到依赖关系中时，只要将他放到适当的组中，并确保他依赖于正确的组。</li>\n</ul>\n<p>依赖的测试和线程<br>当打算并行执行测试时，要记住，线程池中的一个或多个线程将用于依次执行每个方法。所以，如果打算在不同的线程中执行一些测试，过渡的使用依赖的测试将影像执行性能。    </p>\n<p>配置方法的失败<br>依赖测试方法和配置方法之间唯一的不同就是，测试方法隐式的依赖于配置方法。   </p>\n<p>虽然dependsOnMethods可以处理简单的测试或之由一个测试方法依赖于另一个测试方法的情况，但是在大多数情况下，您都应该使用dependsOnGroups，这种方式的伸缩性好，面对将来的重构也更为健壮。   </p>\n<p>既然我们提供了准去的依赖信息，那么TestNG就能够按照于骑的顺序来执行测试。    </p>\n<p>测试隔离并没有因此而受到影响。    </p>\n<p>如果出现层叠式的错误，依赖测试可以加快测试执行速读。    </p>\n<p>继承和annotation范围</p>\n<pre><code>public class CreditCardTest\n{\n　　@Test(groups = &quot;web.credit-card&quot;)\n　　public void test1() {}\n\n　　@Test(groups = &quot;web.credit-card&quot;)\n　　public void test2() {}\n}\n</code></pre><p>他违反了”不要重复自己”的原则<br>他为将来添加测试方法的开发者带来了负担。     </p>\n<pre><code>@Target({METHOD, TYPE, CONSTRUCTOR})\npublic @interface Test{}\n\n\n@Test(groups = &quot;web.credit-card&quot;)\npublic class CreditCardTest\n{\n　　public void test1() {}\n　　public void test2() {}\n}\n</code></pre><p>annotation继承     </p>\n<pre><code>@Test(groups = &quot;web.credit-card&quot;)\nclass BaseWebTest {}\n\npublic class WebTest extends BaseWebTest \n{\n　　public test1() {}\n　　public test2() {}\n}\n</code></pre><p>所有扩展自BaseWebTest的类都会看到，他们所有的工有方法都自动成为web.credit-card组的成员。<br>WebTest变成了一个普通的传统Java对象(POJO),不带任何annotation。    </p>\n<p>集成易犯的错误<br>由于TestNG的测试方法必须是公有的，在基类中声明的方法会自动在子类中可见，所以他们永远也不需要作为测试类显式的列出(不要将测试基类列在testng.xml文件中)     </p>\n<p>测试分组<br>分组解决了上面提到的局限性，实际上，他们进一步提升了TesgNG的一个设计目标：在静态模型(测试代码)和动态模型(执行哪些测试)之间实现清晰的分离。    </p>\n<p>语法<br>@Test annotation和配置annotation(@BeforeClass, @AfterClass, @BeforeMethod…)都可以属于分组</p>\n<pre><code>@Test(groups = {&quot;group1&quot;})\n@Test(groups = {&quot;group1&quot;, &quot;group2&quot;})\n@Test(groups = &quot;group1&quot;)\n\n@Test(groups = &quot;group2&quot;)\npublic class B\n{\n　　@Test\n　　public test1() {}\n\n　　@Test(groups = &quot;group3&quot;)\n　　public test2() {}\n}\n</code></pre><p>test1属于group2组，test2同时属于group2组和group3组</p>\n<p>分组与运行时刻</p>\n<pre><code>&lt;suite name=&quot;Simple suite&quot;&gt;\n　　&lt;test name=&quot;GroupTest&quot;&gt;\n　　　　&lt;groups&gt;\n　　　　　　&lt;run&gt;\n　　　　　　　　&lt;include name=&quot;group1&quot; /&gt;\n　　　　　　&lt;/run&gt;\n　　　　&lt;/groups&gt;\n　　　　&lt;classes&gt;\n　　　　　　&lt;class name=&quot;com.example.A&quot; /&gt;\n　　　　&lt;/classes&gt;\n　　&lt;/test&gt;\n&lt;/suite&gt;\n</code></pre><p>这个testng.xml告诉TestNG执行com.example.A类中所有属于group1组的测试方法。    </p>\n<pre><code>&lt;include name=&quot;database&quot; /&gt;\n&lt;exclude name=&quot;gui&quot; /&gt;\n</code></pre><p>如果某个方法即属于包含的组，又属于排除的组，那么排除的组优先。<br>如果既没有include，也没有exclude，那么TestNG将忽略组，执行所有的测试方法。   </p>\n<p>另一个功能就是可以在testng.xml中利用正则表达式来指定组。</p>\n<pre><code>&lt;groups&gt;\n　　&lt;define name=&quot;all-web&quot;&gt;\n　　　　&lt;include name=&quot;jsp&quot; /&gt;\n　　　　&lt;include name=&quot;servlet&quot; /&gt;\n　　&lt;/define&gt;\n　　&lt;run&gt;\n　　　　&lt;include name=&quot;all-web&quot;&gt;\n　　&lt;/run&gt;\n&lt;/groups&gt;\n</code></pre><p>在设计组的层次关系时，能够在testng.xml中定义新组带来灵活性：<br>可以在代码中使用粒度非常小的分组，然后在运行时刻将这些小分组合并成大分组。     </p>\n<p>执行分组<br>利用命令行执行      </p>\n<pre><code>java org.testng.TestNG -groups jsp -groups servlet -excludegroups broken com.example.MytestClass\n</code></pre><p>利用ant     </p>\n<pre><code>&lt;testng groups=&quot;jsp, servlet&quot; excludegroups=&quot;broken&quot;&gt;\n　　&lt;classfileset&gt;\n　　　　&lt;include name=&quot;com/example/MyTestClass.class&quot; /&gt;\n　　&lt;/classfileset&gt;\n&lt;/testng&gt;\n</code></pre><p>利用Maven     </p>\n<pre><code>&lt;dependencies&gt;\n　　&lt;dependency&gt;\n　　　　&lt;groupId&gt;org.testng&lt;/groupId&gt;\n　　　　&lt;artifactId&gt;testng&lt;/artifactId&gt;\n　　　　&lt;version&gt;5.10&lt;/version&gt;\n　　　　&lt;classifier&gt;jdk15&lt;/classifier&gt;\n　　&lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n　　&lt;plugins&gt;\n　　　　&lt;plugin&gt;\n　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n　　　　　　&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n　　　　　　&lt;version&gt;2.5&lt;/version&gt;\n\n　　　　　　&lt;configuration&gt;\n　　　　　　　　&lt;suiteXmlFiles&gt;\n　　　　　　　　　　&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;\n　　　　　　　　&lt;suiteXmlFiles&gt;\n　　　　　　&lt;/configuration&gt;\n　　　　&lt;/plugin&gt;\n　　&lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p>利用Java API    </p>\n<pre><code>TestNG tng = new TestNG();\ntng.setGroups(&quot;jsp, servlet&quot;);\ntng.setExcludeGroups(&quot;broken&quot;)\n</code></pre><p>排除失败的测试<br>创建一个特书的组如broken</p>\n<pre><code>@Test(groups = { &quot;web&quot;, &quot;broken&quot;})\n</code></pre><p>然后在运行时刻排除这个组。    </p>\n<pre><code>&lt;exclude name=&quot;broken&quot; /&gt;\n</code></pre><p>组分类    </p>\n<p>测试类型:单元测试、继承测试<br>测试规模:小规模、大规模<br>功能描述:数据库、界面<br>测试速度:慢测试、快测试<br>过程描述:冒烟测试、发布测试    </p>\n<p>让开发者能够指定方法的分组，主要的好处在于开发者因此能够很容易找出他们需要执行哪些测试。(如刚刚修改了数据库代码，可能只需要执行fast和database组测试)     </p>\n<p>组命名    </p>\n<pre><code>@Test(groups = {&quot;os.linux.debian&quot;})\n@Test(groups = {&quot;database.table.ACCOUNTS&quot;})\n@Test(groups = {&quot;database.ejb3.connection&quot;})\n</code></pre><p>TestNG能够利用正则表达式来之定要执行的组，如果与这项功能配合使用，这种命名方式就很有用了。    </p>\n<pre><code>&lt;groups&gt;\n　　&lt;run&gt;\n　　　　&lt;include name=&quot;database.*&quot; /&gt;\n　　&lt;/run&gt;\n&lt;/groups&gt;\n</code></pre><p>代码覆盖率<br>类的覆盖率：类覆盖描熟了项目中多少类已被测试套件访问。　<br>方法覆盖率：方法覆盖率是被访问的方法的百分比。<br>语句覆盖率：语句覆盖率追踪单条源代码语句的调用。<br>语句块覆盖率：语句快覆盖率将语句块作为基本的覆盖律单元。<br>分支覆盖率：分支覆盖率也被称为判断覆盖率。指标计算哪些代码分支被执行。    </p>\n<p>覆盖律工具<br>Clover、EMMA和Cobertura    </p>\n<p>成功使用覆盖率的建议<br>覆盖率报告的信息何音的解读不同<br>覆盖率很难<br>百分比没有意义<br>为覆盖率而设计是错误得<br>有一点好过没有<br>覆盖律工具不会测试不存在的代码<br>覆盖率的历史讲述了自己的故事   </p>\n<p>企业级测试<br>单元测试：单元测试对系统中的一个单元进行独立的测试。    </p>\n<p>功能测试：功能测试关注一项功能。通常涉及不同组件之间的交互。    </p>\n<p>继承测试：继承测试是一种端到端的测试，他会执行整个应用栈，包括所有的外部依赖关系或系统。    </p>\n<p>一个具体的例子<br>系统中有一个相当典型的组件，他接收一条JMS消息，其中包含一段有效的XML文本。这段XML文本相当长，描述了一笔财务交易。这个组件的工作是读出这条消息，解析XML，根据消息的内容条填充一些数据库的表，然后调用一个存储过程来处理这些表。    </p>\n<p>测试内容     </p>\n<p>我们将创建一个成功测试。希望确保，如果收到一条有效的XML消息，我们会正确地处理他，并更新正确的数据表，然后存储过程的调用也成功。<br>我们将摹拟不同的场景。希望能够为测试替工不同的XML文本，这样就能够很容易地不断添加测试粒子数据。<br>我们提供明确的失败测试。失败的行为将被记录和测试，这样当组件内部出现失败时，他的状态就可以与测，并且很容易记录下来。    </p>\n<p>非测试内容    </p>\n<p>我们不测试JMS provider的功能。假定他是一个完全兼容的实现，已经正确的进行了配置，将成功地提交我们期望的消息。<br>我们不执行捕捉所有错误得测试。失败测试应该针对明确的、可重现的失败场景。<br>我们不测试API。例如，JDBC去冬的行为不是测试的主题。确保所有的测试都贯注业务功能，要避免对Java语言的语义进行测试。     </p>\n<p>测试成功场景<br>对于JMS API的接口<br>利用模拟对象(或桩)对象，创建TextMessage实现，用一个简单的POJO来表现，带有消息内容和其他属性的设置方法。<br>重构该组件，解除业务功能与JMS API的耦合。    </p>\n<pre><code>public void onMessage(Message message)\n{\n    TextMEssage tm = (TextMessage) message;\n    processDocument(tm.getText());\n}\n\npublic void processDocument(String xml)\n{\n    // code previously in onMessage that updates DB\n}\n\n@Test\npublic void componentUpdateDatabase() throws Exception {}\n</code></pre><p>构件测试数据</p>\n<pre><code>@Test(dataProvider = &quot;&quot;)\npublic void componentUpdateDatabase() throws Exception  {}\n\n@DataProvider(name = &quot;component-data-files&quot;)\npublic Iterator&lt;Object[]&gt; loadXML() throws Exception {}\n</code></pre><p>我们的测试现在接受一个参数，不再需要自己考虑测试数据的来源，也不需要考虑如何加载测试数据。他要做的只是指定数据提供者。加载XML的实际工作现在代理给了一段独立的加载程序。    </p>\n<pre><code>@DataProvider(name = &quot;component-data-files&quot;)\npublic Iterator&lt;Object[]&gt; loadXML() throws Exception\n{\n    File[] f = new File(&quot;filepath&quot;).listFiles();\n    final Iterator&lt;File&gt; files = Arrays.asList(f).iterator();\n\n    return new Iterator&lt;Object[]&gt;() {\n        public boolean hasNext()\n        {\n            return files.hasNext();   \n        }\n\n        public Object[] next()\n        {\n            return new Object[] { IOUtils.readFile(files.next()) };\n        }\n\n        public void remove()\n        {\n            throw new UnsupportedOperationException(); \n        }\n    };\n}\n</code></pre><p>当然，可以从数据提供者返回一个Object[]的数组，但是，这种方法意味着我们必需将所有的文件的数据都一次性加载到内存中，因为数组必须事先填充。    </p>\n<p>测试准备问题    </p>\n<p>幂等的测试是指，这个测试执行一次和执行多次的结果是一样的。如果某个东西是幂等的，那么说明他在多次调用时状态不会改变。    </p>\n<p>不仅需要测试是幂等的，而且测试的次序应该无关紧要。所以除了需要是是幂等的之外，测试不应该在状态或数据方面影像其他测试。   </p>\n<p>对于一些写操作，成功执行之后很容易会对再次执行产生影响，下面方法有助于我们对付这个问题：    </p>\n<p>嵌入式数据<br>    有一些基于Java的数据库引擎，在设计时专门考虑了嵌入式支持。这些数据库可以在测试过程中临时创建并进行初始化。他们开销很小，通常性能不错。<br>    不足之处在于，它们与应用程序实际执行的环境差别非常大。通常在数据库特征上存在巨大的诧异。   </p>\n<p>在测试准备时初始化数据<br>    测试数据库总加载一定数量的已知测试数据。其中包含希望操作的所有数据，以及组件所依赖的所有外部引用。<br>    不足之处在于，很难维护一个健壮的数据集，使他对测试有足够的意义。   </p>\n<p>事务回滚<br>    另一种方法就是利用Java API来防止数据写入到持久数据存储中。总的方法是开是一个事务，执行所有的写操作，验证一切正常，然后让事务回滚。<br>    不足之处在于，如果没有复杂的嵌套事务准备，就不能测试参与事务的代码或开始自己的事务的代码。   </p>\n<p>选择正确的策略   </p>\n<pre><code>private WrappedConnection wrappedConnection;    \n\n@BeforeMethod   \npublic void connection() throws SQLException\n{\n    connection = DatabaseHelper.getConnection();\n    connection.setAutoCommit(false);\n    wrappedConnection = new WrappedConnection(connection);\n    wrappedConnection.setSuppressCommit(true);\n}\n\n@AfterMethod\npublic void rollback() throws SQLException\n{\n    wrappedConnection.rollback(); \n}\n\npublic class WrappedConnection implements Connection\n{\n    private Connection connection;\n    private boolean suppressClose;\n    private boolean suppressCommit;\n\n    public WrappedConnection(Connection connection)\n    {\n        this.connection = connection;    \n    }\n\n    public void commit() throws SQLException\n    {\n        if (!suppressCommit)    \n            connection.commit();\n    }\n\n    // ......\n}\n</code></pre><p>错误处理    </p>\n<pre><code>@Test(dataProvider = &quot;component-data-files&quot;)\npublic void componentupdateDatabase(String xml) throws Exception\n{\n    Component component = new Component();\n    try {\n        component.processDocument(xml);\n    }\n    catch (InvalidTradeException e) {\n        return;\n    }\n    // rest of test code\n}\n</code></pre><p>这种方法在于，他们没能让我们区分失败是否是预期的。相反，我们应该能够区分预期的成功和预期的失败。这个测时目前在两种情况下会通过：要么遇到好的数据时会通过，要么遇到坏数据时会通过。在每种情况下，我们都不能确定会发生些什么。   </p>\n<p>一个测试不应该在两种或两种以上的情况下都通过。如果测试验证了不同的失败情况，这没问题，但如果测试在好数据和坏数据的情况下都通过，那就会导致一些微妙的错误，这类错误难以被发现。(因此我们定义了另一个目录和数据提供者来处理失败的情况)     </p>\n<pre><code>@Test(dataProvider = &quot;component-invalid-data-files&quot;, expectedException = InvalidTradeException.class)\npublic void componentInvalidInput(String xml) throws Exception\n{\n    Component component = new Component();\n    component.processDocument(xml);\n    // rest of test code\n}\n</code></pre><p>逐渐出现的单元测试<br>单元测试不一定是在其它测试之前编写的，他们可以是功能测试驱动的。特别是对于大型项目或原有的代码来说，一开始就编写有用的单元测试可能很困难，因为在不了解全局的情况下，单元测试可能太琐碎或不太重要。相反，单元测试可以从有意义的继承测试中推导出来，因为调试开发功能测试和集成测试的过程揭示他们所需的单元测试。    </p>\n<p>对于例子来说我们需要将XML验证与数据库处理放到各自独立的方法中。这样就能对他们进行测试    </p>\n<pre><code>public void processDocument(String xml) throws InvalidDocumentException\n{\n    Document doc = XMLHelper.parseDocument(xml);\n    validateDocument(doc);\n    // ......\n}\n\npublic void validateDocument(Document doc) throws InvalidDocumentException\n{\n    // perform constraint checks that can&apos;t be captured by XML\n}\n</code></pre><p>这测重构的结果是我们得到了一个简单的单元测试。   </p>\n<p>不论测试编写的次序如何，功能测试和单元测试都是互不的。功能测试是更为水平化的测试，涉及许多不同的组件，执行代码的很多部分。相反，单元测试是更为垂直化的测试，他关注范围狭窄的主题，比功能测试要彻底得多。   </p>\n<p>竞争消费者模式<br>消费者的执行是并发的，所以我们必须在测试中进行某种程度的模拟，生产环境中的真实情况。在我们这样作了之后，也希望验证结果。不论哪个消费者先开始，也不论哪个消费者先结束，都没有关系。我们希望确定对于给定数量的消费者，我们将得道一组已知的结果，可以进行验证。   </p>\n<pre><code>private final List&lt;Object[]&gt; data = Collections.synchronizedList(new ArrayList&lt;Object[]&gt;());\n\n@BeforeClass\npublic void populateData()\n{\n    data.add(new Object[] {&quot;value1&quot;, &quot;prop1&quot;});\n    data.add(new Object[] {&quot;value2&quot;, &quot;prop2&quot;});\n    data.add(new Object[] {&quot;value3&quot;, &quot;prop3&quot;});\n}\n\n@Test(threadPoolSize = 3, invocationCount = 3, dataProvider = &quot;concurrent-processor&quot;)\npublic void runConcurrentProcessors(String value, String someProp)\n{    \n    MessageProcessor processor = new MessageProcessor();\n    processor.process(value, someProp);\n}\n\n@Test(dependsOnMethods = &quot;runConcurrentProcessors&quot;)\npublic void verifyConcurrentProcessors()\n{\n    // load data from db\n    // verify that we have 3 results\n    // verify that each of the 3 result matches our 3 input\n}\n\n@DataProvider(name = &quot;concurrent-processor&quot;)\npublic Object[][] getProcessorData()\n{\n    return new Object[][] {data.remove(data.size() - 1)};\n}\n</code></pre><p>我们的测试被分成两个，一个负责执行消费者，另一个负责验证结果。原因是runConcurrentProcessors会被调用多次，而我们只需要在所有方法调用完成之后，对结果验证一次。为了表示这种次序，我们利用了dependsOnMethods这个annotation属性。   </p>\n<p>当TestNG发现一个数据提供者时，他将针对数据提供者返回的每一条数据调用一次测试。类似的，当我们指定调用次数时，TestNG会按照指定的次数调用测试。因此，如果我们返回数据提供者中准备好的3条数据，那么每个线程都会执行3次测试。    </p>\n<p>因此解决方案是使用一个栈结构，每次调用数据提供者时，返回一条数据，并将这条数据从列表中清除。数据提供者将被调用3次，每次都将为数据返回不一样的数据。    </p>\n<p>原则：将数据的考虑和功能的考虑分开来是很关键的。<br>在这个例子中，消费者需要的数据应该和实际的测试没有依赖关系。这种方法意味着，随着我们对数据的需求不断变化，变得更为复杂，测试本身却不需要被修改。    </p>\n<p>一个具体的例子<br>我们希望测试一个登录servlet。这个servlet接受一个请求，检查用户名和口令，如果他们有效，就在会话中加入一个标记。表明用户已登录。   </p>\n<p>这个例子展示了重构在测试方面起到的重要辅助作用，说明了即使对于看上去很麻烦、需要一很复杂地方是进行交互的API，页可以通过抽象去掉依赖关系。这种抽象意味着 在测试过程中，我们可以利用更简单的对象，这些对象更容易构造，因此也更容易测试。    </p>\n<p>增加可测试性的一个副作用就是改进了设计。为提高可测试性而进行重构，可以帮助我们以一种实际的、代码中的方式来确定职责和考虑，而这种效果通过画设计图是很难达到的。   </p>\n<p>Java EE测试<br>容器内测试与容器外测试的对比    </p>\n<p>容器内测试<br>优点：<br>    完全符合运行时环境   </p>\n<p>缺点：<br>    启动消耗大<br>    难以部署新的测试<br>    难以自动化<br>    夸平台测试的复杂性增加    </p>\n<p>容器外测试<br>优点：<br>    提供了相对较快的启动<br>    可以完全控制环境<br>    可以自动化<br>    容易测试<br>缺点：<br>    没有符合运行时环境<br>    测试所用的实现可能与运行时的实现来自不同的提供商。   </p>\n<p>容器内测试<br>测试步骤：   </p>\n<p>创建一个测试环境的实例。<br>确定测试。<br>在测试框架中注册测试。<br>注册一个监听者来接收搜测试结果。   </p>\n<p>创建测试环境    </p>\n<pre><code>TestNG tester = new TestNG();\ntester.setDeafultSuiteName(&quot;container-tests&quot;);\n</code></pre><p>确定测试<br>假定所有的测试类都在WEB-INF/classes目录下，我们可以递归地读入这个目录，找到其中所有的类文件。    </p>\n<pre><code>public static Class[] scan(ServletContext context)\n{\n    String root = context.getReadPath();\n    ClassScanner scanner = new ClassScanner(new File(root));\n    scanner.setClassLoader(ClassScanner.class.getClassLoader());\n    final File testDir = new File(root, &quot;com/foo/tests&quot;);\n    scanner.setFilter(new FileFilter() {\n        public boolean accept(File pathname) {\n            return pathname.getPath().startsWith(testDir.getPath());\n        }    \n    });\n    Class[] classes = scanner.getClasses();\n    return classes;\n}\n</code></pre><p>context是一个ServletContext实例，他是通过调用servlet或JSP页面得到的。   </p>\n<p>注册测试<br>注册测试类的动作告诉了TestNG他要查看的一组类，TestNG将在这组类中查找需要执行哪些测试。他将检查每个指定的类，确定他是否包涵测试方法或配置方法。当所有类都检查过后，TestNG内部会生成一个依赖关系图，以决定照到的这些测试的执行次序。    </p>\n<pre><code>tester.setTestClasses(classes);\n</code></pre><p>注册结果监听者    </p>\n<p>TestNG自代了3个默认的报告类：    </p>\n<p>SuiteHTMLRepoter 默认报告类，他在一个目录下输出交叉引用HTML文件，让您能看到某个具体测试的结果。   </p>\n<p>FailedReporter: 这个报高生成一个TestNG执行配置，该配置包含了所有前一次运行时失败的测试。他也是默认运行的。   </p>\n<p>EmailableReporter: 这个报告类生成一个报告文件，可以很容易地通过电子邮件发送，显示测试的结果。   </p>\n<p>默认情况下，EmailableReporter在磁盘上生成一个文件。    </p>\n<pre><code>public class SinglePageReporter extends EmailableReporter\n{\n    private Writer writer;\n\n    public SinglePageReporter()\n    {\n        this.writer = writer;\n    }\n\n    protected PrintWriter createWriter(String out)\n    {\n        return new PrintWriter(writer);\n    }\n}\n</code></pre><p>调用TestNG的JSP页面    </p>\n<pre><code>&lt;%@ page import=&quot;org.testng.*, java.io.*&quot; %&gt;\n&lt;%\n    TestNG tester = new TestNG();\n    tester.setDefaultSuiteName(&quot;container-tests&quot;);\n\n    String root = application.getRealPath(&quot;/WEB-INF/classes&quot;);\n    ClassScanner scanner = new ClassScanner(new File(root));\n    scanner.setLoader(getClass().getClassLoader());\n    scanner.setFilter(new FileFilter() {\n        public boolean accept(File pathname) {\n            return pathname.getPath().indexOf(Test) &gt; -1;\n        }\n    });\n\n    Class[] classes = scanner.getClasses();\n    tester.setTestClasses(classes);\n\n    IReporter reporter = new SinglePageReporter(out);\n    tester.addListener(reporter);\n\n    tester.run();\n%&gt;\n</code></pre><p>Java命名和目录接(JNDI)<br>JNDI是一个在全局目录中查找资源的API。可以把他看成是一个很大的树型结构，我们在其中按照名称查找某个节点。    </p>\n<pre><code>new InitialContext().lockup(&quot;someObject&quot;);     \n</code></pre><p>上面创建一个InitialContext对象，如果在执行容器内执行，会利用供应商提供的API实现，来查找容器内部命名目录结构。创建了上下文之后，我们在其中查找对象，列出他的内容，或遍历这棵树。所有这些都是通过JNDI API来完成的。InitialContext的构造方法由一个重载的版本，接受一个Hashtable对象作为参数，其中包含不同的环境变量值，决定了上下文应该如何创建。    </p>\n<pre><code>Hashtable env = new Hashtable();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;&quot;);\nenv.put(Context.PROVIDER_URL, &quot;smqp://localhost:4001&quot;);\nObject topic = new InitialContext(env).lookup(&quot;myTopic&quot;);\n</code></pre><p>避免JNDI<br>组件依赖关系要么通过服务定位(通常是JNDI)来实现，要么通过注入来实现。如果您可以选择，就采用注入的方式，因为这样测试的开销最小，并且这种方式带来了更大的灵活性。   </p>\n<p>Java消息服务(JMS)   </p>\n<pre><code>private Session session;\nprivate Destination destination;\n\n@BeforeClass(groups = &quot;jms&quot;)\npublic void setupJMS() throws NamingException, JMSException\n{\n    Hashtable env = new Hashtable();\n    // populate environmet for out specific provider\n    InitialContext context = new InitialContext(env);\n\n    ConnectionFactory factory = (ConnectionFactory) context.lookup(&quot;QueueConnectionFactory&quot;);\n    Connection connection = factory.createConnection();\n    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    destination = (Detination) context.lookup(&quot;TestQueue@router1&quot;);\n}\n\n\n@Test(groups = &quot;jms&quot;)\npublic void sendMessage() throws JMSException\n{\n    TextMessage msg = session.createTextMessage();\n    msg.setText(&quot;hello!&quot;);\n    msg.setStringProperty(&quot;test&quot;, &quot;test1&quot;);\n    session.createProducer(destination).send(msg);\n}\n\n@Test(groups = &quot;jms&quot;, dependsOnMethods = &quot;sendMessage&quot;, timeOut = 1000)\npublic void receiveMessage() throws JMSException\n{\n    MessageConsumer consumer = session.createConsumer(destination, &quot;test&quot;, &quot;test1&quot;);\n    TextMessage msg = (TextMessage) consumer.receive();\n    assert &quot;hello!&quot;.equals(msg.getText());\n}\n</code></pre><p>在测试中使用ActiveMQ   </p>\n<pre><code>@BeforeClass(groups = &quot;jms&quot;)\npublic void setupActiveMQ() throws Exception\n{\n    BrokerService broker = new BrokerService();\n    broker.setPersistent(false);\n    broker.setUseJmx(false);\n    broker.start();\n\n    URI uri = broker.gettVmCnnectionURI();\n    ConnectionFactory factory = new ActiveMQConnectionFactory(uri);\n    Connection connection = factory.createConnection();\n    connection.start();\n\n    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    destination = session.createQueue(&quot;TestQueue@router1&quot;);\n}\n</code></pre><p>处理状态<br>在JMS的例子中，当我们拥有多个测试时，会引发一个有趣的问题。因为测试是由一对方法组成的，所以让我们假定同一个类中还有另一对发送/接收测试。    </p>\n<p>一种方法是将发送和接受者放在一个测试中，并在每个测试方法之前初始化消息代理。请注意两点都要做到，因为让消息代里在一对测试方法之前初始化是比较麻烦的。    </p>\n<p>另一种方法是使用消息分捡器。JMS消息分捡器让我们能够过滤接收到的消息，这样可以只接收与分捡器匹配的消息。   </p>\n<p>Spring<br>Spring的测试包功能     </p>\n<p>TestNG通过自己的一组针对Spring的类来解决这些问题，这些类作为扩展提供。org.testng.spring.test包中包含了所有Spring在其测试包中提供的类，这些类已修改过，可以用在基于TestNG的测试中。   </p>\n<p>AbstractSpringContextTests<br>这是所有Spring测试的基类。他的主要职责是提供上下文的管理。这个类包含一个静态map，其中包含所有注册的Spring上下文。   </p>\n<p>AbstractSingleSpringContextTests<br>这个类扩展了AbstractSpringContextTests，提供了装入一个ApplicationContext对象的钩子。他的子类应该实现getConfigLocation(String[] paths)方法。这个方法返回一个字符串数组，指出了Spring配置文件的位置，通常是从classpath加载的。    </p>\n<pre><code>import org.testng.annotation.Test;\nimport org.testng.spring.test.AbstractSingleSpringContextTests;\n\npublic class SpringContextTests extends AbstractSingleSpringContextTests\n{\n    protected String[] getConfigLocations()\n    {\n        return new String[] {&quot;/spring.xml&quot;};    \n    }\n\n    @Test\n    public void beanDefined()\n    {\n        assert applicationContext.getBean(&quot;myBean&quot;) != null;\n    }\n}\n</code></pre><p>Spring的配置方法被声明在名为Spring-init的TestNG分组中。我们不必依赖于单个的onSetUp或ontearDown方法，可以根据需要声明任意多个@BeforeMethod/@AfterMethod配置方法，只要指定他们依赖于spring-init，就可以确保他们在Spring执行完准备工作之后得到调用。    </p>\n<p>AbstractDependencyInjectionSpringContextTests<br>这个类提供的最有趣的功能就是向测试注入依赖。测试依赖关系可以表现为设值方法或成员字断。测试也可以指定Spring应该对他们的树性执行哪种类型的自动编织。    </p>\n<pre><code>public class SpringInjectionTests extends AbstractDependncyInjectionSpringContextTests\n{\n    private PersonManager manager;\n\n    protected String[] getConfigLocation()\n    {\n        return new String[] {&quot;/spring.xml&quot;};     \n    }\n\n    public void setManager(PersonManager manager)\n    {\n        this.manager = manager; \n    }\n\n    @Test\n    public void verifyManager()\n    {\n        assert manager != null;    \n    }\n}\n</code></pre><p>这个类有一个事务管理器属性。因为他派生自支持注入的类，配置文件中必需指定一个PlatforTransactionManager，以便注入。     </p>\n<pre><code>public class StrpingTranscationTests extends AbstractTransactionalSpringContextTests\n{\n    private PersonManager manager;\n\n    public void setManager(PersonManager manager)\n    {\n        this.manager = manager\n    }\n\n    protected String[] getConfigLocation()\n    {\n        return new String[] {&quot;/spring.xml&quot;};\n    }\n\n    @Test\n    public void savePerson()\n    {\n        Person p = new Person();\n        manager.savePerson(p);\n\n        assert p.getId() != null;\n        // setComplete();\n    }\n}\n</code></pre><p>我们没有在测试中指定任何事务行为，超类自动处理了事务方面的问题，让每个测试在他自己的事务中执行，这个十五将在该测试完成之后回滚。    </p>\n<p>增加的调用setComplete通知超类在测试执行之后应该提交这个事务，而不是回滚。调用这个方法由一个有趣的副作用：这个类中所有后续测试都会提交事务，而不是依赖于默认行为。   </p>\n<p>答案在于JUnit和TestNG之间的一个微妙区别。Spring测试假定采用了JUnit的语义。每个测试类对每个测试方法都会重新实例化。因此，所有的测试都假定每个测试开始时，测试时里的状态都会复原，但TestNG不是这样的。   </p>\n<p>AbstractTransactionalDataSouceSpringContextTests<br>这个类添加了一些JDBC相关的便利方法。   </p>\n<p>AbstractAnnotationAwareTransactionalTests<br>这个类支持超类提供的所有功能之外，这个类允许我们在测试方法上指定Spring特有的事务annotation，而不是通过编程的方式来指定事务行为。    </p>\n<p>Guice<br>第2章中的例子，对于每个接口，我们都有两个实现。一个是实际的产品实现，他会与一些外部的依赖关系进行交互，如UserDAO对象会与数据库交互，Mailer对象会与SMTP邮件服务器交互。我们还有桩对象实现。    </p>\n<pre><code>@Test\npublic void verifyCreateUser()\n{\n    UserManager manager = new UserManagerImpl();\n    MailerStub mailer = new MailerStub();\n\n    manager.setMailer(mailer);\n    manager.setDao(new UserDAOStub());\n\n    manager.createUser(&quot;tester&quot;);\n    assert mailer.getMails().size() == 1;\n}\n</code></pre><p>Guice注入测试    </p>\n<pre><code>@Inject private UserManager manager;\n@Inject private MailerStub mailer;\n\n@Test\npublic void verifyCreateUser()\n{\n    manager.createUser(&quot;tester&quot;);    \n    assert mailer.getMails().size() == 1;\n}\n</code></pre><p>Spring注入测试    </p>\n<pre><code>private UserManager manager;\nprivate MailerStub mailer;\n\npublic void verifyCreateUser()\n{\n    manager.createUser(&quot;tester&quot;);\n    assert mailer.getMails().size() == 1;\n}\n\npublic void setManager(UserManager manager)\n{\n    this.manager = manager;\n}\n\npublic void setMailer(MailerStub mailer)\n{\n    this.mailer = mailer;    \n}\n</code></pre><p>对象工厂 </p>\n<p>杂谈<br>关注和提供异常<br>一层遇到了一个没有预料到的错误，不知道如何处理。所以这一层就快乐地向上一层抛出一个异常，希望这个可怜的异常最终会遇到知道怎么作的人。  </p>\n<p>吞掉抛出异常    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    throw new BackendException(&quot;Error in backed&quot;);\n}\n</code></pre><p>这种方法问题在于，实际上我们丢试了真实错误的有意义的信息。当我们最后有机会处理这个异常的时候，我们得到的信息仅仅是某一层中出了问题，但我们不知道是在这一曾本身出了问题，还是更低的层出了问题。    </p>\n<p>记日志并抛出    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    log.error(&quot;Error calling backend&quot;, ex);\n    throw ex;\n}\n</code></pre><p>问题在于调用栈经常发生的情况：信息隐藏。假定一个应用程序有三层或四层，每一层都在日志中记录他处里的异常，查遍8页的调用栈信息并不是最有效地方式。    </p>\n<p>嵌套抛出    </p>\n<pre><code>try {\n    callBackend();\n}\ncatch (SQLException ex) {\n    throw new BackendException(&quot;Error in backend&quot;, ex);\n}\n</code></pre><p>当这个调用栈显示的时候，没有丝毫暗示表明背后的原因是什么。您必须编写一个帮助方法，从外面的包装中取出背后实际的异常。   </p>\n<p>我们建议两种解决方案    </p>\n<p>避免需检察异常。运行时异常很合适这样的情况。<br>包装异常。假如您非常肯定在调用栈打印时，背后的原因会显示出来，那么包装的异常也很好。    </p>\n<p>有状态测试<br>有两种截然不同的状态分类：不可修改的状态和可修改的状态   </p>\n<p>不可修改的状态<br>访问共享的不可修改的状态的测试方法，相互之间是独立的。<br>因为这些方法都不能修改他们读到的状态，所以调用顺序可以是任意的，因此他们没有违反测试访法应该彼此肚里的原则。    </p>\n<p>可修改的状态    </p>\n<pre><code>public class MyTest extends TestCase\n{\n    private int count = 0;\n\n    public void test1()\n    {\n        count++;\n        assertEquals(1, count);\n    }\n\n    public void test2()\n    {\n        count++;\n        assertEquals(2, count);\n    }\n}\n</code></pre><p>JUnit会让这个测试通过，但TestNG不会。<br>只有当您知道测试方法被调用的顺序时，共享可修改的状态才有意义。   </p>\n<p>安全的共享数<br>安全          不可修改的状态    </p>\n<p>安全　　　可修改的状态与完全指定的依赖关系    </p>\n<p>不安全　　可修改的状态与不确定的依赖关系   </p>\n<p>测试驱动开发的缺点<br>他注重微观设计超过宏观测试    </p>\n<p>他在实践中难以应用   </p>\n<p>TDD注重微观设计超过宏观设计    </p>\n<p>测试驱动开发可以得到更健壮的软件，但他也可能导致不必要的反复和过度重构的趋势，这可能对饮的软件、设计和最后期限产生负面影响。   </p>\n<p>TDD难以应用    </p>\n<p>这种方式得到的代码本身并不会优先于传统方法测试的代码。    </p>\n<p>如何创建测试并不重要，重要的是确实要创建测试    </p>\n<p>测试私有方法<br>如果他有可能出问题，您就应该测试他。    </p>\n<p>测试私有方法的比较好的方法是提升方法的可见性，例如，让他变成保护可见，或者包可见。后者更好一些，因为您可以把测试和被测类放在同一个包中，然后您就可以访问他的所有字段。如果这些方法都不可取，我们测试私有方法的方式就是利用反射。<br>    public class LoginController<br>    {<br>        private String userName;</p>\n<pre><code>    private void init()\n    {\n        this.username = getUserNameFromCookie();\n    }\n}\n\n@Test\npublic void verifyInit()\n{\n    LoginController lc = new LoginController();\n\n    Field f = lc.getClass().getField(&quot;username&quot;);\n    Object valueBefore = f.get(lc);\n    Assert.assertNull(valueBefore);\n\n    Method m = lc.getClass().getDeclaredMethod(&quot;init&quot;, null);\n    m.setAccessible(true);\n    m.invock(lc);\n\n    Object valueAfter = f.get(lc);\n    Assert.assertNotNull(vlaueAfter);\n}\n</code></pre><p>我们利用字符串来描述Java元素。如果您对这些元素进行重命名，这种危险的实践肯定会失效。    </p>\n<p>我们利用了该类危险的私有信息。我们不仅假定存在一些私有方法和属性，而且也假定这个方法将以某种方式修改一个字段。    </p>\n<p>测试与封装<br>如果让代码更可测试，不要担心破坏封装。可测试星应该胜过封装。   </p>\n<p>让一个私有方法(或字段)成为包可见的、保护可见的或公有的。    </p>\n<p>去掉方法的final限定符。这让测试勒能够扩展这些类，或重写这些方法，模拟或稍微改变他们的实现，从而让系统的其它部分更可测试。    </p>\n<p>记日志的最佳实践<br>在出错时，输出错误或警告是合理的。但是对於警告的情况，重要的是确定这是不是该做的事情。我们添加的每一条无用的日志信息都会干扰有用的信息，所已精心选择是有意义的。   </p>\n<p>对于调试需求，记日志是有用的。但是，只要有一个开关能打开或关闭，绝大多数的记日志需求都能够满足了，不需要复杂的解决方案。   </p>\n<p>参考文档：<a href=\"http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html\">http://www.cnblogs.com/rilley/archive/2012/11/09/2762818.html</a></p>"},{"layout":"post","title":"Mockito简介","date":"2013-06-21T13:29:00.000Z","comments":1,"_content":"\nMockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。   \n\n项目地址:<https://code.google.com/p/mockito/>\n\n##powermock 简介##\nEasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。   \n\n项目地址:<https://code.google.com/p/powermock/>\n<!--more-->\n##Mock 和Stub##\n###Mock###\n所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。\n\n###Stub###\nStub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。\n\n###Stub 与 Mock 的区别###\nStub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。\n\n##Mockito 的使用##\n\n###Maven###\n通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：\n\n\t<dependencies>\n\t<dependency>\n\t<groupId>org.mockito</groupId>\n\t<artifactId>mockito-all</artifactId>\n\t<version>1.9.0</version>\n\t<scope>test</scope>\n\t</dependency>\n\t</dependencies>\n\n在程序中可以`import org.mockito.Mockito`，然后调用它的static方法。\n\n###Maven 程序###\n####1.模拟对象####\n创建 Mock 对象的语法为 mock(class or interface)。\n####2.设置对象调用的预期返回值####\n通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。\n####3.验证被测试类方法####\nMock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。\n\n###Demo###\n\n##Mock 对象的创建##\n\tmock(Class<T> classToMock);\n\tmock(Class<T> classToMock, String name)\n    mock(Class<T> classToMock, Answer defaultAnswer)\n\tmock(Class<T> classToMock, MockSettings mockSettings)\n\tmock(Class<T> classToMock, ReturnValues returnValues)\n\n可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。\n\n##Mock对象的期望行为和返回值设定##\n假设我们创建了LinkedList类的mock对象：\n\n\tLinkedList mockedList = mock(LinkedList.class);\n\n###对方法进行设定返回值和异常###\n####对包含返回值的方法的设定####\n\n\twhen(mockedList.get(0)).thenReturn(\"first\");\n\twhen(mockedList.get(1)).thenThrow(new RuntimeException());   \n\nMockito支持迭代风格的返回值设定\n\n\twhen(mockedList.get(anyInt()).thenReturn(\"first\").thenThrow(new RuntimeException());\n\twhen(mockedList.get(anyInt()).thenReturn(\"first\",\"second\");\n\nStubbing的另一种风格   \n\n\tdoReturn(\"Hello\").when(mockedList).get(0);\n\tdoReturn(\"Hello\").doReturn(\"world\").when(mockedList).get(anyInt());\n\n抛出异常   \n\n\tdoThrow(new RuntimeException()).when(mockedList).get(0);\n\n####对void方法进行方法预期设定####\n\n\tdoNothing().when(mockedClass).SomeVoidMethod();\n \tdoThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n迭代风格\n\n\tdoNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n\n##参数匹配器##\n在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。   \n\n\t//stubbing using anyInt() argument matcher\n\twhen(mockedList.get(anyInt())).thenReturn(\"element\");\n\t\n\t//following prints \"element\"\n\tSystem.out.println(mockedList.get(999));\n\t\n\t//you can also verify using argument matcher\n\tverify(mockedList).get(anyInt());   \n\n需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(\"third argument\")，直接修改为“third argument”会报错。   \n\n\tverify(mockedClass).someMethod(anyObject(), anyString(), eq(\"third argument\"));\n\n##Mock对象行为的验证##\nMock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。   \n\n###调用次数验证###\n\tpublic static <T> T verify(T mock).someMethod()\n\tpublic static <T> T verify(T mock, VerificationMode mode).someMethod()\n\n\tParameters:\n\t\tmock - to be verified\n\t\tmode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() \n\tReturns:\n\t\tmock object itself\n\n###调用顺序验证 ###\n\tpublic static InOrder inOrder(java.lang.Object... mocks)\n\n创建mock对象  \n\n\t// Multiple mocks that must be used in a particular order\n\tList firstMock = mock(List.class);\n\tList secondMock = mock(List.class);\n调用mock对象的方法   \n\t \n\t//using mocks\n\tfirstMock.add(\"was called first\");\n\tsecondMock.add(\"was called second\");\n创建InOrder对象   \n\n\t//create inOrder object passing any mocks that need to be verified in order\n\tInOrder inOrder = inOrder(firstMock, secondMock);\n\n验证方法调用   \n \n\t//following will make sure that firstMock was called before secondMock\n\tinOrder.verify(firstMock).add(\"was called first\");\n\tinOrder.verify(secondMock).add(\"was called second\");\n\n\n\n##`RETURN_SMART_NULLS和RETURN_DEEP_STUBS`##\n`RETURN_SMART_NULLS` 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， `mock(class,answer)`。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空\"\", int 会返回 0,List 会返回 null。   \n\nmock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。   \n\n##注解##\nMockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks   \n\n###Annotation 的初始化 ###\n初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。\n\n\tpublic class ArticleManagerTest {\n   \n\t    @Mock private ArticleCalculator calculator;\n\t    @Mock private ArticleDatabase database;\n\t    @Mock private UserProvider userProvider;\n\t\n\t \t@Before public void setup() {\n\t\t\tMockitoAnnotations.initMocks(testClass);\n\t    }\n\t}\n\n使用Mockito提供的Junit Runner可以省略上述步骤。\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class ExampleTest {\n\t    @Mock private List list;\n\t\n\t    @Test public void shouldDoSomething() {\n\t        list.add(100);\n\t    }\n\t}\n\n## powermock 的使用 ##\n###Maven配置###\n\t<dependency>\n\t\t<groupId>org.powermock</groupId>\n\t\t<artifactId>powermock-module-junit4</artifactId>\n\t\t<version>1.4.10</version>\n\t\t<scope>test</scope>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.powermock</groupId>\n\t\t<artifactId>powermock-api-mockito</artifactId>\n\t\t<version>1.4.10</version>\n\t\t<scope>test</scope>\n\t</dependency>\n##PowerMock 在单元测试中的应用##\n###模拟 Static 方法###\n在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：   \n\n\t@RunWith(PowerMockRunner.class)   \n\n然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：   \n\n\t@PrepareForTest( { YourClassWithEgStaticMethod.class })   \n\n然后就可以开始写测试代码：\n\n\t1，首先，需要有一个含有 static 方法的代码 , 如\n\tpublic class IdGenerator { \n\t    ... \n\t    public static long generateNewId() { \n\t        ... \n\t    } \n\t    ... \n\t } \n\t2，然后，在被测代码中，引用了以上方法\n    public class ClassUnderTest { \n    \t... \n    \tpublic void methodToTest() { \n        .. \n        final long id = IdGenerator.generateNewId(); \n        .. \n     \t} \n    \t... \n \t} \n\n\t3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值\n\t来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：\n\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(IdGenerator.class) \n\t public class MyTestClass { \n\t    @Test \n\t    public void demoStaticMethodMocking() throws Exception { \n\t        PowerMockito.mockStatic(IdGenerator.class);  \n\t        when(IdGenerator.generateNewId()).thenReturn(2L); \n\t\n\t        new ClassUnderTest().methodToTest(); \n\t\n\t        verifyStatic(); \n\t        IdGenerator.generateNewId(); \n\t    } \n\t }\n\n###模拟构造函数###\n有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：\n\n\tpublic class DirectoryStructure { \n\t    public boolean create(String directoryPath) { \n\t        File directory = new File(directoryPath); \n\t\n\t        if (directory.exists()) { \n\t            throw new IllegalArgumentException(\n\t            \"\\\"\" + directoryPath + \"\\\" already exists.\"); \n\t        } \n\t\n\t        return directory.mkdirs(); \n\t    } \n\t }    \n\n为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：   \n\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(DirectoryStructure.class) \n\t public class DirectoryStructureTest { \n\t    @Test \n\t    public void createDirectoryStructureWhenPathDoesntExist() \n\t\tthrows Exception { \n\t        final String directoryPath = \"mocked path\"; \n\t\n\t        File directoryMock = mock(File.class); \n\t\n\t        //File的初始化函数的mock\n\t        whenNew(File.class).withArguments(directoryPath)\n\t\t\t\t.thenReturn(directoryMock); \n\t\n\t        // Standard expectations \n\t        when(directoryMock.exists()).thenReturn(false); \n\t        when(directoryMock.mkdirs()).thenReturn(true); \n\t\n\t        assertTrue(new NewFileExample()\n\t\t\t\t.createDirectoryStructure(directoryPath)); \n\t\n\t        // Optionally verify that a new File was \"created\". \n\t        verifyNew(File.class).withArguments(directoryPath); \n\t    } \n\t } \n使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。\n\n###模拟私有以及 Final 方法###\n为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。   \n\n在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。\n\n局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。   \n\n这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。\n参考如下所示的被测代码：\n\t\n\t public final class PrivatePartialMockingExample { \n\t    public String methodToTest() { \n\t        return methodToMock(\"input\"); \n\t    } \n\t\n\t    private String methodToMock(String input) { \n\t        return \"REAL VALUE = \" + input; \n\t    } \n\t } \n为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：   \n\t\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(PrivatePartialMockingExample.class) \n\t public class PrivatePartialMockingExampleTest { \n\t    @Test \n\t    public void demoPrivateMethodMocking() throws Exception { \n\t        final String expected = \"TEST VALUE\"; \n\t        final String nameOfMethodToMock = \"methodToMock\"; \n\t        final String input = \"input\"; \n\t\n\t        PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); \n\t\n\t        /* \n\t         * Setup the expectation to the private method using the method name \n\t         */ \n\t        when(underTest, nameOfMethodToMock, input).thenReturn(expected); \n\t\n\t        assertEquals(expected, underTest.methodToTest()); \n\t\n\t        // Optionally verify that the private method was actually called \n\t        verifyPrivate(underTest).invoke(nameOfMethodToMock, input); \n\t    } \n\t } \n可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。\n\n参考文献:<http://www.ibm.com/developerworks/cn/java/j-lo-powermock/>\n\n---\nThanks to：lizejun\n","source":"_posts/2013-06-21-mockito-in-brief.markdown","raw":"---\nlayout: post\ntitle: \"Mockito简介\"\ndate: 2013-06-21 21:29\ncomments: true\ncategories: ut\ntags: [ mockito, ut, powermock, stub, mock]\n---\n\nMockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。   \n\n项目地址:<https://code.google.com/p/mockito/>\n\n##powermock 简介##\nEasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。   \n\n项目地址:<https://code.google.com/p/powermock/>\n<!--more-->\n##Mock 和Stub##\n###Mock###\n所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。\n\n###Stub###\nStub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。\n\n###Stub 与 Mock 的区别###\nStub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。\n\n##Mockito 的使用##\n\n###Maven###\n通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：\n\n\t<dependencies>\n\t<dependency>\n\t<groupId>org.mockito</groupId>\n\t<artifactId>mockito-all</artifactId>\n\t<version>1.9.0</version>\n\t<scope>test</scope>\n\t</dependency>\n\t</dependencies>\n\n在程序中可以`import org.mockito.Mockito`，然后调用它的static方法。\n\n###Maven 程序###\n####1.模拟对象####\n创建 Mock 对象的语法为 mock(class or interface)。\n####2.设置对象调用的预期返回值####\n通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。\n####3.验证被测试类方法####\nMock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。\n\n###Demo###\n\n##Mock 对象的创建##\n\tmock(Class<T> classToMock);\n\tmock(Class<T> classToMock, String name)\n    mock(Class<T> classToMock, Answer defaultAnswer)\n\tmock(Class<T> classToMock, MockSettings mockSettings)\n\tmock(Class<T> classToMock, ReturnValues returnValues)\n\n可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。\n\n##Mock对象的期望行为和返回值设定##\n假设我们创建了LinkedList类的mock对象：\n\n\tLinkedList mockedList = mock(LinkedList.class);\n\n###对方法进行设定返回值和异常###\n####对包含返回值的方法的设定####\n\n\twhen(mockedList.get(0)).thenReturn(\"first\");\n\twhen(mockedList.get(1)).thenThrow(new RuntimeException());   \n\nMockito支持迭代风格的返回值设定\n\n\twhen(mockedList.get(anyInt()).thenReturn(\"first\").thenThrow(new RuntimeException());\n\twhen(mockedList.get(anyInt()).thenReturn(\"first\",\"second\");\n\nStubbing的另一种风格   \n\n\tdoReturn(\"Hello\").when(mockedList).get(0);\n\tdoReturn(\"Hello\").doReturn(\"world\").when(mockedList).get(anyInt());\n\n抛出异常   \n\n\tdoThrow(new RuntimeException()).when(mockedList).get(0);\n\n####对void方法进行方法预期设定####\n\n\tdoNothing().when(mockedClass).SomeVoidMethod();\n \tdoThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n迭代风格\n\n\tdoNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n\n##参数匹配器##\n在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。   \n\n\t//stubbing using anyInt() argument matcher\n\twhen(mockedList.get(anyInt())).thenReturn(\"element\");\n\t\n\t//following prints \"element\"\n\tSystem.out.println(mockedList.get(999));\n\t\n\t//you can also verify using argument matcher\n\tverify(mockedList).get(anyInt());   \n\n需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(\"third argument\")，直接修改为“third argument”会报错。   \n\n\tverify(mockedClass).someMethod(anyObject(), anyString(), eq(\"third argument\"));\n\n##Mock对象行为的验证##\nMock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。   \n\n###调用次数验证###\n\tpublic static <T> T verify(T mock).someMethod()\n\tpublic static <T> T verify(T mock, VerificationMode mode).someMethod()\n\n\tParameters:\n\t\tmock - to be verified\n\t\tmode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() \n\tReturns:\n\t\tmock object itself\n\n###调用顺序验证 ###\n\tpublic static InOrder inOrder(java.lang.Object... mocks)\n\n创建mock对象  \n\n\t// Multiple mocks that must be used in a particular order\n\tList firstMock = mock(List.class);\n\tList secondMock = mock(List.class);\n调用mock对象的方法   \n\t \n\t//using mocks\n\tfirstMock.add(\"was called first\");\n\tsecondMock.add(\"was called second\");\n创建InOrder对象   \n\n\t//create inOrder object passing any mocks that need to be verified in order\n\tInOrder inOrder = inOrder(firstMock, secondMock);\n\n验证方法调用   \n \n\t//following will make sure that firstMock was called before secondMock\n\tinOrder.verify(firstMock).add(\"was called first\");\n\tinOrder.verify(secondMock).add(\"was called second\");\n\n\n\n##`RETURN_SMART_NULLS和RETURN_DEEP_STUBS`##\n`RETURN_SMART_NULLS` 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， `mock(class,answer)`。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空\"\", int 会返回 0,List 会返回 null。   \n\nmock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。   \n\n##注解##\nMockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks   \n\n###Annotation 的初始化 ###\n初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。\n\n\tpublic class ArticleManagerTest {\n   \n\t    @Mock private ArticleCalculator calculator;\n\t    @Mock private ArticleDatabase database;\n\t    @Mock private UserProvider userProvider;\n\t\n\t \t@Before public void setup() {\n\t\t\tMockitoAnnotations.initMocks(testClass);\n\t    }\n\t}\n\n使用Mockito提供的Junit Runner可以省略上述步骤。\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class ExampleTest {\n\t    @Mock private List list;\n\t\n\t    @Test public void shouldDoSomething() {\n\t        list.add(100);\n\t    }\n\t}\n\n## powermock 的使用 ##\n###Maven配置###\n\t<dependency>\n\t\t<groupId>org.powermock</groupId>\n\t\t<artifactId>powermock-module-junit4</artifactId>\n\t\t<version>1.4.10</version>\n\t\t<scope>test</scope>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.powermock</groupId>\n\t\t<artifactId>powermock-api-mockito</artifactId>\n\t\t<version>1.4.10</version>\n\t\t<scope>test</scope>\n\t</dependency>\n##PowerMock 在单元测试中的应用##\n###模拟 Static 方法###\n在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：   \n\n\t@RunWith(PowerMockRunner.class)   \n\n然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：   \n\n\t@PrepareForTest( { YourClassWithEgStaticMethod.class })   \n\n然后就可以开始写测试代码：\n\n\t1，首先，需要有一个含有 static 方法的代码 , 如\n\tpublic class IdGenerator { \n\t    ... \n\t    public static long generateNewId() { \n\t        ... \n\t    } \n\t    ... \n\t } \n\t2，然后，在被测代码中，引用了以上方法\n    public class ClassUnderTest { \n    \t... \n    \tpublic void methodToTest() { \n        .. \n        final long id = IdGenerator.generateNewId(); \n        .. \n     \t} \n    \t... \n \t} \n\n\t3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值\n\t来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：\n\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(IdGenerator.class) \n\t public class MyTestClass { \n\t    @Test \n\t    public void demoStaticMethodMocking() throws Exception { \n\t        PowerMockito.mockStatic(IdGenerator.class);  \n\t        when(IdGenerator.generateNewId()).thenReturn(2L); \n\t\n\t        new ClassUnderTest().methodToTest(); \n\t\n\t        verifyStatic(); \n\t        IdGenerator.generateNewId(); \n\t    } \n\t }\n\n###模拟构造函数###\n有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：\n\n\tpublic class DirectoryStructure { \n\t    public boolean create(String directoryPath) { \n\t        File directory = new File(directoryPath); \n\t\n\t        if (directory.exists()) { \n\t            throw new IllegalArgumentException(\n\t            \"\\\"\" + directoryPath + \"\\\" already exists.\"); \n\t        } \n\t\n\t        return directory.mkdirs(); \n\t    } \n\t }    \n\n为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：   \n\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(DirectoryStructure.class) \n\t public class DirectoryStructureTest { \n\t    @Test \n\t    public void createDirectoryStructureWhenPathDoesntExist() \n\t\tthrows Exception { \n\t        final String directoryPath = \"mocked path\"; \n\t\n\t        File directoryMock = mock(File.class); \n\t\n\t        //File的初始化函数的mock\n\t        whenNew(File.class).withArguments(directoryPath)\n\t\t\t\t.thenReturn(directoryMock); \n\t\n\t        // Standard expectations \n\t        when(directoryMock.exists()).thenReturn(false); \n\t        when(directoryMock.mkdirs()).thenReturn(true); \n\t\n\t        assertTrue(new NewFileExample()\n\t\t\t\t.createDirectoryStructure(directoryPath)); \n\t\n\t        // Optionally verify that a new File was \"created\". \n\t        verifyNew(File.class).withArguments(directoryPath); \n\t    } \n\t } \n使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。\n\n###模拟私有以及 Final 方法###\n为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。   \n\n在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。\n\n局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。   \n\n这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。\n参考如下所示的被测代码：\n\t\n\t public final class PrivatePartialMockingExample { \n\t    public String methodToTest() { \n\t        return methodToMock(\"input\"); \n\t    } \n\t\n\t    private String methodToMock(String input) { \n\t        return \"REAL VALUE = \" + input; \n\t    } \n\t } \n为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：   \n\t\n\t @RunWith(PowerMockRunner.class) \n\t @PrepareForTest(PrivatePartialMockingExample.class) \n\t public class PrivatePartialMockingExampleTest { \n\t    @Test \n\t    public void demoPrivateMethodMocking() throws Exception { \n\t        final String expected = \"TEST VALUE\"; \n\t        final String nameOfMethodToMock = \"methodToMock\"; \n\t        final String input = \"input\"; \n\t\n\t        PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); \n\t\n\t        /* \n\t         * Setup the expectation to the private method using the method name \n\t         */ \n\t        when(underTest, nameOfMethodToMock, input).thenReturn(expected); \n\t\n\t        assertEquals(expected, underTest.methodToTest()); \n\t\n\t        // Optionally verify that the private method was actually called \n\t        verifyPrivate(underTest).invoke(nameOfMethodToMock, input); \n\t    } \n\t } \n可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。\n\n参考文献:<http://www.ibm.com/developerworks/cn/java/j-lo-powermock/>\n\n---\nThanks to：lizejun\n","slug":"2013-06-21-mockito-in-brief","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6f0075v8fy3cutfxbz","content":"<p>Mockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。   </p>\n<p>项目地址:<a href=\"https://code.google.com/p/mockito/\" target=\"_blank\" rel=\"external\">https://code.google.com/p/mockito/</a></p>\n<p>##powermock 简介##<br>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。   </p>\n<p>项目地址:<a href=\"https://code.google.com/p/powermock/\" target=\"_blank\" rel=\"external\">https://code.google.com/p/powermock/</a><br><a id=\"more\"></a></p>\n<p>##Mock 和Stub##</p>\n<p>###Mock###<br>所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。</p>\n<p>###Stub###<br>Stub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。</p>\n<p>###Stub 与 Mock 的区别###<br>Stub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。</p>\n<p>##Mockito 的使用##</p>\n<p>###Maven###<br>通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：</p>\n<pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.mockito&lt;/groupId&gt;\n&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;\n&lt;version&gt;1.9.0&lt;/version&gt;\n&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><p>在程序中可以<code>import org.mockito.Mockito</code>，然后调用它的static方法。</p>\n<p>###Maven 程序###</p>\n<p>####1.模拟对象####<br>创建 Mock 对象的语法为 mock(class or interface)。</p>\n<p>####2.设置对象调用的预期返回值####<br>通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。</p>\n<p>####3.验证被测试类方法####<br>Mock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。</p>\n<p>###Demo###</p>\n<p>##Mock 对象的创建##<br>    mock(Class<t> classToMock);<br>    mock(Class<t> classToMock, String name)<br>    mock(Class<t> classToMock, Answer defaultAnswer)<br>    mock(Class<t> classToMock, MockSettings mockSettings)<br>    mock(Class<t> classToMock, ReturnValues returnValues)</t></t></t></t></t></p>\n<p>可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。</p>\n<p>##Mock对象的期望行为和返回值设定##<br>假设我们创建了LinkedList类的mock对象：</p>\n<pre><code>LinkedList mockedList = mock(LinkedList.class);\n</code></pre><p>###对方法进行设定返回值和异常###</p>\n<p>####对包含返回值的方法的设定####</p>\n<pre><code>when(mockedList.get(0)).thenReturn(&quot;first&quot;);\nwhen(mockedList.get(1)).thenThrow(new RuntimeException());   \n</code></pre><p>Mockito支持迭代风格的返回值设定</p>\n<pre><code>when(mockedList.get(anyInt()).thenReturn(&quot;first&quot;).thenThrow(new RuntimeException());\nwhen(mockedList.get(anyInt()).thenReturn(&quot;first&quot;,&quot;second&quot;);\n</code></pre><p>Stubbing的另一种风格   </p>\n<pre><code>doReturn(&quot;Hello&quot;).when(mockedList).get(0);\ndoReturn(&quot;Hello&quot;).doReturn(&quot;world&quot;).when(mockedList).get(anyInt());\n</code></pre><p>抛出异常   </p>\n<pre><code>doThrow(new RuntimeException()).when(mockedList).get(0);\n</code></pre><p>####对void方法进行方法预期设定####</p>\n<pre><code>doNothing().when(mockedClass).SomeVoidMethod();\n doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n</code></pre><p>迭代风格</p>\n<pre><code>doNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n</code></pre><p>##参数匹配器##<br>在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。   </p>\n<pre><code>//stubbing using anyInt() argument matcher\nwhen(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);\n\n//following prints &quot;element&quot;\nSystem.out.println(mockedList.get(999));\n\n//you can also verify using argument matcher\nverify(mockedList).get(anyInt());   \n</code></pre><p>需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(“third argument”)，直接修改为“third argument”会报错。   </p>\n<pre><code>verify(mockedClass).someMethod(anyObject(), anyString(), eq(&quot;third argument&quot;));\n</code></pre><p>##Mock对象行为的验证##<br>Mock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。   </p>\n<p>###调用次数验证###<br>    public static <t> T verify(T mock).someMethod()<br>    public static <t> T verify(T mock, VerificationMode mode).someMethod()</t></t></p>\n<pre><code>Parameters:\n    mock - to be verified\n    mode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() \nReturns:\n    mock object itself\n</code></pre><p>###调用顺序验证 ###<br>    public static InOrder inOrder(java.lang.Object… mocks)</p>\n<p>创建mock对象  </p>\n<pre><code>// Multiple mocks that must be used in a particular order\nList firstMock = mock(List.class);\nList secondMock = mock(List.class);\n</code></pre><p>调用mock对象的方法   </p>\n<pre><code>//using mocks\nfirstMock.add(&quot;was called first&quot;);\nsecondMock.add(&quot;was called second&quot;);\n</code></pre><p>创建InOrder对象   </p>\n<pre><code>//create inOrder object passing any mocks that need to be verified in order\nInOrder inOrder = inOrder(firstMock, secondMock);\n</code></pre><p>验证方法调用   </p>\n<pre><code>//following will make sure that firstMock was called before secondMock\ninOrder.verify(firstMock).add(&quot;was called first&quot;);\ninOrder.verify(secondMock).add(&quot;was called second&quot;);\n</code></pre><p>##<code>RETURN_SMART_NULLS和RETURN_DEEP_STUBS</code>##<br><code>RETURN_SMART_NULLS</code> 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， <code>mock(class,answer)</code>。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空””, int 会返回 0,List 会返回 null。   </p>\n<p>mock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。   </p>\n<p>##注解##<br>Mockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks   </p>\n<p>###Annotation 的初始化 ###<br>初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。</p>\n<pre><code>public class ArticleManagerTest {\n\n    @Mock private ArticleCalculator calculator;\n    @Mock private ArticleDatabase database;\n    @Mock private UserProvider userProvider;\n\n     @Before public void setup() {\n        MockitoAnnotations.initMocks(testClass);\n    }\n}\n</code></pre><p>使用Mockito提供的Junit Runner可以省略上述步骤。</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class ExampleTest {\n    @Mock private List list;\n\n    @Test public void shouldDoSomething() {\n        list.add(100);\n    }\n}\n</code></pre><h2 id=\"powermock-的使用\"><a href=\"#powermock-的使用\" class=\"headerlink\" title=\"powermock 的使用\"></a>powermock 的使用</h2><p>###Maven配置###<br>    <dependency><br>        <groupid>org.powermock</groupid><br>        <artifactid>powermock-module-junit4</artifactid><br>        <version>1.4.10</version><br>        <scope>test</scope><br>    </dependency><br>    <dependency><br>        <groupid>org.powermock</groupid><br>        <artifactid>powermock-api-mockito</artifactid><br>        <version>1.4.10</version><br>        <scope>test</scope><br>    </dependency></p>\n<p>##PowerMock 在单元测试中的应用##</p>\n<p>###模拟 Static 方法###<br>在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：   </p>\n<pre><code>@RunWith(PowerMockRunner.class)   \n</code></pre><p>然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：   </p>\n<pre><code>@PrepareForTest( { YourClassWithEgStaticMethod.class })   \n</code></pre><p>然后就可以开始写测试代码：</p>\n<pre><code>1，首先，需要有一个含有 static 方法的代码 , 如\npublic class IdGenerator { \n    ... \n    public static long generateNewId() { \n        ... \n    } \n    ... \n } \n2，然后，在被测代码中，引用了以上方法\npublic class ClassUnderTest { \n    ... \n    public void methodToTest() { \n    .. \n    final long id = IdGenerator.generateNewId(); \n    .. \n     } \n    ... \n } \n\n3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值\n来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：\n\n @RunWith(PowerMockRunner.class) \n @PrepareForTest(IdGenerator.class) \n public class MyTestClass { \n    @Test \n    public void demoStaticMethodMocking() throws Exception { \n        PowerMockito.mockStatic(IdGenerator.class);  \n        when(IdGenerator.generateNewId()).thenReturn(2L); \n\n        new ClassUnderTest().methodToTest(); \n\n        verifyStatic(); \n        IdGenerator.generateNewId(); \n    } \n }\n</code></pre><p>###模拟构造函数###<br>有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：</p>\n<pre><code>public class DirectoryStructure { \n    public boolean create(String directoryPath) { \n        File directory = new File(directoryPath); \n\n        if (directory.exists()) { \n            throw new IllegalArgumentException(\n            &quot;\\&quot;&quot; + directoryPath + &quot;\\&quot; already exists.&quot;); \n        } \n\n        return directory.mkdirs(); \n    } \n }    \n</code></pre><p>为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：   </p>\n<pre><code>@RunWith(PowerMockRunner.class) \n@PrepareForTest(DirectoryStructure.class) \npublic class DirectoryStructureTest { \n   @Test \n   public void createDirectoryStructureWhenPathDoesntExist() \n   throws Exception { \n       final String directoryPath = &quot;mocked path&quot;; \n\n       File directoryMock = mock(File.class); \n\n       //File的初始化函数的mock\n       whenNew(File.class).withArguments(directoryPath)\n           .thenReturn(directoryMock); \n\n       // Standard expectations \n       when(directoryMock.exists()).thenReturn(false); \n       when(directoryMock.mkdirs()).thenReturn(true); \n\n       assertTrue(new NewFileExample()\n           .createDirectoryStructure(directoryPath)); \n\n       // Optionally verify that a new File was &quot;created&quot;. \n       verifyNew(File.class).withArguments(directoryPath); \n   } \n} \n</code></pre><p>使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。</p>\n<p>###模拟私有以及 Final 方法###<br>为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。   </p>\n<p>在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。</p>\n<p>局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。   </p>\n<p>这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。<br>参考如下所示的被测代码：</p>\n<pre><code>public final class PrivatePartialMockingExample { \n   public String methodToTest() { \n       return methodToMock(&quot;input&quot;); \n   } \n\n   private String methodToMock(String input) { \n       return &quot;REAL VALUE = &quot; + input; \n   } \n} \n</code></pre><p>为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：   </p>\n<pre><code>@RunWith(PowerMockRunner.class) \n@PrepareForTest(PrivatePartialMockingExample.class) \npublic class PrivatePartialMockingExampleTest { \n   @Test \n   public void demoPrivateMethodMocking() throws Exception { \n       final String expected = &quot;TEST VALUE&quot;; \n       final String nameOfMethodToMock = &quot;methodToMock&quot;; \n       final String input = &quot;input&quot;; \n\n       PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); \n\n       /* \n        * Setup the expectation to the private method using the method name \n        */ \n       when(underTest, nameOfMethodToMock, input).thenReturn(expected); \n\n       assertEquals(expected, underTest.methodToTest()); \n\n       // Optionally verify that the private method was actually called \n       verifyPrivate(underTest).invoke(nameOfMethodToMock, input); \n   } \n} \n</code></pre><p>可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。</p>\n<p>参考文献:<a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-powermock/\" target=\"_blank\" rel=\"external\">http://www.ibm.com/developerworks/cn/java/j-lo-powermock/</a></p>\n<hr>\n<p>Thanks to：lizejun</p>\n","excerpt":"<p>Mockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。   </p>\n<p>项目地址:<a href=\"https://code.google.com/p/mockito/\">https://code.google.com/p/mockito/</a></p>\n<p>##powermock 简介##<br>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。   </p>\n<p>项目地址:<a href=\"https://code.google.com/p/powermock/\">https://code.google.com/p/powermock/</a><br>","more":"</p>\n<p>##Mock 和Stub##</p>\n<p>###Mock###<br>所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。</p>\n<p>###Stub###<br>Stub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。</p>\n<p>###Stub 与 Mock 的区别###<br>Stub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。</p>\n<p>##Mockito 的使用##</p>\n<p>###Maven###<br>通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：</p>\n<pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.mockito&lt;/groupId&gt;\n&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;\n&lt;version&gt;1.9.0&lt;/version&gt;\n&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><p>在程序中可以<code>import org.mockito.Mockito</code>，然后调用它的static方法。</p>\n<p>###Maven 程序###</p>\n<p>####1.模拟对象####<br>创建 Mock 对象的语法为 mock(class or interface)。</p>\n<p>####2.设置对象调用的预期返回值####<br>通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。</p>\n<p>####3.验证被测试类方法####<br>Mock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。</p>\n<p>###Demo###</p>\n<p>##Mock 对象的创建##<br>    mock(Class<T> classToMock);<br>    mock(Class<T> classToMock, String name)<br>    mock(Class<T> classToMock, Answer defaultAnswer)<br>    mock(Class<T> classToMock, MockSettings mockSettings)<br>    mock(Class<T> classToMock, ReturnValues returnValues)</p>\n<p>可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。</p>\n<p>##Mock对象的期望行为和返回值设定##<br>假设我们创建了LinkedList类的mock对象：</p>\n<pre><code>LinkedList mockedList = mock(LinkedList.class);\n</code></pre><p>###对方法进行设定返回值和异常###</p>\n<p>####对包含返回值的方法的设定####</p>\n<pre><code>when(mockedList.get(0)).thenReturn(&quot;first&quot;);\nwhen(mockedList.get(1)).thenThrow(new RuntimeException());   \n</code></pre><p>Mockito支持迭代风格的返回值设定</p>\n<pre><code>when(mockedList.get(anyInt()).thenReturn(&quot;first&quot;).thenThrow(new RuntimeException());\nwhen(mockedList.get(anyInt()).thenReturn(&quot;first&quot;,&quot;second&quot;);\n</code></pre><p>Stubbing的另一种风格   </p>\n<pre><code>doReturn(&quot;Hello&quot;).when(mockedList).get(0);\ndoReturn(&quot;Hello&quot;).doReturn(&quot;world&quot;).when(mockedList).get(anyInt());\n</code></pre><p>抛出异常   </p>\n<pre><code>doThrow(new RuntimeException()).when(mockedList).get(0);\n</code></pre><p>####对void方法进行方法预期设定####</p>\n<pre><code>doNothing().when(mockedClass).SomeVoidMethod();\n doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n</code></pre><p>迭代风格</p>\n<pre><code>doNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();\n</code></pre><p>##参数匹配器##<br>在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。   </p>\n<pre><code>//stubbing using anyInt() argument matcher\nwhen(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);\n\n//following prints &quot;element&quot;\nSystem.out.println(mockedList.get(999));\n\n//you can also verify using argument matcher\nverify(mockedList).get(anyInt());   \n</code></pre><p>需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq(“third argument”)，直接修改为“third argument”会报错。   </p>\n<pre><code>verify(mockedClass).someMethod(anyObject(), anyString(), eq(&quot;third argument&quot;));\n</code></pre><p>##Mock对象行为的验证##<br>Mock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。   </p>\n<p>###调用次数验证###<br>    public static <T> T verify(T mock).someMethod()<br>    public static <T> T verify(T mock, VerificationMode mode).someMethod()</p>\n<pre><code>Parameters:\n    mock - to be verified\n    mode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() \nReturns:\n    mock object itself\n</code></pre><p>###调用顺序验证 ###<br>    public static InOrder inOrder(java.lang.Object… mocks)</p>\n<p>创建mock对象  </p>\n<pre><code>// Multiple mocks that must be used in a particular order\nList firstMock = mock(List.class);\nList secondMock = mock(List.class);\n</code></pre><p>调用mock对象的方法   </p>\n<pre><code>//using mocks\nfirstMock.add(&quot;was called first&quot;);\nsecondMock.add(&quot;was called second&quot;);\n</code></pre><p>创建InOrder对象   </p>\n<pre><code>//create inOrder object passing any mocks that need to be verified in order\nInOrder inOrder = inOrder(firstMock, secondMock);\n</code></pre><p>验证方法调用   </p>\n<pre><code>//following will make sure that firstMock was called before secondMock\ninOrder.verify(firstMock).add(&quot;was called first&quot;);\ninOrder.verify(secondMock).add(&quot;was called second&quot;);\n</code></pre><p>##<code>RETURN_SMART_NULLS和RETURN_DEEP_STUBS</code>##<br><code>RETURN_SMART_NULLS</code> 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， <code>mock(class,answer)</code>。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空””, int 会返回 0,List 会返回 null。   </p>\n<p>mock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。   </p>\n<p>##注解##<br>Mockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks   </p>\n<p>###Annotation 的初始化 ###<br>初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。</p>\n<pre><code>public class ArticleManagerTest {\n\n    @Mock private ArticleCalculator calculator;\n    @Mock private ArticleDatabase database;\n    @Mock private UserProvider userProvider;\n\n     @Before public void setup() {\n        MockitoAnnotations.initMocks(testClass);\n    }\n}\n</code></pre><p>使用Mockito提供的Junit Runner可以省略上述步骤。</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class ExampleTest {\n    @Mock private List list;\n\n    @Test public void shouldDoSomething() {\n        list.add(100);\n    }\n}\n</code></pre><h2 id=\"powermock-的使用\"><a href=\"#powermock-的使用\" class=\"headerlink\" title=\"powermock 的使用\"></a>powermock 的使用</h2><p>###Maven配置###<br>    <dependency><br>        <groupId>org.powermock</groupId><br>        <artifactId>powermock-module-junit4</artifactId><br>        <version>1.4.10</version><br>        <scope>test</scope><br>    </dependency><br>    <dependency><br>        <groupId>org.powermock</groupId><br>        <artifactId>powermock-api-mockito</artifactId><br>        <version>1.4.10</version><br>        <scope>test</scope><br>    </dependency></p>\n<p>##PowerMock 在单元测试中的应用##</p>\n<p>###模拟 Static 方法###<br>在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：   </p>\n<pre><code>@RunWith(PowerMockRunner.class)   \n</code></pre><p>然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：   </p>\n<pre><code>@PrepareForTest( { YourClassWithEgStaticMethod.class })   \n</code></pre><p>然后就可以开始写测试代码：</p>\n<pre><code>1，首先，需要有一个含有 static 方法的代码 , 如\npublic class IdGenerator { \n    ... \n    public static long generateNewId() { \n        ... \n    } \n    ... \n } \n2，然后，在被测代码中，引用了以上方法\npublic class ClassUnderTest { \n    ... \n    public void methodToTest() { \n    .. \n    final long id = IdGenerator.generateNewId(); \n    .. \n     } \n    ... \n } \n\n3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值\n来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：\n\n @RunWith(PowerMockRunner.class) \n @PrepareForTest(IdGenerator.class) \n public class MyTestClass { \n    @Test \n    public void demoStaticMethodMocking() throws Exception { \n        PowerMockito.mockStatic(IdGenerator.class);  \n        when(IdGenerator.generateNewId()).thenReturn(2L); \n\n        new ClassUnderTest().methodToTest(); \n\n        verifyStatic(); \n        IdGenerator.generateNewId(); \n    } \n }\n</code></pre><p>###模拟构造函数###<br>有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：</p>\n<pre><code>public class DirectoryStructure { \n    public boolean create(String directoryPath) { \n        File directory = new File(directoryPath); \n\n        if (directory.exists()) { \n            throw new IllegalArgumentException(\n            &quot;\\&quot;&quot; + directoryPath + &quot;\\&quot; already exists.&quot;); \n        } \n\n        return directory.mkdirs(); \n    } \n }    \n</code></pre><p>为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：   </p>\n<pre><code>@RunWith(PowerMockRunner.class) \n@PrepareForTest(DirectoryStructure.class) \npublic class DirectoryStructureTest { \n   @Test \n   public void createDirectoryStructureWhenPathDoesntExist() \n   throws Exception { \n       final String directoryPath = &quot;mocked path&quot;; \n\n       File directoryMock = mock(File.class); \n\n       //File的初始化函数的mock\n       whenNew(File.class).withArguments(directoryPath)\n           .thenReturn(directoryMock); \n\n       // Standard expectations \n       when(directoryMock.exists()).thenReturn(false); \n       when(directoryMock.mkdirs()).thenReturn(true); \n\n       assertTrue(new NewFileExample()\n           .createDirectoryStructure(directoryPath)); \n\n       // Optionally verify that a new File was &quot;created&quot;. \n       verifyNew(File.class).withArguments(directoryPath); \n   } \n} \n</code></pre><p>使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。</p>\n<p>###模拟私有以及 Final 方法###<br>为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。   </p>\n<p>在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。</p>\n<p>局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。   </p>\n<p>这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。<br>参考如下所示的被测代码：</p>\n<pre><code>public final class PrivatePartialMockingExample { \n   public String methodToTest() { \n       return methodToMock(&quot;input&quot;); \n   } \n\n   private String methodToMock(String input) { \n       return &quot;REAL VALUE = &quot; + input; \n   } \n} \n</code></pre><p>为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：   </p>\n<pre><code>@RunWith(PowerMockRunner.class) \n@PrepareForTest(PrivatePartialMockingExample.class) \npublic class PrivatePartialMockingExampleTest { \n   @Test \n   public void demoPrivateMethodMocking() throws Exception { \n       final String expected = &quot;TEST VALUE&quot;; \n       final String nameOfMethodToMock = &quot;methodToMock&quot;; \n       final String input = &quot;input&quot;; \n\n       PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); \n\n       /* \n        * Setup the expectation to the private method using the method name \n        */ \n       when(underTest, nameOfMethodToMock, input).thenReturn(expected); \n\n       assertEquals(expected, underTest.methodToTest()); \n\n       // Optionally verify that the private method was actually called \n       verifyPrivate(underTest).invoke(nameOfMethodToMock, input); \n   } \n} \n</code></pre><p>可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。</p>\n<p>参考文献:<a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-powermock/\">http://www.ibm.com/developerworks/cn/java/j-lo-powermock/</a></p>\n<hr>\n<p>Thanks to：lizejun</p>"},{"layout":"post","title":"DbUnit使用入门","date":"2013-06-27T07:57:00.000Z","comments":1,"_content":"[DbUnit](http://www.dbunit.org/)是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。   \n     \n###DbUnit原理\nDbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。   \nDbUnit包括三个核心部分:\n    \n- IDatabaseConnection ：描述DbUnit数据库连接接口；\n- IDataSet：数据集操作接口；\n- DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；\n\n<!--more-->\n值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。  \n\nDatabaseOperation有以下的可选项：   \n\n- NONE：不执行任何操作，是getTearDownOperation的默认返回值。\n- UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。\n- INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。\n- REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。\n- DELETE：删除数据库中与数据集对应的记录。\n- DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。\n- TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。\n- CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。   \n\n###开始使用DbUnit\n####DataSet数据集准备\nDataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以[手工编写](http://www.dbunit.org/components.html#FlatXmlDataSet)。另外也可以从数据库读取，DbUnit提供了相关的API：  \n\n        QueryDataSet dataSet = new QueryDataSet(getConnection());\n        dataSet.addTable(\"user\", \"select * from user \");\n        FlatXmlDataSet.write(dataSet, new FileOutputStream(\"data.xml\"));\n####继承DBTestCase来实现测试用例\n最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：  \n\n- JdbcBasedDBTestCase\n- DataSourceBasedDBTestCase\n- JndiBasedDBTestCase\n\n下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。   \n\n    public class SampleTest extends DBTestCase\n    {\n        public SampleTest(String name)\n        {\n            super( name );\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, \"org.h2.Driver\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, \"jdbc:h2:~/dbunitdemo\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, \"sa\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, \"\");\n    \n        protected IDataSet getDataSet() throws Exception\n        {\n            return new FlatXmlDataSetBuilder().build(new FileInputStream(\"dataset.xml\"));\n        }\n    }\n那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。     \n\n    protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {\n        return new JdbcDatabaseTester(\"org.h2.Driver\", \"jdbc:h2:~/dbunitdemo\", \"sa\", \"\");\n    }\n    \n####定制测试执行前后的操作\n默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。   \n\n    protected DatabaseOperation getSetUpOperation() throws Exception\n    {\n        return DatabaseOperation.REFRESH;\n    }\n\n    protected DatabaseOperation getTearDownOperation() throws Exception\n    {\n        return DatabaseOperation.NONE;\n    }\n####DatabaseConfig设置\n有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。     \n\n    protected void setUpDatabaseConfig(DatabaseConfig config) {\n            config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));\n            config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);\n    }\n比如，我在使用H2Database时，老是报一个这样的warn:    \n\n    WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory 'class org.dbunit.dataset.datatype.DefaultDataTypeFactory' might cause problems with the current database 'H2' (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.\n那么，如何让这个WARN消失呢？加上这个配置：  \n\n    config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n####Database数据验证\nDbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。\n\n    public class Assertion\n    {\n        public static void assertEquals(ITable expected, ITable actual)\n        public static void assertEquals(IDataSet expected, IDataSet actual)\n    }\n下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。   \n\n\n        // Fetch database data after executing your code\n        IDataSet databaseDataSet = getConnection().createDataSet();\n        ITable actualTable = databaseDataSet.getTable(\"TABLE_NAME\");\n\n        // Load expected data from an XML dataset\n        IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File(\"expectedDataSet.xml\"));\n        ITable expectedTable = expectedDataSet.getTable(\"TABLE_NAME\");\n\n        // Assert actual database table match expected table\n        Assertion.assertEquals(expectedTable, actualTable);\n###DbUnit的运行步骤\n由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：  \n\n    protected void setUp() throws Exception\n    {\n        logger.debug(\"setUp() - start\");\n\n        super.setUp();\n        final IDatabaseTester databaseTester = getDatabaseTester();\n        assertNotNull( \"DatabaseTester is not set\", databaseTester );\n        databaseTester.setSetUpOperation( getSetUpOperation() );\n        databaseTester.setDataSet( getDataSet() );\n        databaseTester.setOperationListener(getOperationListener());\n        databaseTester.onSetup();\n    }\n\n    protected void tearDown() throws Exception\n    {\n        logger.debug(\"tearDown() - start\");\n\n        try {\n            final IDatabaseTester databaseTester = getDatabaseTester();\n            assertNotNull( \"DatabaseTester is not set\", databaseTester );\n            databaseTester.setTearDownOperation( getTearDownOperation() );\n            databaseTester.setDataSet( getDataSet() );\n            databaseTester.setOperationListener(getOperationListener());\n            databaseTester.onTearDown();\n        } finally {\n            tester = null;\n            super.tearDown();\n        }\n    }\n这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。       \n\n总结：   \n\n- 1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。\n- 2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。\n- 3.运行测试。\n- 4.测试运行完毕后，不执行任何操作。\n\n###使用什么数据库？\n由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。    \n这里推荐一个数据库[H2Database](http://www.h2database.com/html/main.html)，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：    \n<table style=\"width: 470px;\" border=\"1\"><tr>\n<th></th>\n<th>H2</th>\n<th><a href=\"http://db.apache.org/derby\">Derby</a></th>\n<th><a href=\"http://hsqldb.org\">HSQLDB</a></th>\n<th><a href=\"http://mysql.com\">MySQL</a></th>\n<th><a href=\"http://www.postgresql.org\">PostgreSQL</a></th>\n</tr><tr>\n<td>Pure Java</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>Memory Mode</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>Encrypted Database</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>ODBC Driver</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Fulltext Search</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Multi Version Concurrency</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Footprint (jar/dll size)</td>\n<td>~1 MB</td>\n<td>~2 MB</td>\n<td>~1 MB</td>\n<td>~4 MB</td>\n<td>~6 MB</td>\n</tr>\n</table>\n之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。    \n有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个[sql-maven-plugin](http://mojo.codehaus.org/sql-maven-plugin/)。它可以方便的执行数据库SQL脚本来创建数据库。     \n\n                <plugin>\n                    <groupId>org.codehaus.mojo</groupId>\n                    <artifactId>sql-maven-plugin</artifactId>\n                    <version>1.5</version>\n                    <dependencies>\n                        <dependency>\n                            <groupId>com.h2database</groupId>\n                            <artifactId>h2</artifactId>\n                            <version>1.3.172</version>\n                        </dependency>\n                    </dependencies>\n                    <configuration>\n                        <driver>org.h2.Driver</driver>\n                        <url>jdbc:h2:~/dbunitdemo</url>\n                        <username>sa</username>\n                        <password></password>\n                        <srcFiles>\n                            <srcFile>${project.basedir}/src/main/sql/dbunitdemo.sql</srcFile>\n                        </srcFiles>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>create-db</id>\n                            <phase>process-test-resources</phase>\n                            <goals>\n                                <goal>execute</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n这里，创建了一个H2Database。直接执行`mvn sql:execute`用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行`mvn test`就OK了。","source":"_posts/2013-06-27-usage-dbunit.markdown","raw":"---\nlayout: post\ntitle: \"DbUnit使用入门\"\ndate: 2013-06-27 15:57\ncomments: true\ncategories: ut\ntags: [ dbunit, h2database, ut，sql-maven-plugin ]\n---\n[DbUnit](http://www.dbunit.org/)是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。   \n     \n###DbUnit原理\nDbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。   \nDbUnit包括三个核心部分:\n    \n- IDatabaseConnection ：描述DbUnit数据库连接接口；\n- IDataSet：数据集操作接口；\n- DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；\n\n<!--more-->\n值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。  \n\nDatabaseOperation有以下的可选项：   \n\n- NONE：不执行任何操作，是getTearDownOperation的默认返回值。\n- UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。\n- INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。\n- REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。\n- DELETE：删除数据库中与数据集对应的记录。\n- DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。\n- TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。\n- CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。   \n\n###开始使用DbUnit\n####DataSet数据集准备\nDataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以[手工编写](http://www.dbunit.org/components.html#FlatXmlDataSet)。另外也可以从数据库读取，DbUnit提供了相关的API：  \n\n        QueryDataSet dataSet = new QueryDataSet(getConnection());\n        dataSet.addTable(\"user\", \"select * from user \");\n        FlatXmlDataSet.write(dataSet, new FileOutputStream(\"data.xml\"));\n####继承DBTestCase来实现测试用例\n最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：  \n\n- JdbcBasedDBTestCase\n- DataSourceBasedDBTestCase\n- JndiBasedDBTestCase\n\n下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。   \n\n    public class SampleTest extends DBTestCase\n    {\n        public SampleTest(String name)\n        {\n            super( name );\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, \"org.h2.Driver\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, \"jdbc:h2:~/dbunitdemo\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, \"sa\");\n            System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, \"\");\n    \n        protected IDataSet getDataSet() throws Exception\n        {\n            return new FlatXmlDataSetBuilder().build(new FileInputStream(\"dataset.xml\"));\n        }\n    }\n那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。     \n\n    protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {\n        return new JdbcDatabaseTester(\"org.h2.Driver\", \"jdbc:h2:~/dbunitdemo\", \"sa\", \"\");\n    }\n    \n####定制测试执行前后的操作\n默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。   \n\n    protected DatabaseOperation getSetUpOperation() throws Exception\n    {\n        return DatabaseOperation.REFRESH;\n    }\n\n    protected DatabaseOperation getTearDownOperation() throws Exception\n    {\n        return DatabaseOperation.NONE;\n    }\n####DatabaseConfig设置\n有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。     \n\n    protected void setUpDatabaseConfig(DatabaseConfig config) {\n            config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));\n            config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);\n    }\n比如，我在使用H2Database时，老是报一个这样的warn:    \n\n    WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory 'class org.dbunit.dataset.datatype.DefaultDataTypeFactory' might cause problems with the current database 'H2' (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.\n那么，如何让这个WARN消失呢？加上这个配置：  \n\n    config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n####Database数据验证\nDbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。\n\n    public class Assertion\n    {\n        public static void assertEquals(ITable expected, ITable actual)\n        public static void assertEquals(IDataSet expected, IDataSet actual)\n    }\n下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。   \n\n\n        // Fetch database data after executing your code\n        IDataSet databaseDataSet = getConnection().createDataSet();\n        ITable actualTable = databaseDataSet.getTable(\"TABLE_NAME\");\n\n        // Load expected data from an XML dataset\n        IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File(\"expectedDataSet.xml\"));\n        ITable expectedTable = expectedDataSet.getTable(\"TABLE_NAME\");\n\n        // Assert actual database table match expected table\n        Assertion.assertEquals(expectedTable, actualTable);\n###DbUnit的运行步骤\n由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：  \n\n    protected void setUp() throws Exception\n    {\n        logger.debug(\"setUp() - start\");\n\n        super.setUp();\n        final IDatabaseTester databaseTester = getDatabaseTester();\n        assertNotNull( \"DatabaseTester is not set\", databaseTester );\n        databaseTester.setSetUpOperation( getSetUpOperation() );\n        databaseTester.setDataSet( getDataSet() );\n        databaseTester.setOperationListener(getOperationListener());\n        databaseTester.onSetup();\n    }\n\n    protected void tearDown() throws Exception\n    {\n        logger.debug(\"tearDown() - start\");\n\n        try {\n            final IDatabaseTester databaseTester = getDatabaseTester();\n            assertNotNull( \"DatabaseTester is not set\", databaseTester );\n            databaseTester.setTearDownOperation( getTearDownOperation() );\n            databaseTester.setDataSet( getDataSet() );\n            databaseTester.setOperationListener(getOperationListener());\n            databaseTester.onTearDown();\n        } finally {\n            tester = null;\n            super.tearDown();\n        }\n    }\n这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。       \n\n总结：   \n\n- 1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。\n- 2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。\n- 3.运行测试。\n- 4.测试运行完毕后，不执行任何操作。\n\n###使用什么数据库？\n由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。    \n这里推荐一个数据库[H2Database](http://www.h2database.com/html/main.html)，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：    \n<table style=\"width: 470px;\" border=\"1\"><tr>\n<th></th>\n<th>H2</th>\n<th><a href=\"http://db.apache.org/derby\">Derby</a></th>\n<th><a href=\"http://hsqldb.org\">HSQLDB</a></th>\n<th><a href=\"http://mysql.com\">MySQL</a></th>\n<th><a href=\"http://www.postgresql.org\">PostgreSQL</a></th>\n</tr><tr>\n<td>Pure Java</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>Memory Mode</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>Encrypted Database</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n</tr><tr>\n<td>ODBC Driver</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Fulltext Search</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Multi Version Concurrency</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareN\">No</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n<td class=\"compareY\">Yes</td>\n</tr><tr>\n<td>Footprint (jar/dll size)</td>\n<td>~1 MB</td>\n<td>~2 MB</td>\n<td>~1 MB</td>\n<td>~4 MB</td>\n<td>~6 MB</td>\n</tr>\n</table>\n之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。    \n有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个[sql-maven-plugin](http://mojo.codehaus.org/sql-maven-plugin/)。它可以方便的执行数据库SQL脚本来创建数据库。     \n\n                <plugin>\n                    <groupId>org.codehaus.mojo</groupId>\n                    <artifactId>sql-maven-plugin</artifactId>\n                    <version>1.5</version>\n                    <dependencies>\n                        <dependency>\n                            <groupId>com.h2database</groupId>\n                            <artifactId>h2</artifactId>\n                            <version>1.3.172</version>\n                        </dependency>\n                    </dependencies>\n                    <configuration>\n                        <driver>org.h2.Driver</driver>\n                        <url>jdbc:h2:~/dbunitdemo</url>\n                        <username>sa</username>\n                        <password></password>\n                        <srcFiles>\n                            <srcFile>${project.basedir}/src/main/sql/dbunitdemo.sql</srcFile>\n                        </srcFiles>\n                    </configuration>\n                    <executions>\n                        <execution>\n                            <id>create-db</id>\n                            <phase>process-test-resources</phase>\n                            <goals>\n                                <goal>execute</goal>\n                            </goals>\n                        </execution>\n                    </executions>\n                </plugin>\n这里，创建了一个H2Database。直接执行`mvn sql:execute`用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行`mvn test`就OK了。","slug":"2013-06-27-usage-dbunit","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6h007av8fyh52rvnnc","content":"<p><a href=\"http://www.dbunit.org/\" target=\"_blank\" rel=\"external\">DbUnit</a>是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。   </p>\n<p>###DbUnit原理<br>DbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。<br>DbUnit包括三个核心部分:</p>\n<ul>\n<li>IDatabaseConnection ：描述DbUnit数据库连接接口；</li>\n<li>IDataSet：数据集操作接口；</li>\n<li>DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；</li>\n</ul>\n<a id=\"more\"></a>\n<p>值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。  </p>\n<p>DatabaseOperation有以下的可选项：   </p>\n<ul>\n<li>NONE：不执行任何操作，是getTearDownOperation的默认返回值。</li>\n<li>UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。</li>\n<li>INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。</li>\n<li>REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。</li>\n<li>DELETE：删除数据库中与数据集对应的记录。</li>\n<li>DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。</li>\n<li>TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。</li>\n<li>CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。   </li>\n</ul>\n<p>###开始使用DbUnit</p>\n<p>####DataSet数据集准备<br>DataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以<a href=\"http://www.dbunit.org/components.html#FlatXmlDataSet\" target=\"_blank\" rel=\"external\">手工编写</a>。另外也可以从数据库读取，DbUnit提供了相关的API：  </p>\n<pre><code>QueryDataSet dataSet = new QueryDataSet(getConnection());\ndataSet.addTable(&quot;user&quot;, &quot;select * from user &quot;);\nFlatXmlDataSet.write(dataSet, new FileOutputStream(&quot;data.xml&quot;));\n</code></pre><p>####继承DBTestCase来实现测试用例<br>最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：  </p>\n<ul>\n<li>JdbcBasedDBTestCase</li>\n<li>DataSourceBasedDBTestCase</li>\n<li>JndiBasedDBTestCase</li>\n</ul>\n<p>下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。   </p>\n<pre><code>public class SampleTest extends DBTestCase\n{\n    public SampleTest(String name)\n    {\n        super( name );\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, &quot;org.h2.Driver&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, &quot;jdbc:h2:~/dbunitdemo&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, &quot;sa&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, &quot;&quot;);\n\n    protected IDataSet getDataSet() throws Exception\n    {\n        return new FlatXmlDataSetBuilder().build(new FileInputStream(&quot;dataset.xml&quot;));\n    }\n}\n</code></pre><p>那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。     </p>\n<pre><code>protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {\n    return new JdbcDatabaseTester(&quot;org.h2.Driver&quot;, &quot;jdbc:h2:~/dbunitdemo&quot;, &quot;sa&quot;, &quot;&quot;);\n}\n</code></pre><p>####定制测试执行前后的操作<br>默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。   </p>\n<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception\n{\n    return DatabaseOperation.REFRESH;\n}\n\nprotected DatabaseOperation getTearDownOperation() throws Exception\n{\n    return DatabaseOperation.NONE;\n}\n</code></pre><p>####DatabaseConfig设置<br>有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。     </p>\n<pre><code>protected void setUpDatabaseConfig(DatabaseConfig config) {\n        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));\n        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);\n}\n</code></pre><p>比如，我在使用H2Database时，老是报一个这样的warn:    </p>\n<pre><code>WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory &apos;class org.dbunit.dataset.datatype.DefaultDataTypeFactory&apos; might cause problems with the current database &apos;H2&apos; (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.\n</code></pre><p>那么，如何让这个WARN消失呢？加上这个配置：  </p>\n<pre><code>config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n</code></pre><p>####Database数据验证<br>DbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。</p>\n<pre><code>public class Assertion\n{\n    public static void assertEquals(ITable expected, ITable actual)\n    public static void assertEquals(IDataSet expected, IDataSet actual)\n}\n</code></pre><p>下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。   </p>\n<pre><code>// Fetch database data after executing your code\nIDataSet databaseDataSet = getConnection().createDataSet();\nITable actualTable = databaseDataSet.getTable(&quot;TABLE_NAME&quot;);\n\n// Load expected data from an XML dataset\nIDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File(&quot;expectedDataSet.xml&quot;));\nITable expectedTable = expectedDataSet.getTable(&quot;TABLE_NAME&quot;);\n\n// Assert actual database table match expected table\nAssertion.assertEquals(expectedTable, actualTable);\n</code></pre><p>###DbUnit的运行步骤<br>由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：  </p>\n<pre><code>protected void setUp() throws Exception\n{\n    logger.debug(&quot;setUp() - start&quot;);\n\n    super.setUp();\n    final IDatabaseTester databaseTester = getDatabaseTester();\n    assertNotNull( &quot;DatabaseTester is not set&quot;, databaseTester );\n    databaseTester.setSetUpOperation( getSetUpOperation() );\n    databaseTester.setDataSet( getDataSet() );\n    databaseTester.setOperationListener(getOperationListener());\n    databaseTester.onSetup();\n}\n\nprotected void tearDown() throws Exception\n{\n    logger.debug(&quot;tearDown() - start&quot;);\n\n    try {\n        final IDatabaseTester databaseTester = getDatabaseTester();\n        assertNotNull( &quot;DatabaseTester is not set&quot;, databaseTester );\n        databaseTester.setTearDownOperation( getTearDownOperation() );\n        databaseTester.setDataSet( getDataSet() );\n        databaseTester.setOperationListener(getOperationListener());\n        databaseTester.onTearDown();\n    } finally {\n        tester = null;\n        super.tearDown();\n    }\n}\n</code></pre><p>这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。       </p>\n<p>总结：   </p>\n<ul>\n<li>1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。</li>\n<li>2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。</li>\n<li>3.运行测试。</li>\n<li>4.测试运行完毕后，不执行任何操作。</li>\n</ul>\n<p>###使用什么数据库？<br>由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。<br>这里推荐一个数据库<a href=\"http://www.h2database.com/html/main.html\" target=\"_blank\" rel=\"external\">H2Database</a>，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：    </p>\n<p><table style=\"width: 470px;\" border=\"1\"><tr></tr></table></p>\n<p><th></th></p>\n<p><th>H2</th></p>\n<p><th><a href=\"http://db.apache.org/derby\" target=\"_blank\" rel=\"external\">Derby</a></th></p>\n<p><th><a href=\"http://hsqldb.org\" target=\"_blank\" rel=\"external\">HSQLDB</a></th></p>\n<p><th><a href=\"http://mysql.com\" target=\"_blank\" rel=\"external\">MySQL</a></th></p>\n<p><th><a href=\"http://www.postgresql.org\" target=\"_blank\" rel=\"external\">PostgreSQL</a></th><br><tr></tr></p>\n<p><td>Pure Java</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br><tr></tr></p>\n<p><td>Memory Mode</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br><tr></tr></p>\n<p><td>Encrypted Database</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br><tr></tr></p>\n<p><td>ODBC Driver</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br><tr></tr></p>\n<p><td>Fulltext Search</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br><tr></tr></p>\n<p><td>Multi Version Concurrency</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br><tr></tr></p>\n<p><td>Footprint (jar/dll size)</td></p>\n<p><td>~1 MB</td></p>\n<p><td>~2 MB</td></p>\n<p><td>~1 MB</td></p>\n<p><td>~4 MB</td></p>\n<p><td>~6 MB</td><br><br><br>之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。<br>有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个<a href=\"http://mojo.codehaus.org/sql-maven-plugin/\" target=\"_blank\" rel=\"external\">sql-maven-plugin</a>。它可以方便的执行数据库SQL脚本来创建数据库。     </p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n    &lt;artifactId&gt;sql-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.5&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;version&gt;1.3.172&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;configuration&gt;\n        &lt;driver&gt;org.h2.Driver&lt;/driver&gt;\n        &lt;url&gt;jdbc:h2:~/dbunitdemo&lt;/url&gt;\n        &lt;username&gt;sa&lt;/username&gt;\n        &lt;password&gt;&lt;/password&gt;\n        &lt;srcFiles&gt;\n            &lt;srcFile&gt;${project.basedir}/src/main/sql/dbunitdemo.sql&lt;/srcFile&gt;\n        &lt;/srcFiles&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;create-db&lt;/id&gt;\n            &lt;phase&gt;process-test-resources&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;execute&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>这里，创建了一个H2Database。直接执行<code>mvn sql:execute</code>用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行<code>mvn test</code>就OK了。</p>\n","excerpt":"<p><a href=\"http://www.dbunit.org/\">DbUnit</a>是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。   </p>\n<p>###DbUnit原理<br>DbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。<br>DbUnit包括三个核心部分:</p>\n<ul>\n<li>IDatabaseConnection ：描述DbUnit数据库连接接口；</li>\n<li>IDataSet：数据集操作接口；</li>\n<li>DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；</li>\n</ul>","more":"<p>值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。  </p>\n<p>DatabaseOperation有以下的可选项：   </p>\n<ul>\n<li>NONE：不执行任何操作，是getTearDownOperation的默认返回值。</li>\n<li>UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。</li>\n<li>INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。</li>\n<li>REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。</li>\n<li>DELETE：删除数据库中与数据集对应的记录。</li>\n<li>DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。</li>\n<li>TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。</li>\n<li>CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。   </li>\n</ul>\n<p>###开始使用DbUnit</p>\n<p>####DataSet数据集准备<br>DataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以<a href=\"http://www.dbunit.org/components.html#FlatXmlDataSet\">手工编写</a>。另外也可以从数据库读取，DbUnit提供了相关的API：  </p>\n<pre><code>QueryDataSet dataSet = new QueryDataSet(getConnection());\ndataSet.addTable(&quot;user&quot;, &quot;select * from user &quot;);\nFlatXmlDataSet.write(dataSet, new FileOutputStream(&quot;data.xml&quot;));\n</code></pre><p>####继承DBTestCase来实现测试用例<br>最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：  </p>\n<ul>\n<li>JdbcBasedDBTestCase</li>\n<li>DataSourceBasedDBTestCase</li>\n<li>JndiBasedDBTestCase</li>\n</ul>\n<p>下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。   </p>\n<pre><code>public class SampleTest extends DBTestCase\n{\n    public SampleTest(String name)\n    {\n        super( name );\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, &quot;org.h2.Driver&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, &quot;jdbc:h2:~/dbunitdemo&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, &quot;sa&quot;);\n        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, &quot;&quot;);\n\n    protected IDataSet getDataSet() throws Exception\n    {\n        return new FlatXmlDataSetBuilder().build(new FileInputStream(&quot;dataset.xml&quot;));\n    }\n}\n</code></pre><p>那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。     </p>\n<pre><code>protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {\n    return new JdbcDatabaseTester(&quot;org.h2.Driver&quot;, &quot;jdbc:h2:~/dbunitdemo&quot;, &quot;sa&quot;, &quot;&quot;);\n}\n</code></pre><p>####定制测试执行前后的操作<br>默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。   </p>\n<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception\n{\n    return DatabaseOperation.REFRESH;\n}\n\nprotected DatabaseOperation getTearDownOperation() throws Exception\n{\n    return DatabaseOperation.NONE;\n}\n</code></pre><p>####DatabaseConfig设置<br>有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。     </p>\n<pre><code>protected void setUpDatabaseConfig(DatabaseConfig config) {\n        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));\n        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);\n}\n</code></pre><p>比如，我在使用H2Database时，老是报一个这样的warn:    </p>\n<pre><code>WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory &apos;class org.dbunit.dataset.datatype.DefaultDataTypeFactory&apos; might cause problems with the current database &apos;H2&apos; (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.\n</code></pre><p>那么，如何让这个WARN消失呢？加上这个配置：  </p>\n<pre><code>config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n</code></pre><p>####Database数据验证<br>DbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。</p>\n<pre><code>public class Assertion\n{\n    public static void assertEquals(ITable expected, ITable actual)\n    public static void assertEquals(IDataSet expected, IDataSet actual)\n}\n</code></pre><p>下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。   </p>\n<pre><code>// Fetch database data after executing your code\nIDataSet databaseDataSet = getConnection().createDataSet();\nITable actualTable = databaseDataSet.getTable(&quot;TABLE_NAME&quot;);\n\n// Load expected data from an XML dataset\nIDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File(&quot;expectedDataSet.xml&quot;));\nITable expectedTable = expectedDataSet.getTable(&quot;TABLE_NAME&quot;);\n\n// Assert actual database table match expected table\nAssertion.assertEquals(expectedTable, actualTable);\n</code></pre><p>###DbUnit的运行步骤<br>由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：  </p>\n<pre><code>protected void setUp() throws Exception\n{\n    logger.debug(&quot;setUp() - start&quot;);\n\n    super.setUp();\n    final IDatabaseTester databaseTester = getDatabaseTester();\n    assertNotNull( &quot;DatabaseTester is not set&quot;, databaseTester );\n    databaseTester.setSetUpOperation( getSetUpOperation() );\n    databaseTester.setDataSet( getDataSet() );\n    databaseTester.setOperationListener(getOperationListener());\n    databaseTester.onSetup();\n}\n\nprotected void tearDown() throws Exception\n{\n    logger.debug(&quot;tearDown() - start&quot;);\n\n    try {\n        final IDatabaseTester databaseTester = getDatabaseTester();\n        assertNotNull( &quot;DatabaseTester is not set&quot;, databaseTester );\n        databaseTester.setTearDownOperation( getTearDownOperation() );\n        databaseTester.setDataSet( getDataSet() );\n        databaseTester.setOperationListener(getOperationListener());\n        databaseTester.onTearDown();\n    } finally {\n        tester = null;\n        super.tearDown();\n    }\n}\n</code></pre><p>这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。       </p>\n<p>总结：   </p>\n<ul>\n<li>1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。</li>\n<li>2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。</li>\n<li>3.运行测试。</li>\n<li>4.测试运行完毕后，不执行任何操作。</li>\n</ul>\n<p>###使用什么数据库？<br>由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。<br>这里推荐一个数据库<a href=\"http://www.h2database.com/html/main.html\">H2Database</a>，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：    </p>\n<p><table style=\"width: 470px;\" border=\"1\"><tr></p>\n<p><th></th></p>\n<p><th>H2</th></p>\n<p><th><a href=\"http://db.apache.org/derby\">Derby</a></th></p>\n<p><th><a href=\"http://hsqldb.org\">HSQLDB</a></th></p>\n<p><th><a href=\"http://mysql.com\">MySQL</a></th></p>\n<p><th><a href=\"http://www.postgresql.org\">PostgreSQL</a></th><br></tr><tr></p>\n<p><td>Pure Java</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br></tr><tr></p>\n<p><td>Memory Mode</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br></tr><tr></p>\n<p><td>Encrypted Database</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td><br></tr><tr></p>\n<p><td>ODBC Driver</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br></tr><tr></p>\n<p><td>Fulltext Search</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br></tr><tr></p>\n<p><td>Multi Version Concurrency</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareN\">No</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td></p>\n<p><td class=\"compareY\">Yes</td><br></tr><tr></p>\n<p><td>Footprint (jar/dll size)</td></p>\n<p><td>~1 MB</td></p>\n<p><td>~2 MB</td></p>\n<p><td>~1 MB</td></p>\n<p><td>~4 MB</td></p>\n<p><td>~6 MB</td><br></tr><br></table><br>之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。<br>有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个<a href=\"http://mojo.codehaus.org/sql-maven-plugin/\">sql-maven-plugin</a>。它可以方便的执行数据库SQL脚本来创建数据库。     </p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n    &lt;artifactId&gt;sql-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.5&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;version&gt;1.3.172&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;configuration&gt;\n        &lt;driver&gt;org.h2.Driver&lt;/driver&gt;\n        &lt;url&gt;jdbc:h2:~/dbunitdemo&lt;/url&gt;\n        &lt;username&gt;sa&lt;/username&gt;\n        &lt;password&gt;&lt;/password&gt;\n        &lt;srcFiles&gt;\n            &lt;srcFile&gt;${project.basedir}/src/main/sql/dbunitdemo.sql&lt;/srcFile&gt;\n        &lt;/srcFiles&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;create-db&lt;/id&gt;\n            &lt;phase&gt;process-test-resources&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;execute&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>这里，创建了一个H2Database。直接执行<code>mvn sql:execute</code>用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行<code>mvn test</code>就OK了。</p>"},{"layout":"post","title":"《重构与模式》读书笔记","date":"2013-06-28T05:53:00.000Z","comments":1,"_content":"GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。   \n###写作缘由\n\n- 过度设计：代码存在设计过度的情况\n- 模式万灵丹：认为设计模式的万能的\n- 设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”\n- 测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”\n- 重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构\n- 演进式设计：将模式放到重构的背景中进行领会\n\n###什么是重构\n定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。   \n重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。  \n\n重构的动机：  \n\n- 使新代码的增加更容易\n- 改善既有代码的设计\n- 对代码理解更透彻\n- 提高编程的趣味性\n\n<!--more-->\n###什么是模式\nGoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。   \n应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。\n\n###代码坏味\n\n- 1.重复代码（Duplicated Code）  \n>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；     \n\n- 2.过长函数（Long Method）：\n>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；\n\n- 3.条件逻辑太复杂（Conditional Complexity）：\n>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;\n\n- 4.基本类型偏执（Primitive Obsession）:\n>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。\n\n- 5.不恰当的暴露（Indecent Exposure）：\n>用Factory封装类；\n\n- 6.解决方案蔓延（Solution Sprawl）：\n>将创建知识搬移到Factory；\n\n- 7.异曲同工的类（Alternative Classes With Different Interfaces）：\n>通过Adapter统一接口；\n\n- 8.冗赘类（Lazy Class）：\n>内联Singeton；\n- 9.过大的类（Large Class）：\n>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；\n- 10.分支语句（Switch Statement）：\n>用Command替换条件调度程序；将聚集操作搬移到Visitor；\n- 11.组合爆炸（Combinatorial Explosion）：\n>用Interpreter替换隐式语言；\n- 12.怪异解决方案（Oddball Solution）：\n>通过Adapter统一接口；    \n\n###创建\n####用Creation Method替换构造函数\n如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。   \n优缺点：  \n+比构造函数能够更好的表达所创建的实例的种类。   \n+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。   \n+更容易发现无用的创建代码。   \n-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。   \n####将创建知识搬移到Factory\n当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。    \n优缺点：   \n+合并创建逻辑和实例化/配置选项。   \n+将客户代码与创建逻辑解耦。    \n-如果可以直接实例化，会使设计复杂化。   \n####用Factory封装类\n如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。   \n优缺点：   \n+通过意图导向的CreationMethod简化了不同种类实例的创建。    \n+通过隐藏不需要公开的类减少了包结构的“概念重量”    \n+帮助严格执行“面向接口编程，而不是面向实现”这一格言。    \n-当需要创建新种类的实例时，必须新建/更新Creation Method。  \n-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。   \n####用Factory Method引入多态创建\n一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。   \n优缺点：   \n+减少因创建自定义对象而产生的重复代码    \n+有效的表达了对象创建发生的位置，以及如何重写对象的创建。   \n+强制Factory Method使用的类必须实现统一的类型。   \n-可能会向Factory Method的一些实现者传递不必要的参数。     \n####用Builder封装Composite\n构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。   \n优缺点：   \n+简化了构造Composite的客户代码。   \n+减少了创建Composite的重复和易出错的本性。  \n+在客户代码和Composite之间实现了松耦合。   \n-接口可能不会很清楚的表达其意图。    \n####内联Singleton\n绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。   \n优缺点：   \n+使对象的协作变得更明显和明确。   \n+保护了单一的实例，且不要要特殊的代码。   \n-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。    \n###简化\n####组合方法\n一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。   \n优缺点：    \n+清晰的描述了一个方法所实现的功能以及如何实现。   \n+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。   \n-可能会产生过多的小方法。   \n-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。  \n####用Strategy替换条件逻辑\n当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。    \n优缺点：   \n+通过减少或去除条件逻辑使算法变得清晰易懂。   \n+通过把算法的变体搬移到类层次中简化了类。   \n+允许在运行时用一种算法替换另一种算法。   \n-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。   \n-增加了算法如何获取或接受上下文类的数据的复杂度。   \n####将装饰功能搬移到Decorator\n如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。   \n优缺点：   \n+把装饰功能从类中搬移去除，从而简化了类。   \n+有效地把类的核心职责和装饰功能区分开来。   \n+可以去除几个相关类中重复的装饰逻辑。   \n-改变了被装饰对象的对象类型。   \n-会使代码变得更难理解和调适。   \n-当Decorator组合产生负面影响的时候，会增加设计的复杂度。   \n####用State替换状态改变条件语句\n如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。   \n优缺点：   \n+减少或去除状态改变条件逻辑。  \n+简化了复杂的状态改变逻辑。   \n+提供了观察状态改变逻辑的很好的鸟瞰图。  \n-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。   \n####用Composite替换隐含树\n有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。   \n优缺点：   \n+封装重复的指令，如格式化、添加或删除结点。   \n+提供了处理相似逻辑增长的一般性方法。   \n+简化了客户代码的构造职责。    \n-当构造隐式树更简单的时候，会增加设计的复杂度。   \n####用Command替换条件调度程序\n许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。    \n优缺点：   \n+提供了用统一方法执行不同行为的简单机制。   \n+允许在运行时改变所处理的请求，以及如何处理请求。   \n+仅仅需要很少的代码实现。   \n-当条件调度程序已经足够的时候，会增加设计的复杂度。   \n\n###泛化\n####形成Template Method\n借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。    \n优点与缺点：   \n+通过把不变行为搬移到超类，去除子类中的重复代码    \n+简化并有效地表达了一个通用算法的步骤。   \n+允许子类很容易的定制一个算法    \n-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。   \n####提取Composite\n在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。    \n优缺点：   \n+去除重复的类存储逻辑和类处理逻辑。    \n+能够有效的表达类处理逻辑的可继承性。\n####用Composite替换一/多之分\n这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题：   \n如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。    \n使用Composite扩展出And，Or等条件，简化客户端的处理。    \n优缺点：   \n+去除与处理一个或多个对象相关联的重复代码。   \n+提供了处理一个或多个对象的同一方法。   \n+支持处理多个对象的更丰富的方法。（如OR表达式）   \n-可能会在Composite的构造过程中要求类型安全的运行时检查。    \n####用Observer替换硬编码的通知\n拒绝使用硬编码的通知，考虑使用Observer模式。   \n优缺点：   \n+使主题及其观察者访问松散耦合   \n+支持一个或多个观察者    \n-当硬编码的通知已经足够的时候，会增加设计复杂度    \n-当出现串联通知的时候，会增加代码的复杂度        \n-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。   \n####通过Adapter统一接口 \n全部满足以下条件，考虑使用Adapter:   \n\n- 2个类所做的事情相同或者相似，但是具有不同的接口。   \n- 如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。   \n- 无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。    \n\n比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。   \n优缺点：   \n+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。   \n+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。    \n+统一了客户代码与不同的类的交互方式。    \n-当类的接口可以改变的时候，会增加设计的复杂度。   \n####提取Adapter\n当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。    \n优缺点：  \n+隔离了不同版本的组件，类库或API之间的不同之处。   \n+使类只负责适配代码的一个版本。    \n+避免频繁地修改代码     \n-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。   \n####用Interpreter替换隐式语言\n在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。    \n优缺点：   \n+比隐式语言更好的支持语言元素的组合。   \n+不需要新的代码来支持语言元素的新组合。  \n+允许行为的运行时配置。\n-会产生定义语法和修改客户代码的开销。   \n-如果语言很复杂，则需要很多的编程工作。   \n-如果语言本身就很简单，则会增加设计的复杂度。  \n\n###保护\n####用类替换类型代码\n字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。    \n优缺点：    \n+更好的避免非法赋值和比较。    \n-比使用不安全类型要求更多的代码。       \n####用Singleton限制实例化\n有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。   \n优缺点：    \n+改进性能。    \n-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。   \n-当对象含有不能共享的状态的时候，本重构就无效了。   \n####引入Null Object\n代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。    \n优缺点：     \n+不需要重复的null逻辑就可以避免null错误。   \n+通过最小化null测试简化了代码。    \n-当系统不太需要null测试的时候，会增加设计的复杂度。   \n-如果程序员不知道Null Object的存在，就会产生多余的null测试。   \n-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。    \n###聚集操作\n####将聚集操作搬移到Collecting Parameter\n有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。    \n优缺点：     \n+帮助我们把很大的方法转换成更小的，更简单的多个方法。    \n-使结果代码运行得更快。    \n####将聚集操作搬移到Visitor\n如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。     \n优缺点：    \n+调节多个算法，使其适用于不同的对象结构。   \n+访问相同或不同继承结构中的类。   \n+调用不同类上的类型特定方法，无需类型转换。    \n-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。    \n-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。    \n-可能会破坏被访问类的封装性。   ","source":"_posts/2013-06-28-refactoring-to-patterns-reading-notes.markdown","raw":"---\nlayout: post\ntitle: \"《重构与模式》读书笔记\"\ndate: 2013-06-28 13:53\ncomments: true\ncategories: 设计模式\ntags: [ 读书笔记, 重构, 模式 ]\n---\nGoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。   \n###写作缘由\n\n- 过度设计：代码存在设计过度的情况\n- 模式万灵丹：认为设计模式的万能的\n- 设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”\n- 测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”\n- 重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构\n- 演进式设计：将模式放到重构的背景中进行领会\n\n###什么是重构\n定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。   \n重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。  \n\n重构的动机：  \n\n- 使新代码的增加更容易\n- 改善既有代码的设计\n- 对代码理解更透彻\n- 提高编程的趣味性\n\n<!--more-->\n###什么是模式\nGoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。   \n应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。\n\n###代码坏味\n\n- 1.重复代码（Duplicated Code）  \n>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；     \n\n- 2.过长函数（Long Method）：\n>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；\n\n- 3.条件逻辑太复杂（Conditional Complexity）：\n>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;\n\n- 4.基本类型偏执（Primitive Obsession）:\n>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。\n\n- 5.不恰当的暴露（Indecent Exposure）：\n>用Factory封装类；\n\n- 6.解决方案蔓延（Solution Sprawl）：\n>将创建知识搬移到Factory；\n\n- 7.异曲同工的类（Alternative Classes With Different Interfaces）：\n>通过Adapter统一接口；\n\n- 8.冗赘类（Lazy Class）：\n>内联Singeton；\n- 9.过大的类（Large Class）：\n>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；\n- 10.分支语句（Switch Statement）：\n>用Command替换条件调度程序；将聚集操作搬移到Visitor；\n- 11.组合爆炸（Combinatorial Explosion）：\n>用Interpreter替换隐式语言；\n- 12.怪异解决方案（Oddball Solution）：\n>通过Adapter统一接口；    \n\n###创建\n####用Creation Method替换构造函数\n如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。   \n优缺点：  \n+比构造函数能够更好的表达所创建的实例的种类。   \n+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。   \n+更容易发现无用的创建代码。   \n-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。   \n####将创建知识搬移到Factory\n当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。    \n优缺点：   \n+合并创建逻辑和实例化/配置选项。   \n+将客户代码与创建逻辑解耦。    \n-如果可以直接实例化，会使设计复杂化。   \n####用Factory封装类\n如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。   \n优缺点：   \n+通过意图导向的CreationMethod简化了不同种类实例的创建。    \n+通过隐藏不需要公开的类减少了包结构的“概念重量”    \n+帮助严格执行“面向接口编程，而不是面向实现”这一格言。    \n-当需要创建新种类的实例时，必须新建/更新Creation Method。  \n-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。   \n####用Factory Method引入多态创建\n一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。   \n优缺点：   \n+减少因创建自定义对象而产生的重复代码    \n+有效的表达了对象创建发生的位置，以及如何重写对象的创建。   \n+强制Factory Method使用的类必须实现统一的类型。   \n-可能会向Factory Method的一些实现者传递不必要的参数。     \n####用Builder封装Composite\n构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。   \n优缺点：   \n+简化了构造Composite的客户代码。   \n+减少了创建Composite的重复和易出错的本性。  \n+在客户代码和Composite之间实现了松耦合。   \n-接口可能不会很清楚的表达其意图。    \n####内联Singleton\n绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。   \n优缺点：   \n+使对象的协作变得更明显和明确。   \n+保护了单一的实例，且不要要特殊的代码。   \n-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。    \n###简化\n####组合方法\n一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。   \n优缺点：    \n+清晰的描述了一个方法所实现的功能以及如何实现。   \n+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。   \n-可能会产生过多的小方法。   \n-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。  \n####用Strategy替换条件逻辑\n当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。    \n优缺点：   \n+通过减少或去除条件逻辑使算法变得清晰易懂。   \n+通过把算法的变体搬移到类层次中简化了类。   \n+允许在运行时用一种算法替换另一种算法。   \n-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。   \n-增加了算法如何获取或接受上下文类的数据的复杂度。   \n####将装饰功能搬移到Decorator\n如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。   \n优缺点：   \n+把装饰功能从类中搬移去除，从而简化了类。   \n+有效地把类的核心职责和装饰功能区分开来。   \n+可以去除几个相关类中重复的装饰逻辑。   \n-改变了被装饰对象的对象类型。   \n-会使代码变得更难理解和调适。   \n-当Decorator组合产生负面影响的时候，会增加设计的复杂度。   \n####用State替换状态改变条件语句\n如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。   \n优缺点：   \n+减少或去除状态改变条件逻辑。  \n+简化了复杂的状态改变逻辑。   \n+提供了观察状态改变逻辑的很好的鸟瞰图。  \n-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。   \n####用Composite替换隐含树\n有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。   \n优缺点：   \n+封装重复的指令，如格式化、添加或删除结点。   \n+提供了处理相似逻辑增长的一般性方法。   \n+简化了客户代码的构造职责。    \n-当构造隐式树更简单的时候，会增加设计的复杂度。   \n####用Command替换条件调度程序\n许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。    \n优缺点：   \n+提供了用统一方法执行不同行为的简单机制。   \n+允许在运行时改变所处理的请求，以及如何处理请求。   \n+仅仅需要很少的代码实现。   \n-当条件调度程序已经足够的时候，会增加设计的复杂度。   \n\n###泛化\n####形成Template Method\n借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。    \n优点与缺点：   \n+通过把不变行为搬移到超类，去除子类中的重复代码    \n+简化并有效地表达了一个通用算法的步骤。   \n+允许子类很容易的定制一个算法    \n-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。   \n####提取Composite\n在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。    \n优缺点：   \n+去除重复的类存储逻辑和类处理逻辑。    \n+能够有效的表达类处理逻辑的可继承性。\n####用Composite替换一/多之分\n这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题：   \n如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。    \n使用Composite扩展出And，Or等条件，简化客户端的处理。    \n优缺点：   \n+去除与处理一个或多个对象相关联的重复代码。   \n+提供了处理一个或多个对象的同一方法。   \n+支持处理多个对象的更丰富的方法。（如OR表达式）   \n-可能会在Composite的构造过程中要求类型安全的运行时检查。    \n####用Observer替换硬编码的通知\n拒绝使用硬编码的通知，考虑使用Observer模式。   \n优缺点：   \n+使主题及其观察者访问松散耦合   \n+支持一个或多个观察者    \n-当硬编码的通知已经足够的时候，会增加设计复杂度    \n-当出现串联通知的时候，会增加代码的复杂度        \n-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。   \n####通过Adapter统一接口 \n全部满足以下条件，考虑使用Adapter:   \n\n- 2个类所做的事情相同或者相似，但是具有不同的接口。   \n- 如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。   \n- 无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。    \n\n比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。   \n优缺点：   \n+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。   \n+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。    \n+统一了客户代码与不同的类的交互方式。    \n-当类的接口可以改变的时候，会增加设计的复杂度。   \n####提取Adapter\n当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。    \n优缺点：  \n+隔离了不同版本的组件，类库或API之间的不同之处。   \n+使类只负责适配代码的一个版本。    \n+避免频繁地修改代码     \n-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。   \n####用Interpreter替换隐式语言\n在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。    \n优缺点：   \n+比隐式语言更好的支持语言元素的组合。   \n+不需要新的代码来支持语言元素的新组合。  \n+允许行为的运行时配置。\n-会产生定义语法和修改客户代码的开销。   \n-如果语言很复杂，则需要很多的编程工作。   \n-如果语言本身就很简单，则会增加设计的复杂度。  \n\n###保护\n####用类替换类型代码\n字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。    \n优缺点：    \n+更好的避免非法赋值和比较。    \n-比使用不安全类型要求更多的代码。       \n####用Singleton限制实例化\n有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。   \n优缺点：    \n+改进性能。    \n-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。   \n-当对象含有不能共享的状态的时候，本重构就无效了。   \n####引入Null Object\n代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。    \n优缺点：     \n+不需要重复的null逻辑就可以避免null错误。   \n+通过最小化null测试简化了代码。    \n-当系统不太需要null测试的时候，会增加设计的复杂度。   \n-如果程序员不知道Null Object的存在，就会产生多余的null测试。   \n-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。    \n###聚集操作\n####将聚集操作搬移到Collecting Parameter\n有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。    \n优缺点：     \n+帮助我们把很大的方法转换成更小的，更简单的多个方法。    \n-使结果代码运行得更快。    \n####将聚集操作搬移到Visitor\n如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。     \n优缺点：    \n+调节多个算法，使其适用于不同的对象结构。   \n+访问相同或不同继承结构中的类。   \n+调用不同类上的类型特定方法，无需类型转换。    \n-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。    \n-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。    \n-可能会破坏被访问类的封装性。   ","slug":"2013-06-28-refactoring-to-patterns-reading-notes","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6j007dv8fytg1se3ac","content":"<p>GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。   </p>\n<p>###写作缘由</p>\n<ul>\n<li>过度设计：代码存在设计过度的情况</li>\n<li>模式万灵丹：认为设计模式的万能的</li>\n<li>设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”</li>\n<li>测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”</li>\n<li>重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构</li>\n<li>演进式设计：将模式放到重构的背景中进行领会</li>\n</ul>\n<p>###什么是重构<br>定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。<br>重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。  </p>\n<p>重构的动机：  </p>\n<ul>\n<li>使新代码的增加更容易</li>\n<li>改善既有代码的设计</li>\n<li>对代码理解更透彻</li>\n<li>提高编程的趣味性</li>\n</ul>\n<a id=\"more\"></a>\n<p>###什么是模式<br>GoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。<br>应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。</p>\n<p>###代码坏味</p>\n<ul>\n<li><p>1.重复代码（Duplicated Code）  </p>\n<blockquote>\n<p>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；     </p>\n</blockquote>\n</li>\n<li><p>2.过长函数（Long Method）：</p>\n<blockquote>\n<p>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；</p>\n</blockquote>\n</li>\n<li><p>3.条件逻辑太复杂（Conditional Complexity）：</p>\n<blockquote>\n<p>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;</p>\n</blockquote>\n</li>\n<li><p>4.基本类型偏执（Primitive Obsession）:</p>\n<blockquote>\n<p>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。</p>\n</blockquote>\n</li>\n<li><p>5.不恰当的暴露（Indecent Exposure）：</p>\n<blockquote>\n<p>用Factory封装类；</p>\n</blockquote>\n</li>\n<li><p>6.解决方案蔓延（Solution Sprawl）：</p>\n<blockquote>\n<p>将创建知识搬移到Factory；</p>\n</blockquote>\n</li>\n<li><p>7.异曲同工的类（Alternative Classes With Different Interfaces）：</p>\n<blockquote>\n<p>通过Adapter统一接口；</p>\n</blockquote>\n</li>\n<li><p>8.冗赘类（Lazy Class）：</p>\n<blockquote>\n<p>内联Singeton；</p>\n</blockquote>\n</li>\n<li>9.过大的类（Large Class）：<blockquote>\n<p>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；</p>\n</blockquote>\n</li>\n<li>10.分支语句（Switch Statement）：<blockquote>\n<p>用Command替换条件调度程序；将聚集操作搬移到Visitor；</p>\n</blockquote>\n</li>\n<li>11.组合爆炸（Combinatorial Explosion）：<blockquote>\n<p>用Interpreter替换隐式语言；</p>\n</blockquote>\n</li>\n<li>12.怪异解决方案（Oddball Solution）：<blockquote>\n<p>通过Adapter统一接口；    </p>\n</blockquote>\n</li>\n</ul>\n<p>###创建</p>\n<p>####用Creation Method替换构造函数<br>如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。<br>优缺点：<br>+比构造函数能够更好的表达所创建的实例的种类。<br>+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。<br>+更容易发现无用的创建代码。<br>-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。   </p>\n<p>####将创建知识搬移到Factory<br>当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。<br>优缺点：<br>+合并创建逻辑和实例化/配置选项。<br>+将客户代码与创建逻辑解耦。<br>-如果可以直接实例化，会使设计复杂化。   </p>\n<p>####用Factory封装类<br>如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。<br>优缺点：<br>+通过意图导向的CreationMethod简化了不同种类实例的创建。<br>+通过隐藏不需要公开的类减少了包结构的“概念重量”<br>+帮助严格执行“面向接口编程，而不是面向实现”这一格言。<br>-当需要创建新种类的实例时，必须新建/更新Creation Method。<br>-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。   </p>\n<p>####用Factory Method引入多态创建<br>一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。<br>优缺点：<br>+减少因创建自定义对象而产生的重复代码<br>+有效的表达了对象创建发生的位置，以及如何重写对象的创建。<br>+强制Factory Method使用的类必须实现统一的类型。<br>-可能会向Factory Method的一些实现者传递不必要的参数。     </p>\n<p>####用Builder封装Composite<br>构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。<br>优缺点：<br>+简化了构造Composite的客户代码。<br>+减少了创建Composite的重复和易出错的本性。<br>+在客户代码和Composite之间实现了松耦合。<br>-接口可能不会很清楚的表达其意图。    </p>\n<p>####内联Singleton<br>绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。<br>优缺点：<br>+使对象的协作变得更明显和明确。<br>+保护了单一的实例，且不要要特殊的代码。<br>-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。    </p>\n<p>###简化</p>\n<p>####组合方法<br>一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。<br>优缺点：<br>+清晰的描述了一个方法所实现的功能以及如何实现。<br>+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。<br>-可能会产生过多的小方法。<br>-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。  </p>\n<p>####用Strategy替换条件逻辑<br>当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。<br>优缺点：<br>+通过减少或去除条件逻辑使算法变得清晰易懂。<br>+通过把算法的变体搬移到类层次中简化了类。<br>+允许在运行时用一种算法替换另一种算法。<br>-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。<br>-增加了算法如何获取或接受上下文类的数据的复杂度。   </p>\n<p>####将装饰功能搬移到Decorator<br>如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。<br>优缺点：<br>+把装饰功能从类中搬移去除，从而简化了类。<br>+有效地把类的核心职责和装饰功能区分开来。<br>+可以去除几个相关类中重复的装饰逻辑。<br>-改变了被装饰对象的对象类型。<br>-会使代码变得更难理解和调适。<br>-当Decorator组合产生负面影响的时候，会增加设计的复杂度。   </p>\n<p>####用State替换状态改变条件语句<br>如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。<br>优缺点：<br>+减少或去除状态改变条件逻辑。<br>+简化了复杂的状态改变逻辑。<br>+提供了观察状态改变逻辑的很好的鸟瞰图。<br>-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。   </p>\n<p>####用Composite替换隐含树<br>有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。<br>优缺点：<br>+封装重复的指令，如格式化、添加或删除结点。<br>+提供了处理相似逻辑增长的一般性方法。<br>+简化了客户代码的构造职责。<br>-当构造隐式树更简单的时候，会增加设计的复杂度。   </p>\n<p>####用Command替换条件调度程序<br>许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。<br>优缺点：<br>+提供了用统一方法执行不同行为的简单机制。<br>+允许在运行时改变所处理的请求，以及如何处理请求。<br>+仅仅需要很少的代码实现。<br>-当条件调度程序已经足够的时候，会增加设计的复杂度。   </p>\n<p>###泛化</p>\n<p>####形成Template Method<br>借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。<br>优点与缺点：<br>+通过把不变行为搬移到超类，去除子类中的重复代码<br>+简化并有效地表达了一个通用算法的步骤。<br>+允许子类很容易的定制一个算法<br>-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。   </p>\n<p>####提取Composite<br>在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。<br>优缺点：<br>+去除重复的类存储逻辑和类处理逻辑。<br>+能够有效的表达类处理逻辑的可继承性。</p>\n<p>####用Composite替换一/多之分<br>这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题：<br>如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。<br>使用Composite扩展出And，Or等条件，简化客户端的处理。<br>优缺点：<br>+去除与处理一个或多个对象相关联的重复代码。<br>+提供了处理一个或多个对象的同一方法。<br>+支持处理多个对象的更丰富的方法。（如OR表达式）<br>-可能会在Composite的构造过程中要求类型安全的运行时检查。    </p>\n<p>####用Observer替换硬编码的通知<br>拒绝使用硬编码的通知，考虑使用Observer模式。<br>优缺点：<br>+使主题及其观察者访问松散耦合<br>+支持一个或多个观察者<br>-当硬编码的通知已经足够的时候，会增加设计复杂度<br>-当出现串联通知的时候，会增加代码的复杂度<br>-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。   </p>\n<p>####通过Adapter统一接口<br>全部满足以下条件，考虑使用Adapter:   </p>\n<ul>\n<li>2个类所做的事情相同或者相似，但是具有不同的接口。   </li>\n<li>如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。   </li>\n<li>无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。    </li>\n</ul>\n<p>比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。<br>优缺点：<br>+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。<br>+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。<br>+统一了客户代码与不同的类的交互方式。<br>-当类的接口可以改变的时候，会增加设计的复杂度。   </p>\n<p>####提取Adapter<br>当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。<br>优缺点：<br>+隔离了不同版本的组件，类库或API之间的不同之处。<br>+使类只负责适配代码的一个版本。<br>+避免频繁地修改代码<br>-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。   </p>\n<p>####用Interpreter替换隐式语言<br>在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。<br>优缺点：<br>+比隐式语言更好的支持语言元素的组合。<br>+不需要新的代码来支持语言元素的新组合。<br>+允许行为的运行时配置。<br>-会产生定义语法和修改客户代码的开销。<br>-如果语言很复杂，则需要很多的编程工作。<br>-如果语言本身就很简单，则会增加设计的复杂度。  </p>\n<p>###保护</p>\n<p>####用类替换类型代码<br>字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。<br>优缺点：<br>+更好的避免非法赋值和比较。<br>-比使用不安全类型要求更多的代码。       </p>\n<p>####用Singleton限制实例化<br>有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。<br>优缺点：<br>+改进性能。<br>-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。<br>-当对象含有不能共享的状态的时候，本重构就无效了。   </p>\n<p>####引入Null Object<br>代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。<br>优缺点：<br>+不需要重复的null逻辑就可以避免null错误。<br>+通过最小化null测试简化了代码。<br>-当系统不太需要null测试的时候，会增加设计的复杂度。<br>-如果程序员不知道Null Object的存在，就会产生多余的null测试。<br>-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。    </p>\n<p>###聚集操作</p>\n<p>####将聚集操作搬移到Collecting Parameter<br>有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。<br>优缺点：<br>+帮助我们把很大的方法转换成更小的，更简单的多个方法。<br>-使结果代码运行得更快。    </p>\n<p>####将聚集操作搬移到Visitor<br>如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。<br>优缺点：<br>+调节多个算法，使其适用于不同的对象结构。<br>+访问相同或不同继承结构中的类。<br>+调用不同类上的类型特定方法，无需类型转换。<br>-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。<br>-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。<br>-可能会破坏被访问类的封装性。   </p>\n","excerpt":"<p>GoF的《设计模式》以及Martin Fowler的《重构》都是经典。而《重构与模式》则是将二者结合起来。通过设计模式来指导重构，而重构的目的就是让代码更加的简单，易于维护和扩展。   </p>\n<p>###写作缘由</p>\n<ul>\n<li>过度设计：代码存在设计过度的情况</li>\n<li>模式万灵丹：认为设计模式的万能的</li>\n<li>设计不足：类比与过度设计，长期设计不足，导致开发节奏“快、慢、更慢”</li>\n<li>测试驱动开发和持续重构：敏捷开发中，Kent Beck说开发过程是“红-绿-重构”</li>\n<li>重构与模式：模式有助于改进设计，通过重构实现模式或者趋向模式进行重构</li>\n<li>演进式设计：将模式放到重构的背景中进行领会</li>\n</ul>\n<p>###什么是重构<br>定义：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。<br>重构过程包括去除重复、简化复杂逻辑和澄清模糊的代码。要保证重构的安全性，必须确保所做的修改不会产生任何破坏，这需要进行手工测试或者自动化测试。循序渐进的进行重构有处于防止增加缺陷。  </p>\n<p>重构的动机：  </p>\n<ul>\n<li>使新代码的增加更容易</li>\n<li>改善既有代码的设计</li>\n<li>对代码理解更透彻</li>\n<li>提高编程的趣味性</li>\n</ul>","more":"<p>###什么是模式<br>GoF的《设计模式》是在软件开发中总结出来的用于解决不同场景下的软件开发模式。但是不应该陷入模式痴迷，应保证代码的可读性。<br>应该知道实现模式的方法不止一种，通过重构是为了实现、趋向和去除模式。通常情况下模式不会使代码更加复杂，实现模式有助于去除重复代码、简化逻辑、说明意图和提高灵活性，但是这也取决于人们对模式的熟悉程度。</p>\n<p>###代码坏味</p>\n<ul>\n<li><p>1.重复代码（Duplicated Code）  </p>\n<blockquote>\n<p>形成Template Method;用Factory Method引入多态创建；链构造函数；用Composite替换一/多之分；提取Composite；通过Adapter统一接口；引入Null Object；     </p>\n</blockquote>\n</li>\n<li><p>2.过长函数（Long Method）：</p>\n<blockquote>\n<p>组合方法；将聚集操作搬移到Collecting Parameter；用Command替换条件调度程序；将聚集操作搬移到Visitor；用Strategy替换条件逻辑；</p>\n</blockquote>\n</li>\n<li><p>3.条件逻辑太复杂（Conditional Complexity）：</p>\n<blockquote>\n<p>用Strategy替换条件逻辑；将装饰功能搬移到Decorator;用State替换状态改变条件语句；引入Null Object;</p>\n</blockquote>\n</li>\n<li><p>4.基本类型偏执（Primitive Obsession）:</p>\n<blockquote>\n<p>用类替换类型代码；用State替换状态改变条件语句；用Strategy替换条件逻辑；用Composite替换隐含树；用Interpreter替换隐式语言；将装饰功能搬移到Decorator；用Builder封装Composite。</p>\n</blockquote>\n</li>\n<li><p>5.不恰当的暴露（Indecent Exposure）：</p>\n<blockquote>\n<p>用Factory封装类；</p>\n</blockquote>\n</li>\n<li><p>6.解决方案蔓延（Solution Sprawl）：</p>\n<blockquote>\n<p>将创建知识搬移到Factory；</p>\n</blockquote>\n</li>\n<li><p>7.异曲同工的类（Alternative Classes With Different Interfaces）：</p>\n<blockquote>\n<p>通过Adapter统一接口；</p>\n</blockquote>\n</li>\n<li><p>8.冗赘类（Lazy Class）：</p>\n<blockquote>\n<p>内联Singeton；</p>\n</blockquote>\n</li>\n<li>9.过大的类（Large Class）：<blockquote>\n<p>用Command替换条件调度程序；用State替换状态改变条件语句；用Interpreter替换隐式语言；</p>\n</blockquote>\n</li>\n<li>10.分支语句（Switch Statement）：<blockquote>\n<p>用Command替换条件调度程序；将聚集操作搬移到Visitor；</p>\n</blockquote>\n</li>\n<li>11.组合爆炸（Combinatorial Explosion）：<blockquote>\n<p>用Interpreter替换隐式语言；</p>\n</blockquote>\n</li>\n<li>12.怪异解决方案（Oddball Solution）：<blockquote>\n<p>通过Adapter统一接口；    </p>\n</blockquote>\n</li>\n</ul>\n<p>###创建</p>\n<p>####用Creation Method替换构造函数<br>如果类中有多个构造函数，那么客户代码就可能不知道该调用哪一个。这个时候，可以使用能够说明意图的返回对象实例的Creation Method来替换构造函数。<br>优缺点：<br>+比构造函数能够更好的表达所创建的实例的种类。<br>+避免了构造函数的局限，比如2个构造函数的参数数目和类型不能相同。<br>+更容易发现无用的创建代码。<br>-创建方式是非标准的：有些是用new初始化，有的是用Creation Method实例化。   </p>\n<p>####将创建知识搬移到Factory<br>当创建一个对象的知识散布在多个类中，说明出现了创建蔓延的问题。应该将有关的创建知识搬移到一个Factory类中。<br>优缺点：<br>+合并创建逻辑和实例化/配置选项。<br>+将客户代码与创建逻辑解耦。<br>-如果可以直接实例化，会使设计复杂化。   </p>\n<p>####用Factory封装类<br>如果在同一个包结构中，有实现了同一接口的多个类。可以把类的构造函数声明为非公共的，并通过Factory来创建它们的实例。<br>优缺点：<br>+通过意图导向的CreationMethod简化了不同种类实例的创建。<br>+通过隐藏不需要公开的类减少了包结构的“概念重量”<br>+帮助严格执行“面向接口编程，而不是面向实现”这一格言。<br>-当需要创建新种类的实例时，必须新建/更新Creation Method。<br>-当客户只获得Factory的二进制代码而无法获得源代码时，对Factory的制定将受到限制。   </p>\n<p>####用Factory Method引入多态创建<br>一个层次中的类都相似的实现一个方法，只是对象创建的步骤不同。可以调用Factory Method来处理实例化的方法的唯一超类版本。<br>优缺点：<br>+减少因创建自定义对象而产生的重复代码<br>+有效的表达了对象创建发生的位置，以及如何重写对象的创建。<br>+强制Factory Method使用的类必须实现统一的类型。<br>-可能会向Factory Method的一些实现者传递不必要的参数。     </p>\n<p>####用Builder封装Composite<br>构造Composite是重复的、复杂的且容易出错的工作。通过使用Builder处理构造细节来简化构造过程。<br>优缺点：<br>+简化了构造Composite的客户代码。<br>+减少了创建Composite的重复和易出错的本性。<br>+在客户代码和Composite之间实现了松耦合。<br>-接口可能不会很清楚的表达其意图。    </p>\n<p>####内联Singleton<br>绝大多数时候，Singleton都是不需要的。当可以设计或重新设计而避免使用它们的时候，Singleton就是不必要的。可以考虑把Singleton的功能搬移到一个保存并提供对象访问入口的类中，并删除Singleton。<br>优缺点：<br>+使对象的协作变得更明显和明确。<br>+保护了单一的实例，且不要要特殊的代码。<br>-当在许多层次间传递对象实例比较困难的时候，会使设计变得复杂。    </p>\n<p>###简化</p>\n<p>####组合方法<br>一个方法逻辑很难理解的时候，就要考虑进行重构。提高每一步骤的可读性。<br>优缺点：<br>+清晰的描述了一个方法所实现的功能以及如何实现。<br>+把方法分解成命名良好的，处在细节的同一层面的行为模块，以此来简化方法。<br>-可能会产生过多的小方法。<br>-可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。  </p>\n<p>####用Strategy替换条件逻辑<br>当一个方法的条件逻辑太多太复杂的时候，考虑使用Strategy模式来为每个分支创建一个Strategy。<br>优缺点：<br>+通过减少或去除条件逻辑使算法变得清晰易懂。<br>+通过把算法的变体搬移到类层次中简化了类。<br>+允许在运行时用一种算法替换另一种算法。<br>-当应用基于继承的解决方案或“简化条件表达式”中的重构更简单时，会增加设计的复杂度。<br>-增加了算法如何获取或接受上下文类的数据的复杂度。   </p>\n<p>####将装饰功能搬移到Decorator<br>如果需要对一个功能进行增强，那增强的部分就称为装饰功能了。如果直接改代码那是不好的，考虑使用Decorator模式吧。把这个装饰功能放到装饰器内部。<br>优缺点：<br>+把装饰功能从类中搬移去除，从而简化了类。<br>+有效地把类的核心职责和装饰功能区分开来。<br>+可以去除几个相关类中重复的装饰逻辑。<br>-改变了被装饰对象的对象类型。<br>-会使代码变得更难理解和调适。<br>-当Decorator组合产生负面影响的时候，会增加设计的复杂度。   </p>\n<p>####用State替换状态改变条件语句<br>如果控制一个对象状态转换的条件表达式过于复杂，那么就使用State模式吧。<br>优缺点：<br>+减少或去除状态改变条件逻辑。<br>+简化了复杂的状态改变逻辑。<br>+提供了观察状态改变逻辑的很好的鸟瞰图。<br>-当状态转换逻辑已经易于理解的时候，会增加设计的复杂度。   </p>\n<p>####用Composite替换隐含树<br>有一些逻辑用原生表示法隐含的形成了树结构。可以使用Composite来进行重构。<br>优缺点：<br>+封装重复的指令，如格式化、添加或删除结点。<br>+提供了处理相似逻辑增长的一般性方法。<br>+简化了客户代码的构造职责。<br>-当构造隐式树更简单的时候，会增加设计的复杂度。   </p>\n<p>####用Command替换条件调度程序<br>许多系统会收到，发送并处理请求。条件调度程序是一条条条件语句，它用来执行请求的发送和处理。可以使用Command模式来实现。<br>优缺点：<br>+提供了用统一方法执行不同行为的简单机制。<br>+允许在运行时改变所处理的请求，以及如何处理请求。<br>+仅仅需要很少的代码实现。<br>-当条件调度程序已经足够的时候，会增加设计的复杂度。   </p>\n<p>###泛化</p>\n<p>####形成Template Method<br>借助Template设计模式，将算法的不变部分全部由父类实现，而可变的行为留给子类来实现。去掉所有子类的不变部分，如果仍有共同的部分，则继续重构。<br>优点与缺点：<br>+通过把不变行为搬移到超类，去除子类中的重复代码<br>+简化并有效地表达了一个通用算法的步骤。<br>+允许子类很容易的定制一个算法<br>-当为了生成算法、子类必须实现很多方法的时候，会增加设计的复杂度。   </p>\n<p>####提取Composite<br>在处于同一层次的子类中，如果存在完全重复的方法或者部分重复的方法，就可以考虑将这个方法上移到超类。完全重复的方法，直接提取上移。对于部分重复的方法，可以先提取出重复的部分，然后上移。<br>优缺点：<br>+去除重复的类存储逻辑和类处理逻辑。<br>+能够有效的表达类处理逻辑的可继承性。</p>\n<p>####用Composite替换一/多之分<br>这个名字，翻译的貌似有点问题。不知道原文是如何写的。简单说，它处理了以下问题：<br>如果一个类含有2个几乎一样的方法，唯一的区别就是一个用来处理单一对象，一个用来处理对象的集合。那么这个就称为一/多之分。这个时候，我们可以使用Composite进行替换。<br>使用Composite扩展出And，Or等条件，简化客户端的处理。<br>优缺点：<br>+去除与处理一个或多个对象相关联的重复代码。<br>+提供了处理一个或多个对象的同一方法。<br>+支持处理多个对象的更丰富的方法。（如OR表达式）<br>-可能会在Composite的构造过程中要求类型安全的运行时检查。    </p>\n<p>####用Observer替换硬编码的通知<br>拒绝使用硬编码的通知，考虑使用Observer模式。<br>优缺点：<br>+使主题及其观察者访问松散耦合<br>+支持一个或多个观察者<br>-当硬编码的通知已经足够的时候，会增加设计复杂度<br>-当出现串联通知的时候，会增加代码的复杂度<br>-当观察者没有从他们的主题中被删除的时候，可能会造成内存泄漏。   </p>\n<p>####通过Adapter统一接口<br>全部满足以下条件，考虑使用Adapter:   </p>\n<ul>\n<li>2个类所做的事情相同或者相似，但是具有不同的接口。   </li>\n<li>如果类共享同一个接口，客户代码会更简单、更直接、更紧凑。   </li>\n<li>无法轻易改变其中一个类的接口，因为它是第三方类库的一部分，或者它是一个已经被其他客户代码广泛使用的框架的一部分，或者无法获得源代码。    </li>\n</ul>\n<p>比如slf4j，就是通过各种Adapter实现了各种日志系统的大一统，并提供统一的接口。<br>优缺点：<br>+使得客户代码可以通过相同的接口与不同的类交互，从而去除或减少了重复代码。<br>+使客户代码可以通过公共的接口与多个对象交互，从而简化了客户代码。<br>+统一了客户代码与不同的类的交互方式。<br>-当类的接口可以改变的时候，会增加设计的复杂度。   </p>\n<p>####提取Adapter<br>当一个类适配了多个版本的组件，类库，API或其他实体。这个时候，应该为组件，类库，API或其他实体的每个版本提取一个Adapter。<br>优缺点：<br>+隔离了不同版本的组件，类库或API之间的不同之处。<br>+使类只负责适配代码的一个版本。<br>+避免频繁地修改代码<br>-如果某个重要行为在Adapter中不可用的话，那么客户代码将无法执行这一重要行为。   </p>\n<p>####用Interpreter替换隐式语言<br>在前面“用Composite替换一/多之分”部分，提到了使用Composite的问题。但是使用了Composite后，是需要对Composite进行翻译的。否则是不知道如何查询的。<br>优缺点：<br>+比隐式语言更好的支持语言元素的组合。<br>+不需要新的代码来支持语言元素的新组合。<br>+允许行为的运行时配置。<br>-会产生定义语法和修改客户代码的开销。<br>-如果语言很复杂，则需要很多的编程工作。<br>-如果语言本身就很简单，则会增加设计的复杂度。  </p>\n<p>###保护</p>\n<p>####用类替换类型代码<br>字段的类型（如，String或int）无法保护它免受不正确的赋值和非法的等同性比较。使用类进行替代，从而可以限制赋值和等同性比较。<br>优缺点：<br>+更好的避免非法赋值和比较。<br>-比使用不安全类型要求更多的代码。       </p>\n<p>####用Singleton限制实例化<br>有时间，遇到创建了一个对象的多个实例，导致内存使用过多和系统性能下降。可以使用单例模式。慎用。<br>优缺点：<br>+改进性能。<br>-从任何地方都可以很容易的访问。在很多情况下，这可能是设计的缺点。<br>-当对象含有不能共享的状态的时候，本重构就无效了。   </p>\n<p>####引入Null Object<br>代码中到处都是处理null字段或变量的重复逻辑。而使用Null Object可以进行改善。<br>优缺点：<br>+不需要重复的null逻辑就可以避免null错误。<br>+通过最小化null测试简化了代码。<br>-当系统不太需要null测试的时候，会增加设计的复杂度。<br>-如果程序员不知道Null Object的存在，就会产生多余的null测试。<br>-使维护变得复杂。拥有超类的Null Object必须重写所有新继承到的公共方法。    </p>\n<p>###聚集操作</p>\n<p>####将聚集操作搬移到Collecting Parameter<br>有一个很大的方法将信息聚集到一个局部变量中，那么可以把结果聚集到一个Collecting Parameter中，将它传入被提炼出的方法。<br>优缺点：<br>+帮助我们把很大的方法转换成更小的，更简单的多个方法。<br>-使结果代码运行得更快。    </p>\n<p>####将聚集操作搬移到Visitor<br>如果一个方法需要从不同的类中聚集信息，可以考虑把聚集工作搬移到一个能够访问每个类以便聚集信息的Visitor中。<br>优缺点：<br>+调节多个算法，使其适用于不同的对象结构。<br>+访问相同或不同继承结构中的类。<br>+调用不同类上的类型特定方法，无需类型转换。<br>-当可以使用通用接口把互不相同的类变成相似类的时候，会增加代码的复杂度。<br>-新的可访问类需要新的接受方法，每个Visitor中需要新的访问方法。<br>-可能会破坏被访问类的封装性。   </p>"},{"layout":"post","title":"提交代码到GitHub SSH错误解决方案","date":"2013-09-16T10:08:00.000Z","comments":1,"_content":"最近，由于公司内部的网络改造，在`git push`的时候提示如下信息：\n\n    ssh: connect to host github.com port 22: Connection timed out\n    fatal: Could not read from remote repository.\n    \n    Please make sure you have the correct access rights\n    and the repository exists.\n看字面的意思就是连接超时了，什么原因造成的呢，这个估计是公司网络禁用了SSH的22端口导致的。所幸git提供了https、git、ssh三种协议来读写。\n\n运行`git config --local -e`打开配置信息。   \n修改其中的    \n\n    url = git@github.com:username/repo.git\n为   \n\n    url = https://username@github.com/username/repo.git\n这样就改为使用https协议了。提交什么的就OK了。\n\n后来，我再使用Octopress提交博客的时候问题又出现了。也就是在`rake deploy`的时候，又走ssh了。此时只要进入_deploy目录，把上述步骤再执行一次就好了。就是每次提交都要输入用户名密码而已。  \n","source":"_posts/2013-09-16-git-ssh-connection.markdown","raw":"---\nlayout: post\ntitle: \"提交代码到GitHub SSH错误解决方案\"\ndate: 2013-09-16 18:08\ncomments: true\ncategories: git\ntags: [ git, ssh, connection ]\n---\n最近，由于公司内部的网络改造，在`git push`的时候提示如下信息：\n\n    ssh: connect to host github.com port 22: Connection timed out\n    fatal: Could not read from remote repository.\n    \n    Please make sure you have the correct access rights\n    and the repository exists.\n看字面的意思就是连接超时了，什么原因造成的呢，这个估计是公司网络禁用了SSH的22端口导致的。所幸git提供了https、git、ssh三种协议来读写。\n\n运行`git config --local -e`打开配置信息。   \n修改其中的    \n\n    url = git@github.com:username/repo.git\n为   \n\n    url = https://username@github.com/username/repo.git\n这样就改为使用https协议了。提交什么的就OK了。\n\n后来，我再使用Octopress提交博客的时候问题又出现了。也就是在`rake deploy`的时候，又走ssh了。此时只要进入_deploy目录，把上述步骤再执行一次就好了。就是每次提交都要输入用户名密码而已。  \n","slug":"2013-09-16-git-ssh-connection","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6l007hv8fybctoipwp","content":"<p>最近，由于公司内部的网络改造，在<code>git push</code>的时候提示如下信息：</p>\n<pre><code>ssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n</code></pre><p>看字面的意思就是连接超时了，什么原因造成的呢，这个估计是公司网络禁用了SSH的22端口导致的。所幸git提供了https、git、ssh三种协议来读写。</p>\n<p>运行<code>git config --local -e</code>打开配置信息。<br>修改其中的    </p>\n<pre><code>url = git@github.com:username/repo.git\n</code></pre><p>为   </p>\n<pre><code>url = https://username@github.com/username/repo.git\n</code></pre><p>这样就改为使用https协议了。提交什么的就OK了。</p>\n<p>后来，我再使用Octopress提交博客的时候问题又出现了。也就是在<code>rake deploy</code>的时候，又走ssh了。此时只要进入_deploy目录，把上述步骤再执行一次就好了。就是每次提交都要输入用户名密码而已。  </p>\n","excerpt":"","more":"<p>最近，由于公司内部的网络改造，在<code>git push</code>的时候提示如下信息：</p>\n<pre><code>ssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n</code></pre><p>看字面的意思就是连接超时了，什么原因造成的呢，这个估计是公司网络禁用了SSH的22端口导致的。所幸git提供了https、git、ssh三种协议来读写。</p>\n<p>运行<code>git config --local -e</code>打开配置信息。<br>修改其中的    </p>\n<pre><code>url = git@github.com:username/repo.git\n</code></pre><p>为   </p>\n<pre><code>url = https://username@github.com/username/repo.git\n</code></pre><p>这样就改为使用https协议了。提交什么的就OK了。</p>\n<p>后来，我再使用Octopress提交博客的时候问题又出现了。也就是在<code>rake deploy</code>的时候，又走ssh了。此时只要进入_deploy目录，把上述步骤再执行一次就好了。就是每次提交都要输入用户名密码而已。  </p>\n"},{"layout":"post","title":"Sonar的安装与使用","date":"2013-09-04T09:02:00.000Z","comments":1,"_content":"###什么是Sonar？\n[Sonar](http://www.sonarqube.org/)是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。  \n\n![](http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png)\n使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。    \n\n###安装Sonar\n1.下载sonar,地址<http://www.sonarqube.org/downloads/>。通常选取稳定版本下载即可，这是一个zip文件。   \n2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME    \n3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行`./sonar.sh console`即可。在windows下是StartSonar.bat。  \n4.现在进入<http://localhost:9000>,就看到了界面。默认的登录使用admin:admin   \n\n这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。\n<!--more-->\n###配置Sonar数据库\n1.首先新建一个数据库。\n\n    CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  \n    grant all privileges on sonar.* to 'sonar'@'%' identified by '你的密码';  \n    flush privileges; \n这样就准备好了数据库sonar,并授权给sonar这个用户。\n\n2.找到$SONAR_HOME/conf/sonar.properties。\n注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。   \n\n    # Comment the following line to deactivate the default embedded database.\n    #sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar\n    #sonar.jdbc.driverClassName:                org.h2.Driver\n    \n    -------------------\n    # The schema must be created first.\nsonar.jdbc.username:                       sonar\nsonar.jdbc.password:                       sonar\n    #----- MySQL 5.x\n    # Comment the embedded database and uncomment the following line to use MySQL\n    sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true\n    \n    # Optional properties\n    sonar.jdbc.driverClassName:                com.mysql.jdbc.Driver\n配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。   \n\n###把Sonar变为中文\n英文看这不方便啊。有2种方法可以将Sonar变为中文界面。   \n\n1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。  \n2.直接下载<http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。\n\n###把Sonar放到JEE容器内\n默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。   \nSonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。   \n\n###如何对源码进行检测\n1.配置maven的settings.xml,添加一下内容：  \n\n        <profile>\n             <id>sonar</id>\n             <activation>\n                 <activeByDefault>true</activeByDefault>\n             </activation>\n             <properties>\n                  <sonar.jdbc.url>\n                  jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8\n                  </sonar.jdbc.url>\n                  <sonar.jdbc.driver>com.mysql.jdbc.Driver</sonar.jdbc.driver>\n                  <sonar.jdbc.username>sonar</sonar.jdbc.username>\n                  <sonar.jdbc.password>sonar</sonar.jdbc.password>\n                 <sonar.host.url>http://localhost:9000/sonar</sonar.host.url>\n             </properties>\n          </profile>\n其中的数据库配置以及sonar主机地址都依据实际进行修改即可。   \n2.在maven项目种执行    \n\n    mvn clean install\n    mvn sonar:sonar\n3.打开sonar主页，就可以看到结果了。    \n\n###Sonar与Jenkins的集成。\n\n1.安装[jenkins-sonar-plugin](http://docs.codehaus.org/display/SONAR/Jenkins+Plugin)到Jenkins内。    \n2.在Jenkins里的系统配置中，填写Sonar安装信息。    \n3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。    \n\n","source":"_posts/2013-09-04-use-sonar.markdown","raw":"---\nlayout: post\ntitle: \"Sonar的安装与使用\"\ndate: 2013-09-04 17:02\ncomments: true\ncategories: 测试\ntags: [ sonar, pmd, checkstyle, findbugs, maven ]\n---\n###什么是Sonar？\n[Sonar](http://www.sonarqube.org/)是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。  \n\n![](http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png)\n使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。    \n\n###安装Sonar\n1.下载sonar,地址<http://www.sonarqube.org/downloads/>。通常选取稳定版本下载即可，这是一个zip文件。   \n2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME    \n3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行`./sonar.sh console`即可。在windows下是StartSonar.bat。  \n4.现在进入<http://localhost:9000>,就看到了界面。默认的登录使用admin:admin   \n\n这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。\n<!--more-->\n###配置Sonar数据库\n1.首先新建一个数据库。\n\n    CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  \n    grant all privileges on sonar.* to 'sonar'@'%' identified by '你的密码';  \n    flush privileges; \n这样就准备好了数据库sonar,并授权给sonar这个用户。\n\n2.找到$SONAR_HOME/conf/sonar.properties。\n注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。   \n\n    # Comment the following line to deactivate the default embedded database.\n    #sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar\n    #sonar.jdbc.driverClassName:                org.h2.Driver\n    \n    -------------------\n    # The schema must be created first.\nsonar.jdbc.username:                       sonar\nsonar.jdbc.password:                       sonar\n    #----- MySQL 5.x\n    # Comment the embedded database and uncomment the following line to use MySQL\n    sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true\n    \n    # Optional properties\n    sonar.jdbc.driverClassName:                com.mysql.jdbc.Driver\n配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。   \n\n###把Sonar变为中文\n英文看这不方便啊。有2种方法可以将Sonar变为中文界面。   \n\n1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。  \n2.直接下载<http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。\n\n###把Sonar放到JEE容器内\n默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。   \nSonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。   \n\n###如何对源码进行检测\n1.配置maven的settings.xml,添加一下内容：  \n\n        <profile>\n             <id>sonar</id>\n             <activation>\n                 <activeByDefault>true</activeByDefault>\n             </activation>\n             <properties>\n                  <sonar.jdbc.url>\n                  jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8\n                  </sonar.jdbc.url>\n                  <sonar.jdbc.driver>com.mysql.jdbc.Driver</sonar.jdbc.driver>\n                  <sonar.jdbc.username>sonar</sonar.jdbc.username>\n                  <sonar.jdbc.password>sonar</sonar.jdbc.password>\n                 <sonar.host.url>http://localhost:9000/sonar</sonar.host.url>\n             </properties>\n          </profile>\n其中的数据库配置以及sonar主机地址都依据实际进行修改即可。   \n2.在maven项目种执行    \n\n    mvn clean install\n    mvn sonar:sonar\n3.打开sonar主页，就可以看到结果了。    \n\n###Sonar与Jenkins的集成。\n\n1.安装[jenkins-sonar-plugin](http://docs.codehaus.org/display/SONAR/Jenkins+Plugin)到Jenkins内。    \n2.在Jenkins里的系统配置中，填写Sonar安装信息。    \n3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。    \n\n","slug":"2013-09-04-use-sonar","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6m007iv8fyhlcya5n7","content":"<p>###什么是Sonar？<br><a href=\"http://www.sonarqube.org/\" target=\"_blank\" rel=\"external\">Sonar</a>是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。  </p>\n<p><img src=\"http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png\" alt=\"\"><br>使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。    </p>\n<p>###安装Sonar<br>1.下载sonar,地址<a href=\"http://www.sonarqube.org/downloads/\" target=\"_blank\" rel=\"external\">http://www.sonarqube.org/downloads/</a>。通常选取稳定版本下载即可，这是一个zip文件。<br>2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME<br>3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行<code>./sonar.sh console</code>即可。在windows下是StartSonar.bat。<br>4.现在进入<a href=\"http://localhost:9000\" target=\"_blank\" rel=\"external\">http://localhost:9000</a>,就看到了界面。默认的登录使用admin:admin   </p>\n<p>这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。<br><a id=\"more\"></a></p>\n<p>###配置Sonar数据库<br>1.首先新建一个数据库。</p>\n<pre><code>CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  \ngrant all privileges on sonar.* to &apos;sonar&apos;@&apos;%&apos; identified by &apos;你的密码&apos;;  \nflush privileges; \n</code></pre><p>这样就准备好了数据库sonar,并授权给sonar这个用户。</p>\n<p>2.找到$SONAR_HOME/conf/sonar.properties。<br>注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。   </p>\n<pre><code># Comment the following line to deactivate the default embedded database.\n#sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar\n#sonar.jdbc.driverClassName:                org.h2.Driver\n\n-------------------\n# The schema must be created first.\n</code></pre><p>sonar.jdbc.username:                       sonar<br>sonar.jdbc.password:                       sonar</p>\n<pre><code>#----- MySQL 5.x\n# Comment the embedded database and uncomment the following line to use MySQL\nsonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true\n\n# Optional properties\nsonar.jdbc.driverClassName:                com.mysql.jdbc.Driver\n</code></pre><p>配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。   </p>\n<p>###把Sonar变为中文<br>英文看这不方便啊。有2种方法可以将Sonar变为中文界面。   </p>\n<p>1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。<br>2.直接下载<a href=\"http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar\" target=\"_blank\" rel=\"external\">http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar</a>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。</p>\n<p>###把Sonar放到JEE容器内<br>默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。<br>Sonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。   </p>\n<p>###如何对源码进行检测<br>1.配置maven的settings.xml,添加一下内容：  </p>\n<pre><code>&lt;profile&gt;\n     &lt;id&gt;sonar&lt;/id&gt;\n     &lt;activation&gt;\n         &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n     &lt;/activation&gt;\n     &lt;properties&gt;\n          &lt;sonar.jdbc.url&gt;\n          jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8\n          &lt;/sonar.jdbc.url&gt;\n          &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt;\n          &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt;\n          &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt;\n         &lt;sonar.host.url&gt;http://localhost:9000/sonar&lt;/sonar.host.url&gt;\n     &lt;/properties&gt;\n  &lt;/profile&gt;\n</code></pre><p>其中的数据库配置以及sonar主机地址都依据实际进行修改即可。<br>2.在maven项目种执行    </p>\n<pre><code>mvn clean install\nmvn sonar:sonar\n</code></pre><p>3.打开sonar主页，就可以看到结果了。    </p>\n<p>###Sonar与Jenkins的集成。</p>\n<p>1.安装<a href=\"http://docs.codehaus.org/display/SONAR/Jenkins+Plugin\" target=\"_blank\" rel=\"external\">jenkins-sonar-plugin</a>到Jenkins内。<br>2.在Jenkins里的系统配置中，填写Sonar安装信息。<br>3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。    </p>\n","excerpt":"<p>###什么是Sonar？<br><a href=\"http://www.sonarqube.org/\">Sonar</a>是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。  </p>\n<p><img src=\"http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png\" alt=\"\"><br>使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。    </p>\n<p>###安装Sonar<br>1.下载sonar,地址<a href=\"http://www.sonarqube.org/downloads/\">http://www.sonarqube.org/downloads/</a>。通常选取稳定版本下载即可，这是一个zip文件。<br>2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME<br>3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行<code>./sonar.sh console</code>即可。在windows下是StartSonar.bat。<br>4.现在进入<a href=\"http://localhost:9000\">http://localhost:9000</a>,就看到了界面。默认的登录使用admin:admin   </p>\n<p>这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。<br>","more":"</p>\n<p>###配置Sonar数据库<br>1.首先新建一个数据库。</p>\n<pre><code>CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  \ngrant all privileges on sonar.* to &apos;sonar&apos;@&apos;%&apos; identified by &apos;你的密码&apos;;  \nflush privileges; \n</code></pre><p>这样就准备好了数据库sonar,并授权给sonar这个用户。</p>\n<p>2.找到$SONAR_HOME/conf/sonar.properties。<br>注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。   </p>\n<pre><code># Comment the following line to deactivate the default embedded database.\n#sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar\n#sonar.jdbc.driverClassName:                org.h2.Driver\n\n-------------------\n# The schema must be created first.\n</code></pre><p>sonar.jdbc.username:                       sonar<br>sonar.jdbc.password:                       sonar</p>\n<pre><code>#----- MySQL 5.x\n# Comment the embedded database and uncomment the following line to use MySQL\nsonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true\n\n# Optional properties\nsonar.jdbc.driverClassName:                com.mysql.jdbc.Driver\n</code></pre><p>配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。   </p>\n<p>###把Sonar变为中文<br>英文看这不方便啊。有2种方法可以将Sonar变为中文界面。   </p>\n<p>1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。<br>2.直接下载<a href=\"http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar\">http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar</a>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。</p>\n<p>###把Sonar放到JEE容器内<br>默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。<br>Sonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。   </p>\n<p>###如何对源码进行检测<br>1.配置maven的settings.xml,添加一下内容：  </p>\n<pre><code>&lt;profile&gt;\n     &lt;id&gt;sonar&lt;/id&gt;\n     &lt;activation&gt;\n         &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n     &lt;/activation&gt;\n     &lt;properties&gt;\n          &lt;sonar.jdbc.url&gt;\n          jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8\n          &lt;/sonar.jdbc.url&gt;\n          &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt;\n          &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt;\n          &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt;\n         &lt;sonar.host.url&gt;http://localhost:9000/sonar&lt;/sonar.host.url&gt;\n     &lt;/properties&gt;\n  &lt;/profile&gt;\n</code></pre><p>其中的数据库配置以及sonar主机地址都依据实际进行修改即可。<br>2.在maven项目种执行    </p>\n<pre><code>mvn clean install\nmvn sonar:sonar\n</code></pre><p>3.打开sonar主页，就可以看到结果了。    </p>\n<p>###Sonar与Jenkins的集成。</p>\n<p>1.安装<a href=\"http://docs.codehaus.org/display/SONAR/Jenkins+Plugin\">jenkins-sonar-plugin</a>到Jenkins内。<br>2.在Jenkins里的系统配置中，填写Sonar安装信息。<br>3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。    </p>"},{"layout":"post","title":"Web系统性能调优常用技巧","date":"2013-09-24T10:02:00.000Z","comments":1,"_content":"####目标Web系统\napache + tomcat + mysql + linux, 介绍如何定位瓶颈与调优\n\n####Tomcat\n按照官方默认配置。   \n并发150正常;达到210时，报connection refuse\n\n$TOMCAT_HOME/conf/server.xml中   \n\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"      connectionTimeout=\"20000\" \n                   redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n\nmaxThreads 默认值是200\nacceptCount 默认值是100\n\n解决方法：显式指明以上2项，并提高数值。并可配合min/maxSpareThreads \n\n参数文档： <http://tomcat.apache.org/tomcat-6.0-doc/config/http.html>     \n\n<!--more-->\n继续增加并发数，出现以下现象：\n\n- 420并发，观察到Jmeter的聚合报告有明显卡顿现象。\n- Noah监控，显示CPU使用率下降。大锯齿出现。\n\n  问题分析：\n        在加压过程中，对tomcat的JVM情况进行监控。出现FullGC,每次大概4s .\n\n如何监控GC吗？    \n\n\tjstat -gcutil 3950 3000 5\n\n      S0     S1         E          O      P       YGC     YGCT    FGC       FGCT     GCT   \n      0.00  47.86  66.10   6.55  99.92      7       0.087     0         0.000    0.087\n      0.00  47.86  66.90   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      \n解决方法：    \n         $TOMCAT_HOME/bin/catalina.sh   第一行添加\n    \texport CATALINA_OPTS=\"-Xmx3500m -Xms2048m -XX:PermSize=256m XX:MaxPermSize=512m -Xss128k\"\n\nJAVA_OPTS   VS   CATALINA_OPTS（推荐使用）     \n**差别**：JAVA_OPTS start run stop   适用所有JVM    \n               CATALINA_OPTS   start run    专门配置tomcat    \n\ntomcat默认-client ，production环境加-server\n\nJVM参数文档：<http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm>\n\n#####Tomcat executor\n据信使用executor后，能在实际中有更好的性能以及稳定性！更为重要的是能在多个connector之间共用。\n\n    <Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\" maxThreads=\"1000\" minSpareThreads=\"25\"/>\n    \n    <Connector executor=\"tomcatThreadPool\"  port=\"8080\" protocol=\"HTTP/1.1\"   connectionTimeout=\"20000\"  redirectPort=\"8443\" />  \n\n此时，connector再使用maxThreads等属性将被忽略。\n\n#####Tomcat Connector protocol\n\n- bio   默认模式，性能低下，无任何优化，阻塞IO模式\n\n    protocol = \"org.apache.coyote.http11.Http11Protocol\" or HTTP/1.1(for http connector)\n    protocol = \"org.apache.jk.server.JkCoyoteHandler\" or AJP/1.3(for ajp connector)\n\n- nio   Java的异步io技术，非阻塞 IO\n\n    protocol = \"org.apache.coyote.http11.Http11NioProtocol\"(for http connector)\n    protocol = \"org.apache.coyote.ajp.AjpProtocol\"(for ajp connector)\n\n- apr  需要安装apr(Apache Portable Runtime)和Native。\n\n    protocol = \"org.apache.coyote.http11.Http11AprProtocol\"(for http connector)\n    protocol = \"org.apache.coyote.ajp.AjpAprProtocol\"  (for ajp connector)\n\n参考文档：    \n<http://tomcat.apache.org/tomcat-6.0-doc/config/http.html#Connector Comparison>   \n \n<http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html>\n\n#####MySQL\n\n大并发下，响应时间如何提高，绝大部分瓶颈都处于数据库端。   \n\n与数据库的连接，使用JDBC连接池    \n\nslow query监控：     \n1. 开启慢查询 my.cnf\n\n    long_query_time = 2\n    log-slow-queries =  slow.log\n\n2.使用mysqldumpslow分析log\n\n\tmysqldumpslow -t 10 -s t  slow.log\n\n解决： \n\n- 1.SQL调优   （http://coolshell.cn/articles/1846.html）   \n- 2.走类似lucene索引，空间换时间（idea实际测试中，吞吐提升7倍）\n- 3.使用NoSQL?\n\n$MYSQL_HOME/etc/my.cnf  或者 my.ini（windows）\n\n主要影响性能参数：   \n\n    max-connections = 3000     会话数上限\n    max_connect_errors = 10000    允许的最大连接错误量\n    query_cache_size =128M    查询缓存\n    query_cache_limit = 2M   小于这么大的才缓存，保护查询缓存\n    sort_buffer_size =256M    排序order by 或 group by 使用\n\n参考：<http://www.ha97.com/4110.html>\n\n####Apache\n\n处理静态资源，无法处理动态（需要应用服务器支持）\n\n静态资源直接交给apache处理\n\nab 命令进行测试，达到1000并发很easy\n\n\tab -k -c 1000  -n 1000000  http://hostname:port/path\n\n参考：<http://httpd.apache.org/docs/2.2/programs/ab.html>\n#####开启MPM支持大并发\n<table border=\"1px\">\n<thead>\n<th>Mpm模式</th><th>并发方式</th><th>内存占用</th><th>并发性能</th>\n</thead>\n<tbody>\n<tr>\n<td>prefork</td><td>进程</td><td>高</td><td>低并发下，吞吐率高</td>\n</tr>\n<tr>\n<td>worker</td><td>进程+线程</td><td>低</td><td>支持海量并发</td>\n</tr>\n</tbody>\n</table>\n\n确定apache模式命令：\n\n\t./httpd –l\n输出：  \n\n    Compiled in modules:\n    core.c\n    worker.c\n    http_core.c\n    mod_so.c\n \n修改httpd-mpm.conf\n    \n    <IfModule mpm_worker_module>\n        StartServers          2\n        MaxClients          150\n        MinSpareThreads      25\n        MaxSpareThreads      75\n        ThreadsPerChild      25\n        MaxRequestsPerChild   0\n    </IfModule>\n\n上面的配置需要满足以下公式：    \n         ThreadLimit >= ThreadsPerChild    \n         MaxClients <= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数     \n         MaxSpareThreads >= MinSpareThreads+ThreadsPerChild    \n\n####Linux\n#####too many open files error\n`ulimit -a `进行查看\n修改`vi /etc/security/limits.conf`\n\n添加：\n\n    *    -     nofile    65535\n\n参考文档：   \n <http://blog.csdn.net/lifeibo/article/details/5972356>\n\nHttp连接是基于TCP的，这个时候需要对linux服务器进行优化。   \n**三次握手**\n\n![三次握手](/images/blog/2013/three-times-handshake.png)    \n\n**四次挥手**\n\n![四次挥手](/images/blog/2013/four-wave.png)  \n\n如何查看服务器TCP状态？    \n命令：    \n\n    netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'\n输出：    \n\n    ESTABLISHED 1423\n    FIN_WAIT1 1\n    FIN_WAIT2 262\n    SYN_SENT 1\n    TIME_WAIT 962\n\n优化TCP连接相关参数：   \n\n`vi /etc/sysctl.conf`\n\n    net.ipv4.tcp_fin_timeout = 30  保持在FIN-WAIT-2的时间。默认60秒。2.2内核是180秒\n    net.ipv4.tcp_keepalive_time = 1200     长连接keepalive打开，发送的频率。默认7200（2H）\n    net.ipv4.tcp_tw_reuse = 1     默认0，处于TIME-WAIT状态的socket可以用于新的TCP连接\n    net.ipv4.tcp_tw_recycle = 1   默认0，TIME-WAIT状态的sockets快速回收\n    net.ipv4.ip_local_port_range = 1024    65000 向外连接的端口范围，默认32768~61000\n    net.ipv4.tcp_max_syn_backlog = 8192  默认1024/128,未获得客户端连接请求并保存在队列中的最大数目。\n    net.ipv4.tcp_max_tw_buckets = 5000   默认180000，系统处理的最大TIME_WAIT数目。\n    net.ipv4.route.gc_timeout = 100  路由缓存刷新频率，失败多长时间跳到另一个。默认300.\n    net.ipv4.tcp_syncookies = 1\t默认0，SYN队列溢出，启用cookies处理。\n    net.ipv4.tcp_syn_retries = 1       新建连接发送SYN次数，默认5，180秒\n    net.ipv4.tcp_synack_retries = 1    3次握手的第二步，重试几次。默认5.\n\n\n`/sbin/sysctl -p`   生效\n\n参考文档：<http://www.itlearner.com/article/4792>\n\n备注：此文由本人在公司内做的PPT分享制作而成，内容有些省略以及跳跃。欢迎留言。     ","source":"_posts/2013-09-24-performance-tuning-in-web-test.markdown","raw":"---\nlayout: post\ntitle: \"Web系统性能调优常用技巧\"\ndate: 2013-09-24 18:02\ncomments: true\ncategories: 调优\ntags: [ apache, tomcat, mysql, linux, 调优 ]\n---\n####目标Web系统\napache + tomcat + mysql + linux, 介绍如何定位瓶颈与调优\n\n####Tomcat\n按照官方默认配置。   \n并发150正常;达到210时，报connection refuse\n\n$TOMCAT_HOME/conf/server.xml中   \n\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"      connectionTimeout=\"20000\" \n                   redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n\nmaxThreads 默认值是200\nacceptCount 默认值是100\n\n解决方法：显式指明以上2项，并提高数值。并可配合min/maxSpareThreads \n\n参数文档： <http://tomcat.apache.org/tomcat-6.0-doc/config/http.html>     \n\n<!--more-->\n继续增加并发数，出现以下现象：\n\n- 420并发，观察到Jmeter的聚合报告有明显卡顿现象。\n- Noah监控，显示CPU使用率下降。大锯齿出现。\n\n  问题分析：\n        在加压过程中，对tomcat的JVM情况进行监控。出现FullGC,每次大概4s .\n\n如何监控GC吗？    \n\n\tjstat -gcutil 3950 3000 5\n\n      S0     S1         E          O      P       YGC     YGCT    FGC       FGCT     GCT   \n      0.00  47.86  66.10   6.55  99.92      7       0.087     0         0.000    0.087\n      0.00  47.86  66.90   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n      \n解决方法：    \n         $TOMCAT_HOME/bin/catalina.sh   第一行添加\n    \texport CATALINA_OPTS=\"-Xmx3500m -Xms2048m -XX:PermSize=256m XX:MaxPermSize=512m -Xss128k\"\n\nJAVA_OPTS   VS   CATALINA_OPTS（推荐使用）     \n**差别**：JAVA_OPTS start run stop   适用所有JVM    \n               CATALINA_OPTS   start run    专门配置tomcat    \n\ntomcat默认-client ，production环境加-server\n\nJVM参数文档：<http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm>\n\n#####Tomcat executor\n据信使用executor后，能在实际中有更好的性能以及稳定性！更为重要的是能在多个connector之间共用。\n\n    <Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\" maxThreads=\"1000\" minSpareThreads=\"25\"/>\n    \n    <Connector executor=\"tomcatThreadPool\"  port=\"8080\" protocol=\"HTTP/1.1\"   connectionTimeout=\"20000\"  redirectPort=\"8443\" />  \n\n此时，connector再使用maxThreads等属性将被忽略。\n\n#####Tomcat Connector protocol\n\n- bio   默认模式，性能低下，无任何优化，阻塞IO模式\n\n    protocol = \"org.apache.coyote.http11.Http11Protocol\" or HTTP/1.1(for http connector)\n    protocol = \"org.apache.jk.server.JkCoyoteHandler\" or AJP/1.3(for ajp connector)\n\n- nio   Java的异步io技术，非阻塞 IO\n\n    protocol = \"org.apache.coyote.http11.Http11NioProtocol\"(for http connector)\n    protocol = \"org.apache.coyote.ajp.AjpProtocol\"(for ajp connector)\n\n- apr  需要安装apr(Apache Portable Runtime)和Native。\n\n    protocol = \"org.apache.coyote.http11.Http11AprProtocol\"(for http connector)\n    protocol = \"org.apache.coyote.ajp.AjpAprProtocol\"  (for ajp connector)\n\n参考文档：    \n<http://tomcat.apache.org/tomcat-6.0-doc/config/http.html#Connector Comparison>   \n \n<http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html>\n\n#####MySQL\n\n大并发下，响应时间如何提高，绝大部分瓶颈都处于数据库端。   \n\n与数据库的连接，使用JDBC连接池    \n\nslow query监控：     \n1. 开启慢查询 my.cnf\n\n    long_query_time = 2\n    log-slow-queries =  slow.log\n\n2.使用mysqldumpslow分析log\n\n\tmysqldumpslow -t 10 -s t  slow.log\n\n解决： \n\n- 1.SQL调优   （http://coolshell.cn/articles/1846.html）   \n- 2.走类似lucene索引，空间换时间（idea实际测试中，吞吐提升7倍）\n- 3.使用NoSQL?\n\n$MYSQL_HOME/etc/my.cnf  或者 my.ini（windows）\n\n主要影响性能参数：   \n\n    max-connections = 3000     会话数上限\n    max_connect_errors = 10000    允许的最大连接错误量\n    query_cache_size =128M    查询缓存\n    query_cache_limit = 2M   小于这么大的才缓存，保护查询缓存\n    sort_buffer_size =256M    排序order by 或 group by 使用\n\n参考：<http://www.ha97.com/4110.html>\n\n####Apache\n\n处理静态资源，无法处理动态（需要应用服务器支持）\n\n静态资源直接交给apache处理\n\nab 命令进行测试，达到1000并发很easy\n\n\tab -k -c 1000  -n 1000000  http://hostname:port/path\n\n参考：<http://httpd.apache.org/docs/2.2/programs/ab.html>\n#####开启MPM支持大并发\n<table border=\"1px\">\n<thead>\n<th>Mpm模式</th><th>并发方式</th><th>内存占用</th><th>并发性能</th>\n</thead>\n<tbody>\n<tr>\n<td>prefork</td><td>进程</td><td>高</td><td>低并发下，吞吐率高</td>\n</tr>\n<tr>\n<td>worker</td><td>进程+线程</td><td>低</td><td>支持海量并发</td>\n</tr>\n</tbody>\n</table>\n\n确定apache模式命令：\n\n\t./httpd –l\n输出：  \n\n    Compiled in modules:\n    core.c\n    worker.c\n    http_core.c\n    mod_so.c\n \n修改httpd-mpm.conf\n    \n    <IfModule mpm_worker_module>\n        StartServers          2\n        MaxClients          150\n        MinSpareThreads      25\n        MaxSpareThreads      75\n        ThreadsPerChild      25\n        MaxRequestsPerChild   0\n    </IfModule>\n\n上面的配置需要满足以下公式：    \n         ThreadLimit >= ThreadsPerChild    \n         MaxClients <= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数     \n         MaxSpareThreads >= MinSpareThreads+ThreadsPerChild    \n\n####Linux\n#####too many open files error\n`ulimit -a `进行查看\n修改`vi /etc/security/limits.conf`\n\n添加：\n\n    *    -     nofile    65535\n\n参考文档：   \n <http://blog.csdn.net/lifeibo/article/details/5972356>\n\nHttp连接是基于TCP的，这个时候需要对linux服务器进行优化。   \n**三次握手**\n\n![三次握手](/images/blog/2013/three-times-handshake.png)    \n\n**四次挥手**\n\n![四次挥手](/images/blog/2013/four-wave.png)  \n\n如何查看服务器TCP状态？    \n命令：    \n\n    netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'\n输出：    \n\n    ESTABLISHED 1423\n    FIN_WAIT1 1\n    FIN_WAIT2 262\n    SYN_SENT 1\n    TIME_WAIT 962\n\n优化TCP连接相关参数：   \n\n`vi /etc/sysctl.conf`\n\n    net.ipv4.tcp_fin_timeout = 30  保持在FIN-WAIT-2的时间。默认60秒。2.2内核是180秒\n    net.ipv4.tcp_keepalive_time = 1200     长连接keepalive打开，发送的频率。默认7200（2H）\n    net.ipv4.tcp_tw_reuse = 1     默认0，处于TIME-WAIT状态的socket可以用于新的TCP连接\n    net.ipv4.tcp_tw_recycle = 1   默认0，TIME-WAIT状态的sockets快速回收\n    net.ipv4.ip_local_port_range = 1024    65000 向外连接的端口范围，默认32768~61000\n    net.ipv4.tcp_max_syn_backlog = 8192  默认1024/128,未获得客户端连接请求并保存在队列中的最大数目。\n    net.ipv4.tcp_max_tw_buckets = 5000   默认180000，系统处理的最大TIME_WAIT数目。\n    net.ipv4.route.gc_timeout = 100  路由缓存刷新频率，失败多长时间跳到另一个。默认300.\n    net.ipv4.tcp_syncookies = 1\t默认0，SYN队列溢出，启用cookies处理。\n    net.ipv4.tcp_syn_retries = 1       新建连接发送SYN次数，默认5，180秒\n    net.ipv4.tcp_synack_retries = 1    3次握手的第二步，重试几次。默认5.\n\n\n`/sbin/sysctl -p`   生效\n\n参考文档：<http://www.itlearner.com/article/4792>\n\n备注：此文由本人在公司内做的PPT分享制作而成，内容有些省略以及跳跃。欢迎留言。     ","slug":"2013-09-24-performance-tuning-in-web-test","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6n007kv8fyvepvrmyw","content":"<p>####目标Web系统<br>apache + tomcat + mysql + linux, 介绍如何定位瓶颈与调优</p>\n<p>####Tomcat<br>按照官方默认配置。<br>并发150正常;达到210时，报connection refuse</p>\n<p>$TOMCAT_HOME/conf/server.xml中   </p>\n<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;      connectionTimeout=&quot;20000&quot; \n               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt;\n</code></pre><p>maxThreads 默认值是200<br>acceptCount 默认值是100</p>\n<p>解决方法：显式指明以上2项，并提高数值。并可配合min/maxSpareThreads </p>\n<p>参数文档： <a href=\"http://tomcat.apache.org/tomcat-6.0-doc/config/http.html\" target=\"_blank\" rel=\"external\">http://tomcat.apache.org/tomcat-6.0-doc/config/http.html</a>     </p>\n<a id=\"more\"></a>\n<p>继续增加并发数，出现以下现象：</p>\n<ul>\n<li>420并发，观察到Jmeter的聚合报告有明显卡顿现象。</li>\n<li><p>Noah监控，显示CPU使用率下降。大锯齿出现。</p>\n<p>问题分析：</p>\n<pre><code>在加压过程中，对tomcat的JVM情况进行监控。出现FullGC,每次大概4s .\n</code></pre></li>\n</ul>\n<p>如何监控GC吗？    </p>\n<pre><code>jstat -gcutil 3950 3000 5\n\n  S0     S1         E          O      P       YGC     YGCT    FGC       FGCT     GCT   \n  0.00  47.86  66.10   6.55  99.92      7       0.087     0         0.000    0.087\n  0.00  47.86  66.90   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n</code></pre><p>解决方法：<br>         $TOMCAT_HOME/bin/catalina.sh   第一行添加<br>        export CATALINA_OPTS=”-Xmx3500m -Xms2048m -XX:PermSize=256m XX:MaxPermSize=512m -Xss128k”</p>\n<p>JAVA_OPTS   VS   CATALINA_OPTS（推荐使用）<br><strong>差别</strong>：JAVA_OPTS start run stop   适用所有JVM<br>               CATALINA_OPTS   start run    专门配置tomcat    </p>\n<p>tomcat默认-client ，production环境加-server</p>\n<p>JVM参数文档：<a href=\"http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm\" target=\"_blank\" rel=\"external\">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>\n<p>#####Tomcat executor<br>据信使用executor后，能在实际中有更好的性能以及稳定性！更为重要的是能在多个connector之间共用。</p>\n<pre><code>&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;1000&quot; minSpareThreads=&quot;25&quot;/&gt;\n\n&lt;Connector executor=&quot;tomcatThreadPool&quot;  port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;   connectionTimeout=&quot;20000&quot;  redirectPort=&quot;8443&quot; /&gt;  \n</code></pre><p>此时，connector再使用maxThreads等属性将被忽略。</p>\n<p>#####Tomcat Connector protocol</p>\n<ul>\n<li><p>bio   默认模式，性能低下，无任何优化，阻塞IO模式</p>\n<p>  protocol = “org.apache.coyote.http11.Http11Protocol” or HTTP/1.1(for http connector)<br>  protocol = “org.apache.jk.server.JkCoyoteHandler” or AJP/1.3(for ajp connector)</p>\n</li>\n<li><p>nio   Java的异步io技术，非阻塞 IO</p>\n<p>  protocol = “org.apache.coyote.http11.Http11NioProtocol”(for http connector)<br>  protocol = “org.apache.coyote.ajp.AjpProtocol”(for ajp connector)</p>\n</li>\n<li><p>apr  需要安装apr(Apache Portable Runtime)和Native。</p>\n<p>  protocol = “org.apache.coyote.http11.Http11AprProtocol”(for http connector)<br>  protocol = “org.apache.coyote.ajp.AjpAprProtocol”  (for ajp connector)</p>\n</li>\n</ul>\n<p>参考文档：<br><http: tomcat.apache.org=\"\" tomcat-6.0-doc=\"\" config=\"\" http.html#connector=\"\" comparison=\"\">   </http:></p>\n<p><a href=\"http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html\" target=\"_blank\" rel=\"external\">http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html</a></p>\n<p>#####MySQL</p>\n<p>大并发下，响应时间如何提高，绝大部分瓶颈都处于数据库端。   </p>\n<p>与数据库的连接，使用JDBC连接池    </p>\n<p>slow query监控：     </p>\n<ol>\n<li><p>开启慢查询 my.cnf</p>\n<p> long_query_time = 2<br> log-slow-queries =  slow.log</p>\n</li>\n</ol>\n<p>2.使用mysqldumpslow分析log</p>\n<pre><code>mysqldumpslow -t 10 -s t  slow.log\n</code></pre><p>解决： </p>\n<ul>\n<li>1.SQL调优   （<a href=\"http://coolshell.cn/articles/1846.html）\" target=\"_blank\" rel=\"external\">http://coolshell.cn/articles/1846.html）</a>   </li>\n<li>2.走类似lucene索引，空间换时间（idea实际测试中，吞吐提升7倍）</li>\n<li>3.使用NoSQL?</li>\n</ul>\n<p>$MYSQL_HOME/etc/my.cnf  或者 my.ini（windows）</p>\n<p>主要影响性能参数：   </p>\n<pre><code>max-connections = 3000     会话数上限\nmax_connect_errors = 10000    允许的最大连接错误量\nquery_cache_size =128M    查询缓存\nquery_cache_limit = 2M   小于这么大的才缓存，保护查询缓存\nsort_buffer_size =256M    排序order by 或 group by 使用\n</code></pre><p>参考：<a href=\"http://www.ha97.com/4110.html\" target=\"_blank\" rel=\"external\">http://www.ha97.com/4110.html</a></p>\n<p>####Apache</p>\n<p>处理静态资源，无法处理动态（需要应用服务器支持）</p>\n<p>静态资源直接交给apache处理</p>\n<p>ab 命令进行测试，达到1000并发很easy</p>\n<pre><code>ab -k -c 1000  -n 1000000  http://hostname:port/path\n</code></pre><p>参考：<a href=\"http://httpd.apache.org/docs/2.2/programs/ab.html\" target=\"_blank\" rel=\"external\">http://httpd.apache.org/docs/2.2/programs/ab.html</a></p>\n<p>#####开启MPM支持大并发</p>\n<table border=\"1px\"><br><thead><br><th>Mpm模式</th><th>并发方式</th><th>内存占用</th><th>并发性能</th><br></thead><br><tbody><br><tr><br><td>prefork</td><td>进程</td><td>高</td><td>低并发下，吞吐率高</td><br></tr><br><tr><br><td>worker</td><td>进程+线程</td><td>低</td><td>支持海量并发</td><br></tr><br></tbody><br></table>\n\n<p>确定apache模式命令：</p>\n<pre><code>./httpd –l\n</code></pre><p>输出：  </p>\n<pre><code>Compiled in modules:\ncore.c\nworker.c\nhttp_core.c\nmod_so.c\n</code></pre><p>修改httpd-mpm.conf</p>\n<pre><code>&lt;IfModule mpm_worker_module&gt;\n    StartServers          2\n    MaxClients          150\n    MinSpareThreads      25\n    MaxSpareThreads      75\n    ThreadsPerChild      25\n    MaxRequestsPerChild   0\n&lt;/IfModule&gt;\n</code></pre><p>上面的配置需要满足以下公式：<br>         ThreadLimit &gt;= ThreadsPerChild<br>         MaxClients &lt;= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数<br>         MaxSpareThreads &gt;= MinSpareThreads+ThreadsPerChild    </p>\n<p>####Linux</p>\n<p>#####too many open files error<br><code>ulimit -a</code>进行查看<br>修改<code>vi /etc/security/limits.conf</code></p>\n<p>添加：</p>\n<pre><code>*    -     nofile    65535\n</code></pre><p>参考文档：<br> <a href=\"http://blog.csdn.net/lifeibo/article/details/5972356\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lifeibo/article/details/5972356</a></p>\n<p>Http连接是基于TCP的，这个时候需要对linux服务器进行优化。<br><strong>三次握手</strong></p>\n<p><img src=\"/images/blog/2013/three-times-handshake.png\" alt=\"三次握手\">    </p>\n<p><strong>四次挥手</strong></p>\n<p><img src=\"/images/blog/2013/four-wave.png\" alt=\"四次挥手\">  </p>\n<p>如何查看服务器TCP状态？<br>命令：    </p>\n<pre><code>netstat -n | awk &apos;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&apos;\n</code></pre><p>输出：    </p>\n<pre><code>ESTABLISHED 1423\nFIN_WAIT1 1\nFIN_WAIT2 262\nSYN_SENT 1\nTIME_WAIT 962\n</code></pre><p>优化TCP连接相关参数：   </p>\n<p><code>vi /etc/sysctl.conf</code></p>\n<pre><code>net.ipv4.tcp_fin_timeout = 30  保持在FIN-WAIT-2的时间。默认60秒。2.2内核是180秒\nnet.ipv4.tcp_keepalive_time = 1200     长连接keepalive打开，发送的频率。默认7200（2H）\nnet.ipv4.tcp_tw_reuse = 1     默认0，处于TIME-WAIT状态的socket可以用于新的TCP连接\nnet.ipv4.tcp_tw_recycle = 1   默认0，TIME-WAIT状态的sockets快速回收\nnet.ipv4.ip_local_port_range = 1024    65000 向外连接的端口范围，默认32768~61000\nnet.ipv4.tcp_max_syn_backlog = 8192  默认1024/128,未获得客户端连接请求并保存在队列中的最大数目。\nnet.ipv4.tcp_max_tw_buckets = 5000   默认180000，系统处理的最大TIME_WAIT数目。\nnet.ipv4.route.gc_timeout = 100  路由缓存刷新频率，失败多长时间跳到另一个。默认300.\nnet.ipv4.tcp_syncookies = 1    默认0，SYN队列溢出，启用cookies处理。\nnet.ipv4.tcp_syn_retries = 1       新建连接发送SYN次数，默认5，180秒\nnet.ipv4.tcp_synack_retries = 1    3次握手的第二步，重试几次。默认5.\n</code></pre><p><code>/sbin/sysctl -p</code>   生效</p>\n<p>参考文档：<a href=\"http://www.itlearner.com/article/4792\" target=\"_blank\" rel=\"external\">http://www.itlearner.com/article/4792</a></p>\n<p>备注：此文由本人在公司内做的PPT分享制作而成，内容有些省略以及跳跃。欢迎留言。     </p>\n","excerpt":"<p>####目标Web系统<br>apache + tomcat + mysql + linux, 介绍如何定位瓶颈与调优</p>\n<p>####Tomcat<br>按照官方默认配置。<br>并发150正常;达到210时，报connection refuse</p>\n<p>$TOMCAT_HOME/conf/server.xml中   </p>\n<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;      connectionTimeout=&quot;20000&quot; \n               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt;\n</code></pre><p>maxThreads 默认值是200<br>acceptCount 默认值是100</p>\n<p>解决方法：显式指明以上2项，并提高数值。并可配合min/maxSpareThreads </p>\n<p>参数文档： <a href=\"http://tomcat.apache.org/tomcat-6.0-doc/config/http.html\">http://tomcat.apache.org/tomcat-6.0-doc/config/http.html</a>     </p>","more":"<p>继续增加并发数，出现以下现象：</p>\n<ul>\n<li>420并发，观察到Jmeter的聚合报告有明显卡顿现象。</li>\n<li><p>Noah监控，显示CPU使用率下降。大锯齿出现。</p>\n<p>问题分析：</p>\n<pre><code>在加压过程中，对tomcat的JVM情况进行监控。出现FullGC,每次大概4s .\n</code></pre></li>\n</ul>\n<p>如何监控GC吗？    </p>\n<pre><code>jstat -gcutil 3950 3000 5\n\n  S0     S1         E          O      P       YGC     YGCT    FGC       FGCT     GCT   \n  0.00  47.86  66.10   6.55  99.92      7       0.087     0         0.000    0.087\n  0.00  47.86  66.90   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n  0.00  47.86  67.30   6.55  99.94      7       0.087     0         0.000    0.087\n</code></pre><p>解决方法：<br>         $TOMCAT_HOME/bin/catalina.sh   第一行添加<br>        export CATALINA_OPTS=”-Xmx3500m -Xms2048m -XX:PermSize=256m XX:MaxPermSize=512m -Xss128k”</p>\n<p>JAVA_OPTS   VS   CATALINA_OPTS（推荐使用）<br><strong>差别</strong>：JAVA_OPTS start run stop   适用所有JVM<br>               CATALINA_OPTS   start run    专门配置tomcat    </p>\n<p>tomcat默认-client ，production环境加-server</p>\n<p>JVM参数文档：<a href=\"http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm\">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p>\n<p>#####Tomcat executor<br>据信使用executor后，能在实际中有更好的性能以及稳定性！更为重要的是能在多个connector之间共用。</p>\n<pre><code>&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;1000&quot; minSpareThreads=&quot;25&quot;/&gt;\n\n&lt;Connector executor=&quot;tomcatThreadPool&quot;  port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;   connectionTimeout=&quot;20000&quot;  redirectPort=&quot;8443&quot; /&gt;  \n</code></pre><p>此时，connector再使用maxThreads等属性将被忽略。</p>\n<p>#####Tomcat Connector protocol</p>\n<ul>\n<li><p>bio   默认模式，性能低下，无任何优化，阻塞IO模式</p>\n<p>  protocol = “org.apache.coyote.http11.Http11Protocol” or HTTP/1.1(for http connector)<br>  protocol = “org.apache.jk.server.JkCoyoteHandler” or AJP/1.3(for ajp connector)</p>\n</li>\n<li><p>nio   Java的异步io技术，非阻塞 IO</p>\n<p>  protocol = “org.apache.coyote.http11.Http11NioProtocol”(for http connector)<br>  protocol = “org.apache.coyote.ajp.AjpProtocol”(for ajp connector)</p>\n</li>\n<li><p>apr  需要安装apr(Apache Portable Runtime)和Native。</p>\n<p>  protocol = “org.apache.coyote.http11.Http11AprProtocol”(for http connector)<br>  protocol = “org.apache.coyote.ajp.AjpAprProtocol”  (for ajp connector)</p>\n</li>\n</ul>\n<p>参考文档：<br><http://tomcat.apache.org/tomcat-6.0-doc/config/http.html#Connector Comparison>   </p>\n<p><a href=\"http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html\">http://tomcat.apache.org/tomcat-6.0-doc/config/ajp.html</a></p>\n<p>#####MySQL</p>\n<p>大并发下，响应时间如何提高，绝大部分瓶颈都处于数据库端。   </p>\n<p>与数据库的连接，使用JDBC连接池    </p>\n<p>slow query监控：     </p>\n<ol>\n<li><p>开启慢查询 my.cnf</p>\n<p> long_query_time = 2<br> log-slow-queries =  slow.log</p>\n</li>\n</ol>\n<p>2.使用mysqldumpslow分析log</p>\n<pre><code>mysqldumpslow -t 10 -s t  slow.log\n</code></pre><p>解决： </p>\n<ul>\n<li>1.SQL调优   （<a href=\"http://coolshell.cn/articles/1846.html）\">http://coolshell.cn/articles/1846.html）</a>   </li>\n<li>2.走类似lucene索引，空间换时间（idea实际测试中，吞吐提升7倍）</li>\n<li>3.使用NoSQL?</li>\n</ul>\n<p>$MYSQL_HOME/etc/my.cnf  或者 my.ini（windows）</p>\n<p>主要影响性能参数：   </p>\n<pre><code>max-connections = 3000     会话数上限\nmax_connect_errors = 10000    允许的最大连接错误量\nquery_cache_size =128M    查询缓存\nquery_cache_limit = 2M   小于这么大的才缓存，保护查询缓存\nsort_buffer_size =256M    排序order by 或 group by 使用\n</code></pre><p>参考：<a href=\"http://www.ha97.com/4110.html\">http://www.ha97.com/4110.html</a></p>\n<p>####Apache</p>\n<p>处理静态资源，无法处理动态（需要应用服务器支持）</p>\n<p>静态资源直接交给apache处理</p>\n<p>ab 命令进行测试，达到1000并发很easy</p>\n<pre><code>ab -k -c 1000  -n 1000000  http://hostname:port/path\n</code></pre><p>参考：<a href=\"http://httpd.apache.org/docs/2.2/programs/ab.html\">http://httpd.apache.org/docs/2.2/programs/ab.html</a></p>\n<p>#####开启MPM支持大并发</p>\n<table border=\"1px\"><br><thead><br><th>Mpm模式</th><th>并发方式</th><th>内存占用</th><th>并发性能</th><br></thead><br><tbody><br><tr><br><td>prefork</td><td>进程</td><td>高</td><td>低并发下，吞吐率高</td><br></tr><br><tr><br><td>worker</td><td>进程+线程</td><td>低</td><td>支持海量并发</td><br></tr><br></tbody><br></table>\n\n<p>确定apache模式命令：</p>\n<pre><code>./httpd –l\n</code></pre><p>输出：  </p>\n<pre><code>Compiled in modules:\ncore.c\nworker.c\nhttp_core.c\nmod_so.c\n</code></pre><p>修改httpd-mpm.conf</p>\n<pre><code>&lt;IfModule mpm_worker_module&gt;\n    StartServers          2\n    MaxClients          150\n    MinSpareThreads      25\n    MaxSpareThreads      75\n    ThreadsPerChild      25\n    MaxRequestsPerChild   0\n&lt;/IfModule&gt;\n</code></pre><p>上面的配置需要满足以下公式：<br>         ThreadLimit &gt;= ThreadsPerChild<br>         MaxClients &lt;= ServerLimit * ThreadsPerChild 必须是ThreadsPerChild的倍数<br>         MaxSpareThreads &gt;= MinSpareThreads+ThreadsPerChild    </p>\n<p>####Linux</p>\n<p>#####too many open files error<br><code>ulimit -a</code>进行查看<br>修改<code>vi /etc/security/limits.conf</code></p>\n<p>添加：</p>\n<pre><code>*    -     nofile    65535\n</code></pre><p>参考文档：<br> <a href=\"http://blog.csdn.net/lifeibo/article/details/5972356\">http://blog.csdn.net/lifeibo/article/details/5972356</a></p>\n<p>Http连接是基于TCP的，这个时候需要对linux服务器进行优化。<br><strong>三次握手</strong></p>\n<p><img src=\"/images/blog/2013/three-times-handshake.png\" alt=\"三次握手\">    </p>\n<p><strong>四次挥手</strong></p>\n<p><img src=\"/images/blog/2013/four-wave.png\" alt=\"四次挥手\">  </p>\n<p>如何查看服务器TCP状态？<br>命令：    </p>\n<pre><code>netstat -n | awk &apos;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&apos;\n</code></pre><p>输出：    </p>\n<pre><code>ESTABLISHED 1423\nFIN_WAIT1 1\nFIN_WAIT2 262\nSYN_SENT 1\nTIME_WAIT 962\n</code></pre><p>优化TCP连接相关参数：   </p>\n<p><code>vi /etc/sysctl.conf</code></p>\n<pre><code>net.ipv4.tcp_fin_timeout = 30  保持在FIN-WAIT-2的时间。默认60秒。2.2内核是180秒\nnet.ipv4.tcp_keepalive_time = 1200     长连接keepalive打开，发送的频率。默认7200（2H）\nnet.ipv4.tcp_tw_reuse = 1     默认0，处于TIME-WAIT状态的socket可以用于新的TCP连接\nnet.ipv4.tcp_tw_recycle = 1   默认0，TIME-WAIT状态的sockets快速回收\nnet.ipv4.ip_local_port_range = 1024    65000 向外连接的端口范围，默认32768~61000\nnet.ipv4.tcp_max_syn_backlog = 8192  默认1024/128,未获得客户端连接请求并保存在队列中的最大数目。\nnet.ipv4.tcp_max_tw_buckets = 5000   默认180000，系统处理的最大TIME_WAIT数目。\nnet.ipv4.route.gc_timeout = 100  路由缓存刷新频率，失败多长时间跳到另一个。默认300.\nnet.ipv4.tcp_syncookies = 1    默认0，SYN队列溢出，启用cookies处理。\nnet.ipv4.tcp_syn_retries = 1       新建连接发送SYN次数，默认5，180秒\nnet.ipv4.tcp_synack_retries = 1    3次握手的第二步，重试几次。默认5.\n</code></pre><p><code>/sbin/sysctl -p</code>   生效</p>\n<p>参考文档：<a href=\"http://www.itlearner.com/article/4792\">http://www.itlearner.com/article/4792</a></p>\n<p>备注：此文由本人在公司内做的PPT分享制作而成，内容有些省略以及跳跃。欢迎留言。     </p>"},{"layout":"post","title":"自定义CheckStyle规则","date":"2013-09-25T05:11:00.000Z","comments":1,"_content":"###CheckStyle基于antlr对源码进行处理\n\n- antlr对AST解析\n- 使用Visitor模式\n\n主要是通过：\n\n    public int[] getDefaultTokens()\n    \n指定要访问的节点类型。   \n\n    public void visitToken(DetailAST assignAST)\n    \n指定如何处理节点，并进行规则校验。\n\n<!--more-->\n####参数不可在方法内重新赋值\n    \n    import com.puppycrawl.tools.checkstyle.api.Check;\n    import com.puppycrawl.tools.checkstyle.api.DetailAST;\n    import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    \n    /**\n     * Date:  13-8-26\n     * Time:  下午4:34\n     * checks the Method Parameter should not assign.\n     *\n     * @author shenyanchao\n     */\n    public class ParameterNoAssignCheck extends Check {\n    \n        private int[] assignTokenTypes = {\n                TokenTypes.ASSIGN,\n                TokenTypes.PLUS_ASSIGN,\n                TokenTypes.MINUS_ASSIGN,\n                TokenTypes.STAR_ASSIGN,\n                TokenTypes.DIV_ASSIGN,\n                TokenTypes.MOD_ASSIGN,\n                TokenTypes.SR_ASSIGN,\n                TokenTypes.BSR_ASSIGN,\n                TokenTypes.SL_ASSIGN,\n                TokenTypes.BAND_ASSIGN,\n                TokenTypes.BXOR_ASSIGN,\n                TokenTypes.BOR_ASSIGN\n        };\n    \n        @Override\n        public int[] getDefaultTokens() {\n            return assignTokenTypes;\n        }\n    \n    \n        @Override\n        public void visitToken(DetailAST assignAST) {\n            if (null == assignAST) {\n                return;\n            }\n            DetailAST leftVarAST = assignAST.findFirstToken(TokenTypes.IDENT);\n            if (null == leftVarAST) {\n                return;\n            }\n            String leftVar = leftVarAST.getText();\n            DetailAST methodDefAST = findParentMethodDefBy(assignAST);\n            if (null != methodDefAST) {\n                List<String> parameters = findMethodParameterNames(methodDefAST);\n                if (parameters.contains(leftVar)) {\n                    log(leftVarAST.getLineNo(), \"Method parameter [\" + leftVar + \"] should not assign!\");\n                }\n            }\n        }\n    \n    \n        private List<String> findMethodParameterNames(DetailAST methodDefAST) {\n            List<String> parameters = new ArrayList<String>();\n            if (null != methodDefAST) {\n                DetailAST parametersAST = methodDefAST.findFirstToken(TokenTypes.PARAMETERS);\n                if (null != parametersAST) {\n                    DetailAST parameterDefAST = parametersAST.getFirstChild();\n                    while (null != parameterDefAST) {\n                        if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF) {\n                            String parameterName = parameterDefAST.findFirstToken(TokenTypes.IDENT).getText();\n                            parameters.add(parameterName);\n                        }\n                        parameterDefAST = parameterDefAST.getNextSibling();\n                    }\n                }\n            }\n            return parameters;\n        }\n    \n    \n        /**\n         * @param aAST aAST\n         * @return ancestor METHOD_DEF or null\n         */\n        private DetailAST findParentMethodDefBy(DetailAST aAST) {\n            if (null == aAST || aAST.getType() == TokenTypes.METHOD_DEF) {\n                return aAST;\n            } else {\n                return findParentMethodDefBy(aAST.getParent());\n            }\n        }\n    \n    }\n    \n####控制使用String连+的数量\n\n\n    import com.puppycrawl.tools.checkstyle.api.Check;\n    import com.puppycrawl.tools.checkstyle.api.DetailAST;\n    import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n    \n    /**\n     * Date:  13-8-26\n     * Time:  下午1:29\n     *\n     * @author shenyanchao\n     */\n    public class ConcatStringCheck extends Check {\n    \n        private static final int DEFAULT_MAX = 10;\n        private int max = DEFAULT_MAX;\n    \n        @Override\n        public int[] getDefaultTokens() {\n            return new int[]{TokenTypes.EXPR};\n        }\n    \n        @Override\n        public void visitToken(DetailAST ast) {\n            int plusCount = findAllSubNodeIn(ast, TokenTypes.PLUS);\n            if (plusCount > max - 1) {\n                log(ast.getLineNo(), \"more than \" + (max) + \" string concat,please use StringBuffer or StringBuilder \" +\n                        \"instead\");\n            }\n        }\n    \n    \n        public void setMax(int limit) {\n            max = limit;\n        }\n    \n        private int findAllSubNodeIn(DetailAST ast, int tokenTypes) {\n            if (ast.getChildCount() == 0) {\n                return 0;\n            } else {\n                int count = 0;\n                count += ast.getChildCount(tokenTypes);\n                DetailAST childAST = ast.getFirstChild();\n                while (null != childAST) {\n                    count += findAllSubNodeIn(childAST, tokenTypes);\n                    childAST = childAST.getNextSibling();\n                }\n                return count;\n            }\n        }\n    \n    }","source":"_posts/2013-09-25-custome-checkstyle-rule.markdown","raw":"---\nlayout: post\ntitle: \"自定义CheckStyle规则\"\ndate: 2013-09-25 13:11\ncomments: true\ncategories: checkstyle\ntags: [ checkstyle, antlr ]\n---\n###CheckStyle基于antlr对源码进行处理\n\n- antlr对AST解析\n- 使用Visitor模式\n\n主要是通过：\n\n    public int[] getDefaultTokens()\n    \n指定要访问的节点类型。   \n\n    public void visitToken(DetailAST assignAST)\n    \n指定如何处理节点，并进行规则校验。\n\n<!--more-->\n####参数不可在方法内重新赋值\n    \n    import com.puppycrawl.tools.checkstyle.api.Check;\n    import com.puppycrawl.tools.checkstyle.api.DetailAST;\n    import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    \n    /**\n     * Date:  13-8-26\n     * Time:  下午4:34\n     * checks the Method Parameter should not assign.\n     *\n     * @author shenyanchao\n     */\n    public class ParameterNoAssignCheck extends Check {\n    \n        private int[] assignTokenTypes = {\n                TokenTypes.ASSIGN,\n                TokenTypes.PLUS_ASSIGN,\n                TokenTypes.MINUS_ASSIGN,\n                TokenTypes.STAR_ASSIGN,\n                TokenTypes.DIV_ASSIGN,\n                TokenTypes.MOD_ASSIGN,\n                TokenTypes.SR_ASSIGN,\n                TokenTypes.BSR_ASSIGN,\n                TokenTypes.SL_ASSIGN,\n                TokenTypes.BAND_ASSIGN,\n                TokenTypes.BXOR_ASSIGN,\n                TokenTypes.BOR_ASSIGN\n        };\n    \n        @Override\n        public int[] getDefaultTokens() {\n            return assignTokenTypes;\n        }\n    \n    \n        @Override\n        public void visitToken(DetailAST assignAST) {\n            if (null == assignAST) {\n                return;\n            }\n            DetailAST leftVarAST = assignAST.findFirstToken(TokenTypes.IDENT);\n            if (null == leftVarAST) {\n                return;\n            }\n            String leftVar = leftVarAST.getText();\n            DetailAST methodDefAST = findParentMethodDefBy(assignAST);\n            if (null != methodDefAST) {\n                List<String> parameters = findMethodParameterNames(methodDefAST);\n                if (parameters.contains(leftVar)) {\n                    log(leftVarAST.getLineNo(), \"Method parameter [\" + leftVar + \"] should not assign!\");\n                }\n            }\n        }\n    \n    \n        private List<String> findMethodParameterNames(DetailAST methodDefAST) {\n            List<String> parameters = new ArrayList<String>();\n            if (null != methodDefAST) {\n                DetailAST parametersAST = methodDefAST.findFirstToken(TokenTypes.PARAMETERS);\n                if (null != parametersAST) {\n                    DetailAST parameterDefAST = parametersAST.getFirstChild();\n                    while (null != parameterDefAST) {\n                        if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF) {\n                            String parameterName = parameterDefAST.findFirstToken(TokenTypes.IDENT).getText();\n                            parameters.add(parameterName);\n                        }\n                        parameterDefAST = parameterDefAST.getNextSibling();\n                    }\n                }\n            }\n            return parameters;\n        }\n    \n    \n        /**\n         * @param aAST aAST\n         * @return ancestor METHOD_DEF or null\n         */\n        private DetailAST findParentMethodDefBy(DetailAST aAST) {\n            if (null == aAST || aAST.getType() == TokenTypes.METHOD_DEF) {\n                return aAST;\n            } else {\n                return findParentMethodDefBy(aAST.getParent());\n            }\n        }\n    \n    }\n    \n####控制使用String连+的数量\n\n\n    import com.puppycrawl.tools.checkstyle.api.Check;\n    import com.puppycrawl.tools.checkstyle.api.DetailAST;\n    import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n    \n    /**\n     * Date:  13-8-26\n     * Time:  下午1:29\n     *\n     * @author shenyanchao\n     */\n    public class ConcatStringCheck extends Check {\n    \n        private static final int DEFAULT_MAX = 10;\n        private int max = DEFAULT_MAX;\n    \n        @Override\n        public int[] getDefaultTokens() {\n            return new int[]{TokenTypes.EXPR};\n        }\n    \n        @Override\n        public void visitToken(DetailAST ast) {\n            int plusCount = findAllSubNodeIn(ast, TokenTypes.PLUS);\n            if (plusCount > max - 1) {\n                log(ast.getLineNo(), \"more than \" + (max) + \" string concat,please use StringBuffer or StringBuilder \" +\n                        \"instead\");\n            }\n        }\n    \n    \n        public void setMax(int limit) {\n            max = limit;\n        }\n    \n        private int findAllSubNodeIn(DetailAST ast, int tokenTypes) {\n            if (ast.getChildCount() == 0) {\n                return 0;\n            } else {\n                int count = 0;\n                count += ast.getChildCount(tokenTypes);\n                DetailAST childAST = ast.getFirstChild();\n                while (null != childAST) {\n                    count += findAllSubNodeIn(childAST, tokenTypes);\n                    childAST = childAST.getNextSibling();\n                }\n                return count;\n            }\n        }\n    \n    }","slug":"2013-09-25-custome-checkstyle-rule","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6p007pv8fy4gvh6m6p","content":"<p>###CheckStyle基于antlr对源码进行处理</p>\n<ul>\n<li>antlr对AST解析</li>\n<li>使用Visitor模式</li>\n</ul>\n<p>主要是通过：</p>\n<pre><code>public int[] getDefaultTokens()\n</code></pre><p>指定要访问的节点类型。   </p>\n<pre><code>public void visitToken(DetailAST assignAST)\n</code></pre><p>指定如何处理节点，并进行规则校验。</p>\n<a id=\"more\"></a>\n<p>####参数不可在方法内重新赋值</p>\n<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Date:  13-8-26\n * Time:  下午4:34\n * checks the Method Parameter should not assign.\n *\n * @author shenyanchao\n */\npublic class ParameterNoAssignCheck extends Check {\n\n    private int[] assignTokenTypes = {\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN\n    };\n\n    @Override\n    public int[] getDefaultTokens() {\n        return assignTokenTypes;\n    }\n\n\n    @Override\n    public void visitToken(DetailAST assignAST) {\n        if (null == assignAST) {\n            return;\n        }\n        DetailAST leftVarAST = assignAST.findFirstToken(TokenTypes.IDENT);\n        if (null == leftVarAST) {\n            return;\n        }\n        String leftVar = leftVarAST.getText();\n        DetailAST methodDefAST = findParentMethodDefBy(assignAST);\n        if (null != methodDefAST) {\n            List&lt;String&gt; parameters = findMethodParameterNames(methodDefAST);\n            if (parameters.contains(leftVar)) {\n                log(leftVarAST.getLineNo(), &quot;Method parameter [&quot; + leftVar + &quot;] should not assign!&quot;);\n            }\n        }\n    }\n\n\n    private List&lt;String&gt; findMethodParameterNames(DetailAST methodDefAST) {\n        List&lt;String&gt; parameters = new ArrayList&lt;String&gt;();\n        if (null != methodDefAST) {\n            DetailAST parametersAST = methodDefAST.findFirstToken(TokenTypes.PARAMETERS);\n            if (null != parametersAST) {\n                DetailAST parameterDefAST = parametersAST.getFirstChild();\n                while (null != parameterDefAST) {\n                    if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF) {\n                        String parameterName = parameterDefAST.findFirstToken(TokenTypes.IDENT).getText();\n                        parameters.add(parameterName);\n                    }\n                    parameterDefAST = parameterDefAST.getNextSibling();\n                }\n            }\n        }\n        return parameters;\n    }\n\n\n    /**\n     * @param aAST aAST\n     * @return ancestor METHOD_DEF or null\n     */\n    private DetailAST findParentMethodDefBy(DetailAST aAST) {\n        if (null == aAST || aAST.getType() == TokenTypes.METHOD_DEF) {\n            return aAST;\n        } else {\n            return findParentMethodDefBy(aAST.getParent());\n        }\n    }\n\n}\n</code></pre><p>####控制使用String连+的数量</p>\n<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * Date:  13-8-26\n * Time:  下午1:29\n *\n * @author shenyanchao\n */\npublic class ConcatStringCheck extends Check {\n\n    private static final int DEFAULT_MAX = 10;\n    private int max = DEFAULT_MAX;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[]{TokenTypes.EXPR};\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        int plusCount = findAllSubNodeIn(ast, TokenTypes.PLUS);\n        if (plusCount &gt; max - 1) {\n            log(ast.getLineNo(), &quot;more than &quot; + (max) + &quot; string concat,please use StringBuffer or StringBuilder &quot; +\n                    &quot;instead&quot;);\n        }\n    }\n\n\n    public void setMax(int limit) {\n        max = limit;\n    }\n\n    private int findAllSubNodeIn(DetailAST ast, int tokenTypes) {\n        if (ast.getChildCount() == 0) {\n            return 0;\n        } else {\n            int count = 0;\n            count += ast.getChildCount(tokenTypes);\n            DetailAST childAST = ast.getFirstChild();\n            while (null != childAST) {\n                count += findAllSubNodeIn(childAST, tokenTypes);\n                childAST = childAST.getNextSibling();\n            }\n            return count;\n        }\n    }\n\n}\n</code></pre>","excerpt":"<p>###CheckStyle基于antlr对源码进行处理</p>\n<ul>\n<li>antlr对AST解析</li>\n<li>使用Visitor模式</li>\n</ul>\n<p>主要是通过：</p>\n<pre><code>public int[] getDefaultTokens()\n</code></pre><p>指定要访问的节点类型。   </p>\n<pre><code>public void visitToken(DetailAST assignAST)\n</code></pre><p>指定如何处理节点，并进行规则校验。</p>","more":"<p>####参数不可在方法内重新赋值</p>\n<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Date:  13-8-26\n * Time:  下午4:34\n * checks the Method Parameter should not assign.\n *\n * @author shenyanchao\n */\npublic class ParameterNoAssignCheck extends Check {\n\n    private int[] assignTokenTypes = {\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN\n    };\n\n    @Override\n    public int[] getDefaultTokens() {\n        return assignTokenTypes;\n    }\n\n\n    @Override\n    public void visitToken(DetailAST assignAST) {\n        if (null == assignAST) {\n            return;\n        }\n        DetailAST leftVarAST = assignAST.findFirstToken(TokenTypes.IDENT);\n        if (null == leftVarAST) {\n            return;\n        }\n        String leftVar = leftVarAST.getText();\n        DetailAST methodDefAST = findParentMethodDefBy(assignAST);\n        if (null != methodDefAST) {\n            List&lt;String&gt; parameters = findMethodParameterNames(methodDefAST);\n            if (parameters.contains(leftVar)) {\n                log(leftVarAST.getLineNo(), &quot;Method parameter [&quot; + leftVar + &quot;] should not assign!&quot;);\n            }\n        }\n    }\n\n\n    private List&lt;String&gt; findMethodParameterNames(DetailAST methodDefAST) {\n        List&lt;String&gt; parameters = new ArrayList&lt;String&gt;();\n        if (null != methodDefAST) {\n            DetailAST parametersAST = methodDefAST.findFirstToken(TokenTypes.PARAMETERS);\n            if (null != parametersAST) {\n                DetailAST parameterDefAST = parametersAST.getFirstChild();\n                while (null != parameterDefAST) {\n                    if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF) {\n                        String parameterName = parameterDefAST.findFirstToken(TokenTypes.IDENT).getText();\n                        parameters.add(parameterName);\n                    }\n                    parameterDefAST = parameterDefAST.getNextSibling();\n                }\n            }\n        }\n        return parameters;\n    }\n\n\n    /**\n     * @param aAST aAST\n     * @return ancestor METHOD_DEF or null\n     */\n    private DetailAST findParentMethodDefBy(DetailAST aAST) {\n        if (null == aAST || aAST.getType() == TokenTypes.METHOD_DEF) {\n            return aAST;\n        } else {\n            return findParentMethodDefBy(aAST.getParent());\n        }\n    }\n\n}\n</code></pre><p>####控制使用String连+的数量</p>\n<pre><code>import com.puppycrawl.tools.checkstyle.api.Check;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * Date:  13-8-26\n * Time:  下午1:29\n *\n * @author shenyanchao\n */\npublic class ConcatStringCheck extends Check {\n\n    private static final int DEFAULT_MAX = 10;\n    private int max = DEFAULT_MAX;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[]{TokenTypes.EXPR};\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        int plusCount = findAllSubNodeIn(ast, TokenTypes.PLUS);\n        if (plusCount &gt; max - 1) {\n            log(ast.getLineNo(), &quot;more than &quot; + (max) + &quot; string concat,please use StringBuffer or StringBuilder &quot; +\n                    &quot;instead&quot;);\n        }\n    }\n\n\n    public void setMax(int limit) {\n        max = limit;\n    }\n\n    private int findAllSubNodeIn(DetailAST ast, int tokenTypes) {\n        if (ast.getChildCount() == 0) {\n            return 0;\n        } else {\n            int count = 0;\n            count += ast.getChildCount(tokenTypes);\n            DetailAST childAST = ast.getFirstChild();\n            while (null != childAST) {\n                count += findAllSubNodeIn(childAST, tokenTypes);\n                childAST = childAST.getNextSibling();\n            }\n            return count;\n        }\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"Maven如何打包本地依赖包","date":"2013-11-20T11:04:00.000Z","comments":1,"_content":"####Maven如何依赖本地包？\n有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？\n\n        <dependency>\n            <groupId>org.wltea.ik-analyzer</groupId>\n            <artifactId>ik-analyzer</artifactId>\n            <version>3.2.8</version>\n            <scope>system</scope>\n            <systemPath>${project.basedir}/lib/ik-analyzer-3.2.8.jar</systemPath>\n        </dependency>\n这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。\n\n####如何将本地包打到war包内？\n打war包，一般直接执行`mvn clean package`即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-war-plugin</artifactId>\n                <version>2.3</version>\n                <configuration>\n                    <warName>${project.artifactId}</warName>\n                    <webResources>\n                        <resource>\n                            <directory>lib/</directory>\n                            <targetPath>WEB-INF/lib</targetPath>\n                            <includes>\n                                <include>**/*.jar</include>\n                            </includes>\n                        </resource>\n                    </webResources>\n                </configuration>\n            </plugin>\n            \n","source":"_posts/2013-11-20-how-package-system-dependency-lib-in-maven.markdown","raw":"---\nlayout: post\ntitle: \"Maven如何打包本地依赖包\"\ndate: 2013-11-20 19:04\ncomments: true\ncategories: maven\ntags: [ maven, package, war ]\n---\n####Maven如何依赖本地包？\n有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？\n\n        <dependency>\n            <groupId>org.wltea.ik-analyzer</groupId>\n            <artifactId>ik-analyzer</artifactId>\n            <version>3.2.8</version>\n            <scope>system</scope>\n            <systemPath>${project.basedir}/lib/ik-analyzer-3.2.8.jar</systemPath>\n        </dependency>\n这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。\n\n####如何将本地包打到war包内？\n打war包，一般直接执行`mvn clean package`即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-war-plugin</artifactId>\n                <version>2.3</version>\n                <configuration>\n                    <warName>${project.artifactId}</warName>\n                    <webResources>\n                        <resource>\n                            <directory>lib/</directory>\n                            <targetPath>WEB-INF/lib</targetPath>\n                            <includes>\n                                <include>**/*.jar</include>\n                            </includes>\n                        </resource>\n                    </webResources>\n                </configuration>\n            </plugin>\n            \n","slug":"2013-11-20-how-package-system-dependency-lib-in-maven","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6q007sv8fyz4jijyce","content":"<p>####Maven如何依赖本地包？<br>有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wltea.ik-analyzer&lt;/groupId&gt;\n    &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt;\n    &lt;version&gt;3.2.8&lt;/version&gt;\n    &lt;scope&gt;system&lt;/scope&gt;\n    &lt;systemPath&gt;${project.basedir}/lib/ik-analyzer-3.2.8.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n</code></pre><p>这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。</p>\n<p>####如何将本地包打到war包内？<br>打war包，一般直接执行<code>mvn clean package</code>即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.3&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;warName&gt;${project.artifactId}&lt;/warName&gt;\n        &lt;webResources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;lib/&lt;/directory&gt;\n                &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.jar&lt;/include&gt;\n                &lt;/includes&gt;\n            &lt;/resource&gt;\n        &lt;/webResources&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>","excerpt":"","more":"<p>####Maven如何依赖本地包？<br>有些依赖包在mavencentral上是没有的。那么如何在项目中使用呢？</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.wltea.ik-analyzer&lt;/groupId&gt;\n    &lt;artifactId&gt;ik-analyzer&lt;/artifactId&gt;\n    &lt;version&gt;3.2.8&lt;/version&gt;\n    &lt;scope&gt;system&lt;/scope&gt;\n    &lt;systemPath&gt;${project.basedir}/lib/ik-analyzer-3.2.8.jar&lt;/systemPath&gt;\n&lt;/dependency&gt;\n</code></pre><p>这里可以指明scope是system,然后制定这个依赖包的systemPath就可以啦。这里依ik-analyzer为例的。</p>\n<p>####如何将本地包打到war包内？<br>打war包，一般直接执行<code>mvn clean package</code>即可，但是默认的情况下是不能将scope=system的本地包打包的。这个时候就需要显式的指定啦。如下面这样，默认将lib下的所有jar文件打包到WEB-INF/lib下。当然也是可以打包其他的文件的，诸如xml,properties等的。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.3&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;warName&gt;${project.artifactId}&lt;/warName&gt;\n        &lt;webResources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;lib/&lt;/directory&gt;\n                &lt;targetPath&gt;WEB-INF/lib&lt;/targetPath&gt;\n                &lt;includes&gt;\n                    &lt;include&gt;**/*.jar&lt;/include&gt;\n                &lt;/includes&gt;\n            &lt;/resource&gt;\n        &lt;/webResources&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"layout":"post","title":"Maven项目集成CheckStyle,PMD,FindBugs进行静态代码扫描","date":"2013-11-20T11:22:00.000Z","comments":1,"_content":"\n在pom.xml里添加以下maven插件配置：   \n\n        <!-- 静态代码检查 -->\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-checkstyle-plugin</artifactId>\n        <version>2.11</version>\n        <configuration>\n            <configLocation>checkstyle.xml</configLocation>\n            <includeResources>false</includeResources>\n            <failOnViolation>true</failOnViolation>\n            <violationSeverity>info</violationSeverity>\n            <maxAllowedViolations>0</maxAllowedViolations>\n            <consoleOutput>true</consoleOutput>\n            <encoding>UTF-8</encoding>\n            <includes>\n                **\\/package\\/**.java,**\\/otherpackage\\/**.java\n            </includes>\n        </configuration>\n    <!--     <executions>\n             <execution>\n                 <goals>\n                     <goal>check</goal>\n                 </goals>\n                 <phase>validate</phase>\n             </execution>\n         </executions>-->\n    </plugin>\n    \n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-pmd-plugin</artifactId>\n        <version>2.7.1</version>\n        <configuration>\n            <failurePriority>5</failurePriority>\n            <failOnViolation>true</failOnViolation>\n            <targetJdk>${jdk.version}</targetJdk>\n            <verbose>true</verbose>\n            <outputEncoding>UTF-8</outputEncoding>\n            <rulesets>\n                <ruleset>pmd.xml</ruleset>\n            </rulesets>\n            <includes>\n                <include>**\\/package\\/**.java</include>\n                <include>**\\/otherpackage\\/**.java</include>\n            </includes>\n        </configuration>\n      <!--   <executions>\n             <execution>\n                 <phase>package</phase>\n                 <goals>\n                     <goal>check</goal>\n                 </goals>\n             </execution>\n         </executions>-->\n    </plugin>\n    <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>findbugs-maven-plugin</artifactId>\n        <version>2.5.2</version>\n        <configuration>\n            <onlyAnalyze>\n                cn.shenyanchao.package.*,\n                cn.shenyanchao.otherpackage.*,\n            </onlyAnalyze>\n            <includeFilterFile>findbugs.xml</includeFilterFile>\n            <failOnError>true</failOnError>\n            <outputEncoding>UTF-8</outputEncoding>\n        </configuration>\n     <!--   <executions>\n            <execution>\n                <phase>package</phase>\n                <goals>\n                    <goal>check</goal>\n                </goals>\n            </execution>\n        </executions>-->\n    </plugin>\n            \n这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。\n<!--more-->  \n#####那么能否指定只扫描特定的包或者文件呢？\n上面checkstyle用的是：  \n\n    <includes>\n        **\\/package\\/**.java,**\\/otherpackage\\/**.java\n    </includes>\n     \npmd是：    \n\n    <includes>\n        <include>**\\/package\\/**.java</include>\n        <include>**\\/otherpackage\\/**.java</include>\n    </includes>\n\nfindbugs则使用的是：\n     \n    <onlyAnalyze>\n        cn.shenyanchao.package.*,\n        cn.shenyanchao.otherpackage.*,\n    </onlyAnalyze>\n      \n   \n#####如何在编译期间或打包期间执行检查？\n\n如上所示的注释掉部分，添加就可以了：\n\n    <executions>\n         <execution>\n             <phase>package</phase>\n             <goals>\n                 <goal>check</goal>\n             </goals>\n         </execution>\n     </executions>\n这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。   \n\n\n","source":"_posts/2013-11-20-maven-project-integrate-checkstyle-pmd-findbugs.markdown","raw":"---\nlayout: post\ntitle: \"Maven项目集成CheckStyle,PMD,FindBugs进行静态代码扫描\"\ndate: 2013-11-20 19:22\ncomments: true\ncategories: maven\ntags: [ maven, checkstyle, pmd, findbugs, 静态代码扫描 ]\n---\n\n在pom.xml里添加以下maven插件配置：   \n\n        <!-- 静态代码检查 -->\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-checkstyle-plugin</artifactId>\n        <version>2.11</version>\n        <configuration>\n            <configLocation>checkstyle.xml</configLocation>\n            <includeResources>false</includeResources>\n            <failOnViolation>true</failOnViolation>\n            <violationSeverity>info</violationSeverity>\n            <maxAllowedViolations>0</maxAllowedViolations>\n            <consoleOutput>true</consoleOutput>\n            <encoding>UTF-8</encoding>\n            <includes>\n                **\\/package\\/**.java,**\\/otherpackage\\/**.java\n            </includes>\n        </configuration>\n    <!--     <executions>\n             <execution>\n                 <goals>\n                     <goal>check</goal>\n                 </goals>\n                 <phase>validate</phase>\n             </execution>\n         </executions>-->\n    </plugin>\n    \n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-pmd-plugin</artifactId>\n        <version>2.7.1</version>\n        <configuration>\n            <failurePriority>5</failurePriority>\n            <failOnViolation>true</failOnViolation>\n            <targetJdk>${jdk.version}</targetJdk>\n            <verbose>true</verbose>\n            <outputEncoding>UTF-8</outputEncoding>\n            <rulesets>\n                <ruleset>pmd.xml</ruleset>\n            </rulesets>\n            <includes>\n                <include>**\\/package\\/**.java</include>\n                <include>**\\/otherpackage\\/**.java</include>\n            </includes>\n        </configuration>\n      <!--   <executions>\n             <execution>\n                 <phase>package</phase>\n                 <goals>\n                     <goal>check</goal>\n                 </goals>\n             </execution>\n         </executions>-->\n    </plugin>\n    <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>findbugs-maven-plugin</artifactId>\n        <version>2.5.2</version>\n        <configuration>\n            <onlyAnalyze>\n                cn.shenyanchao.package.*,\n                cn.shenyanchao.otherpackage.*,\n            </onlyAnalyze>\n            <includeFilterFile>findbugs.xml</includeFilterFile>\n            <failOnError>true</failOnError>\n            <outputEncoding>UTF-8</outputEncoding>\n        </configuration>\n     <!--   <executions>\n            <execution>\n                <phase>package</phase>\n                <goals>\n                    <goal>check</goal>\n                </goals>\n            </execution>\n        </executions>-->\n    </plugin>\n            \n这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。\n<!--more-->  \n#####那么能否指定只扫描特定的包或者文件呢？\n上面checkstyle用的是：  \n\n    <includes>\n        **\\/package\\/**.java,**\\/otherpackage\\/**.java\n    </includes>\n     \npmd是：    \n\n    <includes>\n        <include>**\\/package\\/**.java</include>\n        <include>**\\/otherpackage\\/**.java</include>\n    </includes>\n\nfindbugs则使用的是：\n     \n    <onlyAnalyze>\n        cn.shenyanchao.package.*,\n        cn.shenyanchao.otherpackage.*,\n    </onlyAnalyze>\n      \n   \n#####如何在编译期间或打包期间执行检查？\n\n如上所示的注释掉部分，添加就可以了：\n\n    <executions>\n         <execution>\n             <phase>package</phase>\n             <goals>\n                 <goal>check</goal>\n             </goals>\n         </execution>\n     </executions>\n这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。   \n\n\n","slug":"2013-11-20-maven-project-integrate-checkstyle-pmd-findbugs","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6s007xv8fyebmufpb4","content":"<p>在pom.xml里添加以下maven插件配置：   </p>\n<pre><code>    &lt;!-- 静态代码检查 --&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.11&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;configLocation&gt;checkstyle.xml&lt;/configLocation&gt;\n        &lt;includeResources&gt;false&lt;/includeResources&gt;\n        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;\n        &lt;violationSeverity&gt;info&lt;/violationSeverity&gt;\n        &lt;maxAllowedViolations&gt;0&lt;/maxAllowedViolations&gt;\n        &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;\n        &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n        &lt;includes&gt;\n            **\\/package\\/**.java,**\\/otherpackage\\/**.java\n        &lt;/includes&gt;\n    &lt;/configuration&gt;\n&lt;!--     &lt;executions&gt;\n         &lt;execution&gt;\n             &lt;goals&gt;\n                 &lt;goal&gt;check&lt;/goal&gt;\n             &lt;/goals&gt;\n             &lt;phase&gt;validate&lt;/phase&gt;\n         &lt;/execution&gt;\n     &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.7.1&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;failurePriority&gt;5&lt;/failurePriority&gt;\n        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;\n        &lt;targetJdk&gt;${jdk.version}&lt;/targetJdk&gt;\n        &lt;verbose&gt;true&lt;/verbose&gt;\n        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;\n        &lt;rulesets&gt;\n            &lt;ruleset&gt;pmd.xml&lt;/ruleset&gt;\n        &lt;/rulesets&gt;\n        &lt;includes&gt;\n            &lt;include&gt;**\\/package\\/**.java&lt;/include&gt;\n            &lt;include&gt;**\\/otherpackage\\/**.java&lt;/include&gt;\n        &lt;/includes&gt;\n    &lt;/configuration&gt;\n  &lt;!--   &lt;executions&gt;\n         &lt;execution&gt;\n             &lt;phase&gt;package&lt;/phase&gt;\n             &lt;goals&gt;\n                 &lt;goal&gt;check&lt;/goal&gt;\n             &lt;/goals&gt;\n         &lt;/execution&gt;\n     &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n    &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.5.2&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;onlyAnalyze&gt;\n            cn.shenyanchao.package.*,\n            cn.shenyanchao.otherpackage.*,\n        &lt;/onlyAnalyze&gt;\n        &lt;includeFilterFile&gt;findbugs.xml&lt;/includeFilterFile&gt;\n        &lt;failOnError&gt;true&lt;/failOnError&gt;\n        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;\n    &lt;/configuration&gt;\n &lt;!--   &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;check&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n</code></pre><p>这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。<br><a id=\"more\"></a>  </p>\n<p>#####那么能否指定只扫描特定的包或者文件呢？<br>上面checkstyle用的是：  </p>\n<pre><code>&lt;includes&gt;\n    **\\/package\\/**.java,**\\/otherpackage\\/**.java\n&lt;/includes&gt;\n</code></pre><p>pmd是：    </p>\n<pre><code>&lt;includes&gt;\n    &lt;include&gt;**\\/package\\/**.java&lt;/include&gt;\n    &lt;include&gt;**\\/otherpackage\\/**.java&lt;/include&gt;\n&lt;/includes&gt;\n</code></pre><p>findbugs则使用的是：</p>\n<pre><code>&lt;onlyAnalyze&gt;\n    cn.shenyanchao.package.*,\n    cn.shenyanchao.otherpackage.*,\n&lt;/onlyAnalyze&gt;\n</code></pre><p>#####如何在编译期间或打包期间执行检查？</p>\n<p>如上所示的注释掉部分，添加就可以了：</p>\n<pre><code>&lt;executions&gt;\n     &lt;execution&gt;\n         &lt;phase&gt;package&lt;/phase&gt;\n         &lt;goals&gt;\n             &lt;goal&gt;check&lt;/goal&gt;\n         &lt;/goals&gt;\n     &lt;/execution&gt;\n &lt;/executions&gt;\n</code></pre><p>这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。   </p>\n","excerpt":"<p>在pom.xml里添加以下maven插件配置：   </p>\n<pre><code>    &lt;!-- 静态代码检查 --&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.11&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;configLocation&gt;checkstyle.xml&lt;/configLocation&gt;\n        &lt;includeResources&gt;false&lt;/includeResources&gt;\n        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;\n        &lt;violationSeverity&gt;info&lt;/violationSeverity&gt;\n        &lt;maxAllowedViolations&gt;0&lt;/maxAllowedViolations&gt;\n        &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;\n        &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n        &lt;includes&gt;\n            **\\/package\\/**.java,**\\/otherpackage\\/**.java\n        &lt;/includes&gt;\n    &lt;/configuration&gt;\n&lt;!--     &lt;executions&gt;\n         &lt;execution&gt;\n             &lt;goals&gt;\n                 &lt;goal&gt;check&lt;/goal&gt;\n             &lt;/goals&gt;\n             &lt;phase&gt;validate&lt;/phase&gt;\n         &lt;/execution&gt;\n     &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.7.1&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;failurePriority&gt;5&lt;/failurePriority&gt;\n        &lt;failOnViolation&gt;true&lt;/failOnViolation&gt;\n        &lt;targetJdk&gt;${jdk.version}&lt;/targetJdk&gt;\n        &lt;verbose&gt;true&lt;/verbose&gt;\n        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;\n        &lt;rulesets&gt;\n            &lt;ruleset&gt;pmd.xml&lt;/ruleset&gt;\n        &lt;/rulesets&gt;\n        &lt;includes&gt;\n            &lt;include&gt;**\\/package\\/**.java&lt;/include&gt;\n            &lt;include&gt;**\\/otherpackage\\/**.java&lt;/include&gt;\n        &lt;/includes&gt;\n    &lt;/configuration&gt;\n  &lt;!--   &lt;executions&gt;\n         &lt;execution&gt;\n             &lt;phase&gt;package&lt;/phase&gt;\n             &lt;goals&gt;\n                 &lt;goal&gt;check&lt;/goal&gt;\n             &lt;/goals&gt;\n         &lt;/execution&gt;\n     &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;\n    &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.5.2&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;onlyAnalyze&gt;\n            cn.shenyanchao.package.*,\n            cn.shenyanchao.otherpackage.*,\n        &lt;/onlyAnalyze&gt;\n        &lt;includeFilterFile&gt;findbugs.xml&lt;/includeFilterFile&gt;\n        &lt;failOnError&gt;true&lt;/failOnError&gt;\n        &lt;outputEncoding&gt;UTF-8&lt;/outputEncoding&gt;\n    &lt;/configuration&gt;\n &lt;!--   &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;check&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;--&gt;\n&lt;/plugin&gt;\n</code></pre><p>这些配置集成了checkstyle,pmd,findbugs的插件。并指明了要使用的规则集合（checkstyle.xml,pmd.xml,findbugs.xml）。<br>","more":"</p>\n<p>#####那么能否指定只扫描特定的包或者文件呢？<br>上面checkstyle用的是：  </p>\n<pre><code>&lt;includes&gt;\n    **\\/package\\/**.java,**\\/otherpackage\\/**.java\n&lt;/includes&gt;\n</code></pre><p>pmd是：    </p>\n<pre><code>&lt;includes&gt;\n    &lt;include&gt;**\\/package\\/**.java&lt;/include&gt;\n    &lt;include&gt;**\\/otherpackage\\/**.java&lt;/include&gt;\n&lt;/includes&gt;\n</code></pre><p>findbugs则使用的是：</p>\n<pre><code>&lt;onlyAnalyze&gt;\n    cn.shenyanchao.package.*,\n    cn.shenyanchao.otherpackage.*,\n&lt;/onlyAnalyze&gt;\n</code></pre><p>#####如何在编译期间或打包期间执行检查？</p>\n<p>如上所示的注释掉部分，添加就可以了：</p>\n<pre><code>&lt;executions&gt;\n     &lt;execution&gt;\n         &lt;phase&gt;package&lt;/phase&gt;\n         &lt;goals&gt;\n             &lt;goal&gt;check&lt;/goal&gt;\n         &lt;/goals&gt;\n     &lt;/execution&gt;\n &lt;/executions&gt;\n</code></pre><p>这里的意思是在mvn 执行打包package的时候进行check操作。因此如果check不通过，那么将不会编译打包成功。   </p>"},{"layout":"post","title":"SSH原理","date":"2013-11-26T08:04:00.000Z","comments":1,"_content":"###一、什么是SSH？\n简单说，SSH是一种网络协议，用于计算机之间的加密登录。   \n\n如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   \n\n最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   \n\n需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。    \n<!--more-->\n###二、最基本的用法\nSSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。   \n\n    $ ssh user@host\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。   \n\n    $ ssh host\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。    \n\n　　$ ssh -p 2222 user@host \n\n上面这条命令表示，ssh直接连接远程主机的2222端口。     \n###三、中间人攻击\nSSH之所以能够保证安全，原因在于它采用了公钥加密。   \n\n整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。    \n这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。    \n\n可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的\"中间人攻击\"（Man-in-the-middle attack）。   \nSSH协议是如何应对的呢？    \n###四、口令登录\n如果你是第一次登录对方主机，系统会出现下面的提示：   \n\n    $ ssh user@host\n    The authenticity of host 'host (12.18.429.21)' can't be established.\n    RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n    Are you sure you want to continue connecting (yes/no)?\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？    \n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。     \n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。     \n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。     \n\n    Are you sure you want to continue connecting (yes/no)? yes\n系统会出现一句提示，表示host主机已经得到认可。     \n\n    Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.\n然后，会要求输入密码。    \n\n    Password: (enter password)\n如果密码正确，就可以登录了。     \n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。     \n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。    \n###五、公钥登录\n使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。     \n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。     \n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： \n\n    $ ssh-keygen\n运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。    \n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。     \n这时再输入下面的命令，将公钥传送到远程主机host上面：  \n\n    $ ssh-copy-id user@host\n好了，从此你再登录，就不需要输入密码了。      \n如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面\"#\"注释是否取掉。      \n\n    RSAAuthentication yes\n    PubkeyAuthentication yes\n    AuthorizedKeysFile .ssh/authorized_keys\n然后，重启远程主机的ssh服务。    \n\n    // ubuntu系统\n    service ssh restart\n    // debian系统\n    /etc/init.d/ssh restart\n###六、authorized_keys文件\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。   \n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：   \n\n    $ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub     \n    \n这条命令由多个语句组成，依次分解开来看：   \n（1）`$ ssh user@host`，表示登录远程主机；   \n（2）单引号中的`mkdir .ssh && cat >> .ssh/authorized_keys`，表示登录后在远程shell上执行的命令：   \n（3）`$ mkdir -p .ssh`的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;     \n（4）`cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub`的作用是，将本地的公钥文件`~/.ssh/id_rsa.pub`，重定向追加到远程文件authorized_keys的末尾。      \n写入authorized_keys文件后，公钥登录的设置就完成了。     ","source":"_posts/2013-11-26-the-principle-of-ssh.markdown","raw":"---\nlayout: post\ntitle: \"SSH原理\"\ndate: 2013-11-26 16:04\ncomments: true\ncategories: linux\ntags: [ ssh, linux ]\n---\n###一、什么是SSH？\n简单说，SSH是一种网络协议，用于计算机之间的加密登录。   \n\n如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   \n\n最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   \n\n需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。    \n<!--more-->\n###二、最基本的用法\nSSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。   \n\n    $ ssh user@host\n\n如果本地用户名与远程用户名一致，登录时可以省略用户名。   \n\n    $ ssh host\n\nSSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。    \n\n　　$ ssh -p 2222 user@host \n\n上面这条命令表示，ssh直接连接远程主机的2222端口。     \n###三、中间人攻击\nSSH之所以能够保证安全，原因在于它采用了公钥加密。   \n\n整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。    \n这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。    \n\n可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的\"中间人攻击\"（Man-in-the-middle attack）。   \nSSH协议是如何应对的呢？    \n###四、口令登录\n如果你是第一次登录对方主机，系统会出现下面的提示：   \n\n    $ ssh user@host\n    The authenticity of host 'host (12.18.429.21)' can't be established.\n    RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n    Are you sure you want to continue connecting (yes/no)?\n\n这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？    \n所谓\"公钥指纹\"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。     \n很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。     \n假定经过风险衡量以后，用户决定接受这个远程主机的公钥。     \n\n    Are you sure you want to continue connecting (yes/no)? yes\n系统会出现一句提示，表示host主机已经得到认可。     \n\n    Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.\n然后，会要求输入密码。    \n\n    Password: (enter password)\n如果密码正确，就可以登录了。     \n当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。     \n每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。    \n###五、公钥登录\n使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。     \n所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。     \n这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： \n\n    $ ssh-keygen\n运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。    \n\n运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。     \n这时再输入下面的命令，将公钥传送到远程主机host上面：  \n\n    $ ssh-copy-id user@host\n好了，从此你再登录，就不需要输入密码了。      \n如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面\"#\"注释是否取掉。      \n\n    RSAAuthentication yes\n    PubkeyAuthentication yes\n    AuthorizedKeysFile .ssh/authorized_keys\n然后，重启远程主机的ssh服务。    \n\n    // ubuntu系统\n    service ssh restart\n    // debian系统\n    /etc/init.d/ssh restart\n###六、authorized_keys文件\n\n远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。   \n\n这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：   \n\n    $ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub     \n    \n这条命令由多个语句组成，依次分解开来看：   \n（1）`$ ssh user@host`，表示登录远程主机；   \n（2）单引号中的`mkdir .ssh && cat >> .ssh/authorized_keys`，表示登录后在远程shell上执行的命令：   \n（3）`$ mkdir -p .ssh`的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;     \n（4）`cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub`的作用是，将本地的公钥文件`~/.ssh/id_rsa.pub`，重定向追加到远程文件authorized_keys的末尾。      \n写入authorized_keys文件后，公钥登录的设置就完成了。     ","slug":"2013-11-26-the-principle-of-ssh","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6u0080v8fyxu8gz67l","content":"<p>###一、什么是SSH？<br>简单说，SSH是一种网络协议，用于计算机之间的加密登录。   </p>\n<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   </p>\n<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   </p>\n<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。<br><a id=\"more\"></a></p>\n<p>###二、最基本的用法<br>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。   </p>\n<pre><code>$ ssh user@host\n</code></pre><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。   </p>\n<pre><code>$ ssh host\n</code></pre><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。    </p>\n<p>　　$ ssh -p 2222 user@host </p>\n<p>上面这条命令表示，ssh直接连接远程主机的2222端口。     </p>\n<p>###三、中间人攻击<br>SSH之所以能够保证安全，原因在于它采用了公钥加密。   </p>\n<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。    </p>\n<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。<br>SSH协议是如何应对的呢？    </p>\n<p>###四、口令登录<br>如果你是第一次登录对方主机，系统会出现下面的提示：   </p>\n<pre><code>$ ssh user@host\nThe authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.\nRSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\nAre you sure you want to continue connecting (yes/no)?\n</code></pre><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。     </p>\n<pre><code>Are you sure you want to continue connecting (yes/no)? yes\n</code></pre><p>系统会出现一句提示，表示host主机已经得到认可。     </p>\n<pre><code>Warning: Permanently added &apos;host,12.18.429.21&apos; (RSA) to the list of known hosts.\n</code></pre><p>然后，会要求输入密码。    </p>\n<pre><code>Password: (enter password)\n</code></pre><p>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。    </p>\n<p>###五、公钥登录<br>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： </p>\n<pre><code>$ ssh-keygen\n</code></pre><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。    </p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：  </p>\n<pre><code>$ ssh-copy-id user@host\n</code></pre><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。      </p>\n<pre><code>RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n</code></pre><p>然后，重启远程主机的ssh服务。    </p>\n<pre><code>// ubuntu系统\nservice ssh restart\n// debian系统\n/etc/init.d/ssh restart\n</code></pre><p>###六、authorized_keys文件</p>\n<p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。   </p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：   </p>\n<pre><code>$ ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub     \n</code></pre><p>这条命令由多个语句组成，依次分解开来看：<br>（1）<code>$ ssh user@host</code>，表示登录远程主机；<br>（2）单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程shell上执行的命令：<br>（3）<code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;<br>（4）<code>cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。     </p>\n","excerpt":"<p>###一、什么是SSH？<br>简单说，SSH是一种网络协议，用于计算机之间的加密登录。   </p>\n<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。   </p>\n<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。   </p>\n<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。<br>","more":"</p>\n<p>###二、最基本的用法<br>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。   </p>\n<pre><code>$ ssh user@host\n</code></pre><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。   </p>\n<pre><code>$ ssh host\n</code></pre><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。    </p>\n<p>　　$ ssh -p 2222 user@host </p>\n<p>上面这条命令表示，ssh直接连接远程主机的2222端口。     </p>\n<p>###三、中间人攻击<br>SSH之所以能够保证安全，原因在于它采用了公钥加密。   </p>\n<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。    </p>\n<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。<br>SSH协议是如何应对的呢？    </p>\n<p>###四、口令登录<br>如果你是第一次登录对方主机，系统会出现下面的提示：   </p>\n<pre><code>$ ssh user@host\nThe authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.\nRSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\nAre you sure you want to continue connecting (yes/no)?\n</code></pre><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。     </p>\n<pre><code>Are you sure you want to continue connecting (yes/no)? yes\n</code></pre><p>系统会出现一句提示，表示host主机已经得到认可。     </p>\n<pre><code>Warning: Permanently added &apos;host,12.18.429.21&apos; (RSA) to the list of known hosts.\n</code></pre><p>然后，会要求输入密码。    </p>\n<pre><code>Password: (enter password)\n</code></pre><p>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。    </p>\n<p>###五、公钥登录<br>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： </p>\n<pre><code>$ ssh-keygen\n</code></pre><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。    </p>\n<p>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：  </p>\n<pre><code>$ ssh-copy-id user@host\n</code></pre><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。      </p>\n<pre><code>RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n</code></pre><p>然后，重启远程主机的ssh服务。    </p>\n<pre><code>// ubuntu系统\nservice ssh restart\n// debian系统\n/etc/init.d/ssh restart\n</code></pre><p>###六、authorized_keys文件</p>\n<p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。   </p>\n<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：   </p>\n<pre><code>$ ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub     \n</code></pre><p>这条命令由多个语句组成，依次分解开来看：<br>（1）<code>$ ssh user@host</code>，表示登录远程主机；<br>（2）单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程shell上执行的命令：<br>（3）<code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个;<br>（4）<code>cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。     </p>"},{"layout":"post","title":"《程序员修炼之道》读书笔记","date":"2013-12-04T07:45:00.000Z","comments":1,"_content":"《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。\n\n###关于心态\n####石头汤与煮青蛙\n>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  \n \n>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   \n     \n>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好.......” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。\n>几分钟后，村民们又问：“就这些了吗？”    \n\n>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    \n\n>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    \n\n>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   \n\n<!--more-->\n在石头汤的故事里有两层寓意。  \n\n士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。\n\n另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。   \n\n我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。    \n\n再来看两个案例。   \n\n>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。    \n\n>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！   \n\n锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。     \n\n当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。   \n\n作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。   \n\n###关于工具\n###文本编辑器\n文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：\n\n- 可配置\n- 可扩展\n- 可编程   \n\n一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。   \n知道了这些应该怎么做？   \n<table border=\"1px\">\n<tr>\n<th>如果你现在这样...</th><th>那么考虑...</th>\n</tr>\n<tr>\n<td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td>\n</tr>\n<tr>\n<td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td>\n</tr>\n<tr>\n<td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td>\n</tr>\n<tr>\n<td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td>\n</tr>\n</table>\n\n**推荐工具：**Emacs,vi,CRiSP,Brief以及其他的跨平台软件。    \n珍惜生命，远离office哦。\n\n####源码控制\n源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。\n\n把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。   \n\n###关于编码\n注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。\n\n适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。   \n\n- 不要试图在重构的同时增加功能\n- 在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。\n\n重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。","source":"_posts/2013-12-04-the-pragmatic-programmer-reading-notes.markdown","raw":"---\nlayout: post\ntitle: \"《程序员修炼之道》读书笔记\"\ndate: 2013-12-04 15:45\ncomments: true\ncategories: 开发\ntags: [ 读书笔记 ]\n---\n《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。\n\n###关于心态\n####石头汤与煮青蛙\n>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  \n \n>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   \n     \n>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好.......” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。\n>几分钟后，村民们又问：“就这些了吗？”    \n\n>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    \n\n>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    \n\n>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   \n\n<!--more-->\n在石头汤的故事里有两层寓意。  \n\n士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。\n\n另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。   \n\n我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。    \n\n再来看两个案例。   \n\n>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。    \n\n>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！   \n\n锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。     \n\n当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。   \n\n作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。   \n\n###关于工具\n###文本编辑器\n文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：\n\n- 可配置\n- 可扩展\n- 可编程   \n\n一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。   \n知道了这些应该怎么做？   \n<table border=\"1px\">\n<tr>\n<th>如果你现在这样...</th><th>那么考虑...</th>\n</tr>\n<tr>\n<td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td>\n</tr>\n<tr>\n<td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td>\n</tr>\n<tr>\n<td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td>\n</tr>\n<tr>\n<td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td>\n</tr>\n</table>\n\n**推荐工具：**Emacs,vi,CRiSP,Brief以及其他的跨平台软件。    \n珍惜生命，远离office哦。\n\n####源码控制\n源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。\n\n把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。   \n\n###关于编码\n注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。\n\n适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。   \n\n- 不要试图在重构的同时增加功能\n- 在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。\n\n重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。","slug":"2013-12-04-the-pragmatic-programmer-reading-notes","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6w0084v8fyuydtjwjo","content":"<p>《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。</p>\n<p>###关于心态</p>\n<p>####石头汤与煮青蛙</p>\n<blockquote>\n<p>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  </p>\n<p>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   </p>\n<p>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好…….” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。<br>几分钟后，村民们又问：“就这些了吗？”    </p>\n<p>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    </p>\n<p>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    </p>\n<p>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>在石头汤的故事里有两层寓意。  </p>\n<p>士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。</p>\n<p>另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。   </p>\n<p>我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。    </p>\n<p>再来看两个案例。   </p>\n<blockquote>\n<p>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。    </p>\n<p>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！   </p>\n</blockquote>\n<p>锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。     </p>\n<p>当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。   </p>\n<p>作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。   </p>\n<p>###关于工具</p>\n<p>###文本编辑器<br>文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：</p>\n<ul>\n<li>可配置</li>\n<li>可扩展</li>\n<li>可编程   </li>\n</ul>\n<p>一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。<br>知道了这些应该怎么做？   </p>\n<table border=\"1px\"><br><tr><br><th>如果你现在这样…</th><th>那么考虑…</th><br></tr><br><tr><br><td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td><br></tr><br><tr><br><td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td><br></tr><br></table>\n\n<p><strong>推荐工具：</strong>Emacs,vi,CRiSP,Brief以及其他的跨平台软件。<br>珍惜生命，远离office哦。</p>\n<p>####源码控制<br>源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。</p>\n<p>把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。   </p>\n<p>###关于编码<br>注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。</p>\n<p>适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。   </p>\n<ul>\n<li>不要试图在重构的同时增加功能</li>\n<li>在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。</li>\n</ul>\n<p>重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。</p>\n","excerpt":"<p>《程序员修炼之道-从小工到专家》写的具有普遍意义的指导方法。很少有具体的开发讲解，更多的是告诉你，作为一个程序员，你应该具有哪些素质，以及怎么做。下面是我对书中印象比较深的一些记录。</p>\n<p>###关于心态</p>\n<p>####石头汤与煮青蛙</p>\n<blockquote>\n<p>三个士兵从战场返回家乡，在路上饿了，他们看见前面有村庄，就来了精神(他们相信村民会给他们一顿饭吃)。但当他们到达那里，却发现门锁着，窗户也关着。经历了多年的战乱，村名们粮食匮乏，并把他们仅有的一点粮食藏了起来。  </p>\n<p>士兵们并没有气馁，他们煮开一锅水，小心地把三块石头放进去。吃惊的村民走出来望着他们。   </p>\n<p>“这是石头汤。”士兵们解释说。“就放这些吗？”村民们问。“一点也没错——但是有人说加一些胡萝卜味道更好…….” 一个村民跑开了，又很快带着他储藏的一篮胡萝卜跑回来。<br>几分钟后，村民们又问：“就这些了吗？”    </p>\n<p>“啊，”士兵们说：“几个土豆会让汤更实在。”又一个村民跑开了。    </p>\n<p>接下来的一小时，士兵们列举了更多让汤更鲜美的配料：牛肉，韭菜，盐，还有香菜。每一次都会有一个不同的村民跑回去搜寻自己的私人储藏品。    </p>\n<p>最后他们煮出了一大锅热气腾腾的汤。士兵们掉石头，和所有的村民一起享用了一顿美餐，这是几个月以来他们所有人第一次吃饱饭。   </p>\n</blockquote>","more":"<p>在石头汤的故事里有两层寓意。  </p>\n<p>士兵们戏弄了村民，他们利用村民的好奇，从他们那里弄到了食物。但更重要的是，士兵充当了催化剂，把村名团结起来，和他们一起做到了他们自己本来做不到的事情—— 一项协作的成果。最后每个人都是赢家。</p>\n<p>另一方面，石头汤的故事也是关于温和渐进的欺骗的故事。它讲述的是过于集中的注意力。村民们想到了石头，却忘记了世界的其余部分。我们都是这样，每一天,事情都会悄悄爬到我们身上。   </p>\n<p>我们现在是程序员，那你的目标是什么呢？当然是软件的总设计师—— 项目经理。那又会有什么启示呢？你常常是否也可以效仿这些士兵，做一个聪明的项目经理呢？在有些情况下，你也许确切的知道需要做什么，以及怎样去做。整个项目就在你的眼前，完全在你的掌控之中—— 你知道它是对的。但随着项目的深入，问题的复杂化，你会遇到拖延和漠然。这时你将会怎么做呢？你可以把项目看成是石头，把我们的成员看成是村民，而把我们自己看成是士兵。因为每个人都会保卫他们自己的资源。这正是拿出石头的时候。设计出你可以合理请求的东西，好好的开发它。一旦完成就拿给大家看，让他们大吃一惊。然后说：“要是我们增加…….可能就会更好。”然后假装那并不重要。坐回椅子上，等他们开始增加你本来就想增加的功能。这时大家就会发现参与正在发生的成功更容易。让他们去创造未来，你就会让他们聚集在你的周围，最大化的发挥团队的作用。    </p>\n<p>再来看两个案例。   </p>\n<blockquote>\n<p>如果你抓一只青蛙放进沸水里，他会一下子跳出来。但是你把青蛙放进冷水里，然后慢慢加热，青蛙不会注意到温度的缓慢变化，会呆在锅里，直到被煮熟。    </p>\n<p>一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！   </p>\n</blockquote>\n<p>锅里的那只可怜的青蛙是谁？它没有注意到周围环境的渐变，最终被煮熟了。同样的事情也会发生在不警醒的人身上。在项目开发高涨的热度里，很难再用一只眼睛注意中周围的环境。这又引出了一个“破窗户”的理论。一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑物周围的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，慢慢的更严重的结构破坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主想象的程度，也超出了业主愿意修理的程度，而废弃感则变成了现实！那我们如何解决呢？很简单，当第一扇破窗户出现时就及时的修理。     </p>\n<p>当然我们也看到过这样的症状。项目慢慢的不可改变的完全失去控制。大多数的软件灾难都是从微不足道的小事情开始的，大多数项目的拖延也都是一天一天发生的。系统一个特性一个特性地偏离其规范，项目的目标也慢慢的偏离轨道，直到整个项目的失败。常常是小事情的积累破坏了士气和团队，因为众所周知的困难是不会导致失败的，只有那些微不足道的小事才会导致失败。这些小事并不会立即显现出来，它只会在积累到一定程度时才会爆发。   </p>\n<p>作为整体开发的团队更容易被煮熟。所以未来的项目经理们，我们要时刻，持续地检查范围的扩大，时间的减缩，新增特性，新环境 ——任何不在初期的约定中定义的东西。因为团队无需拒绝不在预计中的变化—— 只要你注意到它们正在发生。记住，当出现第一扇破窗户时就及时修理。否则，你就会置身于热水之中。   </p>\n<p>###关于工具</p>\n<p>###文本编辑器<br>文本处理是每个程序员无法回避的问题。首先，要选择编辑器。一个好的编辑器应该具有以下的特性：</p>\n<ul>\n<li>可配置</li>\n<li>可扩展</li>\n<li>可编程   </li>\n</ul>\n<p>一旦你选择了一种编辑器，就彻底的了解它，并将其用于所有的编辑任务。如果你用一种编辑器进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵。编辑器将成为你双手的延伸。<br>知道了这些应该怎么做？   </p>\n<table border=\"1px\"><br><tr><br><th>如果你现在这样…</th><th>那么考虑…</th><br></tr><br><tr><br><td>我使用不同的编辑器，但只使用其基本特性。</td><td>选一种强大的编辑器，好好学习它。</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，但不使用其全部特性。</td><td>学习它们。减少你需要敲击的键数</td><br></tr><br><tr><br><td>我有最喜欢的编辑器，只要可能就使用它。</td><td>设法扩展它，并将其用于比现在更多的任务。</td><br></tr><br><tr><br><td>我认为你们在胡说。notepad就是有史以来最好的编辑器。</td><td>只要你愿意，并且生产率很高，那就这样吧！但如果你发现自己在羡慕别人的编辑器，你可能需要重新评估自己的位置啦。</td><br></tr><br></table>\n\n<p><strong>推荐工具：</strong>Emacs,vi,CRiSP,Brief以及其他的跨平台软件。<br>珍惜生命，远离office哦。</p>\n<p>####源码控制<br>源码控制系统追踪你在源码和文档中的每一项变动。并且能在适当的时候进行undo操作。</p>\n<p>把源码置于源码控制系统的保护之下具有一个很大，隐蔽的好处：可以进行自动的和可重复的产品持续集成构建。   </p>\n<p>###关于编码<br>注重时效的程序员批判的思考所有代码，包括自己写的。要相信从来没有完美的软件。不能靠运气和偶然的成功，而要深思熟虑的编程。并且要考虑算法的效率。</p>\n<p>适时的进行重构。Martin Fowler告诉我们如何进行利大于弊的重构。   </p>\n<ul>\n<li>不要试图在重构的同时增加功能</li>\n<li>在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快的知道。</li>\n</ul>\n<p>重构需要良好的测试代码。测试代码的存在要求代码有很好的可测性。</p>"},{"layout":"post","title":"ut-maven-plugin","date":"2013-12-14T13:31:00.000Z","comments":1,"_content":"###ut-maven-plugin简介\n\n这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。  \n《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。\n\n也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。\n<!--more-->\n###实现原理\n如何解析源码，这是首先需要解决的问题。在计算机科学中，有**抽象语法树(Abstract Syntax Tree)**这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。 \n  \nEclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。\n\n![](/images/blog/2013/eclipse-outline.png)\n\n同时,Eclipse也提供的有抽象语法树视图，即ASTView。\n\n![](/images/blog/2013/eclipse-ast-view.png)\n\n本插件选用[JavaParser](https://code.google.com/p/javaparser/)来分析源码，提取并生成测试代码。  \n\n###如何使用这个工具？\n这个插件一个被我放到了[Maven Central](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22)上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。   \n比如：  \n\n    <plugin>\n    <groupId>cn.shenyanchao.ut</groupId>\n    <artifactId>ut-maven-plugin</artifactId>\n    <version>0.2.9</version>\n    <executions>\n        <execution>\n            <id>source2test</id>\n            <phase>process-test-sources</phase>\n            <goals>\n                <goal>source2test</goal>\n            </goals>\n        </execution>\n    </executions>\n    </plugin>\n    \n###解决了什么问题？\n以[spring-petclinic](https://github.com/spring-projects/spring-petclinic)中的代码为例。\n\n下面的Service代码：  \n\n    package org.springframework.samples.petclinic.service;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.dao.DataAccessException;\n    import org.springframework.samples.petclinic.model.Pet;\n    import org.springframework.samples.petclinic.model.PetType;\n    import org.springframework.samples.petclinic.repository.PetRepository;\n    import org.springframework.stereotype.Service;\n    import org.springframework.transaction.annotation.Transactional;\n    \n    import java.util.Collection;\n\n    @Service\n    public class ClinicServiceImpl implements ClinicService {\n    \n        @Autowired\n        private PetRepository petRepository;\n        //省略\n        ......\n        \n        @Override\n        @Transactional(readOnly = true)\n        public Pet findPetById(int id) throws DataAccessException {\n            return petRepository.findById(id);\n        }\n        //省略\n        ......\n    \n    }\n\n那么，我们自己手工写的单元测试代码有可能是这样的：   \n\n    package org.springframework.samples.petclinic.service.test;\n    \n    import org.junit.Assert;\n    import org.junit.Before;\n    import org.junit.Test;\n    import org.mockito.InjectMocks;\n    import org.mockito.Mock;\n    import org.mockito.MockitoAnnotations;\n    import org.springframework.samples.petclinic.model.Pet;\n    import org.springframework.samples.petclinic.repository.PetRepository;\n    import org.springframework.samples.petclinic.service.ClinicServiceImpl;\n    \n    import static org.mockito.Matchers.anyInt;\n    import static org.mockito.Mockito.when;\n    \n    public class ClinicServiceImplTest {\n    \n        @InjectMocks\n        private ClinicServiceImpl clinicService = new ClinicServiceImpl();\n    \n        @Mock\n        private PetRepository petRepository;\n    \n        @Before\n        public void initMocks() {\n            MockitoAnnotations.initMocks(this);\n        }\n    \n        @Test\n        public void findPetByIdTest() {\n            when(petRepository.findById(anyInt())).thenReturn(new Pet());\n            Pet pet = clinicService.findPetById(1);\n            Assert.assertNotNull(pet);\n        }\n如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：  \n\n            when(petRepository.findById(anyInt())).thenReturn(new Pet());\n            Pet pet = clinicService.findPetById(1);\n因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。   \n\n当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。   \n\n","source":"_posts/2013-12-14-ut-maven-plugin.markdown","raw":"---\nlayout: post\ntitle: \"ut-maven-plugin\"\ndate: 2013-12-14 21:31\ncomments: true\ncategories: 测试\ntags: [ ut-maven-plugin, ast, javaparser ]\n---\n###ut-maven-plugin简介\n\n这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。  \n《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。\n\n也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。\n<!--more-->\n###实现原理\n如何解析源码，这是首先需要解决的问题。在计算机科学中，有**抽象语法树(Abstract Syntax Tree)**这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。 \n  \nEclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。\n\n![](/images/blog/2013/eclipse-outline.png)\n\n同时,Eclipse也提供的有抽象语法树视图，即ASTView。\n\n![](/images/blog/2013/eclipse-ast-view.png)\n\n本插件选用[JavaParser](https://code.google.com/p/javaparser/)来分析源码，提取并生成测试代码。  \n\n###如何使用这个工具？\n这个插件一个被我放到了[Maven Central](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22)上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。   \n比如：  \n\n    <plugin>\n    <groupId>cn.shenyanchao.ut</groupId>\n    <artifactId>ut-maven-plugin</artifactId>\n    <version>0.2.9</version>\n    <executions>\n        <execution>\n            <id>source2test</id>\n            <phase>process-test-sources</phase>\n            <goals>\n                <goal>source2test</goal>\n            </goals>\n        </execution>\n    </executions>\n    </plugin>\n    \n###解决了什么问题？\n以[spring-petclinic](https://github.com/spring-projects/spring-petclinic)中的代码为例。\n\n下面的Service代码：  \n\n    package org.springframework.samples.petclinic.service;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.dao.DataAccessException;\n    import org.springframework.samples.petclinic.model.Pet;\n    import org.springframework.samples.petclinic.model.PetType;\n    import org.springframework.samples.petclinic.repository.PetRepository;\n    import org.springframework.stereotype.Service;\n    import org.springframework.transaction.annotation.Transactional;\n    \n    import java.util.Collection;\n\n    @Service\n    public class ClinicServiceImpl implements ClinicService {\n    \n        @Autowired\n        private PetRepository petRepository;\n        //省略\n        ......\n        \n        @Override\n        @Transactional(readOnly = true)\n        public Pet findPetById(int id) throws DataAccessException {\n            return petRepository.findById(id);\n        }\n        //省略\n        ......\n    \n    }\n\n那么，我们自己手工写的单元测试代码有可能是这样的：   \n\n    package org.springframework.samples.petclinic.service.test;\n    \n    import org.junit.Assert;\n    import org.junit.Before;\n    import org.junit.Test;\n    import org.mockito.InjectMocks;\n    import org.mockito.Mock;\n    import org.mockito.MockitoAnnotations;\n    import org.springframework.samples.petclinic.model.Pet;\n    import org.springframework.samples.petclinic.repository.PetRepository;\n    import org.springframework.samples.petclinic.service.ClinicServiceImpl;\n    \n    import static org.mockito.Matchers.anyInt;\n    import static org.mockito.Mockito.when;\n    \n    public class ClinicServiceImplTest {\n    \n        @InjectMocks\n        private ClinicServiceImpl clinicService = new ClinicServiceImpl();\n    \n        @Mock\n        private PetRepository petRepository;\n    \n        @Before\n        public void initMocks() {\n            MockitoAnnotations.initMocks(this);\n        }\n    \n        @Test\n        public void findPetByIdTest() {\n            when(petRepository.findById(anyInt())).thenReturn(new Pet());\n            Pet pet = clinicService.findPetById(1);\n            Assert.assertNotNull(pet);\n        }\n如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：  \n\n            when(petRepository.findById(anyInt())).thenReturn(new Pet());\n            Pet pet = clinicService.findPetById(1);\n因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。   \n\n当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。   \n\n","slug":"2013-12-14-ut-maven-plugin","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6x0086v8fym70ezwgu","content":"<p>###ut-maven-plugin简介</p>\n<p>这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。<br>《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。</p>\n<p>也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。<br><a id=\"more\"></a></p>\n<p>###实现原理<br>如何解析源码，这是首先需要解决的问题。在计算机科学中，有<strong>抽象语法树(Abstract Syntax Tree)</strong>这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。 </p>\n<p>Eclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。</p>\n<p><img src=\"/images/blog/2013/eclipse-outline.png\" alt=\"\"></p>\n<p>同时,Eclipse也提供的有抽象语法树视图，即ASTView。</p>\n<p><img src=\"/images/blog/2013/eclipse-ast-view.png\" alt=\"\"></p>\n<p>本插件选用<a href=\"https://code.google.com/p/javaparser/\" target=\"_blank\" rel=\"external\">JavaParser</a>来分析源码，提取并生成测试代码。  </p>\n<p>###如何使用这个工具？<br>这个插件一个被我放到了<a href=\"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22\" target=\"_blank\" rel=\"external\">Maven Central</a>上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。<br>比如：  </p>\n<pre><code>&lt;plugin&gt;\n&lt;groupId&gt;cn.shenyanchao.ut&lt;/groupId&gt;\n&lt;artifactId&gt;ut-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;0.2.9&lt;/version&gt;\n&lt;executions&gt;\n    &lt;execution&gt;\n        &lt;id&gt;source2test&lt;/id&gt;\n        &lt;phase&gt;process-test-sources&lt;/phase&gt;\n        &lt;goals&gt;\n            &lt;goal&gt;source2test&lt;/goal&gt;\n        &lt;/goals&gt;\n    &lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>###解决了什么问题？<br>以<a href=\"https://github.com/spring-projects/spring-petclinic\" target=\"_blank\" rel=\"external\">spring-petclinic</a>中的代码为例。</p>\n<p>下面的Service代码：  </p>\n<pre><code>package org.springframework.samples.petclinic.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.samples.petclinic.model.Pet;\nimport org.springframework.samples.petclinic.model.PetType;\nimport org.springframework.samples.petclinic.repository.PetRepository;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Collection;\n\n@Service\npublic class ClinicServiceImpl implements ClinicService {\n\n    @Autowired\n    private PetRepository petRepository;\n    //省略\n    ......\n\n    @Override\n    @Transactional(readOnly = true)\n    public Pet findPetById(int id) throws DataAccessException {\n        return petRepository.findById(id);\n    }\n    //省略\n    ......\n\n}\n</code></pre><p>那么，我们自己手工写的单元测试代码有可能是这样的：   </p>\n<pre><code>package org.springframework.samples.petclinic.service.test;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.samples.petclinic.model.Pet;\nimport org.springframework.samples.petclinic.repository.PetRepository;\nimport org.springframework.samples.petclinic.service.ClinicServiceImpl;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.when;\n\npublic class ClinicServiceImplTest {\n\n    @InjectMocks\n    private ClinicServiceImpl clinicService = new ClinicServiceImpl();\n\n    @Mock\n    private PetRepository petRepository;\n\n    @Before\n    public void initMocks() {\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void findPetByIdTest() {\n        when(petRepository.findById(anyInt())).thenReturn(new Pet());\n        Pet pet = clinicService.findPetById(1);\n        Assert.assertNotNull(pet);\n    }\n</code></pre><p>如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：  </p>\n<pre><code>when(petRepository.findById(anyInt())).thenReturn(new Pet());\nPet pet = clinicService.findPetById(1);\n</code></pre><p>因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。   </p>\n<p>当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。   </p>\n","excerpt":"<p>###ut-maven-plugin简介</p>\n<p>这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。<br>《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。</p>\n<p>也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。<br>","more":"</p>\n<p>###实现原理<br>如何解析源码，这是首先需要解决的问题。在计算机科学中，有<strong>抽象语法树(Abstract Syntax Tree)</strong>这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。 </p>\n<p>Eclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。</p>\n<p><img src=\"/images/blog/2013/eclipse-outline.png\" alt=\"\"></p>\n<p>同时,Eclipse也提供的有抽象语法树视图，即ASTView。</p>\n<p><img src=\"/images/blog/2013/eclipse-ast-view.png\" alt=\"\"></p>\n<p>本插件选用<a href=\"https://code.google.com/p/javaparser/\">JavaParser</a>来分析源码，提取并生成测试代码。  </p>\n<p>###如何使用这个工具？<br>这个插件一个被我放到了<a href=\"http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22\">Maven Central</a>上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。<br>比如：  </p>\n<pre><code>&lt;plugin&gt;\n&lt;groupId&gt;cn.shenyanchao.ut&lt;/groupId&gt;\n&lt;artifactId&gt;ut-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;0.2.9&lt;/version&gt;\n&lt;executions&gt;\n    &lt;execution&gt;\n        &lt;id&gt;source2test&lt;/id&gt;\n        &lt;phase&gt;process-test-sources&lt;/phase&gt;\n        &lt;goals&gt;\n            &lt;goal&gt;source2test&lt;/goal&gt;\n        &lt;/goals&gt;\n    &lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>###解决了什么问题？<br>以<a href=\"https://github.com/spring-projects/spring-petclinic\">spring-petclinic</a>中的代码为例。</p>\n<p>下面的Service代码：  </p>\n<pre><code>package org.springframework.samples.petclinic.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.samples.petclinic.model.Pet;\nimport org.springframework.samples.petclinic.model.PetType;\nimport org.springframework.samples.petclinic.repository.PetRepository;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Collection;\n\n@Service\npublic class ClinicServiceImpl implements ClinicService {\n\n    @Autowired\n    private PetRepository petRepository;\n    //省略\n    ......\n\n    @Override\n    @Transactional(readOnly = true)\n    public Pet findPetById(int id) throws DataAccessException {\n        return petRepository.findById(id);\n    }\n    //省略\n    ......\n\n}\n</code></pre><p>那么，我们自己手工写的单元测试代码有可能是这样的：   </p>\n<pre><code>package org.springframework.samples.petclinic.service.test;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.samples.petclinic.model.Pet;\nimport org.springframework.samples.petclinic.repository.PetRepository;\nimport org.springframework.samples.petclinic.service.ClinicServiceImpl;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.when;\n\npublic class ClinicServiceImplTest {\n\n    @InjectMocks\n    private ClinicServiceImpl clinicService = new ClinicServiceImpl();\n\n    @Mock\n    private PetRepository petRepository;\n\n    @Before\n    public void initMocks() {\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void findPetByIdTest() {\n        when(petRepository.findById(anyInt())).thenReturn(new Pet());\n        Pet pet = clinicService.findPetById(1);\n        Assert.assertNotNull(pet);\n    }\n</code></pre><p>如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：  </p>\n<pre><code>when(petRepository.findById(anyInt())).thenReturn(new Pet());\nPet pet = clinicService.findPetById(1);\n</code></pre><p>因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。   </p>\n<p>当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。   </p>"},{"layout":"post","title":"又见Java乱码","date":"2014-03-27T13:43:00.000Z","comments":1,"_content":"###dom4j解析xml\n\ndom4j提供了一个`DocumentHelper`来解析xml内容，此处的内容是String类型的。下面是其源码：  \n\n        public static Document parseText(String text) throws DocumentException {\n            Document result = null;\n    \n            SAXReader reader = new SAXReader();\n            String encoding = getEncoding(text);\n    \n            InputSource source = new InputSource(new StringReader(text));\n            source.setEncoding(encoding);\n    \n            result = reader.read(source);\n    \n            // if the XML parser doesn't provide a way to retrieve the encoding,\n            // specify it manually\n            if (result.getXMLEncoding() == null) {\n                result.setXMLEncoding(encoding);\n            }\n    \n            return result;\n        }\n        \n        private static String getEncoding(String text) {\n            String result = null;\n    \n            String xml = text.trim();\n    \n            if (xml.startsWith(\"<?xml\")) {\n                int end = xml.indexOf(\"?>\");\n                String sub = xml.substring(0, end);\n                StringTokenizer tokens = new StringTokenizer(sub, \" =\\\"\\'\");\n    \n                while (tokens.hasMoreTokens()) {\n                    String token = tokens.nextToken();\n    \n                    if (\"encoding\".equals(token)) {\n                        if (tokens.hasMoreTokens()) {\n                            result = tokens.nextToken();\n                        }\n    \n                        break;\n                    }\n                }\n            }\n    \n            return result;\n        }\n        \n从以上的代码中可以看出，解析过程中是使用XML的头`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`来获取编码信息的。\n<!--more-->\n###如何读取文件到String\n\n        public String loadXmlRule() {\n            InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"file.xml\");\n            String xmlContent = null;\n            try {\n                xmlContent = IOUtils.toString(inputStream);\n            } catch (IOException e) {\n                LOG.error(\"read xml:{} io error\", e);\n            } finally {\n                IOUtils.closeQuietly(inputStream);\n            }\n            return xmlContent;\n        }\n\n[getResourceAsStream将文件读为字节流](<http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as>)，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。\n\n    xmlContent = IOUtils.toString(inputStream);\n    \n    转换为：\n    \n    xmlContent = IOUtils.toString(inputStream，\"UTF-8);//假设文件是UTF-8\n    \n由此，一定要慎重使用编码。**永远不要相信默认编码**。\n\n###Jenkins/Hudson中shell command的编码\n\n遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。","source":"_posts/2014-03-27-java-encode-error-again.markdown","raw":"---\nlayout: post\ntitle: \"又见Java乱码\"\ndate: 2014-03-27 21:43\ncomments: true\ncategories: encode\ntags: [ dom4j, jenkins, java, 编码 ]\n---\n###dom4j解析xml\n\ndom4j提供了一个`DocumentHelper`来解析xml内容，此处的内容是String类型的。下面是其源码：  \n\n        public static Document parseText(String text) throws DocumentException {\n            Document result = null;\n    \n            SAXReader reader = new SAXReader();\n            String encoding = getEncoding(text);\n    \n            InputSource source = new InputSource(new StringReader(text));\n            source.setEncoding(encoding);\n    \n            result = reader.read(source);\n    \n            // if the XML parser doesn't provide a way to retrieve the encoding,\n            // specify it manually\n            if (result.getXMLEncoding() == null) {\n                result.setXMLEncoding(encoding);\n            }\n    \n            return result;\n        }\n        \n        private static String getEncoding(String text) {\n            String result = null;\n    \n            String xml = text.trim();\n    \n            if (xml.startsWith(\"<?xml\")) {\n                int end = xml.indexOf(\"?>\");\n                String sub = xml.substring(0, end);\n                StringTokenizer tokens = new StringTokenizer(sub, \" =\\\"\\'\");\n    \n                while (tokens.hasMoreTokens()) {\n                    String token = tokens.nextToken();\n    \n                    if (\"encoding\".equals(token)) {\n                        if (tokens.hasMoreTokens()) {\n                            result = tokens.nextToken();\n                        }\n    \n                        break;\n                    }\n                }\n            }\n    \n            return result;\n        }\n        \n从以上的代码中可以看出，解析过程中是使用XML的头`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`来获取编码信息的。\n<!--more-->\n###如何读取文件到String\n\n        public String loadXmlRule() {\n            InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"file.xml\");\n            String xmlContent = null;\n            try {\n                xmlContent = IOUtils.toString(inputStream);\n            } catch (IOException e) {\n                LOG.error(\"read xml:{} io error\", e);\n            } finally {\n                IOUtils.closeQuietly(inputStream);\n            }\n            return xmlContent;\n        }\n\n[getResourceAsStream将文件读为字节流](<http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as>)，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。\n\n    xmlContent = IOUtils.toString(inputStream);\n    \n    转换为：\n    \n    xmlContent = IOUtils.toString(inputStream，\"UTF-8);//假设文件是UTF-8\n    \n由此，一定要慎重使用编码。**永远不要相信默认编码**。\n\n###Jenkins/Hudson中shell command的编码\n\n遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。","slug":"2014-03-27-java-encode-error-again","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop6z008av8fyihmw6sam","content":"<p>###dom4j解析xml</p>\n<p>dom4j提供了一个<code>DocumentHelper</code>来解析xml内容，此处的内容是String类型的。下面是其源码：  </p>\n<pre><code>public static Document parseText(String text) throws DocumentException {\n    Document result = null;\n\n    SAXReader reader = new SAXReader();\n    String encoding = getEncoding(text);\n\n    InputSource source = new InputSource(new StringReader(text));\n    source.setEncoding(encoding);\n\n    result = reader.read(source);\n\n    // if the XML parser doesn&apos;t provide a way to retrieve the encoding,\n    // specify it manually\n    if (result.getXMLEncoding() == null) {\n        result.setXMLEncoding(encoding);\n    }\n\n    return result;\n}\n\nprivate static String getEncoding(String text) {\n    String result = null;\n\n    String xml = text.trim();\n\n    if (xml.startsWith(&quot;&lt;?xml&quot;)) {\n        int end = xml.indexOf(&quot;?&gt;&quot;);\n        String sub = xml.substring(0, end);\n        StringTokenizer tokens = new StringTokenizer(sub, &quot; =\\&quot;\\&apos;&quot;);\n\n        while (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\n            if (&quot;encoding&quot;.equals(token)) {\n                if (tokens.hasMoreTokens()) {\n                    result = tokens.nextToken();\n                }\n\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n</code></pre><p>从以上的代码中可以看出，解析过程中是使用XML的头<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>来获取编码信息的。<br><a id=\"more\"></a></p>\n<p>###如何读取文件到String</p>\n<pre><code>public String loadXmlRule() {\n    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;file.xml&quot;);\n    String xmlContent = null;\n    try {\n        xmlContent = IOUtils.toString(inputStream);\n    } catch (IOException e) {\n        LOG.error(&quot;read xml:{} io error&quot;, e);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n    }\n    return xmlContent;\n}\n</code></pre><p><a href=\"http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as\" target=\"_blank\" rel=\"external\">getResourceAsStream将文件读为字节流</a>，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。</p>\n<pre><code>xmlContent = IOUtils.toString(inputStream);\n\n转换为：\n\nxmlContent = IOUtils.toString(inputStream，&quot;UTF-8);//假设文件是UTF-8\n</code></pre><p>由此，一定要慎重使用编码。<strong>永远不要相信默认编码</strong>。</p>\n<p>###Jenkins/Hudson中shell command的编码</p>\n<p>遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。</p>\n","excerpt":"<p>###dom4j解析xml</p>\n<p>dom4j提供了一个<code>DocumentHelper</code>来解析xml内容，此处的内容是String类型的。下面是其源码：  </p>\n<pre><code>public static Document parseText(String text) throws DocumentException {\n    Document result = null;\n\n    SAXReader reader = new SAXReader();\n    String encoding = getEncoding(text);\n\n    InputSource source = new InputSource(new StringReader(text));\n    source.setEncoding(encoding);\n\n    result = reader.read(source);\n\n    // if the XML parser doesn&apos;t provide a way to retrieve the encoding,\n    // specify it manually\n    if (result.getXMLEncoding() == null) {\n        result.setXMLEncoding(encoding);\n    }\n\n    return result;\n}\n\nprivate static String getEncoding(String text) {\n    String result = null;\n\n    String xml = text.trim();\n\n    if (xml.startsWith(&quot;&lt;?xml&quot;)) {\n        int end = xml.indexOf(&quot;?&gt;&quot;);\n        String sub = xml.substring(0, end);\n        StringTokenizer tokens = new StringTokenizer(sub, &quot; =\\&quot;\\&apos;&quot;);\n\n        while (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\n            if (&quot;encoding&quot;.equals(token)) {\n                if (tokens.hasMoreTokens()) {\n                    result = tokens.nextToken();\n                }\n\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n</code></pre><p>从以上的代码中可以看出，解析过程中是使用XML的头<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>来获取编码信息的。<br>","more":"</p>\n<p>###如何读取文件到String</p>\n<pre><code>public String loadXmlRule() {\n    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;file.xml&quot;);\n    String xmlContent = null;\n    try {\n        xmlContent = IOUtils.toString(inputStream);\n    } catch (IOException e) {\n        LOG.error(&quot;read xml:{} io error&quot;, e);\n    } finally {\n        IOUtils.closeQuietly(inputStream);\n    }\n    return xmlContent;\n}\n</code></pre><p><a href=\"http://stackoverflow.com/questions/5590451/getresourceasstream-what-encoding-is-it-read-as\">getResourceAsStream将文件读为字节流</a>，不牵涉到字符编码问题。但是当你把这个inputStream转为String的时候，就需要指定字符编码了。否则不知道按什么编码规则解析字节流到字符。不知道什么编码的情况下，程序可能就会从系统变量取默认的字符编码，也就是LANG值。这个时候在LINUX，WINDOWS下表现的可能就不一致。因此必须显式的指明编码。</p>\n<pre><code>xmlContent = IOUtils.toString(inputStream);\n\n转换为：\n\nxmlContent = IOUtils.toString(inputStream，&quot;UTF-8);//假设文件是UTF-8\n</code></pre><p>由此，一定要慎重使用编码。<strong>永远不要相信默认编码</strong>。</p>\n<p>###Jenkins/Hudson中shell command的编码</p>\n<p>遇到这样的情况，在jenkins的机器上直接执行shell命令，与在jenkins job中执行shell的默认编码是不一样的。机器上直接执行默认从环境变量里取的，但是jenkins job的编码是走的jenkins node上的默认编码配置。为了防止出现类似的问题，可以在jenkins job中提前指定特定的编码。</p>"},{"layout":"post","title":"使用 jXLS导出报表","date":"2014-06-24T07:17:00.000Z","comments":1,"_content":"###常用的excel操作工具\n\n- Apache POI\n- jexcelApi\n\n它们都提供了完善的API来支持EXCEL的读写。\n\n###jXLS是什么？\n\njXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。\n\njXLS的基本功能：\n\n- 支持Excel 95-2000的所有版本\n- 生成Excel 2000标准格式\n- 支持字体、数字、日期操作\n- 能够修饰单元格属性\n- 支持图像和图表\n\n        <dependency>\n               <groupId>net.sf.jxls</groupId>\n               <artifactId>jxls-core</artifactId>\n               <version>1.0.5</version>\n        </dependency>\n        \n<!--more-->\njXLS的API也很简单：\n\n                Map beans = new HashMap();\n                beans.put(\"department\", department);\n                XLSTransformer transformer = new XLSTransformer();\n                transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);\n###jXLS是如何解析模板生成数据的？\n\n查看`net.sf.jxls.transformer.CellTransformer`可以看到：\n\n    Object value = ((Expression) cell.getExpressions().get(0)).evaluate();\n而evaluate()方法如下：\n\n    public Object evaluate() throws Exception {\n        if (beans != null && !beans.isEmpty()) {\n            JexlContext context = new MapContext(beans);\n            Object ret = jexlExpresssion.evaluate(context);\n            if (aggregateFunction != null) {\n                return calculateAggregate(aggregateFunction, aggregateField, ret);\n            }\n            return ret;\n        }\n        return expression;\n    }\n从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。\n\n###让jXLS支持hyperlink\n\n业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：\n\n        if (cell.getStringCellValue().toLowerCase().startsWith(\"${href}\") && cell.getExpressions().size() == 3){\n               //是链接类型的cell\n               HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();\n               Expression valueExpr = (Expression)cell.getExpressions().get(1);\n               Expression linkExpr = (Expression)cell.getExpressions().get(2);\n               hssfCell.setCellValue((String)valueExpr.evaluate());\n               Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);\n               link.setAddress((String)linkExpr.evaluate());\n               hssfCell.setHyperlink(link);\n               cell.setPoiCell(hssfCell);\n            }\n当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。","source":"_posts/2014-06-24-export-excel-by-jxls.markdown","raw":"---\nlayout: post\ntitle: \"使用 jXLS导出报表\"\ndate: 2014-06-24 15:17\ncomments: true\ncategories: Java\ntags: [ apache poi, excel, jXLS, jxl ]\n---\n###常用的excel操作工具\n\n- Apache POI\n- jexcelApi\n\n它们都提供了完善的API来支持EXCEL的读写。\n\n###jXLS是什么？\n\njXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。\n\njXLS的基本功能：\n\n- 支持Excel 95-2000的所有版本\n- 生成Excel 2000标准格式\n- 支持字体、数字、日期操作\n- 能够修饰单元格属性\n- 支持图像和图表\n\n        <dependency>\n               <groupId>net.sf.jxls</groupId>\n               <artifactId>jxls-core</artifactId>\n               <version>1.0.5</version>\n        </dependency>\n        \n<!--more-->\njXLS的API也很简单：\n\n                Map beans = new HashMap();\n                beans.put(\"department\", department);\n                XLSTransformer transformer = new XLSTransformer();\n                transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);\n###jXLS是如何解析模板生成数据的？\n\n查看`net.sf.jxls.transformer.CellTransformer`可以看到：\n\n    Object value = ((Expression) cell.getExpressions().get(0)).evaluate();\n而evaluate()方法如下：\n\n    public Object evaluate() throws Exception {\n        if (beans != null && !beans.isEmpty()) {\n            JexlContext context = new MapContext(beans);\n            Object ret = jexlExpresssion.evaluate(context);\n            if (aggregateFunction != null) {\n                return calculateAggregate(aggregateFunction, aggregateField, ret);\n            }\n            return ret;\n        }\n        return expression;\n    }\n从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。\n\n###让jXLS支持hyperlink\n\n业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：\n\n        if (cell.getStringCellValue().toLowerCase().startsWith(\"${href}\") && cell.getExpressions().size() == 3){\n               //是链接类型的cell\n               HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();\n               Expression valueExpr = (Expression)cell.getExpressions().get(1);\n               Expression linkExpr = (Expression)cell.getExpressions().get(2);\n               hssfCell.setCellValue((String)valueExpr.evaluate());\n               Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);\n               link.setAddress((String)linkExpr.evaluate());\n               hssfCell.setHyperlink(link);\n               cell.setPoiCell(hssfCell);\n            }\n当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。","slug":"2014-06-24-export-excel-by-jxls","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop70008dv8fyktivah25","content":"<p>###常用的excel操作工具</p>\n<ul>\n<li>Apache POI</li>\n<li>jexcelApi</li>\n</ul>\n<p>它们都提供了完善的API来支持EXCEL的读写。</p>\n<p>###jXLS是什么？</p>\n<p>jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>\n<p>jXLS的基本功能：</p>\n<ul>\n<li>支持Excel 95-2000的所有版本</li>\n<li>生成Excel 2000标准格式</li>\n<li>支持字体、数字、日期操作</li>\n<li>能够修饰单元格属性</li>\n<li><p>支持图像和图表</p>\n<pre><code>&lt;dependency&gt;\n       &lt;groupId&gt;net.sf.jxls&lt;/groupId&gt;\n       &lt;artifactId&gt;jxls-core&lt;/artifactId&gt;\n       &lt;version&gt;1.0.5&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></li>\n</ul>\n<a id=\"more\"></a>\n<p>jXLS的API也很简单：</p>\n<pre><code>Map beans = new HashMap();\nbeans.put(&quot;department&quot;, department);\nXLSTransformer transformer = new XLSTransformer();\ntransformer.transformXLS(xlsTemplateFileName, beans, outputFileName);\n</code></pre><p>###jXLS是如何解析模板生成数据的？</p>\n<p>查看<code>net.sf.jxls.transformer.CellTransformer</code>可以看到：</p>\n<pre><code>Object value = ((Expression) cell.getExpressions().get(0)).evaluate();\n</code></pre><p>而evaluate()方法如下：</p>\n<pre><code>public Object evaluate() throws Exception {\n    if (beans != null &amp;&amp; !beans.isEmpty()) {\n        JexlContext context = new MapContext(beans);\n        Object ret = jexlExpresssion.evaluate(context);\n        if (aggregateFunction != null) {\n            return calculateAggregate(aggregateFunction, aggregateField, ret);\n        }\n        return ret;\n    }\n    return expression;\n}\n</code></pre><p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>\n<p>###让jXLS支持hyperlink</p>\n<p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>\n<pre><code>if (cell.getStringCellValue().toLowerCase().startsWith(&quot;${href}&quot;) &amp;&amp; cell.getExpressions().size() == 3){\n       //是链接类型的cell\n       HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();\n       Expression valueExpr = (Expression)cell.getExpressions().get(1);\n       Expression linkExpr = (Expression)cell.getExpressions().get(2);\n       hssfCell.setCellValue((String)valueExpr.evaluate());\n       Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);\n       link.setAddress((String)linkExpr.evaluate());\n       hssfCell.setHyperlink(link);\n       cell.setPoiCell(hssfCell);\n    }\n</code></pre><p>当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>\n","excerpt":"<p>###常用的excel操作工具</p>\n<ul>\n<li>Apache POI</li>\n<li>jexcelApi</li>\n</ul>\n<p>它们都提供了完善的API来支持EXCEL的读写。</p>\n<p>###jXLS是什么？</p>\n<p>jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>\n<p>jXLS的基本功能：</p>\n<ul>\n<li>支持Excel 95-2000的所有版本</li>\n<li>生成Excel 2000标准格式</li>\n<li>支持字体、数字、日期操作</li>\n<li>能够修饰单元格属性</li>\n<li><p>支持图像和图表</p>\n<pre><code>&lt;dependency&gt;\n       &lt;groupId&gt;net.sf.jxls&lt;/groupId&gt;\n       &lt;artifactId&gt;jxls-core&lt;/artifactId&gt;\n       &lt;version&gt;1.0.5&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></li>\n</ul>","more":"<p>jXLS的API也很简单：</p>\n<pre><code>Map beans = new HashMap();\nbeans.put(&quot;department&quot;, department);\nXLSTransformer transformer = new XLSTransformer();\ntransformer.transformXLS(xlsTemplateFileName, beans, outputFileName);\n</code></pre><p>###jXLS是如何解析模板生成数据的？</p>\n<p>查看<code>net.sf.jxls.transformer.CellTransformer</code>可以看到：</p>\n<pre><code>Object value = ((Expression) cell.getExpressions().get(0)).evaluate();\n</code></pre><p>而evaluate()方法如下：</p>\n<pre><code>public Object evaluate() throws Exception {\n    if (beans != null &amp;&amp; !beans.isEmpty()) {\n        JexlContext context = new MapContext(beans);\n        Object ret = jexlExpresssion.evaluate(context);\n        if (aggregateFunction != null) {\n            return calculateAggregate(aggregateFunction, aggregateField, ret);\n        }\n        return ret;\n    }\n    return expression;\n}\n</code></pre><p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>\n<p>###让jXLS支持hyperlink</p>\n<p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>\n<pre><code>if (cell.getStringCellValue().toLowerCase().startsWith(&quot;${href}&quot;) &amp;&amp; cell.getExpressions().size() == 3){\n       //是链接类型的cell\n       HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();\n       Expression valueExpr = (Expression)cell.getExpressions().get(1);\n       Expression linkExpr = (Expression)cell.getExpressions().get(2);\n       hssfCell.setCellValue((String)valueExpr.evaluate());\n       Hyperlink link = new HSSFHyperlink(Hyperlink.LINK_URL);\n       link.setAddress((String)linkExpr.evaluate());\n       hssfCell.setHyperlink(link);\n       cell.setPoiCell(hssfCell);\n    }\n</code></pre><p>当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>"},{"layout":"post","title":"Velocity学习小结","date":"2014-03-31T08:24:00.000Z","comments":1,"_content":"\n###velocity在spring项目中的使用\n本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。\n首先，可以交给Spring来初始化velocityEngine:\n\n    <bean id=\"velocityEngine\" class=\"org.springframework.ui.velocity.VelocityEngineFactoryBean\">\n        <property name=\"configLocation\">\n            <value>classpath:velocity.properties</value>\n        </property>\n        <property name=\"resourceLoaderPath\">\n            <value>/WEB-INF/velocity/</value>\n        </property>\n    </bean>\n\n其中的`configLocation`指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：   \n    \n    resource.loader  =  file\n    \n    file.resource.loader.description =  Velocity  File Resource Loader\n    file.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader\n    file.resource.loader.cache =  true\n    file.resource.loader.modificationCheckInterval =  100\n    \n    input.encoding = utf-8\n    output.encoding = utf-8\n\n需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：\n\n- spring增强了file加载的能力，推荐使用`resourceLoaderPath`来指明路径，而不是交给`file.resource.loader.path`进行处理。如果使用这个可能会跑NullPointerException；\n- class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。\n\n\n###关于Velocity使用的坑\n\n- 关于减号（-）的问题\n>请注意下面的2中写法    \n`#set($maxIndex=$DOC_COUNT-1)`报错    \n`#set($maxIndex=$DOC_COUNT - 1)`正确，区别仅在于-两侧的空格\n\n- 关于Range类型的问题\n>`#set($array = [0..$maxIndex])` 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样`#set($array = [0..$maxIndex+1])`也是错误的。\n\n\n\n","source":"_posts/2014-03-31-velocity-study-summary.markdown","raw":"---\nlayout: post\ntitle: \"Velocity学习小结\"\ndate: 2014-03-31 16:24\ncomments: true\ncategories: velocity\ntags: [ velocity, spring ]\n---\n\n###velocity在spring项目中的使用\n本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。\n首先，可以交给Spring来初始化velocityEngine:\n\n    <bean id=\"velocityEngine\" class=\"org.springframework.ui.velocity.VelocityEngineFactoryBean\">\n        <property name=\"configLocation\">\n            <value>classpath:velocity.properties</value>\n        </property>\n        <property name=\"resourceLoaderPath\">\n            <value>/WEB-INF/velocity/</value>\n        </property>\n    </bean>\n\n其中的`configLocation`指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：   \n    \n    resource.loader  =  file\n    \n    file.resource.loader.description =  Velocity  File Resource Loader\n    file.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader\n    file.resource.loader.cache =  true\n    file.resource.loader.modificationCheckInterval =  100\n    \n    input.encoding = utf-8\n    output.encoding = utf-8\n\n需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：\n\n- spring增强了file加载的能力，推荐使用`resourceLoaderPath`来指明路径，而不是交给`file.resource.loader.path`进行处理。如果使用这个可能会跑NullPointerException；\n- class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。\n\n\n###关于Velocity使用的坑\n\n- 关于减号（-）的问题\n>请注意下面的2中写法    \n`#set($maxIndex=$DOC_COUNT-1)`报错    \n`#set($maxIndex=$DOC_COUNT - 1)`正确，区别仅在于-两侧的空格\n\n- 关于Range类型的问题\n>`#set($array = [0..$maxIndex])` 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样`#set($array = [0..$maxIndex+1])`也是错误的。\n\n\n\n","slug":"2014-03-31-velocity-study-summary","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop72008iv8fydxaqx2yl","content":"<p>###velocity在spring项目中的使用<br>本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。<br>首先，可以交给Spring来初始化velocityEngine:</p>\n<pre><code>&lt;bean id=&quot;velocityEngine&quot; class=&quot;org.springframework.ui.velocity.VelocityEngineFactoryBean&quot;&gt;\n    &lt;property name=&quot;configLocation&quot;&gt;\n        &lt;value&gt;classpath:velocity.properties&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;resourceLoaderPath&quot;&gt;\n        &lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>其中的<code>configLocation</code>指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：   </p>\n<pre><code>resource.loader  =  file\n\nfile.resource.loader.description =  Velocity  File Resource Loader\nfile.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader\nfile.resource.loader.cache =  true\nfile.resource.loader.modificationCheckInterval =  100\n\ninput.encoding = utf-8\noutput.encoding = utf-8\n</code></pre><p>需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：</p>\n<ul>\n<li>spring增强了file加载的能力，推荐使用<code>resourceLoaderPath</code>来指明路径，而不是交给<code>file.resource.loader.path</code>进行处理。如果使用这个可能会跑NullPointerException；</li>\n<li>class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。</li>\n</ul>\n<p>###关于Velocity使用的坑</p>\n<ul>\n<li><p>关于减号（-）的问题</p>\n<blockquote>\n<p>请注意下面的2中写法<br><code>#set($maxIndex=$DOC_COUNT-1)</code>报错<br><code>#set($maxIndex=$DOC_COUNT - 1)</code>正确，区别仅在于-两侧的空格</p>\n</blockquote>\n</li>\n<li><p>关于Range类型的问题</p>\n<blockquote>\n<p><code>#set($array = [0..$maxIndex])</code> 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样<code>#set($array = [0..$maxIndex+1])</code>也是错误的。</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<p>###velocity在spring项目中的使用<br>本文，不是讲velocityResolver来渲染页面的只从最原始的使用方式如何使用。<br>首先，可以交给Spring来初始化velocityEngine:</p>\n<pre><code>&lt;bean id=&quot;velocityEngine&quot; class=&quot;org.springframework.ui.velocity.VelocityEngineFactoryBean&quot;&gt;\n    &lt;property name=&quot;configLocation&quot;&gt;\n        &lt;value&gt;classpath:velocity.properties&lt;/value&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;resourceLoaderPath&quot;&gt;\n        &lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>其中的<code>configLocation</code>指明了velocity的配置文件路径。也就是说一些个性化的配置都可以直接在velocity.properties进行操作了。比如下面的例子：   </p>\n<pre><code>resource.loader  =  file\n\nfile.resource.loader.description =  Velocity  File Resource Loader\nfile.resource.loader.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader\nfile.resource.loader.cache =  true\nfile.resource.loader.modificationCheckInterval =  100\n\ninput.encoding = utf-8\noutput.encoding = utf-8\n</code></pre><p>需要注意的是，resource.loader可能有多种选择，最常用的是file，class.当然也有webapp,jar等类型。file要求指明具体的路径，而在WEB应用里这块常常就会出现问题。因此，我们倾向于认为从classpath来加载模板。但是，为什么此处仍然推荐使用file而不是class呢。那是因为：</p>\n<ul>\n<li>spring增强了file加载的能力，推荐使用<code>resourceLoaderPath</code>来指明路径，而不是交给<code>file.resource.loader.path</code>进行处理。如果使用这个可能会跑NullPointerException；</li>\n<li>class加载存在弊端，在生产环境classpath里的内容一旦加载就被缓存起来了，这导致velocity模板加载的cache机制失效。</li>\n</ul>\n<p>###关于Velocity使用的坑</p>\n<ul>\n<li><p>关于减号（-）的问题</p>\n<blockquote>\n<p>请注意下面的2中写法<br><code>#set($maxIndex=$DOC_COUNT-1)</code>报错<br><code>#set($maxIndex=$DOC_COUNT - 1)</code>正确，区别仅在于-两侧的空格</p>\n</blockquote>\n</li>\n<li><p>关于Range类型的问题</p>\n<blockquote>\n<p><code>#set($array = [0..$maxIndex])</code> 这个里面$maxIndex应该只是一个变量，不能是一个表达式。比如这样<code>#set($array = [0..$maxIndex+1])</code>也是错误的。</p>\n</blockquote>\n</li>\n</ul>\n"},{"layout":"post","title":"Spring中配置quartz集群","date":"2014-06-24T07:10:00.000Z","comments":1,"_content":"###为什么使用quartz集群？\n\n在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。\nquartz集群在spring中的配置\n####1.导入数据库表\n\n以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。\n\n注意事项：\n\n修改SQL： TYPE=InnoDB –> ENGINE=InnoDB\n<!--more-->\n\n####2.项目中加入配置文件quartz.properties\n\n    #============================================================================\n    # Configure Main Scheduler Properties\n    #============================================================================\n    org.quartz.scheduler.instanceName = ClusteredScheduler\n    org.quartz.scheduler.instanceId = AUTO\n    org.quartz.scheduler.skipUpdateCheck = true\n    \n    #============================================================================\n    # Configure ThreadPool\n    #============================================================================\n    org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\n    org.quartz.threadPool.threadCount = 5\n    org.quartz.threadPool.threadPriority = 5\n    \n    #============================================================================\n    # Configure JobStore\n    #============================================================================\n    org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\n    org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate\n    org.quartz.jobStore.misfireThreshold = 60000\n    org.quartz.jobStore.useProperties = false\n    org.quartz.jobStore.tablePrefix = QRTZ_\n    \n    org.quartz.jobStore.isClustered = true\n    org.quartz.jobStore.clusterCheckinInterval = 15000\n\n####3.增加applicationContext-quartz.xml\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:util=\"http://www.springframework.org/schema/util\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n           default-lazy-init=\"false\">\n    \n        <description>Quartz的定时集群任务配置</description>\n    \n        <bean id=\"quartzDataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\">\n            <property name=\"driverClass\" value=\"${db.driver}\" />\n            <property name=\"url\" value=\"${db.url}\" />\n            <property name=\"username\" value=\"${db.user}\" />\n            <property name=\"password\" value=\"${db.pass}\" />\n        </bean>\n    \n        <!-- Quartz集群Schduler -->\n        <bean id=\"clusterQuartzScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n            <!-- Triggers集成 -->\n            <property name=\"triggers\">\n                <list>\n                    <ref bean=\"testTrigger\" />\n                </list>\n            </property>\n            <!--  quartz配置文件路径-->\n            <property name=\"configLocation\" value=\"classpath:quartz/quartz.properties\" />\n            <!-- 启动时延期3秒开始任务 -->\n            <property name=\"startupDelay\" value=\"3\" />\n            <!-- 保存Job数据到数据库所需的数据源 -->\n            <property name=\"dataSource\" ref=\"quartzDataSource\" />\n            <!-- Job接受applicationContext的成员变量名 -->\n            <property name=\"applicationContextSchedulerContextKey\" value=\"applicationContext\" />\n            <property name=\"overwriteExistingJobs\" value=\"true\" />\n            <property name=\"jobFactory\">\n                <bean class=\"com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory\"/>\n            </property>\n         </bean>\n    \n    \n        <bean id=\"testTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerBean\">\n            <property name=\"jobDetail\" ref=\"testJobDetail\" />\n            <property name=\"cronExpression\" value=\"* 0/10 * * * ?\" />\n        </bean>\n    \n        <!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 -->\n        <bean id=\"testJobDetail\" class=\"org.springframework.scheduling.quartz.JobDetailBean\">\n            <property name=\"jobClass\" value=\"cn.shenyanchao.quartz.TestTask\" />\n        </bean>\n    \n        <!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 -->\n        <util:map id=\"timerJobConfig\">\n            <entry key=\"nodeName\" value=\"default\" />\n        </util:map>\n    </beans>\n\n其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。\n\n另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：\n\n    public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n    \n            private transient AutowireCapableBeanFactory beanFactory;\n    \n            public void setApplicationContext(final ApplicationContext context) {\n                beanFactory = context.getAutowireCapableBeanFactory();\n            }\n    \n            @Override\n            protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {\n                final Object job = super.createJobInstance(bundle);\n                beanFactory.autowireBean(job);\n                return job;\n            }\n        }\n\n####4. 如何写JOB？\n\n    @Component\n    public class TestTask extends QuartzJobBean {\n    \n    \n        @Autowired\n        private UserService userService;\n    \n        @Override\n        protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n            System.out.println(userService.findByName(\"shenyanchao\").getEmail());\n        }\n    }\n\n由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。\n\n####5.quartz在mysql5.6下报错\n\n    You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OPTION SQL_SELECT_LIMIT=5' at line 1\n\n这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1>\n","source":"_posts/2014-06-24-quartz-cluster-with-spring.markdown","raw":"---\nlayout: post\ntitle: \"Spring中配置quartz集群\"\ndate: 2014-06-24 15:10\ncomments: true\ncategories: Java\ntags: [ quartz, spring, 集群 ]\n---\n###为什么使用quartz集群？\n\n在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。\nquartz集群在spring中的配置\n####1.导入数据库表\n\n以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。\n\n注意事项：\n\n修改SQL： TYPE=InnoDB –> ENGINE=InnoDB\n<!--more-->\n\n####2.项目中加入配置文件quartz.properties\n\n    #============================================================================\n    # Configure Main Scheduler Properties\n    #============================================================================\n    org.quartz.scheduler.instanceName = ClusteredScheduler\n    org.quartz.scheduler.instanceId = AUTO\n    org.quartz.scheduler.skipUpdateCheck = true\n    \n    #============================================================================\n    # Configure ThreadPool\n    #============================================================================\n    org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\n    org.quartz.threadPool.threadCount = 5\n    org.quartz.threadPool.threadPriority = 5\n    \n    #============================================================================\n    # Configure JobStore\n    #============================================================================\n    org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\n    org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate\n    org.quartz.jobStore.misfireThreshold = 60000\n    org.quartz.jobStore.useProperties = false\n    org.quartz.jobStore.tablePrefix = QRTZ_\n    \n    org.quartz.jobStore.isClustered = true\n    org.quartz.jobStore.clusterCheckinInterval = 15000\n\n####3.增加applicationContext-quartz.xml\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:util=\"http://www.springframework.org/schema/util\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n           default-lazy-init=\"false\">\n    \n        <description>Quartz的定时集群任务配置</description>\n    \n        <bean id=\"quartzDataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\">\n            <property name=\"driverClass\" value=\"${db.driver}\" />\n            <property name=\"url\" value=\"${db.url}\" />\n            <property name=\"username\" value=\"${db.user}\" />\n            <property name=\"password\" value=\"${db.pass}\" />\n        </bean>\n    \n        <!-- Quartz集群Schduler -->\n        <bean id=\"clusterQuartzScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n            <!-- Triggers集成 -->\n            <property name=\"triggers\">\n                <list>\n                    <ref bean=\"testTrigger\" />\n                </list>\n            </property>\n            <!--  quartz配置文件路径-->\n            <property name=\"configLocation\" value=\"classpath:quartz/quartz.properties\" />\n            <!-- 启动时延期3秒开始任务 -->\n            <property name=\"startupDelay\" value=\"3\" />\n            <!-- 保存Job数据到数据库所需的数据源 -->\n            <property name=\"dataSource\" ref=\"quartzDataSource\" />\n            <!-- Job接受applicationContext的成员变量名 -->\n            <property name=\"applicationContextSchedulerContextKey\" value=\"applicationContext\" />\n            <property name=\"overwriteExistingJobs\" value=\"true\" />\n            <property name=\"jobFactory\">\n                <bean class=\"com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory\"/>\n            </property>\n         </bean>\n    \n    \n        <bean id=\"testTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerBean\">\n            <property name=\"jobDetail\" ref=\"testJobDetail\" />\n            <property name=\"cronExpression\" value=\"* 0/10 * * * ?\" />\n        </bean>\n    \n        <!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 -->\n        <bean id=\"testJobDetail\" class=\"org.springframework.scheduling.quartz.JobDetailBean\">\n            <property name=\"jobClass\" value=\"cn.shenyanchao.quartz.TestTask\" />\n        </bean>\n    \n        <!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 -->\n        <util:map id=\"timerJobConfig\">\n            <entry key=\"nodeName\" value=\"default\" />\n        </util:map>\n    </beans>\n\n其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。\n\n另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：\n\n    public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n    \n            private transient AutowireCapableBeanFactory beanFactory;\n    \n            public void setApplicationContext(final ApplicationContext context) {\n                beanFactory = context.getAutowireCapableBeanFactory();\n            }\n    \n            @Override\n            protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {\n                final Object job = super.createJobInstance(bundle);\n                beanFactory.autowireBean(job);\n                return job;\n            }\n        }\n\n####4. 如何写JOB？\n\n    @Component\n    public class TestTask extends QuartzJobBean {\n    \n    \n        @Autowired\n        private UserService userService;\n    \n        @Override\n        protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n            System.out.println(userService.findByName(\"shenyanchao\").getEmail());\n        }\n    }\n\n由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。\n\n####5.quartz在mysql5.6下报错\n\n    You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'OPTION SQL_SELECT_LIMIT=5' at line 1\n\n这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1>\n","slug":"2014-06-24-quartz-cluster-with-spring","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop73008lv8fyb05snz15","content":"<p>###为什么使用quartz集群？</p>\n<p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。<br>quartz集群在spring中的配置</p>\n<p>####1.导入数据库表</p>\n<p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>\n<p>注意事项：</p>\n<p>修改SQL： TYPE=InnoDB –&gt; ENGINE=InnoDB<br><a id=\"more\"></a></p>\n<p>####2.项目中加入配置文件quartz.properties</p>\n<pre><code>#============================================================================\n# Configure Main Scheduler Properties\n#============================================================================\norg.quartz.scheduler.instanceName = ClusteredScheduler\norg.quartz.scheduler.instanceId = AUTO\norg.quartz.scheduler.skipUpdateCheck = true\n\n#============================================================================\n# Configure ThreadPool\n#============================================================================\norg.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount = 5\norg.quartz.threadPool.threadPriority = 5\n\n#============================================================================\n# Configure JobStore\n#============================================================================\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.useProperties = false\norg.quartz.jobStore.tablePrefix = QRTZ_\n\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 15000\n</code></pre><p>####3.增加applicationContext-quartz.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;\n       default-lazy-init=&quot;false&quot;&gt;\n\n    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;\n\n    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;&gt;\n        &lt;property name=&quot;driverClass&quot; value=&quot;${db.driver}&quot; /&gt;\n        &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot; /&gt;\n        &lt;property name=&quot;username&quot; value=&quot;${db.user}&quot; /&gt;\n        &lt;property name=&quot;password&quot; value=&quot;${db.pass}&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Quartz集群Schduler --&gt;\n    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n        &lt;!-- Triggers集成 --&gt;\n        &lt;property name=&quot;triggers&quot;&gt;\n            &lt;list&gt;\n                &lt;ref bean=&quot;testTrigger&quot; /&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n        &lt;!--  quartz配置文件路径--&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz/quartz.properties&quot; /&gt;\n        &lt;!-- 启动时延期3秒开始任务 --&gt;\n        &lt;property name=&quot;startupDelay&quot; value=&quot;3&quot; /&gt;\n        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;\n        &lt;!-- Job接受applicationContext的成员变量名 --&gt;\n        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;\n        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;\n        &lt;property name=&quot;jobFactory&quot;&gt;\n            &lt;bean class=&quot;com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory&quot;/&gt;\n        &lt;/property&gt;\n     &lt;/bean&gt;\n\n\n    &lt;bean id=&quot;testTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;\n        &lt;property name=&quot;jobDetail&quot; ref=&quot;testJobDetail&quot; /&gt;\n        &lt;property name=&quot;cronExpression&quot; value=&quot;* 0/10 * * * ?&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;\n    &lt;bean id=&quot;testJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailBean&quot;&gt;\n        &lt;property name=&quot;jobClass&quot; value=&quot;cn.shenyanchao.quartz.TestTask&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;\n    &lt;util:map id=&quot;timerJobConfig&quot;&gt;\n        &lt;entry key=&quot;nodeName&quot; value=&quot;default&quot; /&gt;\n    &lt;/util:map&gt;\n&lt;/beans&gt;\n</code></pre><p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>\n<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>\n<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n\n        private transient AutowireCapableBeanFactory beanFactory;\n\n        public void setApplicationContext(final ApplicationContext context) {\n            beanFactory = context.getAutowireCapableBeanFactory();\n        }\n\n        @Override\n        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {\n            final Object job = super.createJobInstance(bundle);\n            beanFactory.autowireBean(job);\n            return job;\n        }\n    }\n</code></pre><p>####4. 如何写JOB？</p>\n<pre><code>@Component\npublic class TestTask extends QuartzJobBean {\n\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(userService.findByName(&quot;shenyanchao&quot;).getEmail());\n    }\n}\n</code></pre><p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>\n<p>####5.quartz在mysql5.6下报错</p>\n<pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;OPTION SQL_SELECT_LIMIT=5&apos; at line 1\n</code></pre><p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<a href=\"http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>\n","excerpt":"<p>###为什么使用quartz集群？</p>\n<p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。<br>quartz集群在spring中的配置</p>\n<p>####1.导入数据库表</p>\n<p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>\n<p>注意事项：</p>\n<p>修改SQL： TYPE=InnoDB –&gt; ENGINE=InnoDB<br>","more":"</p>\n<p>####2.项目中加入配置文件quartz.properties</p>\n<pre><code>#============================================================================\n# Configure Main Scheduler Properties\n#============================================================================\norg.quartz.scheduler.instanceName = ClusteredScheduler\norg.quartz.scheduler.instanceId = AUTO\norg.quartz.scheduler.skipUpdateCheck = true\n\n#============================================================================\n# Configure ThreadPool\n#============================================================================\norg.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount = 5\norg.quartz.threadPool.threadPriority = 5\n\n#============================================================================\n# Configure JobStore\n#============================================================================\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.useProperties = false\norg.quartz.jobStore.tablePrefix = QRTZ_\n\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 15000\n</code></pre><p>####3.增加applicationContext-quartz.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;\n       default-lazy-init=&quot;false&quot;&gt;\n\n    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;\n\n    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;&gt;\n        &lt;property name=&quot;driverClass&quot; value=&quot;${db.driver}&quot; /&gt;\n        &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot; /&gt;\n        &lt;property name=&quot;username&quot; value=&quot;${db.user}&quot; /&gt;\n        &lt;property name=&quot;password&quot; value=&quot;${db.pass}&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Quartz集群Schduler --&gt;\n    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n        &lt;!-- Triggers集成 --&gt;\n        &lt;property name=&quot;triggers&quot;&gt;\n            &lt;list&gt;\n                &lt;ref bean=&quot;testTrigger&quot; /&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n        &lt;!--  quartz配置文件路径--&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz/quartz.properties&quot; /&gt;\n        &lt;!-- 启动时延期3秒开始任务 --&gt;\n        &lt;property name=&quot;startupDelay&quot; value=&quot;3&quot; /&gt;\n        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;\n        &lt;!-- Job接受applicationContext的成员变量名 --&gt;\n        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;\n        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;\n        &lt;property name=&quot;jobFactory&quot;&gt;\n            &lt;bean class=&quot;com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory&quot;/&gt;\n        &lt;/property&gt;\n     &lt;/bean&gt;\n\n\n    &lt;bean id=&quot;testTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;\n        &lt;property name=&quot;jobDetail&quot; ref=&quot;testJobDetail&quot; /&gt;\n        &lt;property name=&quot;cronExpression&quot; value=&quot;* 0/10 * * * ?&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;\n    &lt;bean id=&quot;testJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailBean&quot;&gt;\n        &lt;property name=&quot;jobClass&quot; value=&quot;cn.shenyanchao.quartz.TestTask&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;\n    &lt;util:map id=&quot;timerJobConfig&quot;&gt;\n        &lt;entry key=&quot;nodeName&quot; value=&quot;default&quot; /&gt;\n    &lt;/util:map&gt;\n&lt;/beans&gt;\n</code></pre><p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>\n<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>\n<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n\n        private transient AutowireCapableBeanFactory beanFactory;\n\n        public void setApplicationContext(final ApplicationContext context) {\n            beanFactory = context.getAutowireCapableBeanFactory();\n        }\n\n        @Override\n        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {\n            final Object job = super.createJobInstance(bundle);\n            beanFactory.autowireBean(job);\n            return job;\n        }\n    }\n</code></pre><p>####4. 如何写JOB？</p>\n<pre><code>@Component\npublic class TestTask extends QuartzJobBean {\n\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(userService.findByName(&quot;shenyanchao&quot;).getEmail());\n    }\n}\n</code></pre><p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>\n<p>####5.quartz在mysql5.6下报错</p>\n<pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;OPTION SQL_SELECT_LIMIT=5&apos; at line 1\n</code></pre><p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<a href=\"http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1\">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>"},{"layout":"post","title":"solr中的tie breaker","date":"2014-10-22T09:14:00.000Z","comments":1,"_content":"solr 查询参数中有tie这样的一个参数，下面是它的官方解释：\n\n\n**The tie (Tie Breaker) Parameter**\n\nThe tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.\n\nWhen a term from the user's input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.\n\nA value of \"0.0\" makes the query a pure \"disjunction max query\": that is, only the maximum scoring subquery contributes to the final score. A value of \"1.0\" makes the query a pure \"disjunction sum query\" where it doesn't matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.\n\n读起来比较令人费解。\n\n简单解释就是：\n\n这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。\n\n如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.\n\n也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。\n\n通常情况下呢，官方推荐tie=0.1。\n\n\n","source":"_posts/2014-10-22-tie-breaker-in-solr.markdown","raw":"---\nlayout: post\ntitle: \"solr中的tie breaker\"\ndate: 2014-10-22 17:14\ncomments: true\ncategories: solr\ntags: [ solr, lucene, tie ]\n---\nsolr 查询参数中有tie这样的一个参数，下面是它的官方解释：\n\n\n**The tie (Tie Breaker) Parameter**\n\nThe tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.\n\nWhen a term from the user's input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.\n\nA value of \"0.0\" makes the query a pure \"disjunction max query\": that is, only the maximum scoring subquery contributes to the final score. A value of \"1.0\" makes the query a pure \"disjunction sum query\" where it doesn't matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.\n\n读起来比较令人费解。\n\n简单解释就是：\n\n这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。\n\n如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.\n\n也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。\n\n通常情况下呢，官方推荐tie=0.1。\n\n\n","slug":"2014-10-22-tie-breaker-in-solr","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop75008ov8fyfr7p08vo","content":"<p>solr 查询参数中有tie这样的一个参数，下面是它的官方解释：</p>\n<p><strong>The tie (Tie Breaker) Parameter</strong></p>\n<p>The tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.</p>\n<p>When a term from the user’s input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.</p>\n<p>A value of “0.0” makes the query a pure “disjunction max query”: that is, only the maximum scoring subquery contributes to the final score. A value of “1.0” makes the query a pure “disjunction sum query” where it doesn’t matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.</p>\n<p>读起来比较令人费解。</p>\n<p>简单解释就是：</p>\n<p>这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。</p>\n<p>如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.</p>\n<p>也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。</p>\n<p>通常情况下呢，官方推荐tie=0.1。</p>\n","excerpt":"","more":"<p>solr 查询参数中有tie这样的一个参数，下面是它的官方解释：</p>\n<p><strong>The tie (Tie Breaker) Parameter</strong></p>\n<p>The tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.</p>\n<p>When a term from the user’s input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.</p>\n<p>A value of “0.0” makes the query a pure “disjunction max query”: that is, only the maximum scoring subquery contributes to the final score. A value of “1.0” makes the query a pure “disjunction sum query” where it doesn’t matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.</p>\n<p>读起来比较令人费解。</p>\n<p>简单解释就是：</p>\n<p>这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。</p>\n<p>如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.</p>\n<p>也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。</p>\n<p>通常情况下呢，官方推荐tie=0.1。</p>\n"},{"layout":"post","title":"Java新特性","date":"2014-08-27T06:43:00.000Z","comments":1,"_content":"##Java7新特性\n\n###Java7语法特性\n根据JSR 334，Java7添加了数个语法方面的新特性：\n\n####1. switch可以消化String\n\n比如：\n\n    public static void switchString(String s){\n        switch (s){\n        case \"db\": ...\n        case \"wls\": ...\n        case \"ibm\": ...\n        case \"soa\": ...\n        case \"fa\": ...\n        default: ...\n        }\n    }\n<!--more-->\n\n####2. 新的整数字面表达方式 - \"0b\"前缀和\"_\"连数符，提升程序员的幸福感。\n- a. 表示二进制字面值的前缀, 0b:\n 比如以下三个变量的值相同：\n \n        byte b1 = 0b00100001;     // New\n        byte b2 = 0x21;        // Old\n        byte b3 = 33;        // Old\n\n- b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：\n \n    \tlong phone_nbr = 021_1111_2222;\n\n####3. 简化了泛型对象创建的语法 - \"菱形 new\"，以下两个语句等价：\n\n        ArrayList<String> al1 = new ArrayList<String>();    // Old\n        ArrayList<String> al2 = new ArrayList<>();        // New\n\n####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：\n\n        ClassNotFoundException, \n        IllegalAccessException, \n        InstantiationException, \n        InvocationTargetException, \n        NoSuchFieldException, \n        NoSuchMethodException\n\n####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：\n\n        try{\n            // code\n        }\n        catch (SQLException | IOException ex) {\n            // ...\n        }\n\n####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：\n\n        public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类\n            try{\n                // code\n            }\n            catch (RelectiveOperationException ex){    // 父类\n                throws ex;\n            }\n        }\n\n####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是\"(\"不是\"{\"：\n    try(BufferedReader br = new BufferedReader(new FileReader(\"/home/oracle/temp.txt\"))){\n        ... br.readLine() ...\n    }\ntry-with-resources语句可以带catch，也可以向上例一样一个catch也没有。\n\n###Java7 NIO 新方法\n整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。\n\n####1.增加`java.nio.file.Paths`用于目录操作\n\n\t\tPath path = Paths.get(\"/home/shenyanchao\", \"Desktop\");\n        System.out.println(path.toAbsolutePath());\n        System.out.println(path.getParent());\n        System.out.println(path.getFileSystem().isOpen());\n####2.增加`java.nio.file.Files`工具类来处理文件\n\n        Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);\n\n        Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);\n\n        Files.createLink(src,dest);\n        Files.createSymbolicLink(src,dest);\n        Files.deleteIfExists(dest);\n\n        Files.readAllLines(src);\n\n        Files.createTempFile(src,\"aa\",\"bb\");\n####3.目录树遍历\n使用`FileVisitor`来实现访问者模式。\n\n    preVisitDirectory(T dir, BasicFileAttributes attrs);\n    visitFile(T dir, BasicFileAttributes attrs);\n    visitFileFailed(T dir, IOException exc);\n    postVisitDirectory(T dir, IOException exc);\n####4.使用WatchService来监控目录，变化请通知\n\n        WatchService watchService = FileSystems.getDefault().newWatchService();\n        Path path = Paths.get(\"/home/shenyanchao/Documents\");\n        WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,\n                StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);\n        while (true) {\n            List<WatchEvent<?>> watchEvents = watchService.take().pollEvents();\n            for (WatchEvent<?> watchEvent : watchEvents) {\n                System.out.printf(\"[%s]文件发生了[%s]事件。%n\", watchEvent.context(), watchEvent.kind());\n            }\n            boolean valid = watchKey.reset();\n            if (!valid){\n                break;\n            }\n        }\n        \n###Java7并发（JSR166Y）\n\n####Fork Join框架，大任务分解为小任务\n通过ForkJoinPool，ForkJoinTask来实现的。\n\n    public class Fibonacci extends RecursiveTask<Integer> {\n\n        final int n;\n\n        Fibonacci(int n) {\n            this.n = n;\n        }\n\n        @Override\n        protected Integer compute() {\n            if (n <= 1)\n                return n;\n            Fibonacci f1 = new Fibonacci(n - 1);\n            f1.fork();\n            Fibonacci f2 = new Fibonacci(n - 2);\n            f2.fork();\n            return f1.join() + f2.join();\n        }\n\n        public static void main(String[] args) {\n            Fibonacci fibonacci = new Fibonacci(4);\n            System.out.println(fibonacci.compute());\n        }\n    }\n    \n####TransferQueue，ConcurrentLinkedDeque等新类\nTransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。\n\n####ThreadLocalRandom用于生成随机数\n\n\tThreadLocalRandom.current().nextInt (...)\nRandom是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。\n\n###Java7 client\n诸如更新了很多swing显示相关的api.   \n更好的支持linux fonts\n\n###Java7 VM新特性\n\n####1.引入Garbage First回收算法\nGarbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS\n\n---\n\n参考文档：<http://www.slideshare.net/boulderjug/55-things-in-java-7>\n\n##Java8新特性\n###1.接口默认方法[接口允许有实现啦]\nJava 8允许我们给接口添加一个非抽象的方法实现，只需要使用 `default`关键字即可，这个特征又叫做扩展方法。\n\n\tinterface Formula {\n    \tdouble calculate(int a);\n\n    \tdefault double sqrt(int a) {\n        \treturn Math.sqrt(a);\n    \t}\n\t}\n\n###2.Lambda表达式\n据说借鉴了各种动态语言的新特性，比如scala，python\n首先看看在老版本的Java中是如何排列字符串的：\n\n    List<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n\n    Collections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n    });\nJava 8 提供了更为简介的语法，lambda表达式：\n\n    Collections.sort(names, (String a, String b) -> {\n        return b.compareTo(a);\n    });\n\n可以更短：\n\n\tCollections.sort(names, (String a, String b) -> b.compareTo(a));\n再短： \n\n    Collections.sort(names, (a, b) -> b.compareTo(a));\n###3.@FunctionalInterface\n这是新引入的一个注解，用于支持lambda。用`FunctionalInterface`标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。\n\n    @FunctionalInterface\n    interface Converter<F, T> {\n        T convert(F from);\n    }\n\n    Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted);    // 123\n\n例子中，`(from) -> Integer.valueOf(from)`这个lambda表达式指出了convert方法的具体实现。\n\n####(1)方法与构造函数的引用::\nJava 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法\n\n    Converter<String, Integer> converter = Integer::valueOf;\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted);   // 123\n\n当然也可以引用一个对象的方法：\n\n    converter = something::startsWith;\n    String converted = converter.convert(\"Java\");\n    System.out.println(converted);    // \"J\"\n    \n那么如何引用构造函数呢？\n\n    class Person {\n        String firstName;\n        String lastName;\n\n        Person() {}\n\n        Person(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n    }\n这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：\n\n    interface PersonFactory<P extends Person> {\n        P create(String firstName, String lastName);\n    }\n这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：\n\n    PersonFactory<Person> personFactory = Person::new;\n    Person person = personFactory.create(\"Peter\", \"Parker\");\n我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。\n\n####(2)内嵌的Functional Interfaces\n上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。\n\n另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。\n\n- Predicates   \n\nPredicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：\n\n        Predicate<String> predicate = (s) -> s.length() > 0;\n\n        predicate.test(\"foo\");              // true\n        predicate.negate().test(\"foo\");     // false\n\n        Predicate<Boolean> nonNull = Objects::nonNull;\n        Predicate<Boolean> isNull = Objects::isNull;\n\n        Predicate<String> isEmpty = String::isEmpty;\n        Predicate<String> isNotEmpty = isEmpty.negate();\n        \n- Function\n\nFunction 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：\n\n        Function<String, Integer> toInteger = Integer::valueOf;\n        Function<String, String> backToString = toInteger.andThen(String::valueOf);\n\n        backToString.apply(\"123\");     // \"123\"\n        \n- Supplier\n\nSupplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.\n\n        Supplier<Person> personSupplier = Person::new;\n        personSupplier.get();   // new Person\n        \n- Consumer\n\nConsumer在一个输入参数上做一些操作。\n\n        Consumer<Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);\n        greeter.accept(new Person(\"Luke\", \"Skywalker\"));\n\n- Comparator\n\nComparator是早就存在的，不过java 8提供了一些默认方法。\n\n        Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\n\n        Person p1 = new Person(\"John\", \"Doe\");\n        Person p2 = new Person(\"Alice\", \"Wonderland\");\n\n        comparator.compare(p1, p2);             // > 0\n        comparator.reversed().compare(p1, p2);  // < 0\n        \n- Optional\n\nOptional其实并不是一个FunctionInterface，而是一个用来避免`NullPointerException`的工具。\n\n        Optional<String> optional = Optional.of(\"bam\");\n\n        optional.isPresent();           // true\n        optional.get();                 // \"bam\"\n        optional.orElse(\"fallback\");    // \"bam\"\n\n        optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // \"b\"\n        \n- Stream\n\n`java.util.stream.Stream`代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过`Collections.stream()`或者`Collections.parallelStream()`来创建Stream。\n首先，新建一个数组。\n\n        List<String> stringCollection = new ArrayList<>();\n        stringCollection.add(\"ddd2\");\n        stringCollection.add(\"aaa2\");\n        stringCollection.add(\"bbb1\");\n        stringCollection.add(\"aaa1\");\n        stringCollection.add(\"bbb3\");\n        stringCollection.add(\"ccc\");\n        stringCollection.add(\"bbb2\");\n        stringCollection.add(\"ddd1\");\n具体使用如下：\n\n        stringCollection\n            .stream()\n            .sorted()\n            .filter((s) -> s.startsWith(\"a\"))\n            .forEach(System.out::println);\n\n        // \"aaa1\", \"aaa2\"\nmap()函数可以把每个值转换为另外的值。\n\n        stringCollection\n            .stream()\n            .map(String::toUpperCase)\n            .sorted((a, b) -> b.compareTo(a))\n            .forEach(System.out::println);\n\n        // \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\"        \n另外提供有各种match方法。\n\n        boolean anyStartsWithA =\n            stringCollection\n                .stream()\n                .anyMatch((s) -> s.startsWith(\"a\"));\n\n        System.out.println(anyStartsWithA);      // true\n\n        boolean allStartsWithA =\n            stringCollection\n                .stream()\n                .allMatch((s) -> s.startsWith(\"a\"));\n\n        System.out.println(allStartsWithA);      // false\n\n        boolean noneStartsWithZ =\n            stringCollection\n                .stream()\n                .noneMatch((s) -> s.startsWith(\"z\"));\n\n        System.out.println(noneStartsWithZ);      // true\ncount()方法返回的是一个值。\n\n        long startsWithB =\n            stringCollection\n                .stream()\n                .filter((s) -> s.startsWith(\"b\"))\n                .count();\n\n        System.out.println(startsWithB);    // 3        \nreduce则进行了归一化处理：\n\n        Optional<String> reduced =\n            stringCollection\n                .stream()\n                .sorted()\n                .reduce((s1, s2) -> s1 + \"#\" + s2);\n\n        reduced.ifPresent(System.out::println);\n        // \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\"\n        \n- ParallelStream \n\n它是一个并行的。速度要比stream快的多。\n\n- Map\n\nMap并不支持Stream，不过Java 8 提供了各种有用的新方法：\n\n        Map<Integer, String> map = new HashMap<>();\n\n        for (int i = 0; i < 10; i++) {\n            map.putIfAbsent(i, \"val\" + i);\n        }\n\n        map.forEach((id, val) -> System.out.println(val));\n\n        map.computeIfPresent(3, (num, val) -> val + num);\n        map.get(3);             // val33\n\n        map.computeIfPresent(9, (num, val) -> null);\n        map.containsKey(9);     // false\n\n        map.computeIfAbsent(23, num -> \"val\" + num);\n        map.containsKey(23);    // true\n\n        map.computeIfAbsent(3, num -> \"bam\");\n        map.get(3);             // val33\n\n        map.remove(3, \"val3\");\n        map.get(3);             // val33\n\n        map.remove(3, \"val33\");\n        map.get(3);             // null\n\n        map.getOrDefault(42, \"not found\");  // not found\n\n        map.merge(9, \"val9\", (value, newValue) -> value.concat(newValue));\n        map.get(9);             // val9\n\n        map.merge(9, \"concat\", (value, newValue) -> value.concat(newValue));\n        map.get(9);             // val9concat\n        \n###4.时间API\nJava8更新了Date API,这个新的api与joda-time类似。\n####(1)Clock\nClock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。\n\n        Clock clock = Clock.systemDefaultZone();\n        long millis = clock.millis();\n\n        Instant instant = clock.instant();\n        Date legacyDate = Date.from(instant);   // legacy java.util.Date\n        \n####(2)TimeZones\n在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的\n\n        System.out.println(ZoneId.getAvailableZoneIds());\n        // prints all available timezone ids\n\n        ZoneId zone1 = ZoneId.of(\"Europe/Berlin\");\n        ZoneId zone2 = ZoneId.of(\"Brazil/East\");\n        System.out.println(zone1.getRules());\n        System.out.println(zone2.getRules());\n\n        // ZoneRules[currentStandardOffset=+01:00]\n        // ZoneRules[currentStandardOffset=-03:00]\n####(3)LocalTime\nLocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：\n\n        LocalTime now1 = LocalTime.now(zone1);\n        LocalTime now2 = LocalTime.now(zone2);\n\n        System.out.println(now1.isBefore(now2));  // false\n\n        long hoursBetween = ChronoUnit.HOURS.between(now1, now2);\n        long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\n        System.out.println(hoursBetween);       // -3\n        System.out.println(minutesBetween);     // -239\nLocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串\n\n        LocalTime late = LocalTime.of(23, 59, 59);\n        System.out.println(late);       // 23:59:59\n\n        DateTimeFormatter germanFormatter =\n            DateTimeFormatter\n                .ofLocalizedTime(FormatStyle.SHORT)\n                .withLocale(Locale.GERMAN);\n\n        LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);\n        System.out.println(leetTime);   // 13:37\n        \n####(4)LocalDate\nLocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。\n\n        LocalDate today = LocalDate.now();\n        LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\n        LocalDate yesterday = tomorrow.minusDays(2);\n\n        LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\n        DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\n        System.out.println(dayOfWeek);    // FRIDAY\n\n        DateTimeFormatter germanFormatter =\n            DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.MEDIUM)\n                .withLocale(Locale.GERMAN);\n\n        LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);\n        System.out.println(xmas);   // 2014-12-24\n####(5)LocalDateTime\n        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。\n\n        LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\n        DayOfWeek dayOfWeek = sylvester.getDayOfWeek();\n        System.out.println(dayOfWeek);      // WEDNESDAY\n\n        Month month = sylvester.getMonth();\n        System.out.println(month);          // DECEMBER\n\n        long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\n        System.out.println(minuteOfDay);    // 1439\n\n        Instant instant = sylvester\n                .atZone(ZoneId.systemDefault())\n                .toInstant();\n\n        Date legacyDate = Date.from(instant);\n        System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\n        DateTimeFormatter formatter =\n            DateTimeFormatter\n                .ofPattern(\"MMM dd, yyyy - HH:mm\");\n\n        LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);\n        String string = formatter.format(parsed);\n        System.out.println(string);     // Nov 03, 2014 - 07:13\n        \n###5.支持重复注解了，注解也可以用在任何地方了\njava8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。\n\n    new @Interned MyObject();\n    myString = (@NonNull String) str;\n    \n    void monitorTemperature() throws @Critical TemperatureException { ... }\n之前要实现重复注解需要这样：\n\n    public @interface Authority {\n         String role();\n    }\n     \n    public @interface Authorities {\n        Authority[] value();\n    }\n     \n    public class RepeatAnnotationUseOldVersion {\n         \n        @Authorities({@Authority(role=\"Admin\"),@Authority(role=\"Manager\")})\n        public void doSomeThing(){\n        }\n    }\n\n而现在：\n\n    @Repeatable(Authorities.class)\n    public @interface Authority {\n         String role();\n    }\n     \n    public @interface Authorities {\n        Authority[] value();\n    }\n     \n    public class RepeatAnnotationUseNewVersion {\n        @Authority(role=\"Admin\")\n        @Authority(role=\"Manager\")\n        public void doSomeThing(){ }\n    }\n        \n###6.Nashorn JavaScript 引擎\n简单的说，它是 Rhino 的接替者.升级啦。\n\n###7.StampedLock\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n    class Point {\n       private double x, y;\n       private final StampedLock sl = new StampedLock();\n       void move(double deltaX, double deltaY) { // an exclusively locked method\n         long stamp = sl.writeLock();\n         try {\n           x += deltaX;\n           y += deltaY;\n         } finally {\n           sl.unlockWrite(stamp);\n         }\n       }\n      //下面看看乐观读锁案例\n       double distanceFromOrigin() { // A read-only method\n         long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n         double currentX = x, currentY = y; //将两个字段读入本地局部变量\n         if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？\n            stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n            try {\n              currentX = x; // 将两个字段读入本地局部变量\n              currentY = y; // 将两个字段读入本地局部变量\n            } finally {\n               sl.unlockRead(stamp);\n            }\n         }\n         return Math.sqrt(currentX * currentX + currentY * currentY);\n       }\n    //下面是悲观读锁案例\n       void moveIfAtOrigin(double newX, double newY) { // upgrade\n         // Could instead start with optimistic, not read mode\n         long stamp = sl.readLock();\n         try {\n           while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n             long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n             if (ws != 0L) { //这是确认转为写锁是否成功\n               stamp = ws; //如果成功 替换票据\n               x = newX; //进行状态改变\n               y = newY; //进行状态改变\n               break;\n             }\n             else { //如果不能成功转换为写锁\n               sl.unlockRead(stamp); //我们显式释放读锁\n               stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n             }\n           }\n         } finally {\n           sl.unlock(stamp); //释放读锁或写锁\n         }\n       }\n     }\n     \n- - -\n\n参考文档：<http://winterbe.com/posts/2014/03/16/java-8-tutorial/>","source":"_posts/2014-08-27-java-new-feature.markdown","raw":"---\nlayout: post\ntitle: \"Java新特性\"\ndate: 2014-08-27 14:43\ncomments: true\ncategories: java\ntags: [ java7, java8 ]\n---\n##Java7新特性\n\n###Java7语法特性\n根据JSR 334，Java7添加了数个语法方面的新特性：\n\n####1. switch可以消化String\n\n比如：\n\n    public static void switchString(String s){\n        switch (s){\n        case \"db\": ...\n        case \"wls\": ...\n        case \"ibm\": ...\n        case \"soa\": ...\n        case \"fa\": ...\n        default: ...\n        }\n    }\n<!--more-->\n\n####2. 新的整数字面表达方式 - \"0b\"前缀和\"_\"连数符，提升程序员的幸福感。\n- a. 表示二进制字面值的前缀, 0b:\n 比如以下三个变量的值相同：\n \n        byte b1 = 0b00100001;     // New\n        byte b2 = 0x21;        // Old\n        byte b3 = 33;        // Old\n\n- b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：\n \n    \tlong phone_nbr = 021_1111_2222;\n\n####3. 简化了泛型对象创建的语法 - \"菱形 new\"，以下两个语句等价：\n\n        ArrayList<String> al1 = new ArrayList<String>();    // Old\n        ArrayList<String> al2 = new ArrayList<>();        // New\n\n####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：\n\n        ClassNotFoundException, \n        IllegalAccessException, \n        InstantiationException, \n        InvocationTargetException, \n        NoSuchFieldException, \n        NoSuchMethodException\n\n####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：\n\n        try{\n            // code\n        }\n        catch (SQLException | IOException ex) {\n            // ...\n        }\n\n####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：\n\n        public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类\n            try{\n                // code\n            }\n            catch (RelectiveOperationException ex){    // 父类\n                throws ex;\n            }\n        }\n\n####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是\"(\"不是\"{\"：\n    try(BufferedReader br = new BufferedReader(new FileReader(\"/home/oracle/temp.txt\"))){\n        ... br.readLine() ...\n    }\ntry-with-resources语句可以带catch，也可以向上例一样一个catch也没有。\n\n###Java7 NIO 新方法\n整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。\n\n####1.增加`java.nio.file.Paths`用于目录操作\n\n\t\tPath path = Paths.get(\"/home/shenyanchao\", \"Desktop\");\n        System.out.println(path.toAbsolutePath());\n        System.out.println(path.getParent());\n        System.out.println(path.getFileSystem().isOpen());\n####2.增加`java.nio.file.Files`工具类来处理文件\n\n        Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);\n\n        Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);\n\n        Files.createLink(src,dest);\n        Files.createSymbolicLink(src,dest);\n        Files.deleteIfExists(dest);\n\n        Files.readAllLines(src);\n\n        Files.createTempFile(src,\"aa\",\"bb\");\n####3.目录树遍历\n使用`FileVisitor`来实现访问者模式。\n\n    preVisitDirectory(T dir, BasicFileAttributes attrs);\n    visitFile(T dir, BasicFileAttributes attrs);\n    visitFileFailed(T dir, IOException exc);\n    postVisitDirectory(T dir, IOException exc);\n####4.使用WatchService来监控目录，变化请通知\n\n        WatchService watchService = FileSystems.getDefault().newWatchService();\n        Path path = Paths.get(\"/home/shenyanchao/Documents\");\n        WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,\n                StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);\n        while (true) {\n            List<WatchEvent<?>> watchEvents = watchService.take().pollEvents();\n            for (WatchEvent<?> watchEvent : watchEvents) {\n                System.out.printf(\"[%s]文件发生了[%s]事件。%n\", watchEvent.context(), watchEvent.kind());\n            }\n            boolean valid = watchKey.reset();\n            if (!valid){\n                break;\n            }\n        }\n        \n###Java7并发（JSR166Y）\n\n####Fork Join框架，大任务分解为小任务\n通过ForkJoinPool，ForkJoinTask来实现的。\n\n    public class Fibonacci extends RecursiveTask<Integer> {\n\n        final int n;\n\n        Fibonacci(int n) {\n            this.n = n;\n        }\n\n        @Override\n        protected Integer compute() {\n            if (n <= 1)\n                return n;\n            Fibonacci f1 = new Fibonacci(n - 1);\n            f1.fork();\n            Fibonacci f2 = new Fibonacci(n - 2);\n            f2.fork();\n            return f1.join() + f2.join();\n        }\n\n        public static void main(String[] args) {\n            Fibonacci fibonacci = new Fibonacci(4);\n            System.out.println(fibonacci.compute());\n        }\n    }\n    \n####TransferQueue，ConcurrentLinkedDeque等新类\nTransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。\n\n####ThreadLocalRandom用于生成随机数\n\n\tThreadLocalRandom.current().nextInt (...)\nRandom是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。\n\n###Java7 client\n诸如更新了很多swing显示相关的api.   \n更好的支持linux fonts\n\n###Java7 VM新特性\n\n####1.引入Garbage First回收算法\nGarbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS\n\n---\n\n参考文档：<http://www.slideshare.net/boulderjug/55-things-in-java-7>\n\n##Java8新特性\n###1.接口默认方法[接口允许有实现啦]\nJava 8允许我们给接口添加一个非抽象的方法实现，只需要使用 `default`关键字即可，这个特征又叫做扩展方法。\n\n\tinterface Formula {\n    \tdouble calculate(int a);\n\n    \tdefault double sqrt(int a) {\n        \treturn Math.sqrt(a);\n    \t}\n\t}\n\n###2.Lambda表达式\n据说借鉴了各种动态语言的新特性，比如scala，python\n首先看看在老版本的Java中是如何排列字符串的：\n\n    List<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n\n    Collections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n    });\nJava 8 提供了更为简介的语法，lambda表达式：\n\n    Collections.sort(names, (String a, String b) -> {\n        return b.compareTo(a);\n    });\n\n可以更短：\n\n\tCollections.sort(names, (String a, String b) -> b.compareTo(a));\n再短： \n\n    Collections.sort(names, (a, b) -> b.compareTo(a));\n###3.@FunctionalInterface\n这是新引入的一个注解，用于支持lambda。用`FunctionalInterface`标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。\n\n    @FunctionalInterface\n    interface Converter<F, T> {\n        T convert(F from);\n    }\n\n    Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted);    // 123\n\n例子中，`(from) -> Integer.valueOf(from)`这个lambda表达式指出了convert方法的具体实现。\n\n####(1)方法与构造函数的引用::\nJava 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法\n\n    Converter<String, Integer> converter = Integer::valueOf;\n    Integer converted = converter.convert(\"123\");\n    System.out.println(converted);   // 123\n\n当然也可以引用一个对象的方法：\n\n    converter = something::startsWith;\n    String converted = converter.convert(\"Java\");\n    System.out.println(converted);    // \"J\"\n    \n那么如何引用构造函数呢？\n\n    class Person {\n        String firstName;\n        String lastName;\n\n        Person() {}\n\n        Person(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n    }\n这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：\n\n    interface PersonFactory<P extends Person> {\n        P create(String firstName, String lastName);\n    }\n这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：\n\n    PersonFactory<Person> personFactory = Person::new;\n    Person person = personFactory.create(\"Peter\", \"Parker\");\n我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。\n\n####(2)内嵌的Functional Interfaces\n上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。\n\n另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。\n\n- Predicates   \n\nPredicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：\n\n        Predicate<String> predicate = (s) -> s.length() > 0;\n\n        predicate.test(\"foo\");              // true\n        predicate.negate().test(\"foo\");     // false\n\n        Predicate<Boolean> nonNull = Objects::nonNull;\n        Predicate<Boolean> isNull = Objects::isNull;\n\n        Predicate<String> isEmpty = String::isEmpty;\n        Predicate<String> isNotEmpty = isEmpty.negate();\n        \n- Function\n\nFunction 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：\n\n        Function<String, Integer> toInteger = Integer::valueOf;\n        Function<String, String> backToString = toInteger.andThen(String::valueOf);\n\n        backToString.apply(\"123\");     // \"123\"\n        \n- Supplier\n\nSupplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.\n\n        Supplier<Person> personSupplier = Person::new;\n        personSupplier.get();   // new Person\n        \n- Consumer\n\nConsumer在一个输入参数上做一些操作。\n\n        Consumer<Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);\n        greeter.accept(new Person(\"Luke\", \"Skywalker\"));\n\n- Comparator\n\nComparator是早就存在的，不过java 8提供了一些默认方法。\n\n        Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\n\n        Person p1 = new Person(\"John\", \"Doe\");\n        Person p2 = new Person(\"Alice\", \"Wonderland\");\n\n        comparator.compare(p1, p2);             // > 0\n        comparator.reversed().compare(p1, p2);  // < 0\n        \n- Optional\n\nOptional其实并不是一个FunctionInterface，而是一个用来避免`NullPointerException`的工具。\n\n        Optional<String> optional = Optional.of(\"bam\");\n\n        optional.isPresent();           // true\n        optional.get();                 // \"bam\"\n        optional.orElse(\"fallback\");    // \"bam\"\n\n        optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // \"b\"\n        \n- Stream\n\n`java.util.stream.Stream`代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过`Collections.stream()`或者`Collections.parallelStream()`来创建Stream。\n首先，新建一个数组。\n\n        List<String> stringCollection = new ArrayList<>();\n        stringCollection.add(\"ddd2\");\n        stringCollection.add(\"aaa2\");\n        stringCollection.add(\"bbb1\");\n        stringCollection.add(\"aaa1\");\n        stringCollection.add(\"bbb3\");\n        stringCollection.add(\"ccc\");\n        stringCollection.add(\"bbb2\");\n        stringCollection.add(\"ddd1\");\n具体使用如下：\n\n        stringCollection\n            .stream()\n            .sorted()\n            .filter((s) -> s.startsWith(\"a\"))\n            .forEach(System.out::println);\n\n        // \"aaa1\", \"aaa2\"\nmap()函数可以把每个值转换为另外的值。\n\n        stringCollection\n            .stream()\n            .map(String::toUpperCase)\n            .sorted((a, b) -> b.compareTo(a))\n            .forEach(System.out::println);\n\n        // \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\"        \n另外提供有各种match方法。\n\n        boolean anyStartsWithA =\n            stringCollection\n                .stream()\n                .anyMatch((s) -> s.startsWith(\"a\"));\n\n        System.out.println(anyStartsWithA);      // true\n\n        boolean allStartsWithA =\n            stringCollection\n                .stream()\n                .allMatch((s) -> s.startsWith(\"a\"));\n\n        System.out.println(allStartsWithA);      // false\n\n        boolean noneStartsWithZ =\n            stringCollection\n                .stream()\n                .noneMatch((s) -> s.startsWith(\"z\"));\n\n        System.out.println(noneStartsWithZ);      // true\ncount()方法返回的是一个值。\n\n        long startsWithB =\n            stringCollection\n                .stream()\n                .filter((s) -> s.startsWith(\"b\"))\n                .count();\n\n        System.out.println(startsWithB);    // 3        \nreduce则进行了归一化处理：\n\n        Optional<String> reduced =\n            stringCollection\n                .stream()\n                .sorted()\n                .reduce((s1, s2) -> s1 + \"#\" + s2);\n\n        reduced.ifPresent(System.out::println);\n        // \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\"\n        \n- ParallelStream \n\n它是一个并行的。速度要比stream快的多。\n\n- Map\n\nMap并不支持Stream，不过Java 8 提供了各种有用的新方法：\n\n        Map<Integer, String> map = new HashMap<>();\n\n        for (int i = 0; i < 10; i++) {\n            map.putIfAbsent(i, \"val\" + i);\n        }\n\n        map.forEach((id, val) -> System.out.println(val));\n\n        map.computeIfPresent(3, (num, val) -> val + num);\n        map.get(3);             // val33\n\n        map.computeIfPresent(9, (num, val) -> null);\n        map.containsKey(9);     // false\n\n        map.computeIfAbsent(23, num -> \"val\" + num);\n        map.containsKey(23);    // true\n\n        map.computeIfAbsent(3, num -> \"bam\");\n        map.get(3);             // val33\n\n        map.remove(3, \"val3\");\n        map.get(3);             // val33\n\n        map.remove(3, \"val33\");\n        map.get(3);             // null\n\n        map.getOrDefault(42, \"not found\");  // not found\n\n        map.merge(9, \"val9\", (value, newValue) -> value.concat(newValue));\n        map.get(9);             // val9\n\n        map.merge(9, \"concat\", (value, newValue) -> value.concat(newValue));\n        map.get(9);             // val9concat\n        \n###4.时间API\nJava8更新了Date API,这个新的api与joda-time类似。\n####(1)Clock\nClock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。\n\n        Clock clock = Clock.systemDefaultZone();\n        long millis = clock.millis();\n\n        Instant instant = clock.instant();\n        Date legacyDate = Date.from(instant);   // legacy java.util.Date\n        \n####(2)TimeZones\n在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的\n\n        System.out.println(ZoneId.getAvailableZoneIds());\n        // prints all available timezone ids\n\n        ZoneId zone1 = ZoneId.of(\"Europe/Berlin\");\n        ZoneId zone2 = ZoneId.of(\"Brazil/East\");\n        System.out.println(zone1.getRules());\n        System.out.println(zone2.getRules());\n\n        // ZoneRules[currentStandardOffset=+01:00]\n        // ZoneRules[currentStandardOffset=-03:00]\n####(3)LocalTime\nLocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：\n\n        LocalTime now1 = LocalTime.now(zone1);\n        LocalTime now2 = LocalTime.now(zone2);\n\n        System.out.println(now1.isBefore(now2));  // false\n\n        long hoursBetween = ChronoUnit.HOURS.between(now1, now2);\n        long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\n        System.out.println(hoursBetween);       // -3\n        System.out.println(minutesBetween);     // -239\nLocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串\n\n        LocalTime late = LocalTime.of(23, 59, 59);\n        System.out.println(late);       // 23:59:59\n\n        DateTimeFormatter germanFormatter =\n            DateTimeFormatter\n                .ofLocalizedTime(FormatStyle.SHORT)\n                .withLocale(Locale.GERMAN);\n\n        LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);\n        System.out.println(leetTime);   // 13:37\n        \n####(4)LocalDate\nLocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。\n\n        LocalDate today = LocalDate.now();\n        LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\n        LocalDate yesterday = tomorrow.minusDays(2);\n\n        LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\n        DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\n        System.out.println(dayOfWeek);    // FRIDAY\n\n        DateTimeFormatter germanFormatter =\n            DateTimeFormatter\n                .ofLocalizedDate(FormatStyle.MEDIUM)\n                .withLocale(Locale.GERMAN);\n\n        LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);\n        System.out.println(xmas);   // 2014-12-24\n####(5)LocalDateTime\n        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。\n\n        LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\n        DayOfWeek dayOfWeek = sylvester.getDayOfWeek();\n        System.out.println(dayOfWeek);      // WEDNESDAY\n\n        Month month = sylvester.getMonth();\n        System.out.println(month);          // DECEMBER\n\n        long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\n        System.out.println(minuteOfDay);    // 1439\n\n        Instant instant = sylvester\n                .atZone(ZoneId.systemDefault())\n                .toInstant();\n\n        Date legacyDate = Date.from(instant);\n        System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\n        DateTimeFormatter formatter =\n            DateTimeFormatter\n                .ofPattern(\"MMM dd, yyyy - HH:mm\");\n\n        LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);\n        String string = formatter.format(parsed);\n        System.out.println(string);     // Nov 03, 2014 - 07:13\n        \n###5.支持重复注解了，注解也可以用在任何地方了\njava8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。\n\n    new @Interned MyObject();\n    myString = (@NonNull String) str;\n    \n    void monitorTemperature() throws @Critical TemperatureException { ... }\n之前要实现重复注解需要这样：\n\n    public @interface Authority {\n         String role();\n    }\n     \n    public @interface Authorities {\n        Authority[] value();\n    }\n     \n    public class RepeatAnnotationUseOldVersion {\n         \n        @Authorities({@Authority(role=\"Admin\"),@Authority(role=\"Manager\")})\n        public void doSomeThing(){\n        }\n    }\n\n而现在：\n\n    @Repeatable(Authorities.class)\n    public @interface Authority {\n         String role();\n    }\n     \n    public @interface Authorities {\n        Authority[] value();\n    }\n     \n    public class RepeatAnnotationUseNewVersion {\n        @Authority(role=\"Admin\")\n        @Authority(role=\"Manager\")\n        public void doSomeThing(){ }\n    }\n        \n###6.Nashorn JavaScript 引擎\n简单的说，它是 Rhino 的接替者.升级啦。\n\n###7.StampedLock\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n它是java8在java.util.concurrent.locks新增的一个API。\n\nReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。\n\n然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。\n\nStampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。\n\n所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！\n\n    class Point {\n       private double x, y;\n       private final StampedLock sl = new StampedLock();\n       void move(double deltaX, double deltaY) { // an exclusively locked method\n         long stamp = sl.writeLock();\n         try {\n           x += deltaX;\n           y += deltaY;\n         } finally {\n           sl.unlockWrite(stamp);\n         }\n       }\n      //下面看看乐观读锁案例\n       double distanceFromOrigin() { // A read-only method\n         long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n         double currentX = x, currentY = y; //将两个字段读入本地局部变量\n         if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？\n            stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n            try {\n              currentX = x; // 将两个字段读入本地局部变量\n              currentY = y; // 将两个字段读入本地局部变量\n            } finally {\n               sl.unlockRead(stamp);\n            }\n         }\n         return Math.sqrt(currentX * currentX + currentY * currentY);\n       }\n    //下面是悲观读锁案例\n       void moveIfAtOrigin(double newX, double newY) { // upgrade\n         // Could instead start with optimistic, not read mode\n         long stamp = sl.readLock();\n         try {\n           while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合\n             long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n             if (ws != 0L) { //这是确认转为写锁是否成功\n               stamp = ws; //如果成功 替换票据\n               x = newX; //进行状态改变\n               y = newY; //进行状态改变\n               break;\n             }\n             else { //如果不能成功转换为写锁\n               sl.unlockRead(stamp); //我们显式释放读锁\n               stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n             }\n           }\n         } finally {\n           sl.unlock(stamp); //释放读锁或写锁\n         }\n       }\n     }\n     \n- - -\n\n参考文档：<http://winterbe.com/posts/2014/03/16/java-8-tutorial/>","slug":"2014-08-27-java-new-feature","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop76008sv8fybyemtels","content":"<p>##Java7新特性</p>\n<p>###Java7语法特性<br>根据JSR 334，Java7添加了数个语法方面的新特性：</p>\n<p>####1. switch可以消化String</p>\n<p>比如：</p>\n<pre><code>public static void switchString(String s){\n    switch (s){\n    case &quot;db&quot;: ...\n    case &quot;wls&quot;: ...\n    case &quot;ibm&quot;: ...\n    case &quot;soa&quot;: ...\n    case &quot;fa&quot;: ...\n    default: ...\n    }\n}\n</code></pre><a id=\"more\"></a>\n<p>####2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。</p>\n<ul>\n<li><p>a. 表示二进制字面值的前缀, 0b:<br>比如以下三个变量的值相同：</p>\n<pre><code>byte b1 = 0b00100001;     // New\nbyte b2 = 0x21;        // Old\nbyte b3 = 33;        // Old\n</code></pre></li>\n<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>\n<pre><code>long phone_nbr = 021_1111_2222;\n</code></pre></li>\n</ul>\n<p>####3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价：</p>\n<pre><code>ArrayList&lt;String&gt; al1 = new ArrayList&lt;String&gt;();    // Old\nArrayList&lt;String&gt; al2 = new ArrayList&lt;&gt;();        // New\n</code></pre><p>####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</p>\n<pre><code>ClassNotFoundException, \nIllegalAccessException, \nInstantiationException, \nInvocationTargetException, \nNoSuchFieldException, \nNoSuchMethodException\n</code></pre><p>####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</p>\n<pre><code>try{\n    // code\n}\ncatch (SQLException | IOException ex) {\n    // ...\n}\n</code></pre><p>####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</p>\n<pre><code>public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类\n    try{\n        // code\n    }\n    catch (RelectiveOperationException ex){    // 父类\n        throws ex;\n    }\n}\n</code></pre><p>####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“：<br>    try(BufferedReader br = new BufferedReader(new FileReader(“/home/oracle/temp.txt”))){<br>        … br.readLine() …<br>    }<br>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>\n<p>###Java7 NIO 新方法<br>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>\n<p>####1.增加<code>java.nio.file.Paths</code>用于目录操作</p>\n<pre><code>Path path = Paths.get(&quot;/home/shenyanchao&quot;, &quot;Desktop&quot;);\nSystem.out.println(path.toAbsolutePath());\nSystem.out.println(path.getParent());\nSystem.out.println(path.getFileSystem().isOpen());\n</code></pre><p>####2.增加<code>java.nio.file.Files</code>工具类来处理文件</p>\n<pre><code>Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);\n\nFiles.move(src,dest,StandardCopyOption.ATOMIC_MOVE);\n\nFiles.createLink(src,dest);\nFiles.createSymbolicLink(src,dest);\nFiles.deleteIfExists(dest);\n\nFiles.readAllLines(src);\n\nFiles.createTempFile(src,&quot;aa&quot;,&quot;bb&quot;);\n</code></pre><p>####3.目录树遍历<br>使用<code>FileVisitor</code>来实现访问者模式。</p>\n<pre><code>preVisitDirectory(T dir, BasicFileAttributes attrs);\nvisitFile(T dir, BasicFileAttributes attrs);\nvisitFileFailed(T dir, IOException exc);\npostVisitDirectory(T dir, IOException exc);\n</code></pre><p>####4.使用WatchService来监控目录，变化请通知</p>\n<pre><code>WatchService watchService = FileSystems.getDefault().newWatchService();\nPath path = Paths.get(&quot;/home/shenyanchao/Documents&quot;);\nWatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,\n        StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);\nwhile (true) {\n    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();\n    for (WatchEvent&lt;?&gt; watchEvent : watchEvents) {\n        System.out.printf(&quot;[%s]文件发生了[%s]事件。%n&quot;, watchEvent.context(), watchEvent.kind());\n    }\n    boolean valid = watchKey.reset();\n    if (!valid){\n        break;\n    }\n}\n</code></pre><p>###Java7并发（JSR166Y）</p>\n<p>####Fork Join框架，大任务分解为小任务<br>通过ForkJoinPool，ForkJoinTask来实现的。</p>\n<pre><code>public class Fibonacci extends RecursiveTask&lt;Integer&gt; {\n\n    final int n;\n\n    Fibonacci(int n) {\n        this.n = n;\n    }\n\n    @Override\n    protected Integer compute() {\n        if (n &lt;= 1)\n            return n;\n        Fibonacci f1 = new Fibonacci(n - 1);\n        f1.fork();\n        Fibonacci f2 = new Fibonacci(n - 2);\n        f2.fork();\n        return f1.join() + f2.join();\n    }\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(4);\n        System.out.println(fibonacci.compute());\n    }\n}\n</code></pre><p>####TransferQueue，ConcurrentLinkedDeque等新类<br>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>\n<p>####ThreadLocalRandom用于生成随机数</p>\n<pre><code>ThreadLocalRandom.current().nextInt (...)\n</code></pre><p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>\n<p>###Java7 client<br>诸如更新了很多swing显示相关的api.<br>更好的支持linux fonts</p>\n<p>###Java7 VM新特性</p>\n<p>####1.引入Garbage First回收算法<br>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>\n<hr>\n<p>参考文档：<a href=\"http://www.slideshare.net/boulderjug/55-things-in-java-7\" target=\"_blank\" rel=\"external\">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>\n<p>##Java8新特性</p>\n<p>###1.接口默认方法[接口允许有实现啦]<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>\n<pre><code>interface Formula {\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n</code></pre><p>###2.Lambda表达式<br>据说借鉴了各种动态语言的新特性，比如scala，python<br>首先看看在老版本的Java中是如何排列字符串的：</p>\n<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);\n\nCollections.sort(names, new Comparator&lt;String&gt;() {\n@Override\npublic int compare(String a, String b) {\n    return b.compareTo(a);\n}\n});\n</code></pre><p>Java 8 提供了更为简介的语法，lambda表达式：</p>\n<pre><code>Collections.sort(names, (String a, String b) -&gt; {\n    return b.compareTo(a);\n});\n</code></pre><p>可以更短：</p>\n<pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));\n</code></pre><p>再短： </p>\n<pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));\n</code></pre><p>###3.@FunctionalInterface<br>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>\n<pre><code>@FunctionalInterface\ninterface Converter&lt;F, T&gt; {\n    T convert(F from);\n}\n\nConverter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);\nInteger converted = converter.convert(&quot;123&quot;);\nSystem.out.println(converted);    // 123\n</code></pre><p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>\n<p>####(1)方法与构造函数的引用::<br>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>\n<pre><code>Converter&lt;String, Integer&gt; converter = Integer::valueOf;\nInteger converted = converter.convert(&quot;123&quot;);\nSystem.out.println(converted);   // 123\n</code></pre><p>当然也可以引用一个对象的方法：</p>\n<pre><code>converter = something::startsWith;\nString converted = converter.convert(&quot;Java&quot;);\nSystem.out.println(converted);    // &quot;J&quot;\n</code></pre><p>那么如何引用构造函数呢？</p>\n<pre><code>class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n</code></pre><p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>\n<pre><code>interface PersonFactory&lt;P extends Person&gt; {\n    P create(String firstName, String lastName);\n}\n</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>\n<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;\nPerson person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);\n</code></pre><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>\n<p>####(2)内嵌的Functional Interfaces<br>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>\n<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>\n<ul>\n<li>Predicates   </li>\n</ul>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>\n<pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n\npredicate.test(&quot;foo&quot;);              // true\npredicate.negate().test(&quot;foo&quot;);     // false\n\nPredicate&lt;Boolean&gt; nonNull = Objects::nonNull;\nPredicate&lt;Boolean&gt; isNull = Objects::isNull;\n\nPredicate&lt;String&gt; isEmpty = String::isEmpty;\nPredicate&lt;String&gt; isNotEmpty = isEmpty.negate();\n</code></pre><ul>\n<li>Function</li>\n</ul>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<pre><code>Function&lt;String, Integer&gt; toInteger = Integer::valueOf;\nFunction&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);\n\nbackToString.apply(&quot;123&quot;);     // &quot;123&quot;\n</code></pre><ul>\n<li>Supplier</li>\n</ul>\n<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>\n<pre><code>Supplier&lt;Person&gt; personSupplier = Person::new;\npersonSupplier.get();   // new Person\n</code></pre><ul>\n<li>Consumer</li>\n</ul>\n<p>Consumer在一个输入参数上做一些操作。</p>\n<pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);\ngreeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));\n</code></pre><ul>\n<li>Comparator</li>\n</ul>\n<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>\n<pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);\nPerson p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);\n\ncomparator.compare(p1, p2);             // &gt; 0\ncomparator.reversed().compare(p1, p2);  // &lt; 0\n</code></pre><ul>\n<li>Optional</li>\n</ul>\n<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>\n<pre><code>Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);\n\noptional.isPresent();           // true\noptional.get();                 // &quot;bam&quot;\noptional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;\n\noptional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;\n</code></pre><ul>\n<li>Stream</li>\n</ul>\n<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。<br>首先，新建一个数组。</p>\n<pre><code>List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();\nstringCollection.add(&quot;ddd2&quot;);\nstringCollection.add(&quot;aaa2&quot;);\nstringCollection.add(&quot;bbb1&quot;);\nstringCollection.add(&quot;aaa1&quot;);\nstringCollection.add(&quot;bbb3&quot;);\nstringCollection.add(&quot;ccc&quot;);\nstringCollection.add(&quot;bbb2&quot;);\nstringCollection.add(&quot;ddd1&quot;);\n</code></pre><p>具体使用如下：</p>\n<pre><code>stringCollection\n    .stream()\n    .sorted()\n    .filter((s) -&gt; s.startsWith(&quot;a&quot;))\n    .forEach(System.out::println);\n\n// &quot;aaa1&quot;, &quot;aaa2&quot;\n</code></pre><p>map()函数可以把每个值转换为另外的值。</p>\n<pre><code>stringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -&gt; b.compareTo(a))\n    .forEach(System.out::println);\n\n// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;        \n</code></pre><p>另外提供有各种match方法。</p>\n<pre><code>boolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));\n\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));\n\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));\n\nSystem.out.println(noneStartsWithZ);      // true\n</code></pre><p>count()方法返回的是一个值。</p>\n<pre><code>long startsWithB =\n    stringCollection\n        .stream()\n        .filter((s) -&gt; s.startsWith(&quot;b&quot;))\n        .count();\n\nSystem.out.println(startsWithB);    // 3        \n</code></pre><p>reduce则进行了归一化处理：</p>\n<pre><code>Optional&lt;String&gt; reduced =\n    stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);\n\nreduced.ifPresent(System.out::println);\n// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;\n</code></pre><ul>\n<li>ParallelStream </li>\n</ul>\n<p>它是一个并行的。速度要比stream快的多。</p>\n<ul>\n<li>Map</li>\n</ul>\n<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>\n<pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\nfor (int i = 0; i &lt; 10; i++) {\n    map.putIfAbsent(i, &quot;val&quot; + i);\n}\n\nmap.forEach((id, val) -&gt; System.out.println(val));\n\nmap.computeIfPresent(3, (num, val) -&gt; val + num);\nmap.get(3);             // val33\n\nmap.computeIfPresent(9, (num, val) -&gt; null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);\nmap.get(3);             // val33\n\nmap.remove(3, &quot;val3&quot;);\nmap.get(3);             // val33\n\nmap.remove(3, &quot;val33&quot;);\nmap.get(3);             // null\n\nmap.getOrDefault(42, &quot;not found&quot;);  // not found\n\nmap.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));\nmap.get(9);             // val9\n\nmap.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));\nmap.get(9);             // val9concat\n</code></pre><p>###4.时间API<br>Java8更新了Date API,这个新的api与joda-time类似。</p>\n<p>####(1)Clock<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>\n<pre><code>Clock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\n\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // legacy java.util.Date\n</code></pre><p>####(2)TimeZones<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>\n<pre><code>System.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\n\nZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);\nZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n</code></pre><p>####(3)LocalTime<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>\n<pre><code>LocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\n\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n</code></pre><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>\n<pre><code>LocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n</code></pre><p>####(4)LocalDate<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>\n<pre><code>LocalDate today = LocalDate.now();\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nLocalDate yesterday = tomorrow.minusDays(2);\n\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println(dayOfWeek);    // FRIDAY\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\n\nLocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n</code></pre><p>####(5)LocalDateTime<br>        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>\n<pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);\n\nLocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n</code></pre><p>###5.支持重复注解了，注解也可以用在任何地方了<br>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>\n<pre><code>new @Interned MyObject();\nmyString = (@NonNull String) str;\n\nvoid monitorTemperature() throws @Critical TemperatureException { ... }\n</code></pre><p>之前要实现重复注解需要这样：</p>\n<pre><code>public @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseOldVersion {\n\n    @Authorities({@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)})\n    public void doSomeThing(){\n    }\n}\n</code></pre><p>而现在：</p>\n<pre><code>@Repeatable(Authorities.class)\npublic @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseNewVersion {\n    @Authority(role=&quot;Admin&quot;)\n    @Authority(role=&quot;Manager&quot;)\n    public void doSomeThing(){ }\n}\n</code></pre><p>###6.Nashorn JavaScript 引擎<br>简单的说，它是 Rhino 的接替者.升级啦。</p>\n<p>###7.StampedLock<br>它是java8在java.util.concurrent.locks新增的一个API。</p>\n<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>\n<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>\n<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>\n<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>\n<p>它是java8在java.util.concurrent.locks新增的一个API。</p>\n<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>\n<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>\n<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>\n<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>\n<pre><code>class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  //下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？\n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n</code></pre><hr>\n<p>参考文档：<a href=\"http://winterbe.com/posts/2014/03/16/java-8-tutorial/\" target=\"_blank\" rel=\"external\">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>\n","excerpt":"<p>##Java7新特性</p>\n<p>###Java7语法特性<br>根据JSR 334，Java7添加了数个语法方面的新特性：</p>\n<p>####1. switch可以消化String</p>\n<p>比如：</p>\n<pre><code>public static void switchString(String s){\n    switch (s){\n    case &quot;db&quot;: ...\n    case &quot;wls&quot;: ...\n    case &quot;ibm&quot;: ...\n    case &quot;soa&quot;: ...\n    case &quot;fa&quot;: ...\n    default: ...\n    }\n}\n</code></pre>","more":"<p>####2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。</p>\n<ul>\n<li><p>a. 表示二进制字面值的前缀, 0b:<br>比如以下三个变量的值相同：</p>\n<pre><code>byte b1 = 0b00100001;     // New\nbyte b2 = 0x21;        // Old\nbyte b3 = 33;        // Old\n</code></pre></li>\n<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>\n<pre><code>long phone_nbr = 021_1111_2222;\n</code></pre></li>\n</ul>\n<p>####3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价：</p>\n<pre><code>ArrayList&lt;String&gt; al1 = new ArrayList&lt;String&gt;();    // Old\nArrayList&lt;String&gt; al2 = new ArrayList&lt;&gt;();        // New\n</code></pre><p>####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</p>\n<pre><code>ClassNotFoundException, \nIllegalAccessException, \nInstantiationException, \nInvocationTargetException, \nNoSuchFieldException, \nNoSuchMethodException\n</code></pre><p>####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</p>\n<pre><code>try{\n    // code\n}\ncatch (SQLException | IOException ex) {\n    // ...\n}\n</code></pre><p>####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</p>\n<pre><code>public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类\n    try{\n        // code\n    }\n    catch (RelectiveOperationException ex){    // 父类\n        throws ex;\n    }\n}\n</code></pre><p>####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“：<br>    try(BufferedReader br = new BufferedReader(new FileReader(“/home/oracle/temp.txt”))){<br>        … br.readLine() …<br>    }<br>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>\n<p>###Java7 NIO 新方法<br>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>\n<p>####1.增加<code>java.nio.file.Paths</code>用于目录操作</p>\n<pre><code>Path path = Paths.get(&quot;/home/shenyanchao&quot;, &quot;Desktop&quot;);\nSystem.out.println(path.toAbsolutePath());\nSystem.out.println(path.getParent());\nSystem.out.println(path.getFileSystem().isOpen());\n</code></pre><p>####2.增加<code>java.nio.file.Files</code>工具类来处理文件</p>\n<pre><code>Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);\n\nFiles.move(src,dest,StandardCopyOption.ATOMIC_MOVE);\n\nFiles.createLink(src,dest);\nFiles.createSymbolicLink(src,dest);\nFiles.deleteIfExists(dest);\n\nFiles.readAllLines(src);\n\nFiles.createTempFile(src,&quot;aa&quot;,&quot;bb&quot;);\n</code></pre><p>####3.目录树遍历<br>使用<code>FileVisitor</code>来实现访问者模式。</p>\n<pre><code>preVisitDirectory(T dir, BasicFileAttributes attrs);\nvisitFile(T dir, BasicFileAttributes attrs);\nvisitFileFailed(T dir, IOException exc);\npostVisitDirectory(T dir, IOException exc);\n</code></pre><p>####4.使用WatchService来监控目录，变化请通知</p>\n<pre><code>WatchService watchService = FileSystems.getDefault().newWatchService();\nPath path = Paths.get(&quot;/home/shenyanchao/Documents&quot;);\nWatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,\n        StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);\nwhile (true) {\n    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();\n    for (WatchEvent&lt;?&gt; watchEvent : watchEvents) {\n        System.out.printf(&quot;[%s]文件发生了[%s]事件。%n&quot;, watchEvent.context(), watchEvent.kind());\n    }\n    boolean valid = watchKey.reset();\n    if (!valid){\n        break;\n    }\n}\n</code></pre><p>###Java7并发（JSR166Y）</p>\n<p>####Fork Join框架，大任务分解为小任务<br>通过ForkJoinPool，ForkJoinTask来实现的。</p>\n<pre><code>public class Fibonacci extends RecursiveTask&lt;Integer&gt; {\n\n    final int n;\n\n    Fibonacci(int n) {\n        this.n = n;\n    }\n\n    @Override\n    protected Integer compute() {\n        if (n &lt;= 1)\n            return n;\n        Fibonacci f1 = new Fibonacci(n - 1);\n        f1.fork();\n        Fibonacci f2 = new Fibonacci(n - 2);\n        f2.fork();\n        return f1.join() + f2.join();\n    }\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(4);\n        System.out.println(fibonacci.compute());\n    }\n}\n</code></pre><p>####TransferQueue，ConcurrentLinkedDeque等新类<br>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>\n<p>####ThreadLocalRandom用于生成随机数</p>\n<pre><code>ThreadLocalRandom.current().nextInt (...)\n</code></pre><p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>\n<p>###Java7 client<br>诸如更新了很多swing显示相关的api.<br>更好的支持linux fonts</p>\n<p>###Java7 VM新特性</p>\n<p>####1.引入Garbage First回收算法<br>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>\n<hr>\n<p>参考文档：<a href=\"http://www.slideshare.net/boulderjug/55-things-in-java-7\">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>\n<p>##Java8新特性</p>\n<p>###1.接口默认方法[接口允许有实现啦]<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>\n<pre><code>interface Formula {\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n</code></pre><p>###2.Lambda表达式<br>据说借鉴了各种动态语言的新特性，比如scala，python<br>首先看看在老版本的Java中是如何排列字符串的：</p>\n<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);\n\nCollections.sort(names, new Comparator&lt;String&gt;() {\n@Override\npublic int compare(String a, String b) {\n    return b.compareTo(a);\n}\n});\n</code></pre><p>Java 8 提供了更为简介的语法，lambda表达式：</p>\n<pre><code>Collections.sort(names, (String a, String b) -&gt; {\n    return b.compareTo(a);\n});\n</code></pre><p>可以更短：</p>\n<pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));\n</code></pre><p>再短： </p>\n<pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));\n</code></pre><p>###3.@FunctionalInterface<br>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>\n<pre><code>@FunctionalInterface\ninterface Converter&lt;F, T&gt; {\n    T convert(F from);\n}\n\nConverter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);\nInteger converted = converter.convert(&quot;123&quot;);\nSystem.out.println(converted);    // 123\n</code></pre><p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>\n<p>####(1)方法与构造函数的引用::<br>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>\n<pre><code>Converter&lt;String, Integer&gt; converter = Integer::valueOf;\nInteger converted = converter.convert(&quot;123&quot;);\nSystem.out.println(converted);   // 123\n</code></pre><p>当然也可以引用一个对象的方法：</p>\n<pre><code>converter = something::startsWith;\nString converted = converter.convert(&quot;Java&quot;);\nSystem.out.println(converted);    // &quot;J&quot;\n</code></pre><p>那么如何引用构造函数呢？</p>\n<pre><code>class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n</code></pre><p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>\n<pre><code>interface PersonFactory&lt;P extends Person&gt; {\n    P create(String firstName, String lastName);\n}\n</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>\n<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;\nPerson person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);\n</code></pre><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>\n<p>####(2)内嵌的Functional Interfaces<br>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>\n<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>\n<ul>\n<li>Predicates   </li>\n</ul>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>\n<pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n\npredicate.test(&quot;foo&quot;);              // true\npredicate.negate().test(&quot;foo&quot;);     // false\n\nPredicate&lt;Boolean&gt; nonNull = Objects::nonNull;\nPredicate&lt;Boolean&gt; isNull = Objects::isNull;\n\nPredicate&lt;String&gt; isEmpty = String::isEmpty;\nPredicate&lt;String&gt; isNotEmpty = isEmpty.negate();\n</code></pre><ul>\n<li>Function</li>\n</ul>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<pre><code>Function&lt;String, Integer&gt; toInteger = Integer::valueOf;\nFunction&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);\n\nbackToString.apply(&quot;123&quot;);     // &quot;123&quot;\n</code></pre><ul>\n<li>Supplier</li>\n</ul>\n<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>\n<pre><code>Supplier&lt;Person&gt; personSupplier = Person::new;\npersonSupplier.get();   // new Person\n</code></pre><ul>\n<li>Consumer</li>\n</ul>\n<p>Consumer在一个输入参数上做一些操作。</p>\n<pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);\ngreeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));\n</code></pre><ul>\n<li>Comparator</li>\n</ul>\n<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>\n<pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);\nPerson p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);\n\ncomparator.compare(p1, p2);             // &gt; 0\ncomparator.reversed().compare(p1, p2);  // &lt; 0\n</code></pre><ul>\n<li>Optional</li>\n</ul>\n<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>\n<pre><code>Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);\n\noptional.isPresent();           // true\noptional.get();                 // &quot;bam&quot;\noptional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;\n\noptional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;\n</code></pre><ul>\n<li>Stream</li>\n</ul>\n<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。<br>首先，新建一个数组。</p>\n<pre><code>List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();\nstringCollection.add(&quot;ddd2&quot;);\nstringCollection.add(&quot;aaa2&quot;);\nstringCollection.add(&quot;bbb1&quot;);\nstringCollection.add(&quot;aaa1&quot;);\nstringCollection.add(&quot;bbb3&quot;);\nstringCollection.add(&quot;ccc&quot;);\nstringCollection.add(&quot;bbb2&quot;);\nstringCollection.add(&quot;ddd1&quot;);\n</code></pre><p>具体使用如下：</p>\n<pre><code>stringCollection\n    .stream()\n    .sorted()\n    .filter((s) -&gt; s.startsWith(&quot;a&quot;))\n    .forEach(System.out::println);\n\n// &quot;aaa1&quot;, &quot;aaa2&quot;\n</code></pre><p>map()函数可以把每个值转换为另外的值。</p>\n<pre><code>stringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -&gt; b.compareTo(a))\n    .forEach(System.out::println);\n\n// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;        \n</code></pre><p>另外提供有各种match方法。</p>\n<pre><code>boolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));\n\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));\n\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));\n\nSystem.out.println(noneStartsWithZ);      // true\n</code></pre><p>count()方法返回的是一个值。</p>\n<pre><code>long startsWithB =\n    stringCollection\n        .stream()\n        .filter((s) -&gt; s.startsWith(&quot;b&quot;))\n        .count();\n\nSystem.out.println(startsWithB);    // 3        \n</code></pre><p>reduce则进行了归一化处理：</p>\n<pre><code>Optional&lt;String&gt; reduced =\n    stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);\n\nreduced.ifPresent(System.out::println);\n// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;\n</code></pre><ul>\n<li>ParallelStream </li>\n</ul>\n<p>它是一个并行的。速度要比stream快的多。</p>\n<ul>\n<li>Map</li>\n</ul>\n<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>\n<pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\nfor (int i = 0; i &lt; 10; i++) {\n    map.putIfAbsent(i, &quot;val&quot; + i);\n}\n\nmap.forEach((id, val) -&gt; System.out.println(val));\n\nmap.computeIfPresent(3, (num, val) -&gt; val + num);\nmap.get(3);             // val33\n\nmap.computeIfPresent(9, (num, val) -&gt; null);\nmap.containsKey(9);     // false\n\nmap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);\nmap.containsKey(23);    // true\n\nmap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);\nmap.get(3);             // val33\n\nmap.remove(3, &quot;val3&quot;);\nmap.get(3);             // val33\n\nmap.remove(3, &quot;val33&quot;);\nmap.get(3);             // null\n\nmap.getOrDefault(42, &quot;not found&quot;);  // not found\n\nmap.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));\nmap.get(9);             // val9\n\nmap.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));\nmap.get(9);             // val9concat\n</code></pre><p>###4.时间API<br>Java8更新了Date API,这个新的api与joda-time类似。</p>\n<p>####(1)Clock<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>\n<pre><code>Clock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\n\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // legacy java.util.Date\n</code></pre><p>####(2)TimeZones<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>\n<pre><code>System.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\n\nZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);\nZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n</code></pre><p>####(3)LocalTime<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>\n<pre><code>LocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\n\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n</code></pre><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>\n<pre><code>LocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n</code></pre><p>####(4)LocalDate<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>\n<pre><code>LocalDate today = LocalDate.now();\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nLocalDate yesterday = tomorrow.minusDays(2);\n\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println(dayOfWeek);    // FRIDAY\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\n\nLocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n</code></pre><p>####(5)LocalDateTime<br>        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>\n<pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\n\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);\n\nLocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n</code></pre><p>###5.支持重复注解了，注解也可以用在任何地方了<br>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>\n<pre><code>new @Interned MyObject();\nmyString = (@NonNull String) str;\n\nvoid monitorTemperature() throws @Critical TemperatureException { ... }\n</code></pre><p>之前要实现重复注解需要这样：</p>\n<pre><code>public @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseOldVersion {\n\n    @Authorities({@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)})\n    public void doSomeThing(){\n    }\n}\n</code></pre><p>而现在：</p>\n<pre><code>@Repeatable(Authorities.class)\npublic @interface Authority {\n     String role();\n}\n\npublic @interface Authorities {\n    Authority[] value();\n}\n\npublic class RepeatAnnotationUseNewVersion {\n    @Authority(role=&quot;Admin&quot;)\n    @Authority(role=&quot;Manager&quot;)\n    public void doSomeThing(){ }\n}\n</code></pre><p>###6.Nashorn JavaScript 引擎<br>简单的说，它是 Rhino 的接替者.升级啦。</p>\n<p>###7.StampedLock<br>它是java8在java.util.concurrent.locks新增的一个API。</p>\n<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>\n<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>\n<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>\n<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>\n<p>它是java8在java.util.concurrent.locks新增的一个API。</p>\n<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>\n<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>\n<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>\n<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>\n<pre><code>class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n  //下面看看乐观读锁案例\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁\n     double currentX = x, currentY = y; //将两个字段读入本地局部变量\n     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？\n        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁\n        try {\n          currentX = x; // 将两个字段读入本地局部变量\n          currentY = y; // 将两个字段读入本地局部变量\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n//下面是悲观读锁案例\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合\n         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁\n         if (ws != 0L) { //这是确认转为写锁是否成功\n           stamp = ws; //如果成功 替换票据\n           x = newX; //进行状态改变\n           y = newY; //进行状态改变\n           break;\n         }\n         else { //如果不能成功转换为写锁\n           sl.unlockRead(stamp); //我们显式释放读锁\n           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试\n         }\n       }\n     } finally {\n       sl.unlock(stamp); //释放读锁或写锁\n     }\n   }\n }\n</code></pre><hr>\n<p>参考文档：<a href=\"http://winterbe.com/posts/2014/03/16/java-8-tutorial/\">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>"},{"layout":"post","title":"Linux中文件编码转换","date":"2014-11-13T08:20:00.000Z","comments":1,"_content":"　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK->UTF-8文件编码批量转换。\n\nLinux命令-enca 查看文件的编码\n\nEnca语法\n\n    Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...\n            enconv [-L LANGUAGE] [OPTION]... [FILE]...\n            Detect encoding of text files and convert them if required.\nEnca用法\n\n    $ enca -L zh_CN file 检查文件的编码\n    $ enca -L zh_CN -x UTF-8 file 将文件编码转换为\"UTF-8\"编码\n    $ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样\n除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。\n<!--more-->\n转换单个文件的编码\n\n    $ enca -L none -x utf-8  index.html\n转换多个文件的编码\n\n    $ enca -x utf-8 *\nLinux文件名编码批量转换--convmv\n\nConvmv语法\n\n    $ convmv -f 源编码 -t 新编码 [选项] 文件名\nConvmv 常用参数\n\n    -r 递归处理子文件夹\n    –notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。\n    –list 显示所有支持的编码\n    –unescap 可以做一下转义，比如把%20变成空格\n示例\n\n转换一个文件由GBK转换成UTF-8\n\n    convmv -f GBK -t UTF-8 --notest utf8 filename\nGBK->UTF-8文件编码批量转换脚本\n\n    $ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \\;\n使用iconv 转换\n\nIconv语法\n\n    iconv -f encoding -t encoding inputfile\n示例\n\n单个文件转换\n\n    $ iconv -f GBK -t UTF-8 file1 -o file2\n批量转换\n\n    $ find default -type d -exec mkdir -p utf/{} \\;\n    $ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \\;\n这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。\n\n---\n原文:<http://blog.csdn.net/a280606790/article/details/8504133>","source":"_posts/2014-11-13-encode-convert-in-linux.markdown","raw":"---\nlayout: post\ntitle: \"Linux中文件编码转换\"\ndate: 2014-11-13 16:20\ncomments: true\ncategories: linux\ntags: [ enca, iconv, convmv, 编码 ]\n---\n　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK->UTF-8文件编码批量转换。\n\nLinux命令-enca 查看文件的编码\n\nEnca语法\n\n    Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...\n            enconv [-L LANGUAGE] [OPTION]... [FILE]...\n            Detect encoding of text files and convert them if required.\nEnca用法\n\n    $ enca -L zh_CN file 检查文件的编码\n    $ enca -L zh_CN -x UTF-8 file 将文件编码转换为\"UTF-8\"编码\n    $ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样\n除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。\n<!--more-->\n转换单个文件的编码\n\n    $ enca -L none -x utf-8  index.html\n转换多个文件的编码\n\n    $ enca -x utf-8 *\nLinux文件名编码批量转换--convmv\n\nConvmv语法\n\n    $ convmv -f 源编码 -t 新编码 [选项] 文件名\nConvmv 常用参数\n\n    -r 递归处理子文件夹\n    –notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。\n    –list 显示所有支持的编码\n    –unescap 可以做一下转义，比如把%20变成空格\n示例\n\n转换一个文件由GBK转换成UTF-8\n\n    convmv -f GBK -t UTF-8 --notest utf8 filename\nGBK->UTF-8文件编码批量转换脚本\n\n    $ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \\;\n使用iconv 转换\n\nIconv语法\n\n    iconv -f encoding -t encoding inputfile\n示例\n\n单个文件转换\n\n    $ iconv -f GBK -t UTF-8 file1 -o file2\n批量转换\n\n    $ find default -type d -exec mkdir -p utf/{} \\;\n    $ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \\;\n这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。\n\n---\n原文:<http://blog.csdn.net/a280606790/article/details/8504133>","slug":"2014-11-13-encode-convert-in-linux","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop79008wv8fy0wup01we","content":"<p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>\n<p>Linux命令-enca 查看文件的编码</p>\n<p>Enca语法</p>\n<pre><code>Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...\n        enconv [-L LANGUAGE] [OPTION]... [FILE]...\n        Detect encoding of text files and convert them if required.\n</code></pre><p>Enca用法</p>\n<pre><code>$ enca -L zh_CN file 检查文件的编码\n$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&quot;UTF-8&quot;编码\n$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样\n</code></pre><p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。<br><a id=\"more\"></a><br>转换单个文件的编码</p>\n<pre><code>$ enca -L none -x utf-8  index.html\n</code></pre><p>转换多个文件的编码</p>\n<pre><code>$ enca -x utf-8 *\n</code></pre><p>Linux文件名编码批量转换–convmv</p>\n<p>Convmv语法</p>\n<pre><code>$ convmv -f 源编码 -t 新编码 [选项] 文件名\n</code></pre><p>Convmv 常用参数</p>\n<pre><code>-r 递归处理子文件夹\n–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。\n–list 显示所有支持的编码\n–unescap 可以做一下转义，比如把%20变成空格\n</code></pre><p>示例</p>\n<p>转换一个文件由GBK转换成UTF-8</p>\n<pre><code>convmv -f GBK -t UTF-8 --notest utf8 filename\n</code></pre><p>GBK-&gt;UTF-8文件编码批量转换脚本</p>\n<pre><code>$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \\;\n</code></pre><p>使用iconv 转换</p>\n<p>Iconv语法</p>\n<pre><code>iconv -f encoding -t encoding inputfile\n</code></pre><p>示例</p>\n<p>单个文件转换</p>\n<pre><code>$ iconv -f GBK -t UTF-8 file1 -o file2\n</code></pre><p>批量转换</p>\n<pre><code>$ find default -type d -exec mkdir -p utf/{} \\;\n$ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \\;\n</code></pre><p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>\n<hr>\n<p>原文:<a href=\"http://blog.csdn.net/a280606790/article/details/8504133\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/a280606790/article/details/8504133</a></p>\n","excerpt":"<p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>\n<p>Linux命令-enca 查看文件的编码</p>\n<p>Enca语法</p>\n<pre><code>Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...\n        enconv [-L LANGUAGE] [OPTION]... [FILE]...\n        Detect encoding of text files and convert them if required.\n</code></pre><p>Enca用法</p>\n<pre><code>$ enca -L zh_CN file 检查文件的编码\n$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&quot;UTF-8&quot;编码\n$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样\n</code></pre><p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。<br>","more":"<br>转换单个文件的编码</p>\n<pre><code>$ enca -L none -x utf-8  index.html\n</code></pre><p>转换多个文件的编码</p>\n<pre><code>$ enca -x utf-8 *\n</code></pre><p>Linux文件名编码批量转换–convmv</p>\n<p>Convmv语法</p>\n<pre><code>$ convmv -f 源编码 -t 新编码 [选项] 文件名\n</code></pre><p>Convmv 常用参数</p>\n<pre><code>-r 递归处理子文件夹\n–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。\n–list 显示所有支持的编码\n–unescap 可以做一下转义，比如把%20变成空格\n</code></pre><p>示例</p>\n<p>转换一个文件由GBK转换成UTF-8</p>\n<pre><code>convmv -f GBK -t UTF-8 --notest utf8 filename\n</code></pre><p>GBK-&gt;UTF-8文件编码批量转换脚本</p>\n<pre><code>$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 {} -o utf/{} \\;\n</code></pre><p>使用iconv 转换</p>\n<p>Iconv语法</p>\n<pre><code>iconv -f encoding -t encoding inputfile\n</code></pre><p>示例</p>\n<p>单个文件转换</p>\n<pre><code>$ iconv -f GBK -t UTF-8 file1 -o file2\n</code></pre><p>批量转换</p>\n<pre><code>$ find default -type d -exec mkdir -p utf/{} \\;\n$ find default -type f -exec iconv -f GBK -t UTF-8 {} -o utf/{} \\;\n</code></pre><p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>\n<hr>\n<p>原文:<a href=\"http://blog.csdn.net/a280606790/article/details/8504133\">http://blog.csdn.net/a280606790/article/details/8504133</a></p>"},{"layout":"post","title":"oryx介绍","date":"2014-11-11T11:31:00.000Z","comments":1,"_content":"Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业[Myrrix](https://github.com/myrrix/myrrix-recommender])——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。\n\n　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为[Oryx](https://github.com/cloudera/oryx)的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。\n\n<!--more-->\n　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”\n\n　　作为Hadoop当中实现机器学习模式创建的传统途径，[Apache Mahout](http://mahout.apache.org/)“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。\n\n　　开放而且简便的推荐引擎\n\n　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。\n\n　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。\n\n　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。\n\n　　还只是个项目而非产品\n\n　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”\n\n　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”\n\n　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。\n\n　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”\n\n　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。\n\n---\n参考：\n<http://storage.chinabyte.com/134/12873634.shtml>","source":"_posts/2014-11-11-introduce-oryx.markdown","raw":"---\nlayout: post\ntitle: \"oryx介绍\"\ndate: 2014-11-11 19:31\ncomments: true\ncategories: oryx\ntags: [ cloudera, oryx, myrrix ]\n---\nHadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业[Myrrix](https://github.com/myrrix/myrrix-recommender])——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。\n\n　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为[Oryx](https://github.com/cloudera/oryx)的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。\n\n<!--more-->\n　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”\n\n　　作为Hadoop当中实现机器学习模式创建的传统途径，[Apache Mahout](http://mahout.apache.org/)“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。\n\n　　开放而且简便的推荐引擎\n\n　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。\n\n　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。\n\n　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。\n\n　　还只是个项目而非产品\n\n　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”\n\n　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”\n\n　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。\n\n　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”\n\n　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。\n\n---\n参考：\n<http://storage.chinabyte.com/134/12873634.shtml>","slug":"2014-11-11-introduce-oryx","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7b008zv8fyakjcsgy5","content":"<p>Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业<a href=\"https://github.com/myrrix/myrrix-recommender]\" target=\"_blank\" rel=\"external\">Myrrix</a>——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。</p>\n<p>　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为<a href=\"https://github.com/cloudera/oryx\" target=\"_blank\" rel=\"external\">Oryx</a>的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。</p>\n<a id=\"more\"></a>\n<p>　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”</p>\n<p>　　作为Hadoop当中实现机器学习模式创建的传统途径，<a href=\"http://mahout.apache.org/\" target=\"_blank\" rel=\"external\">Apache Mahout</a>“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。</p>\n<p>　　开放而且简便的推荐引擎</p>\n<p>　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。</p>\n<p>　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。</p>\n<p>　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。</p>\n<p>　　还只是个项目而非产品</p>\n<p>　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”</p>\n<p>　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”</p>\n<p>　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。</p>\n<p>　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”</p>\n<p>　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。</p>\n<hr>\n<p>参考：<br><a href=\"http://storage.chinabyte.com/134/12873634.shtml\" target=\"_blank\" rel=\"external\">http://storage.chinabyte.com/134/12873634.shtml</a></p>\n","excerpt":"<p>Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业<a href=\"https://github.com/myrrix/myrrix-recommender]\">Myrrix</a>——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。</p>\n<p>　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为<a href=\"https://github.com/cloudera/oryx\">Oryx</a>的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。</p>","more":"<p>　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”</p>\n<p>　　作为Hadoop当中实现机器学习模式创建的传统途径，<a href=\"http://mahout.apache.org/\">Apache Mahout</a>“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。</p>\n<p>　　开放而且简便的推荐引擎</p>\n<p>　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。</p>\n<p>　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。</p>\n<p>　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。</p>\n<p>　　还只是个项目而非产品</p>\n<p>　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”</p>\n<p>　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”</p>\n<p>　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。</p>\n<p>　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”</p>\n<p>　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。</p>\n<hr>\n<p>参考：<br><a href=\"http://storage.chinabyte.com/134/12873634.shtml\">http://storage.chinabyte.com/134/12873634.shtml</a></p>"},{"layout":"post","title":"使用mahout对Sogou语料库进行分类","date":"2014-11-14T05:26:00.000Z","comments":1,"_content":"###软件版本\n- Ubuntu Linux\n- [mahout-0.9](http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz),本文写作的时候的最新版本\n- [Sogou语料库](http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz)精简版\n- [ik-analyzer](https://github.com/blueshen/ik-analyzer), 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。\n\n###Sogou语料库处理\n下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.\n语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：\n\n    find sogou -type d -exec mkdir -p utf/{} \\;\n    find sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \\;\n\n###使用mahout生成sequence file\n进入utf/sogou目录，执行：\n\n    mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow\n生成的sequence file存放在sogou-seq目录内。\n可以通过seqdumper命令查看：  \n<!--more-->\n    mahout seqdumper -i sogou-seq/part-m-00000 | more\n![](/images/blog/2014/sogou-seqfile.png)\n\n如果是在hadoop上跑，可以这样看。\n\n    hadoop fs -text sogou-seq/part-m-00000 | more\n\n###使用seq2sparse生成Vectors\n执行命令：\n\n    mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow\n\n查看生成的vector\n\nmahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more\n\n![](/images/blog/2014/sogou-vector.png)\n\n需要注意的是`org.wltea.analyzer.lucene.IKAnalyzer`，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是`org.apache.lucene.analysis.standard.StandardAnalyzer`，空格分割明显不适用中文。\n\n###切分训练集和测试集\n\n    mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential\n\n###使用Native Bayes训练model\n\n    mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c\n\n###使用测试集来查看效果\n\n    mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c\n![](/images/blog/2014/sogou-result.png)\n\n可以看出87%的正确率还是不错的。\n\n---\n参考文档：\n\n<http://mahout.apache.org/users/classification/twenty-newsgroups.html>     \n<http://www.sogou.com/labs/dl/c.html>\n","source":"_posts/2014-11-14-use-mahout-to-classify-sogou-corpus.markdown","raw":"---\nlayout: post\ntitle: \"使用mahout对Sogou语料库进行分类\"\ndate: 2014-11-14 13:26\ncomments: true\ncategories: mahout\ntags: [ mahout, sogou, ik-analyzer, ubuntu ]\n---\n###软件版本\n- Ubuntu Linux\n- [mahout-0.9](http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz),本文写作的时候的最新版本\n- [Sogou语料库](http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz)精简版\n- [ik-analyzer](https://github.com/blueshen/ik-analyzer), 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。\n\n###Sogou语料库处理\n下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.\n语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：\n\n    find sogou -type d -exec mkdir -p utf/{} \\;\n    find sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \\;\n\n###使用mahout生成sequence file\n进入utf/sogou目录，执行：\n\n    mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow\n生成的sequence file存放在sogou-seq目录内。\n可以通过seqdumper命令查看：  \n<!--more-->\n    mahout seqdumper -i sogou-seq/part-m-00000 | more\n![](/images/blog/2014/sogou-seqfile.png)\n\n如果是在hadoop上跑，可以这样看。\n\n    hadoop fs -text sogou-seq/part-m-00000 | more\n\n###使用seq2sparse生成Vectors\n执行命令：\n\n    mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow\n\n查看生成的vector\n\nmahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more\n\n![](/images/blog/2014/sogou-vector.png)\n\n需要注意的是`org.wltea.analyzer.lucene.IKAnalyzer`，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是`org.apache.lucene.analysis.standard.StandardAnalyzer`，空格分割明显不适用中文。\n\n###切分训练集和测试集\n\n    mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential\n\n###使用Native Bayes训练model\n\n    mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c\n\n###使用测试集来查看效果\n\n    mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c\n![](/images/blog/2014/sogou-result.png)\n\n可以看出87%的正确率还是不错的。\n\n---\n参考文档：\n\n<http://mahout.apache.org/users/classification/twenty-newsgroups.html>     \n<http://www.sogou.com/labs/dl/c.html>\n","slug":"2014-11-14-use-mahout-to-classify-sogou-corpus","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7d0092v8fyiet0ynxf","content":"<p>###软件版本</p>\n<ul>\n<li>Ubuntu Linux</li>\n<li><a href=\"http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz\" target=\"_blank\" rel=\"external\">mahout-0.9</a>,本文写作的时候的最新版本</li>\n<li><a href=\"http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz\" target=\"_blank\" rel=\"external\">Sogou语料库</a>精简版</li>\n<li><a href=\"https://github.com/blueshen/ik-analyzer\" target=\"_blank\" rel=\"external\">ik-analyzer</a>, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。</li>\n</ul>\n<p>###Sogou语料库处理<br>下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.<br>语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：</p>\n<pre><code>find sogou -type d -exec mkdir -p utf/{} \\;\nfind sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \\;\n</code></pre><p>###使用mahout生成sequence file<br>进入utf/sogou目录，执行：</p>\n<pre><code>mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow\n</code></pre><p>生成的sequence file存放在sogou-seq目录内。<br>可以通过seqdumper命令查看：<br><a id=\"more\"></a><br>    mahout seqdumper -i sogou-seq/part-m-00000 | more<br><img src=\"/images/blog/2014/sogou-seqfile.png\" alt=\"\"></p>\n<p>如果是在hadoop上跑，可以这样看。</p>\n<pre><code>hadoop fs -text sogou-seq/part-m-00000 | more\n</code></pre><p>###使用seq2sparse生成Vectors<br>执行命令：</p>\n<pre><code>mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow\n</code></pre><p>查看生成的vector</p>\n<p>mahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more</p>\n<p><img src=\"/images/blog/2014/sogou-vector.png\" alt=\"\"></p>\n<p>需要注意的是<code>org.wltea.analyzer.lucene.IKAnalyzer</code>，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code>，空格分割明显不适用中文。</p>\n<p>###切分训练集和测试集</p>\n<pre><code>mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential\n</code></pre><p>###使用Native Bayes训练model</p>\n<pre><code>mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c\n</code></pre><p>###使用测试集来查看效果</p>\n<pre><code>mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c\n</code></pre><p><img src=\"/images/blog/2014/sogou-result.png\" alt=\"\"></p>\n<p>可以看出87%的正确率还是不错的。</p>\n<hr>\n<p>参考文档：</p>\n<p><a href=\"http://mahout.apache.org/users/classification/twenty-newsgroups.html\" target=\"_blank\" rel=\"external\">http://mahout.apache.org/users/classification/twenty-newsgroups.html</a><br><a href=\"http://www.sogou.com/labs/dl/c.html\" target=\"_blank\" rel=\"external\">http://www.sogou.com/labs/dl/c.html</a></p>\n","excerpt":"<p>###软件版本</p>\n<ul>\n<li>Ubuntu Linux</li>\n<li><a href=\"http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz\">mahout-0.9</a>,本文写作的时候的最新版本</li>\n<li><a href=\"http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz\">Sogou语料库</a>精简版</li>\n<li><a href=\"https://github.com/blueshen/ik-analyzer\">ik-analyzer</a>, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。</li>\n</ul>\n<p>###Sogou语料库处理<br>下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.<br>语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：</p>\n<pre><code>find sogou -type d -exec mkdir -p utf/{} \\;\nfind sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \\;\n</code></pre><p>###使用mahout生成sequence file<br>进入utf/sogou目录，执行：</p>\n<pre><code>mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow\n</code></pre><p>生成的sequence file存放在sogou-seq目录内。<br>可以通过seqdumper命令查看：<br>","more":"<br>    mahout seqdumper -i sogou-seq/part-m-00000 | more<br><img src=\"/images/blog/2014/sogou-seqfile.png\" alt=\"\"></p>\n<p>如果是在hadoop上跑，可以这样看。</p>\n<pre><code>hadoop fs -text sogou-seq/part-m-00000 | more\n</code></pre><p>###使用seq2sparse生成Vectors<br>执行命令：</p>\n<pre><code>mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow\n</code></pre><p>查看生成的vector</p>\n<p>mahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more</p>\n<p><img src=\"/images/blog/2014/sogou-vector.png\" alt=\"\"></p>\n<p>需要注意的是<code>org.wltea.analyzer.lucene.IKAnalyzer</code>，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code>，空格分割明显不适用中文。</p>\n<p>###切分训练集和测试集</p>\n<pre><code>mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential\n</code></pre><p>###使用Native Bayes训练model</p>\n<pre><code>mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c\n</code></pre><p>###使用测试集来查看效果</p>\n<pre><code>mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c\n</code></pre><p><img src=\"/images/blog/2014/sogou-result.png\" alt=\"\"></p>\n<p>可以看出87%的正确率还是不错的。</p>\n<hr>\n<p>参考文档：</p>\n<p><a href=\"http://mahout.apache.org/users/classification/twenty-newsgroups.html\">http://mahout.apache.org/users/classification/twenty-newsgroups.html</a><br><a href=\"http://www.sogou.com/labs/dl/c.html\">http://www.sogou.com/labs/dl/c.html</a></p>"},{"layout":"post","title":"如何在Solr中更好的处理同义词","date":"2014-11-25T05:53:00.000Z","comments":1,"_content":"\n当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)\"?\n\n![小狗](/images/blog/2014/File-Licking_the_staffy_pup.JPG)\n\n叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。\n\n事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。\n\n<!--more-->\n\n###The SynonymFilterFactory\n\nSolr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。   \n\n举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。\n\n当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。\n\n###Index-time vs. query-time\n\n下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。\n\n![Index-time vs. query-time expansion.](/images/blog/2014/index_vs_query_expansion2.png)\n\n你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：\n\n- 索引大小不会变化\n- 同义词可以随时更换，不用更新索引\n- 同义词实时生效，不需要重新索引\n\n然而，按[Solr Docs](http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory)所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：\n\n- 多字同义词并不能识别为短语查询\n- 罕见同义词的IDF会被加权，导致不可想象的搜索结果\n- 多字同义词不会匹配查询\n\n这有点复杂，因此也值得我们一一解决这些问题。\n\n\n###多字同义词并不能识别为短语查询\n\n在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词： \n\n    breast neoplasm\n    breast neoplasms\n    breast tumor\n    breast tumors\n    cancer of breast\n    cancer of the breast\n \n因此在正常情况下，如果SynonymFilterFactory配置了`expand=\"true\"`,查询”breast cancer“就变成了： \n\n    +((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)\n \n这将命中包含”breast neoplasms“,\"cancer of the breast\"等等的文档。\n\n然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。\n\n啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：\n\n![](/images/blog/2014/graph11.png)\n\n但是，它真正构建的是下面这样的：   \n\n![](/images/blog/2014/graph22.png)\n\n简直是一碗意大利面。\n\n你可怜的文档必须依序包含所有的4个部分。让人惊讶。\n\n同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置`mm=100%`将需要所有4个部分都匹配。\n\n    +((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4\n \n###   罕见同义词的IDF会被加权\n\n即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog\",\"hound\",\"pooch\"例子，查询3个里面的任意一个都会被扩展为：\n\n    +(dog hound pooch)\n \n由于“hound\"和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。\n\n索引时扩展通过给”dog\",\"hound\",\"pooch\"赋予相同的IDF值，而不管原始文档是什么。\n\n###多字同义词不会匹配查询\n最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。  \n\n比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[\"cancer\",\"of\",\"the\",\"breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。\n\n###其他问题\n最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。   \n\n当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。\n \n![](/images/blog/2014/breast_cancer_highlighting2.png)\n\n看完这个[solr bug](https://issues.apache.org/jira/browse/SOLR-3390),这和前面提到的Solr多字同义词扩展是一个原因。\n\n使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。\n\n![](/images/blog/2014/graph33.png)\n\n这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。\n\n从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。\n\n查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。\n\n###总结\n\n所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。\n\n总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。   \n\n**Index-time**\n\n- 索引爆炸\n- 同义词不能立即生效，所有文档需重新索引\n- 同义词不能立即删除\n- 多字同义词导致多余的文字被高亮\n\n\n**Query-time**\n\n- 短语查询不支持\n- 罕见同义词被认为加权了\n- 多字同义词不匹配查询\n\n我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。\n\n回到”dog“/\"hound\"/\"pooch\"的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy & Scratchy & Poochy Show”). 一视同仁感觉是错误的。\n\n同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。  \n\n在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。 \n###Solution\n\n我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。\n\n因此，搜索“dog”为被解析为类似这样：   \n\n    +((dog)^1.2 (hound pooch)^1.1)\n \n1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,\"hound\"或者“pooch”，但是“dog”更优先显示。\n\n这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：   \n\n    +((\"breast cancer\")^1.2 ((\"breast neoplasm\") (\"breast tumor\") (\"cancer ? breast\") (\"cancer ? ? breast\"))^1.1)\n \n(问号?的出现是由于停用词“of”和“the”)\n\n这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。  \n\n我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：\n\n    dog,hound,pooch\n    bite,nibble\n \n\n… then the query will be expanded into:\n\n查询将会被扩展为：\n\n    dog bite\n    hound bite\n    pooch bite\n    dog nibble\n    hound nibble\n    pooch nibble\n\n\n<!--\n\n###尝试一下\n\n使用步骤见<https://github.com/blueshen/hon-lucene-synonyms>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n原文：[Better synonym handling in Solr](http://nolanlawson.com/2012/10/31/better-synonym-handling-in-solr/)\n\n-->","source":"_posts/2014-11-25-better-synonym-handling-in-solr.markdown","raw":"---\nlayout: post\ntitle: \"如何在Solr中更好的处理同义词\"\ndate: 2014-11-25 13:53\ncomments: true\ncategories: solr\ntags: [ 同义词, solr, lucene]\n---\n\n当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)\"?\n\n![小狗](/images/blog/2014/File-Licking_the_staffy_pup.JPG)\n\n叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。\n\n事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。\n\n<!--more-->\n\n###The SynonymFilterFactory\n\nSolr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。   \n\n举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。\n\n当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。\n\n###Index-time vs. query-time\n\n下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。\n\n![Index-time vs. query-time expansion.](/images/blog/2014/index_vs_query_expansion2.png)\n\n你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：\n\n- 索引大小不会变化\n- 同义词可以随时更换，不用更新索引\n- 同义词实时生效，不需要重新索引\n\n然而，按[Solr Docs](http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory)所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：\n\n- 多字同义词并不能识别为短语查询\n- 罕见同义词的IDF会被加权，导致不可想象的搜索结果\n- 多字同义词不会匹配查询\n\n这有点复杂，因此也值得我们一一解决这些问题。\n\n\n###多字同义词并不能识别为短语查询\n\n在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词： \n\n    breast neoplasm\n    breast neoplasms\n    breast tumor\n    breast tumors\n    cancer of breast\n    cancer of the breast\n \n因此在正常情况下，如果SynonymFilterFactory配置了`expand=\"true\"`,查询”breast cancer“就变成了： \n\n    +((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)\n \n这将命中包含”breast neoplasms“,\"cancer of the breast\"等等的文档。\n\n然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。\n\n啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：\n\n![](/images/blog/2014/graph11.png)\n\n但是，它真正构建的是下面这样的：   \n\n![](/images/blog/2014/graph22.png)\n\n简直是一碗意大利面。\n\n你可怜的文档必须依序包含所有的4个部分。让人惊讶。\n\n同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置`mm=100%`将需要所有4个部分都匹配。\n\n    +((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4\n \n###   罕见同义词的IDF会被加权\n\n即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog\",\"hound\",\"pooch\"例子，查询3个里面的任意一个都会被扩展为：\n\n    +(dog hound pooch)\n \n由于“hound\"和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。\n\n索引时扩展通过给”dog\",\"hound\",\"pooch\"赋予相同的IDF值，而不管原始文档是什么。\n\n###多字同义词不会匹配查询\n最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。  \n\n比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[\"cancer\",\"of\",\"the\",\"breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。\n\n###其他问题\n最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。   \n\n当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。\n \n![](/images/blog/2014/breast_cancer_highlighting2.png)\n\n看完这个[solr bug](https://issues.apache.org/jira/browse/SOLR-3390),这和前面提到的Solr多字同义词扩展是一个原因。\n\n使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。\n\n![](/images/blog/2014/graph33.png)\n\n这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。\n\n从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。\n\n查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。\n\n###总结\n\n所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。\n\n总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。   \n\n**Index-time**\n\n- 索引爆炸\n- 同义词不能立即生效，所有文档需重新索引\n- 同义词不能立即删除\n- 多字同义词导致多余的文字被高亮\n\n\n**Query-time**\n\n- 短语查询不支持\n- 罕见同义词被认为加权了\n- 多字同义词不匹配查询\n\n我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。\n\n回到”dog“/\"hound\"/\"pooch\"的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy & Scratchy & Poochy Show”). 一视同仁感觉是错误的。\n\n同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。  \n\n在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。 \n###Solution\n\n我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。\n\n因此，搜索“dog”为被解析为类似这样：   \n\n    +((dog)^1.2 (hound pooch)^1.1)\n \n1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,\"hound\"或者“pooch”，但是“dog”更优先显示。\n\n这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：   \n\n    +((\"breast cancer\")^1.2 ((\"breast neoplasm\") (\"breast tumor\") (\"cancer ? breast\") (\"cancer ? ? breast\"))^1.1)\n \n(问号?的出现是由于停用词“of”和“the”)\n\n这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。  \n\n我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：\n\n    dog,hound,pooch\n    bite,nibble\n \n\n… then the query will be expanded into:\n\n查询将会被扩展为：\n\n    dog bite\n    hound bite\n    pooch bite\n    dog nibble\n    hound nibble\n    pooch nibble\n\n\n<!--\n\n###尝试一下\n\n使用步骤见<https://github.com/blueshen/hon-lucene-synonyms>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---\n原文：[Better synonym handling in Solr](http://nolanlawson.com/2012/10/31/better-synonym-handling-in-solr/)\n\n-->","slug":"2014-11-25-better-synonym-handling-in-solr","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7e0095v8fy66gdyn0i","content":"<p>当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?</p>\n<p><img src=\"/images/blog/2014/File-Licking_the_staffy_pup.JPG\" alt=\"小狗\"></p>\n<p>叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。</p>\n<p>事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。</p>\n<a id=\"more\"></a>\n<p>###The SynonymFilterFactory</p>\n<p>Solr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。   </p>\n<p>举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。</p>\n<p>当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。</p>\n<p>###Index-time vs. query-time</p>\n<p>下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。</p>\n<p><img src=\"/images/blog/2014/index_vs_query_expansion2.png\" alt=\"Index-time vs. query-time expansion.\"></p>\n<p>你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：</p>\n<ul>\n<li>索引大小不会变化</li>\n<li>同义词可以随时更换，不用更新索引</li>\n<li>同义词实时生效，不需要重新索引</li>\n</ul>\n<p>然而，按<a href=\"http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory\" target=\"_blank\" rel=\"external\">Solr Docs</a>所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：</p>\n<ul>\n<li>多字同义词并不能识别为短语查询</li>\n<li>罕见同义词的IDF会被加权，导致不可想象的搜索结果</li>\n<li>多字同义词不会匹配查询</li>\n</ul>\n<p>这有点复杂，因此也值得我们一一解决这些问题。</p>\n<p>###多字同义词并不能识别为短语查询</p>\n<p>在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词： </p>\n<pre><code>breast neoplasm\nbreast neoplasms\nbreast tumor\nbreast tumors\ncancer of breast\ncancer of the breast\n</code></pre><p>因此在正常情况下，如果SynonymFilterFactory配置了<code>expand=&quot;true&quot;</code>,查询”breast cancer“就变成了： </p>\n<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)\n</code></pre><p>这将命中包含”breast neoplasms“,”cancer of the breast”等等的文档。</p>\n<p>然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。</p>\n<p>啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：</p>\n<p><img src=\"/images/blog/2014/graph11.png\" alt=\"\"></p>\n<p>但是，它真正构建的是下面这样的：   </p>\n<p><img src=\"/images/blog/2014/graph22.png\" alt=\"\"></p>\n<p>简直是一碗意大利面。</p>\n<p>你可怜的文档必须依序包含所有的4个部分。让人惊讶。</p>\n<p>同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置<code>mm=100%</code>将需要所有4个部分都匹配。</p>\n<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4\n</code></pre><h3 id=\"罕见同义词的IDF会被加权\"><a href=\"#罕见同义词的IDF会被加权\" class=\"headerlink\" title=\"罕见同义词的IDF会被加权\"></a>罕见同义词的IDF会被加权</h3><p>即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog”,”hound”,”pooch”例子，查询3个里面的任意一个都会被扩展为：</p>\n<pre><code>+(dog hound pooch)\n</code></pre><p>由于“hound”和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。</p>\n<p>索引时扩展通过给”dog”,”hound”,”pooch”赋予相同的IDF值，而不管原始文档是什么。</p>\n<p>###多字同义词不会匹配查询<br>最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。  </p>\n<p>比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[“cancer”,”of”,”the”,”breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。</p>\n<p>###其他问题<br>最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。   </p>\n<p>当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。</p>\n<p><img src=\"/images/blog/2014/breast_cancer_highlighting2.png\" alt=\"\"></p>\n<p>看完这个<a href=\"https://issues.apache.org/jira/browse/SOLR-3390\" target=\"_blank\" rel=\"external\">solr bug</a>,这和前面提到的Solr多字同义词扩展是一个原因。</p>\n<p>使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。</p>\n<p><img src=\"/images/blog/2014/graph33.png\" alt=\"\"></p>\n<p>这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。</p>\n<p>从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。</p>\n<p>查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。</p>\n<p>###总结</p>\n<p>所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。</p>\n<p>总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。   </p>\n<p><strong>Index-time</strong></p>\n<ul>\n<li>索引爆炸</li>\n<li>同义词不能立即生效，所有文档需重新索引</li>\n<li>同义词不能立即删除</li>\n<li>多字同义词导致多余的文字被高亮</li>\n</ul>\n<p><strong>Query-time</strong></p>\n<ul>\n<li>短语查询不支持</li>\n<li>罕见同义词被认为加权了</li>\n<li>多字同义词不匹配查询</li>\n</ul>\n<p>我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。</p>\n<p>回到”dog“/“hound”/“pooch”的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy &amp; Scratchy &amp; Poochy Show”). 一视同仁感觉是错误的。</p>\n<p>同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。  </p>\n<p>在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。 </p>\n<p>###Solution</p>\n<p>我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。</p>\n<p>因此，搜索“dog”为被解析为类似这样：   </p>\n<pre><code>+((dog)^1.2 (hound pooch)^1.1)\n</code></pre><p>1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,”hound”或者“pooch”，但是“dog”更优先显示。</p>\n<p>这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：   </p>\n<pre><code>+((&quot;breast cancer&quot;)^1.2 ((&quot;breast neoplasm&quot;) (&quot;breast tumor&quot;) (&quot;cancer ? breast&quot;) (&quot;cancer ? ? breast&quot;))^1.1)\n</code></pre><p>(问号?的出现是由于停用词“of”和“the”)</p>\n<p>这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。  </p>\n<p>我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：</p>\n<pre><code>dog,hound,pooch\nbite,nibble\n</code></pre><p>… then the query will be expanded into:</p>\n<p>查询将会被扩展为：</p>\n<pre><code>dog bite\nhound bite\npooch bite\ndog nibble\nhound nibble\npooch nibble\n</code></pre><a href=\"!--\n\n###尝试一下\n\n使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms\">!--\n\n###尝试一下\n\n使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms</a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>—<br>原文：<a href=\"http://nolanlawson.com/2012/10/31/better-synonym-handling-in-solr/\" target=\"_blank\" rel=\"external\">Better synonym handling in Solr</a><br><br>–&gt;","excerpt":"<p>当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?</p>\n<p><img src=\"/images/blog/2014/File-Licking_the_staffy_pup.JPG\" alt=\"小狗\"></p>\n<p>叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。</p>\n<p>事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。</p>","more":"<p>###The SynonymFilterFactory</p>\n<p>Solr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。   </p>\n<p>举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。</p>\n<p>当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。</p>\n<p>###Index-time vs. query-time</p>\n<p>下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。</p>\n<p><img src=\"/images/blog/2014/index_vs_query_expansion2.png\" alt=\"Index-time vs. query-time expansion.\"></p>\n<p>你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：</p>\n<ul>\n<li>索引大小不会变化</li>\n<li>同义词可以随时更换，不用更新索引</li>\n<li>同义词实时生效，不需要重新索引</li>\n</ul>\n<p>然而，按<a href=\"http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory\">Solr Docs</a>所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：</p>\n<ul>\n<li>多字同义词并不能识别为短语查询</li>\n<li>罕见同义词的IDF会被加权，导致不可想象的搜索结果</li>\n<li>多字同义词不会匹配查询</li>\n</ul>\n<p>这有点复杂，因此也值得我们一一解决这些问题。</p>\n<p>###多字同义词并不能识别为短语查询</p>\n<p>在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词： </p>\n<pre><code>breast neoplasm\nbreast neoplasms\nbreast tumor\nbreast tumors\ncancer of breast\ncancer of the breast\n</code></pre><p>因此在正常情况下，如果SynonymFilterFactory配置了<code>expand=&quot;true&quot;</code>,查询”breast cancer“就变成了： </p>\n<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)\n</code></pre><p>这将命中包含”breast neoplasms“,”cancer of the breast”等等的文档。</p>\n<p>然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。</p>\n<p>啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：</p>\n<p><img src=\"/images/blog/2014/graph11.png\" alt=\"\"></p>\n<p>但是，它真正构建的是下面这样的：   </p>\n<p><img src=\"/images/blog/2014/graph22.png\" alt=\"\"></p>\n<p>简直是一碗意大利面。</p>\n<p>你可怜的文档必须依序包含所有的4个部分。让人惊讶。</p>\n<p>同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置<code>mm=100%</code>将需要所有4个部分都匹配。</p>\n<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4\n</code></pre><h3 id=\"罕见同义词的IDF会被加权\"><a href=\"#罕见同义词的IDF会被加权\" class=\"headerlink\" title=\"罕见同义词的IDF会被加权\"></a>罕见同义词的IDF会被加权</h3><p>即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog”,”hound”,”pooch”例子，查询3个里面的任意一个都会被扩展为：</p>\n<pre><code>+(dog hound pooch)\n</code></pre><p>由于“hound”和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。</p>\n<p>索引时扩展通过给”dog”,”hound”,”pooch”赋予相同的IDF值，而不管原始文档是什么。</p>\n<p>###多字同义词不会匹配查询<br>最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。  </p>\n<p>比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[“cancer”,”of”,”the”,”breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。</p>\n<p>###其他问题<br>最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。   </p>\n<p>当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。</p>\n<p><img src=\"/images/blog/2014/breast_cancer_highlighting2.png\" alt=\"\"></p>\n<p>看完这个<a href=\"https://issues.apache.org/jira/browse/SOLR-3390\">solr bug</a>,这和前面提到的Solr多字同义词扩展是一个原因。</p>\n<p>使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。</p>\n<p><img src=\"/images/blog/2014/graph33.png\" alt=\"\"></p>\n<p>这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。</p>\n<p>从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。</p>\n<p>查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。</p>\n<p>###总结</p>\n<p>所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。</p>\n<p>总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。   </p>\n<p><strong>Index-time</strong></p>\n<ul>\n<li>索引爆炸</li>\n<li>同义词不能立即生效，所有文档需重新索引</li>\n<li>同义词不能立即删除</li>\n<li>多字同义词导致多余的文字被高亮</li>\n</ul>\n<p><strong>Query-time</strong></p>\n<ul>\n<li>短语查询不支持</li>\n<li>罕见同义词被认为加权了</li>\n<li>多字同义词不匹配查询</li>\n</ul>\n<p>我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。</p>\n<p>回到”dog“/“hound”/“pooch”的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy &amp; Scratchy &amp; Poochy Show”). 一视同仁感觉是错误的。</p>\n<p>同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。  </p>\n<p>在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。 </p>\n<p>###Solution</p>\n<p>我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。</p>\n<p>因此，搜索“dog”为被解析为类似这样：   </p>\n<pre><code>+((dog)^1.2 (hound pooch)^1.1)\n</code></pre><p>1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,”hound”或者“pooch”，但是“dog”更优先显示。</p>\n<p>这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：   </p>\n<pre><code>+((&quot;breast cancer&quot;)^1.2 ((&quot;breast neoplasm&quot;) (&quot;breast tumor&quot;) (&quot;cancer ? breast&quot;) (&quot;cancer ? ? breast&quot;))^1.1)\n</code></pre><p>(问号?的出现是由于停用词“of”和“the”)</p>\n<p>这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。  </p>\n<p>我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：</p>\n<pre><code>dog,hound,pooch\nbite,nibble\n</code></pre><p>… then the query will be expanded into:</p>\n<p>查询将会被扩展为：</p>\n<pre><code>dog bite\nhound bite\npooch bite\ndog nibble\nhound nibble\npooch nibble\n</code></pre><a href=\"!--\n\n###尝试一下\n\n使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms\">!--\n\n###尝试一下\n\n使用步骤见&lt;https://github.com/blueshen/hon-lucene-synonyms</a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>—<br>原文：<a href=\"http://nolanlawson.com/2012/10/31/better-synonym-handling-in-solr/\">Better synonym handling in Solr</a><br><br>–&gt;"},{"layout":"post","title":"Hadoop1.2.1安装部署","date":"2014-11-13T05:24:00.000Z","comments":1,"_content":"###安装需求\n- Java 1.6\n- ssh,sshd正常安装\n\n确保可以ssh到localhost，并且不需要密码\n\n    ssh localhost\n 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。\n 运行：  \n \n    ps -ef | grep sshd \n查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。\n\n    sudo apt-get install openssh-server\n\n然后再执行`ssh localhost`,如果不能无密码登陆，需要做一下操作：\n\n        ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa \n        cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n\n<!--more-->\n###相关软件\nUbuntu Linux为例：\n\n     sudo apt-get install ssh \n     sudo apt-get install rsync\n     \n###Hadoop下载\n从[Hadoop官网](http://hadoop.apache.org/releases.html)下载一个稳定版，这里就是1.2.1版本啦。\n\n    wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz\n    \n ###启动Hadoop\n \n 1.解压`tar -xzvf hadoop-1.2.1.tar.gz `，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。\n \n    export JAVA_HOME=/path/to/java/home\n \n 2.进入/hadoop-1.2.1目录，运行`bin\\hadoop`,会显示hadoop的使用说明信息。 \n \n      Usage: hadoop [--config confdir] COMMAND\n      where COMMAND is one of:\n      namenode -format     format the DFS filesystem\n      secondarynamenode    run the DFS secondary namenode\n      namenode             run the DFS namenode\n      datanode             run a DFS datanode\n      dfsadmin             run a DFS admin client\n      mradmin              run a Map-Reduce admin client\n      fsck                 run a DFS filesystem checking utility\n      fs                   run a generic filesystem user client\n      balancer             run a cluster balancing utility\n      oiv                  apply the offline fsimage viewer to an fsimage\n      fetchdt              fetch a delegation token from the NameNode\n      jobtracker           run the MapReduce job Tracker node\n      pipes                run a Pipes job\n      tasktracker          run a MapReduce task Tracker node\n      historyserver        run job history servers as a standalone daemon\n      job                  manipulate MapReduce jobs\n      queue                get information regarding JobQueues\n      version              print the version\n      jar <jar>            run a jar file\n      distcp <srcurl> <desturl> copy file or directories recursively\n      distcp2 <srcurl> <desturl> DistCp version 2\n      archive -archiveName NAME -p <parent path> <src>* <dest> create a hadoop archive\n      classpath            prints the class path needed to get the\n                           Hadoop jar and the required libraries\n      daemonlog            get/set the log level for each daemon\n     or\n      CLASSNAME            run the class named CLASSNAME\n    Most commands print help when invoked w/o parameters.\n  你可以下3中模式来启动hadoop：\n  \n  - 本地(standalone)模式\n  - 伪分布(Pseudo-Distributed)式\n  - 全分布(Full-Distributed)式\n  \n####本地(Standalone)模式安装\n  默认情况下，Hadoop就是单机本地模式。方便调试。   \n  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录\n\n        $ mkdir input \n        $ cp conf/*.xml input \n        $ bin/hadoop jar hadoop-examples-*.jar grep input output 'dfs[a-z.]+' \n        $ cat output/*\n        \n####伪分布(Pseudo-Distributed)式\n配置conf/core-site.xml\n\n    <configuration>\n         <property>\n             <name>fs.default.name</name>\n             <value>hdfs://localhost:9000</value>\n         </property>\n    </configuration>\n配置conf/hdfs-site.xml\n\n    <configuration>\n         <property>\n             <name>dfs.replication</name>\n             <value>1</value>\n         </property>\n    </configuration>\n    \n配置conf/mapred-site.xml:\n\n    <configuration>\n         <property>\n             <name>mapred.job.tracker</name>\n             <value>localhost:9001</value>\n         </property>\n    </configuration>\n    \n  格式化一个新的distributed-filesystem\n  \n     bin/hadoop namenode -format\n     \n 启动hadoop：\n \n    bin/start-all.sh\n    \n  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker\n  \n- NameNode - <http://localhost:50070/dfshealth.jsp/>\n- JobTracker - <http://localhost:50030/jobtracker.jsp/>\n- TaskTracker - <http://localhost:50060/tasktracker.jsp>\n \n 下面使用distributed filesystem来跑样例:\n 拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。\n \n    $ bin/hadoop fs -put conf input\n\n运行:\n    $ bin/hadoop jar hadoop-examples-*.jar grep input output 'dfs[a-z.]+'\n\n检查结果：\n\n拷贝output目录到本地并检查:\n    $ bin/hadoop fs -get output output \n    $ cat output/*\n\n或者直接在distributed filesystem查看: \n\n    $ bin/hadoop fs -cat output/*\n\n使用完，可以这样来关闭：\n\n    $ bin/stop-all.sh\n \n \n####Hadoop分布式部署\n 详见<http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html>\n \n---\n参考文档：<http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html>","source":"_posts/2014-11-13-install-hadoop.markdown","raw":"---\nlayout: post\ntitle: \"Hadoop1.2.1安装部署\"\ndate: 2014-11-13 13:24\ncomments: true\ncategories: hadoop\ntags: [ hadoop, linux]\n---\n###安装需求\n- Java 1.6\n- ssh,sshd正常安装\n\n确保可以ssh到localhost，并且不需要密码\n\n    ssh localhost\n 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。\n 运行：  \n \n    ps -ef | grep sshd \n查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。\n\n    sudo apt-get install openssh-server\n\n然后再执行`ssh localhost`,如果不能无密码登陆，需要做一下操作：\n\n        ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa \n        cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n\n<!--more-->\n###相关软件\nUbuntu Linux为例：\n\n     sudo apt-get install ssh \n     sudo apt-get install rsync\n     \n###Hadoop下载\n从[Hadoop官网](http://hadoop.apache.org/releases.html)下载一个稳定版，这里就是1.2.1版本啦。\n\n    wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz\n    \n ###启动Hadoop\n \n 1.解压`tar -xzvf hadoop-1.2.1.tar.gz `，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。\n \n    export JAVA_HOME=/path/to/java/home\n \n 2.进入/hadoop-1.2.1目录，运行`bin\\hadoop`,会显示hadoop的使用说明信息。 \n \n      Usage: hadoop [--config confdir] COMMAND\n      where COMMAND is one of:\n      namenode -format     format the DFS filesystem\n      secondarynamenode    run the DFS secondary namenode\n      namenode             run the DFS namenode\n      datanode             run a DFS datanode\n      dfsadmin             run a DFS admin client\n      mradmin              run a Map-Reduce admin client\n      fsck                 run a DFS filesystem checking utility\n      fs                   run a generic filesystem user client\n      balancer             run a cluster balancing utility\n      oiv                  apply the offline fsimage viewer to an fsimage\n      fetchdt              fetch a delegation token from the NameNode\n      jobtracker           run the MapReduce job Tracker node\n      pipes                run a Pipes job\n      tasktracker          run a MapReduce task Tracker node\n      historyserver        run job history servers as a standalone daemon\n      job                  manipulate MapReduce jobs\n      queue                get information regarding JobQueues\n      version              print the version\n      jar <jar>            run a jar file\n      distcp <srcurl> <desturl> copy file or directories recursively\n      distcp2 <srcurl> <desturl> DistCp version 2\n      archive -archiveName NAME -p <parent path> <src>* <dest> create a hadoop archive\n      classpath            prints the class path needed to get the\n                           Hadoop jar and the required libraries\n      daemonlog            get/set the log level for each daemon\n     or\n      CLASSNAME            run the class named CLASSNAME\n    Most commands print help when invoked w/o parameters.\n  你可以下3中模式来启动hadoop：\n  \n  - 本地(standalone)模式\n  - 伪分布(Pseudo-Distributed)式\n  - 全分布(Full-Distributed)式\n  \n####本地(Standalone)模式安装\n  默认情况下，Hadoop就是单机本地模式。方便调试。   \n  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录\n\n        $ mkdir input \n        $ cp conf/*.xml input \n        $ bin/hadoop jar hadoop-examples-*.jar grep input output 'dfs[a-z.]+' \n        $ cat output/*\n        \n####伪分布(Pseudo-Distributed)式\n配置conf/core-site.xml\n\n    <configuration>\n         <property>\n             <name>fs.default.name</name>\n             <value>hdfs://localhost:9000</value>\n         </property>\n    </configuration>\n配置conf/hdfs-site.xml\n\n    <configuration>\n         <property>\n             <name>dfs.replication</name>\n             <value>1</value>\n         </property>\n    </configuration>\n    \n配置conf/mapred-site.xml:\n\n    <configuration>\n         <property>\n             <name>mapred.job.tracker</name>\n             <value>localhost:9001</value>\n         </property>\n    </configuration>\n    \n  格式化一个新的distributed-filesystem\n  \n     bin/hadoop namenode -format\n     \n 启动hadoop：\n \n    bin/start-all.sh\n    \n  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker\n  \n- NameNode - <http://localhost:50070/dfshealth.jsp/>\n- JobTracker - <http://localhost:50030/jobtracker.jsp/>\n- TaskTracker - <http://localhost:50060/tasktracker.jsp>\n \n 下面使用distributed filesystem来跑样例:\n 拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。\n \n    $ bin/hadoop fs -put conf input\n\n运行:\n    $ bin/hadoop jar hadoop-examples-*.jar grep input output 'dfs[a-z.]+'\n\n检查结果：\n\n拷贝output目录到本地并检查:\n    $ bin/hadoop fs -get output output \n    $ cat output/*\n\n或者直接在distributed filesystem查看: \n\n    $ bin/hadoop fs -cat output/*\n\n使用完，可以这样来关闭：\n\n    $ bin/stop-all.sh\n \n \n####Hadoop分布式部署\n 详见<http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html>\n \n---\n参考文档：<http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html>","slug":"2014-11-13-install-hadoop","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7h0098v8fyf1dqo17l","content":"<p>###安装需求</p>\n<ul>\n<li>Java 1.6</li>\n<li>ssh,sshd正常安装</li>\n</ul>\n<p>确保可以ssh到localhost，并且不需要密码</p>\n<pre><code>ssh localhost\n</code></pre><p> 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。<br> 运行：  </p>\n<pre><code>ps -ef | grep sshd \n</code></pre><p>查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。</p>\n<pre><code>sudo apt-get install openssh-server\n</code></pre><p>然后再执行<code>ssh localhost</code>,如果不能无密码登陆，需要做一下操作：</p>\n<pre><code>ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa \ncat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys\n</code></pre><a id=\"more\"></a>\n<p>###相关软件<br>Ubuntu Linux为例：</p>\n<pre><code>sudo apt-get install ssh \nsudo apt-get install rsync\n</code></pre><p>###Hadoop下载<br>从<a href=\"http://hadoop.apache.org/releases.html\" target=\"_blank\" rel=\"external\">Hadoop官网</a>下载一个稳定版，这里就是1.2.1版本啦。</p>\n<pre><code>wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz\n</code></pre><p> ###启动Hadoop</p>\n<p> 1.解压<code>tar -xzvf hadoop-1.2.1.tar.gz</code>，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。</p>\n<pre><code>export JAVA_HOME=/path/to/java/home\n</code></pre><p> 2.进入/hadoop-1.2.1目录，运行<code>bin\\hadoop</code>,会显示hadoop的使用说明信息。 </p>\n<pre><code>  Usage: hadoop [--config confdir] COMMAND\n  where COMMAND is one of:\n  namenode -format     format the DFS filesystem\n  secondarynamenode    run the DFS secondary namenode\n  namenode             run the DFS namenode\n  datanode             run a DFS datanode\n  dfsadmin             run a DFS admin client\n  mradmin              run a Map-Reduce admin client\n  fsck                 run a DFS filesystem checking utility\n  fs                   run a generic filesystem user client\n  balancer             run a cluster balancing utility\n  oiv                  apply the offline fsimage viewer to an fsimage\n  fetchdt              fetch a delegation token from the NameNode\n  jobtracker           run the MapReduce job Tracker node\n  pipes                run a Pipes job\n  tasktracker          run a MapReduce task Tracker node\n  historyserver        run job history servers as a standalone daemon\n  job                  manipulate MapReduce jobs\n  queue                get information regarding JobQueues\n  version              print the version\n  jar &lt;jar&gt;            run a jar file\n  distcp &lt;srcurl&gt; &lt;desturl&gt; copy file or directories recursively\n  distcp2 &lt;srcurl&gt; &lt;desturl&gt; DistCp version 2\n  archive -archiveName NAME -p &lt;parent path&gt; &lt;src&gt;* &lt;dest&gt; create a hadoop archive\n  classpath            prints the class path needed to get the\n                       Hadoop jar and the required libraries\n  daemonlog            get/set the log level for each daemon\n or\n  CLASSNAME            run the class named CLASSNAME\nMost commands print help when invoked w/o parameters.\n</code></pre><p>  你可以下3中模式来启动hadoop：</p>\n<ul>\n<li>本地(standalone)模式</li>\n<li>伪分布(Pseudo-Distributed)式</li>\n<li>全分布(Full-Distributed)式</li>\n</ul>\n<p>####本地(Standalone)模式安装<br>  默认情况下，Hadoop就是单机本地模式。方便调试。<br>  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录</p>\n<pre><code>$ mkdir input \n$ cp conf/*.xml input \n$ bin/hadoop jar hadoop-examples-*.jar grep input output &apos;dfs[a-z.]+&apos; \n$ cat output/*\n</code></pre><p>####伪分布(Pseudo-Distributed)式<br>配置conf/core-site.xml</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;fs.default.name&lt;/name&gt;\n         &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>配置conf/hdfs-site.xml</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;dfs.replication&lt;/name&gt;\n         &lt;value&gt;1&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>配置conf/mapred-site.xml:</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;mapred.job.tracker&lt;/name&gt;\n         &lt;value&gt;localhost:9001&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>  格式化一个新的distributed-filesystem</p>\n<pre><code>bin/hadoop namenode -format\n</code></pre><p> 启动hadoop：</p>\n<pre><code>bin/start-all.sh\n</code></pre><p>  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker</p>\n<ul>\n<li>NameNode - <a href=\"http://localhost:50070/dfshealth.jsp/\" target=\"_blank\" rel=\"external\">http://localhost:50070/dfshealth.jsp/</a></li>\n<li>JobTracker - <a href=\"http://localhost:50030/jobtracker.jsp/\" target=\"_blank\" rel=\"external\">http://localhost:50030/jobtracker.jsp/</a></li>\n<li><p>TaskTracker - <a href=\"http://localhost:50060/tasktracker.jsp\" target=\"_blank\" rel=\"external\">http://localhost:50060/tasktracker.jsp</a></p>\n<p>下面使用distributed filesystem来跑样例:<br>拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。</p>\n<p>  $ bin/hadoop fs -put conf input</p>\n</li>\n</ul>\n<p>运行:<br>    $ bin/hadoop jar hadoop-examples-*.jar grep input output ‘dfs[a-z.]+’</p>\n<p>检查结果：</p>\n<p>拷贝output目录到本地并检查:<br>    $ bin/hadoop fs -get output output<br>    $ cat output/*</p>\n<p>或者直接在distributed filesystem查看: </p>\n<pre><code>$ bin/hadoop fs -cat output/*\n</code></pre><p>使用完，可以这样来关闭：</p>\n<pre><code>$ bin/stop-all.sh\n</code></pre><p>####Hadoop分布式部署<br> 详见<a href=\"http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html</a></p>\n<hr>\n<p>参考文档：<a href=\"http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html</a></p>\n","excerpt":"<p>###安装需求</p>\n<ul>\n<li>Java 1.6</li>\n<li>ssh,sshd正常安装</li>\n</ul>\n<p>确保可以ssh到localhost，并且不需要密码</p>\n<pre><code>ssh localhost\n</code></pre><p> 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。<br> 运行：  </p>\n<pre><code>ps -ef | grep sshd \n</code></pre><p>查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。</p>\n<pre><code>sudo apt-get install openssh-server\n</code></pre><p>然后再执行<code>ssh localhost</code>,如果不能无密码登陆，需要做一下操作：</p>\n<pre><code>ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa \ncat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys\n</code></pre>","more":"<p>###相关软件<br>Ubuntu Linux为例：</p>\n<pre><code>sudo apt-get install ssh \nsudo apt-get install rsync\n</code></pre><p>###Hadoop下载<br>从<a href=\"http://hadoop.apache.org/releases.html\">Hadoop官网</a>下载一个稳定版，这里就是1.2.1版本啦。</p>\n<pre><code>wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz\n</code></pre><p> ###启动Hadoop</p>\n<p> 1.解压<code>tar -xzvf hadoop-1.2.1.tar.gz</code>，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。</p>\n<pre><code>export JAVA_HOME=/path/to/java/home\n</code></pre><p> 2.进入/hadoop-1.2.1目录，运行<code>bin\\hadoop</code>,会显示hadoop的使用说明信息。 </p>\n<pre><code>  Usage: hadoop [--config confdir] COMMAND\n  where COMMAND is one of:\n  namenode -format     format the DFS filesystem\n  secondarynamenode    run the DFS secondary namenode\n  namenode             run the DFS namenode\n  datanode             run a DFS datanode\n  dfsadmin             run a DFS admin client\n  mradmin              run a Map-Reduce admin client\n  fsck                 run a DFS filesystem checking utility\n  fs                   run a generic filesystem user client\n  balancer             run a cluster balancing utility\n  oiv                  apply the offline fsimage viewer to an fsimage\n  fetchdt              fetch a delegation token from the NameNode\n  jobtracker           run the MapReduce job Tracker node\n  pipes                run a Pipes job\n  tasktracker          run a MapReduce task Tracker node\n  historyserver        run job history servers as a standalone daemon\n  job                  manipulate MapReduce jobs\n  queue                get information regarding JobQueues\n  version              print the version\n  jar &lt;jar&gt;            run a jar file\n  distcp &lt;srcurl&gt; &lt;desturl&gt; copy file or directories recursively\n  distcp2 &lt;srcurl&gt; &lt;desturl&gt; DistCp version 2\n  archive -archiveName NAME -p &lt;parent path&gt; &lt;src&gt;* &lt;dest&gt; create a hadoop archive\n  classpath            prints the class path needed to get the\n                       Hadoop jar and the required libraries\n  daemonlog            get/set the log level for each daemon\n or\n  CLASSNAME            run the class named CLASSNAME\nMost commands print help when invoked w/o parameters.\n</code></pre><p>  你可以下3中模式来启动hadoop：</p>\n<ul>\n<li>本地(standalone)模式</li>\n<li>伪分布(Pseudo-Distributed)式</li>\n<li>全分布(Full-Distributed)式</li>\n</ul>\n<p>####本地(Standalone)模式安装<br>  默认情况下，Hadoop就是单机本地模式。方便调试。<br>  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录</p>\n<pre><code>$ mkdir input \n$ cp conf/*.xml input \n$ bin/hadoop jar hadoop-examples-*.jar grep input output &apos;dfs[a-z.]+&apos; \n$ cat output/*\n</code></pre><p>####伪分布(Pseudo-Distributed)式<br>配置conf/core-site.xml</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;fs.default.name&lt;/name&gt;\n         &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>配置conf/hdfs-site.xml</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;dfs.replication&lt;/name&gt;\n         &lt;value&gt;1&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>配置conf/mapred-site.xml:</p>\n<pre><code>&lt;configuration&gt;\n     &lt;property&gt;\n         &lt;name&gt;mapred.job.tracker&lt;/name&gt;\n         &lt;value&gt;localhost:9001&lt;/value&gt;\n     &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre><p>  格式化一个新的distributed-filesystem</p>\n<pre><code>bin/hadoop namenode -format\n</code></pre><p> 启动hadoop：</p>\n<pre><code>bin/start-all.sh\n</code></pre><p>  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker</p>\n<ul>\n<li>NameNode - <a href=\"http://localhost:50070/dfshealth.jsp/\">http://localhost:50070/dfshealth.jsp/</a></li>\n<li>JobTracker - <a href=\"http://localhost:50030/jobtracker.jsp/\">http://localhost:50030/jobtracker.jsp/</a></li>\n<li><p>TaskTracker - <a href=\"http://localhost:50060/tasktracker.jsp\">http://localhost:50060/tasktracker.jsp</a></p>\n<p>下面使用distributed filesystem来跑样例:<br>拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。</p>\n<p>  $ bin/hadoop fs -put conf input</p>\n</li>\n</ul>\n<p>运行:<br>    $ bin/hadoop jar hadoop-examples-*.jar grep input output ‘dfs[a-z.]+’</p>\n<p>检查结果：</p>\n<p>拷贝output目录到本地并检查:<br>    $ bin/hadoop fs -get output output<br>    $ cat output/*</p>\n<p>或者直接在distributed filesystem查看: </p>\n<pre><code>$ bin/hadoop fs -cat output/*\n</code></pre><p>使用完，可以这样来关闭：</p>\n<pre><code>$ bin/stop-all.sh\n</code></pre><p>####Hadoop分布式部署<br> 详见<a href=\"http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html\">http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html</a></p>\n<hr>\n<p>参考文档：<a href=\"http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html\">http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html</a></p>"},{"layout":"post","title":"关于C3P0容错和自动重连特性的研究","date":"2015-03-26T05:07:00.000Z","comments":1,"_content":"\n最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。\n\n####1）C3P0容错和自动重连与以下配置参数有关：\n\n`breakAfterAcquireFailure` ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false\n<!--more-->\n`idleConnectionTestPeriod` ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。\n\n`testConnectionOnCheckout` ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。\n\n`testConnectionOnCheckin` ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。\n\n`acquireRetryAttempts 和acquireRetryDelay` ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数>池内能提供的连接数\n\n`automaticTestTable 、connectionTesterClassName 、preferredTestQuery` ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释\n\n`maxIdleTime 和 maxConnectionAge` ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间\n\n####2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。\n\n####3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection\n\n####4）breakAfterAcquireFailure=false是关键。\n如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接\n\n####5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。\n\n####6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性\n\n####7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行\n\n综上所述，要想保证性能的前提下，本人推荐的配置组合如下：\n\n\n    breakAfterAcquireFailure: false\n    testConnectionOnCheckout: false\n    testConnectionOnCheckin: false\n    idleConnectionTestPeriod: 60\n    acquireRetryAttempts: 10\n    acquireRetryDelay: 1000\n\n\n但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。\n\n在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：\n\n- 1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。\n\n- 2）根据请求情况和配置，pool向数据库请求新连接并加入池内\n\n- 3）应用端getConnection->是否发生异常->如果发生异常，检验其有效性，并剔除出pool->如果没有发生异常（自动检查task之前已检测），调用成功\n","source":"_posts/2015-03-26-c3p0-config.markdown","raw":"---\nlayout: post\ntitle: \"关于C3P0容错和自动重连特性的研究\"\ndate: 2015-03-26 13:07\ncomments: true\ncategories: c3p0\ntags: [ c3p0, dhcp]\n---\n\n最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。\n\n####1）C3P0容错和自动重连与以下配置参数有关：\n\n`breakAfterAcquireFailure` ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false\n<!--more-->\n`idleConnectionTestPeriod` ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。\n\n`testConnectionOnCheckout` ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。\n\n`testConnectionOnCheckin` ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。\n\n`acquireRetryAttempts 和acquireRetryDelay` ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数>池内能提供的连接数\n\n`automaticTestTable 、connectionTesterClassName 、preferredTestQuery` ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释\n\n`maxIdleTime 和 maxConnectionAge` ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间\n\n####2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。\n\n####3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection\n\n####4）breakAfterAcquireFailure=false是关键。\n如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接\n\n####5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。\n\n####6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性\n\n####7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行\n\n综上所述，要想保证性能的前提下，本人推荐的配置组合如下：\n\n\n    breakAfterAcquireFailure: false\n    testConnectionOnCheckout: false\n    testConnectionOnCheckin: false\n    idleConnectionTestPeriod: 60\n    acquireRetryAttempts: 10\n    acquireRetryDelay: 1000\n\n\n但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。\n\n在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：\n\n- 1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。\n\n- 2）根据请求情况和配置，pool向数据库请求新连接并加入池内\n\n- 3）应用端getConnection->是否发生异常->如果发生异常，检验其有效性，并剔除出pool->如果没有发生异常（自动检查task之前已检测），调用成功\n","slug":"2015-03-26-c3p0-config","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7j009bv8fytzdddjwa","content":"<p>最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。</p>\n<p>####1）C3P0容错和自动重连与以下配置参数有关：</p>\n<p><code>breakAfterAcquireFailure</code> ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false<br><a id=\"more\"></a><br><code>idleConnectionTestPeriod</code> ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。</p>\n<p><code>testConnectionOnCheckout</code> ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。</p>\n<p><code>testConnectionOnCheckin</code> ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。</p>\n<p><code>acquireRetryAttempts 和acquireRetryDelay</code> ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数&gt;池内能提供的连接数</p>\n<p><code>automaticTestTable 、connectionTesterClassName 、preferredTestQuery</code> ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释</p>\n<p><code>maxIdleTime 和 maxConnectionAge</code> ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间</p>\n<p>####2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。</p>\n<p>####3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection</p>\n<p>####4）breakAfterAcquireFailure=false是关键。<br>如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接</p>\n<p>####5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。</p>\n<p>####6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性</p>\n<p>####7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行</p>\n<p>综上所述，要想保证性能的前提下，本人推荐的配置组合如下：</p>\n<pre><code>breakAfterAcquireFailure: false\ntestConnectionOnCheckout: false\ntestConnectionOnCheckin: false\nidleConnectionTestPeriod: 60\nacquireRetryAttempts: 10\nacquireRetryDelay: 1000\n</code></pre><p>但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。</p>\n<p>在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：</p>\n<ul>\n<li><p>1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。</p>\n</li>\n<li><p>2）根据请求情况和配置，pool向数据库请求新连接并加入池内</p>\n</li>\n<li><p>3）应用端getConnection-&gt;是否发生异常-&gt;如果发生异常，检验其有效性，并剔除出pool-&gt;如果没有发生异常（自动检查task之前已检测），调用成功</p>\n</li>\n</ul>\n","excerpt":"<p>最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。</p>\n<p>####1）C3P0容错和自动重连与以下配置参数有关：</p>\n<p><code>breakAfterAcquireFailure</code> ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false<br>","more":"<br><code>idleConnectionTestPeriod</code> ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。</p>\n<p><code>testConnectionOnCheckout</code> ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。</p>\n<p><code>testConnectionOnCheckin</code> ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。</p>\n<p><code>acquireRetryAttempts 和acquireRetryDelay</code> ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数&gt;池内能提供的连接数</p>\n<p><code>automaticTestTable 、connectionTesterClassName 、preferredTestQuery</code> ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释</p>\n<p><code>maxIdleTime 和 maxConnectionAge</code> ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间</p>\n<p>####2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。</p>\n<p>####3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection</p>\n<p>####4）breakAfterAcquireFailure=false是关键。<br>如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接</p>\n<p>####5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。</p>\n<p>####6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性</p>\n<p>####7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行</p>\n<p>综上所述，要想保证性能的前提下，本人推荐的配置组合如下：</p>\n<pre><code>breakAfterAcquireFailure: false\ntestConnectionOnCheckout: false\ntestConnectionOnCheckin: false\nidleConnectionTestPeriod: 60\nacquireRetryAttempts: 10\nacquireRetryDelay: 1000\n</code></pre><p>但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。</p>\n<p>在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：</p>\n<ul>\n<li><p>1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。</p>\n</li>\n<li><p>2）根据请求情况和配置，pool向数据库请求新连接并加入池内</p>\n</li>\n<li><p>3）应用端getConnection-&gt;是否发生异常-&gt;如果发生异常，检验其有效性，并剔除出pool-&gt;如果没有发生异常（自动检查task之前已检测），调用成功</p>\n</li>\n</ul>"},{"layout":"post","title":"关于接口定义的一些想法","description":"","_content":"\n最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。\n\n### 使用RESTFul接口\nRESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.\n\n\n### 解决接口联调的苦难\n作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。\n因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。\n\n- swagger-maven-plugin\n- swagger-ui\n\n\n### 项目中遇到的一些教训\n作为技术负责人\n\n- 提前制定接口，方便联调\n- 提前规划返回接口类型，统一字段名称。","source":"_posts/2015-11-04-about-interface-define.md","raw":"---\nlayout: post\ntitle: \"关于接口定义的一些想法\"\ndescription: \"\"\ncategory: java\ntags: [ spring, restful, interface]\n---\n\n最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。\n\n### 使用RESTFul接口\nRESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.\n\n\n### 解决接口联调的苦难\n作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。\n因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。\n\n- swagger-maven-plugin\n- swagger-ui\n\n\n### 项目中遇到的一些教训\n作为技术负责人\n\n- 提前制定接口，方便联调\n- 提前规划返回接口类型，统一字段名称。","slug":"2015-11-04-about-interface-define","published":1,"date":"2016-08-12T09:23:26.000Z","updated":"2016-08-12T09:29:39.000Z","comments":1,"photos":[],"link":"","_id":"cirrmop7l009fv8fyujnjkdk0","content":"<p>最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。</p>\n<h3 id=\"使用RESTFul接口\"><a href=\"#使用RESTFul接口\" class=\"headerlink\" title=\"使用RESTFul接口\"></a>使用RESTFul接口</h3><p>RESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.</p>\n<h3 id=\"解决接口联调的苦难\"><a href=\"#解决接口联调的苦难\" class=\"headerlink\" title=\"解决接口联调的苦难\"></a>解决接口联调的苦难</h3><p>作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。<br>因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。</wwww.swagger.io></p>\n<ul>\n<li>swagger-maven-plugin</li>\n<li>swagger-ui</li>\n</ul>\n<h3 id=\"项目中遇到的一些教训\"><a href=\"#项目中遇到的一些教训\" class=\"headerlink\" title=\"项目中遇到的一些教训\"></a>项目中遇到的一些教训</h3><p>作为技术负责人</p>\n<ul>\n<li>提前制定接口，方便联调</li>\n<li>提前规划返回接口类型，统一字段名称。</li>\n</ul>\n","excerpt":"","more":"<p>最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。</p>\n<h3 id=\"使用RESTFul接口\"><a href=\"#使用RESTFul接口\" class=\"headerlink\" title=\"使用RESTFul接口\"></a>使用RESTFul接口</h3><p>RESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.</p>\n<h3 id=\"解决接口联调的苦难\"><a href=\"#解决接口联调的苦难\" class=\"headerlink\" title=\"解决接口联调的苦难\"></a>解决接口联调的苦难</h3><p>作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。<br>因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。</p>\n<ul>\n<li>swagger-maven-plugin</li>\n<li>swagger-ui</li>\n</ul>\n<h3 id=\"项目中遇到的一些教训\"><a href=\"#项目中遇到的一些教训\" class=\"headerlink\" title=\"项目中遇到的一些教训\"></a>项目中遇到的一些教训</h3><p>作为技术负责人</p>\n<ul>\n<li>提前制定接口，方便联调</li>\n<li>提前规划返回接口类型，统一字段名称。</li>\n</ul>\n"},{"layout":"post","title":"Restful Spring MVC","date":"2015-11-03T05:53:00.000Z","comments":1,"_content":"\n\nSpring MVC本身对Restful支持非常好。它的`@RequestMapping`、`@RequestParam`、`@PathVariable`、`@ResponseBody`注解很好的支持了REST。[18.2 Creating RESTful services](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html)\n\n### 1. `@RequestMapping`\n\nSpring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。\n\n### 2. `@PathVariable`\n\nThe @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是`@RequestParam`做的事情。）\n\n    @RequestMapping(\"/owners/{ownerId}\", method=RequestMethod.GET)\n    public String findOwner(@PathVariable String ownerId, Model model) {\n            // ...\n    }\n\n如果变量名与pathVariable名不一致，那么需要指定：\n\n    @RequestMapping(\"/owners/{ownerId}\", method=RequestMethod.GET)\n    public String findOwner(@PathVariable(\"ownerId\") String theOwner, Model model) {\n        // implementation omitted\n    }\n\n>**Tip**\n>\nmethod parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date... Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.\n\n\n### 3. `@RequestParam`\n\n官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟`@PathVariable`功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。\n\n对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:\n\n    @RequestMapping(\"/imageUpload\")\n    public String processImageUpload(@RequestParam(\"name\") String name,\n                    @RequestParam(\"description\") String description,\n                    @RequestParam(\"image\") MultipartFile image) throws IOException {\n        this.imageDatabase.storeImage(name, image.getInputStream(), \n                                        (int) image.getSize(), description);\n        return \"redirect:imageList\";\n    }\n\n    \n还可以设置defaultValue：\n\n    @RequestMapping(\"/imageUpload\")\n    public String processImageUpload(@RequestParam(value=\"name\", defaultValue=\"arganzheng\") String name,\n                    @RequestParam(\"description\") String description,\n                    @RequestParam(\"image\") MultipartFile image) throws IOException {\n        this.imageDatabase.storeImage(name, image.getInputStream(), \n                                        (int) image.getSize(), description);\n        return \"redirect:imageList\";\n    }\n\n### 4. `@RequestBody`和`@ResponseBody`\n\n这两个注解其实用到了Spring的一个非常灵活的设计——`HttpMessageConverter` [18.3.2 HTTP Message Conversion](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion)\n\n与`@RequestParam`不同，`@RequestBody`和`@ResponseBody`是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。\n\n`HtppMessageConverter`负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。\n    \n    public interface HttpMessageConverter<T> {\n\n        // Indicate whether the given class is supported by this converter.\n        boolean supports(Class<? extends T> clazz);\n\n        // Return the list of MediaType objects supported by this converter.\n        List<MediaType> getSupportedMediaTypes();\n\n        // Read an object of the given type form the given input message, and returns it.\n        T read(Class<T> clazz, HttpInputMessage inputMessage) throws IOException, \n                                                                        HttpMessageNotReadableException;\n\n        // Write an given object to the given output message.\n        void write(T t, HttpOutputMessage outputMessage) throws IOException, \n                                                                HttpMessageNotWritableException;\n\n    }        \n    \n    \nSpring MVC对`HttpMessageConverter`有多种默认实现，基本上不需要自己再自定义`HttpMessageConverter`\n>\n+ StringHttpMessageConverter - converts strings\n+ FormHttpMessageConverter - converts form data to/from a MultiValueMap<String, String>\n+ ByteArrayMessageConverter - converts byte arrays\n+ SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source\n+ RssChannelHttpMessageConverter - convert to/from RSS feeds\n+ MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson's ObjectMapper\n+ etc...\n\n然而对于RESTful应用，用的最多的当然是`MappingJacksonHttpMessageConverter`。\n\n但是`MappingJacksonHttpMessageConverter`不是默认的`HttpMessageConverter`：\n\n    public class AnnotationMethodHandlerAdapter extends WebContentGenerator\n    implements HandlerAdapter, Ordered, BeanFactoryAware {\n\n        ...\n        \n        public AnnotationMethodHandlerAdapter() {\n            // no restriction of HTTP methods by default\n            super(false);\n\n            // See SPR-7316\n            StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();\n            stringHttpMessageConverter.setWriteAcceptCharset(false);\n            this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,\n            new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};\n        }\n    }   \n\n如上：默认的`HttpMessageConverter`是`ByteArrayHttpMessageConverter`、`stringHttpMessageConverter`、`SourceHttpMessageConverter`和`XmlAwareFormHttpMessageConverter`转换器。所以需要配置一下：\n        \n    <bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n        <property name=\"messageConverters\">\n        <list>\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n            <property name=\"supportedMediaTypes\">\n                <list>\n                <value>text/plain;charset=GBK</value>\n                </list>\n            </property>\n            </bean>\n            <bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\" />\n        </list>\n        </property>\n    </bean>\n\n配置好了之后，就可以享受`@Requestbody`和`@ResponseBody`对JONS转换的便利之处了：\n\n    @RequestMapping(value = \"api\", method = RequestMethod.POST)\n    @ResponseBody\n    public boolean addApi(@RequestBody\n        Api api, @RequestParam(value = \"afterApiId\", required = false)\n        Integer afterApiId) {\n            Integer id = apiMetadataService.addApi(api);\n            return id > 0;\n    }\n\n    @RequestMapping(value = \"api/{apiId}\", method = RequestMethod.GET)\n    @ResponseBody\n    public Api getApi(@PathVariable(\"apiId\")\n        int apiId) {\n            return apiMetadataService.getApi(apiId, Version.primary);\n    }\n\n一般情况下我们是不需要自定义`HttpMessageConverter`，不过对于Restful应用，有时候我们需要返回jsonp数据：\n\n    package me.arganzheng.study.springmvc.util;\n\n    import java.io.IOException;\n    import java.io.PrintStream;\n\n    import org.codehaus.jackson.map.ObjectMapper;\n    import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;\n    import org.springframework.http.HttpOutputMessage;\n    import org.springframework.http.converter.HttpMessageNotWritableException;\n    import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;\n    import org.springframework.web.context.request.RequestAttributes;\n    import org.springframework.web.context.request.RequestContextHolder;\n    import org.springframework.web.context.request.ServletRequestAttributes;\n\n    public class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {\n\n        public MappingJsonpHttpMessageConverter() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));\n        setObjectMapper(objectMapper);\n        }\n\n        @Override\n        protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n        String jsonpCallback = null;\n\n        RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();\n        if(reqAttrs instanceof ServletRequestAttributes){\n            jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(\"jsonpCallback\");\n        }\n\n        if(jsonpCallback != null){\n            new PrintStream(outputMessage.getBody()).print(jsonpCallback + \"(\");\n        }\n        \n        super.writeInternal(o, outputMessage);\n        \n        if(jsonpCallback != null){\n            new PrintStream(outputMessage.getBody()).println(\");\");\n        }\n        }\n    }\n\n如果请求的参数中带有`jsonpCallback`，那么会返回jsonp格式数据。比如：\nhttp://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。\n会返回`clientFunction(…);`\n\n\n### 5. `@CookieValue`\n\n`@CookieValue`用于将请求的Cookie数据映射到功能处理方法的参数上。\n\n    public String test(@CookieValue(value=\"JSESSIONID\", defaultValue=\"\") String sessionId){\n        ...\n    }\n    \n如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。\n    \n    public String test2(@CookieValue(value=\"JSESSIONID\", defaultValue=\"\") Cookie sessionId){\n        ...\n    }\n    \n传入参数类型也可以是javax.servlet.http.Cookie类型。\n\n**TIPS** 如果是使用cookies值来保持回话状态的话，推荐使用Spring的[Bean Scopes](http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html)机制，具体参见笔者的另一篇文章：[Spring的Bean Scopes](http://blog.arganzheng.me/posts/spring-bean-scopes.html)。非常方便。\n\n### 6. `@RequestHeader`\n\n`@RequestHeader`用于将请求的头信息区数据映射到功能处理方法的参数上。\n\n    @RequestMapping(value=\"/header\")  \n    public String test(  \n       @RequestHeader(\"User-Agent\") String userAgent,  \n       @RequestHeader(value=\"Accept\") String[] accepts)  \n          \n如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。\n\n\n### 7. 返回多种表现形式(Returning multiple representations)\n\n对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？\n\n一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：\n\n1. 使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式.\n2. 使用一个请求参数告诉服务器希望得到的资源格式。如format=json。\n3. 使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求http://blog.arganzheng.me/users/argan，如果带上`text/xml` accept header表示请求一个XML资源，带上`application/pdf`则表示期望收到pdf格式资源。\n \n这其实就是Spring MVC默认的三个`ContentNegotiationStrategy`，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。\n\nSpring提供了[`ContentNegotiatingViewResolver`](http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html)来解决这个问题：\n\n  \n    public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {\n\n        private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);\n    \n        private static final String ACCEPT_HEADER = \"Accept\";\n    \n        private static final boolean jafPresent =\n            ClassUtils.isPresent(\"javax.activation.FileTypeMap\", ContentNegotiatingViewResolver.class.getClassLoader());\n    \n        private static final UrlPathHelper urlPathHelper = new UrlPathHelper();\n    \n    \n        private int order = Ordered.HIGHEST_PRECEDENCE;\n    \n        private boolean favorPathExtension = true;\n    \n        private boolean favorParameter = false;\n    \n        private String parameterName = \"format\";\n    \n        private boolean useNotAcceptableStatusCode = false;\n    \n        private boolean ignoreAcceptHeader = false;\n    \n        private boolean useJaf = true;\n    \n        private ConcurrentMap<String, MediaType> mediaTypes = new ConcurrentHashMap<String, MediaType>();\n    \n        private List<View> defaultViews;\n    \n        private MediaType defaultContentType;\n    \n        private List<ViewResolver> viewResolvers;\n    \n    \n        // ignore some setter and getter...    \n        \n        public void setMediaTypes(Map<String, String> mediaTypes) {\n          Assert.notNull(mediaTypes, \"'mediaTypes' must not be null\");\n          for (Map.Entry<String, String> entry : mediaTypes.entrySet()) {\n            String extension = entry.getKey().toLowerCase(Locale.ENGLISH);\n            MediaType mediaType = MediaType.parseMediaType(entry.getValue());\n            this.mediaTypes.put(extension, mediaType);\n          }\n        }\n    \n        public void setDefaultViews(List<View> defaultViews) {\n          this.defaultViews = defaultViews;\n        }\n    \n        public void setDefaultContentType(MediaType defaultContentType) {\n          this.defaultContentType = defaultContentType;\n        }\n        \n        public void setViewResolvers(List<ViewResolver> viewResolvers) {\n          this.viewResolvers = viewResolvers;\n        }\n    \n    \n        @Override\n        protected void initServletContext(ServletContext servletContext) {\n          if (this.viewResolvers == null) {\n            Map<String, ViewResolver> matchingBeans =\n                BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);\n            this.viewResolvers = new ArrayList<ViewResolver>(matchingBeans.size());\n            for (ViewResolver viewResolver : matchingBeans.values()) {\n              if (this != viewResolver) {\n                this.viewResolvers.add(viewResolver);\n              }\n            }\n          }\n          if (this.viewResolvers.isEmpty()) {\n            logger.warn(\"Did not find any ViewResolvers to delegate to; please configure them using the \" +\n                \"'viewResolvers' property on the ContentNegotiatingViewResolver\");\n          }\n          OrderComparator.sort(this.viewResolvers);\n        }\n    \n        public View resolveViewName(String viewName, Locale locale) throws Exception {\n          RequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n          Assert.isInstanceOf(ServletRequestAttributes.class, attrs);\n          List<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n          if (requestedMediaTypes != null) {\n            List<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n            View bestView = getBestView(candidateViews, requestedMediaTypes);\n            if (bestView != null) {\n              return bestView;\n            }\n          }\n          if (this.useNotAcceptableStatusCode) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"No acceptable view found; returning 406 (Not Acceptable) status code\");\n            }\n            return NOT_ACCEPTABLE_VIEW;\n          }\n          else {\n            logger.debug(\"No acceptable view found; returning null\");\n            return null;\n          }\n        }\n    \n        \n        protected List<MediaType> getMediaTypes(HttpServletRequest request) {\n          if (this.favorPathExtension) {\n            String requestUri = urlPathHelper.getRequestUri(request);\n            String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);\n            MediaType mediaType = getMediaTypeFromFilename(filename);\n            if (mediaType != null) {\n              if (logger.isDebugEnabled()) {\n                logger.debug(\"Requested media type is '\" + mediaType + \"' (based on filename '\" + filename + \"')\");\n              }\n              return Collections.singletonList(mediaType);\n            }\n          }\n          if (this.favorParameter) {\n            if (request.getParameter(this.parameterName) != null) {\n              String parameterValue = request.getParameter(this.parameterName);\n              MediaType mediaType = getMediaTypeFromParameter(parameterValue);\n              if (mediaType != null) {\n                if (logger.isDebugEnabled()) {\n                  logger.debug(\"Requested media type is '\" + mediaType + \"' (based on parameter '\" +\n                      this.parameterName + \"'='\" + parameterValue + \"')\");\n                }\n                return Collections.singletonList(mediaType);\n              }\n            }\n          }\n          if (!this.ignoreAcceptHeader) {\n            String acceptHeader = request.getHeader(ACCEPT_HEADER);\n            if (StringUtils.hasText(acceptHeader)) {\n              try {\n                          List<MediaType> mediaTypes = MediaType.parseMediaTypes(acceptHeader);\n                          MediaType.sortByQualityValue(mediaTypes);\n                          if (logger.isDebugEnabled()) {\n                              logger.debug(\"Requested media types are \" + mediaTypes + \" (based on Accept header)\");\n                          }\n                          return mediaTypes;\n              }\n              catch (IllegalArgumentException ex) {\n                if (logger.isDebugEnabled()) {\n                  logger.debug(\"Could not parse accept header [\" + acceptHeader + \"]: \" + ex.getMessage());\n                }\n                return null;\n              }\n            }\n          }\n          if (this.defaultContentType != null) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"Requested media types is \" + this.defaultContentType +\n                  \" (based on defaultContentType property)\");\n            }\n            return Collections.singletonList(this.defaultContentType);\n          }\n          else {\n            return Collections.emptyList();\n          }\n        }\n    \n        \n        protected MediaType getMediaTypeFromFilename(String filename) {\n          String extension = StringUtils.getFilenameExtension(filename);\n          if (!StringUtils.hasText(extension)) {\n            return null;\n          }\n          extension = extension.toLowerCase(Locale.ENGLISH);\n          MediaType mediaType = this.mediaTypes.get(extension);\n          if (mediaType == null && this.useJaf && jafPresent) {\n            mediaType = ActivationMediaTypeFactory.getMediaType(filename);\n            if (mediaType != null) {\n              this.mediaTypes.putIfAbsent(extension, mediaType);\n            }\n          }\n          return mediaType;\n        }\n    \n        \n        protected MediaType getMediaTypeFromParameter(String parameterValue) {\n          return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));\n        }\n    \n        private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes)\n            throws Exception {\n    \n          List<View> candidateViews = new ArrayList<View>();\n          for (ViewResolver viewResolver : this.viewResolvers) {\n            View view = viewResolver.resolveViewName(viewName, locale);\n            if (view != null) {\n              candidateViews.add(view);\n            }\n            for (MediaType requestedMediaType : requestedMediaTypes) {\n              List<String> extensions = getExtensionsForMediaType(requestedMediaType);\n              for (String extension : extensions) {\n                String viewNameWithExtension = viewName + \".\" + extension;\n                view = viewResolver.resolveViewName(viewNameWithExtension, locale);\n                if (view != null) {\n                  candidateViews.add(view);\n                }\n              }\n    \n            }\n          }\n          if (!CollectionUtils.isEmpty(this.defaultViews)) {\n            candidateViews.addAll(this.defaultViews);\n          }\n          return candidateViews;\n        }\n    \n        private List<String> getExtensionsForMediaType(MediaType requestedMediaType) {\n          List<String> result = new ArrayList<String>();\n          for (Entry<String, MediaType> entry : this.mediaTypes.entrySet()) {\n            if (requestedMediaType.includes(entry.getValue())) {\n              result.add(entry.getKey());\n            }\n          }\n          return result;\n        }\n    \n        private View getBestView(List<View> candidateViews, List<MediaType> requestedMediaTypes) {\n          MediaType bestRequestedMediaType = null;\n          View bestView = null;\n          for (MediaType requestedMediaType : requestedMediaTypes) {\n            for (View candidateView : candidateViews) {\n              if (StringUtils.hasText(candidateView.getContentType())) {\n                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());\n                if (requestedMediaType.includes(candidateContentType)) {\n                  bestRequestedMediaType = requestedMediaType;\n                  bestView = candidateView;\n                  break;\n                }\n              }\n            }\n            if (bestView != null) {\n              if (logger.isDebugEnabled()) {\n                logger.debug(\"Returning [\" + bestView + \"] based on requested media type '\" +\n                    bestRequestedMediaType + \"'\");\n              }\n              break;\n            }\n          }\n          return bestView;\n    \n        }\n        \n        ...\n        \n    }\n\n\n可以看到`ContentNegotiationViewResolver`有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。\n\n所以关键在两点：\n\n#### 1. content negotiation策略 (`ContentNegotiationStrategy`)\n\n>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:\n>\n1. If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.\n2. If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.\n3. If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.\n4. If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.\n>   \nOnce the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view's content type). The most compatible view is returned.\n\n这个就是上面提到的Spring MVC默认的三个`ContentNegotiationStrategy`，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。\n\n关于`ContentNegotiationStrategy`，可以参考笔者的另一篇文章：[content negotiation using spring mvc](http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html)。有具体的实际案例。\n\n##### 2. 供选择的SingleViewResolver\n>    \n1. The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)\n> \n    说明：即`private List<ViewResolver> viewResolvers;`属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到`ContentNegotiationViewResolover`的`viewResolvers`属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由`ContentNegotiationViewResolover`来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给`ContentNegotiationViewResolover`配置最高的order(其实默认就是最高了)。\n>\n2. Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.\n>\n    说明：即`private List<View> defaultViews;`和`private MediaType defaultContentType;`属性。\n\n\n关于`ContentNegotiatingViewResolver`，下面两篇文章都不错，值得一看：\n\n1. [Content Negotiation using Spring MVC's ContentNegotiatingViewResolver](http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html):使用了`viewResolvers`配置。\n2. [ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING'S REST SUPPORT](http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/):使用了`ViewResolvers`配置。\n3. [Spring 3 MVC ContentNegotiatingViewResolver Example](http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/):使用了`defaultViews`配置。\n\n注意：`@ResponseBody`是为了单个View准备的，即它只能转换成一种格式，对于`ContentNegotiatingViewResolver`，需要多个**Single**ViewResolver来接收。\n\n### 8. 客户端调用 [Accessing RESTful services on the Client](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate)\n\nSpring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。\n\n以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：\n    \n    String uri = \"http://example.com/hotels/1/bookings\";\n    \n    PostMethod post = new PostMethod(uri);\n    String request = // create booking request content\n    post.setRequestEntity(new StringRequestEntity(request));\n    \n    httpClient.executeMethod(post);\n    \n    if (HttpStatus.SC_CREATED == post.getStatusCode()) {\n      Header location = post.getRequestHeader(\"Location\");\n      if (location != null) {\n        System.out.println(\"Created new booking at :\" + location.getValue());\n      }\n    }\n\n太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。\n\n#### [RestTemplate](http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/)\n\nRestTemplate是client-site HTTP access的核心类。正如它的名称所示，`RestTemplate`非常类似于`JdbcTemplate`, `JmsTemplate`等XXXTemplate。这意味着`RestTemplate`是线程安全的并且可以通过callback来定制它的行为。\n\n**TIPS** Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。\n\nRestTemplate默认使用`java.net`包下的基础类来创建HTTP请求。你可以实现`ClientHttpRequestFactory`接口，提供你自己的Http请求工厂类。Spring提供了`CommonsClientHttpRequestFactory`，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。\n\n[RestTemplate提供的方法如下](http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html)：\n\n>**HTTP Method**\t**RestTemplate Method**\n>\n* DELETE\tdelete(String url, String… urlVariables)\n* GET\tgetForObject(String url, Class<T> responseType, String… urlVariables)\n* HEAD\theadForHeaders(String url, String… urlVariables)\n* OPTIONS\toptionsForAllow(String url, String… urlVariables)\n* POST\tpostForLocation(String url, Object request, String… urlVariables)\n* PUT\tput(String url, Object request, String…urlVariables)\n* ANY\texchange(String, HttpMethod, HttpEntity, Class, Object...)\n        execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)\n\n方法名称很有规律，都是这个pattern——`${HTTP Method}${WhatIsReturne}`。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.\n\n其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过`HttpMessageConverter`来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的`@RequestBody`和`@ResponseBody`是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。\n\n另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得`@PathVariable`吗:)哦。参数有两种方式绑定值：\n\n1. 作为字符串变量数组(String variable arguments array)\n    \n        String result = restTemplate.getForObject(\"http://example.com/hotels/{hotel}/bookings/{booking}\", String.class, \"42\", \"21\");\n        \n    会转换为一个对`http://example.com/hotels/42/bookings/21`的GET请求。\n    \n2. 或者Map对象(Map)\n\n   The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.\n        \n        Map<String, String> vars = new HashMap<String, String>();\n        vars.put(\"hotel\", \"42\");\n        vars.put(\"booking\", \"21\");\n        String result = restTemplate.getForObject(\"http://example.com/hotels/{hotel}/bookings/{booking}\", String.class, vars);\n        会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。\n\n关于RestTemplate使用的具体例子可以参考这篇文章[\nREST IN SPRING 3: RESTTEMPLATE](http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/)。写的非常好，强烈推荐！\n    \n### 9. 支持RESTful的URL\n\n在开发功能模块之前，应该先把URL设计好。比查对 **消息** 这个资源的操作URL可以这么设计：\n    \n    http://arganzheng.me/messages/show/123456\n    http://arganzheng.me/messages/preview/123456\n    http://arganzheng.me/messages/delete/123456\n    http://arganzheng.me/messages/new\n    http://arganzheng.me/message/update\n    \n说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。\n\n要支持这种URL，web.xml需要这么配置：\n\n    <!-- REST servlet-mapping -->\n    <servlet-mapping>\n    \t<servlet-name>DispatcherServlet<srvlet-name>\n    \t<url-pattern>/</url-pattern>\n    <srvlet-mapping>\n\t\n但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理[16.14.5 Configuring Serving of Resources](http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources)：\n\n    <!-- Forwards requests to the \"/\" resource to the \"welcome\" view -->\n  \t<mvc:view-controller path=\"/\" view-name=\"index\"/>\n  \t\n  \t<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory -->\n  \t<mvc:resources mapping=\"/resources/**\" location=\"/resources/\" />\n  \t<!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 \n  \t\t@see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined \n  \t-->\n  \t<mvc:annotation-driven />\n\n这样所有请求：`http://arganzheng.me/resources/**`会映射到webapp下的resources目录，而不是找我们的controller处理。\n\n但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个`<mvc:annotation-driven />`配置。具体参见[The handler mapping from the mvc:resource override other mappings which defined with annotation](http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined)。\n\n另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：\n\n    <!-- 避免被Spring DispatcherServlet接管 -->\n  \t<servlet-mapping>\n  \t\t<servlet-name>default<srvlet-name>\n  \t\t<url-pattern>*.html</url-pattern>\n  \t<srvlet-mapping>\n\n\n\n\n   \n\n","source":"_posts/2015-11-03-restful-springmvc.markdown","raw":"---\nlayout: post\ntitle: Restful Spring MVC\ndate: 2015-11-03 13:53\ncomments: true\ncategories: spring\ntags: [ restful, spring, mvc]\n---\n\n\nSpring MVC本身对Restful支持非常好。它的`@RequestMapping`、`@RequestParam`、`@PathVariable`、`@ResponseBody`注解很好的支持了REST。[18.2 Creating RESTful services](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html)\n\n### 1. `@RequestMapping`\n\nSpring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。\n\n### 2. `@PathVariable`\n\nThe @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是`@RequestParam`做的事情。）\n\n    @RequestMapping(\"/owners/{ownerId}\", method=RequestMethod.GET)\n    public String findOwner(@PathVariable String ownerId, Model model) {\n            // ...\n    }\n\n如果变量名与pathVariable名不一致，那么需要指定：\n\n    @RequestMapping(\"/owners/{ownerId}\", method=RequestMethod.GET)\n    public String findOwner(@PathVariable(\"ownerId\") String theOwner, Model model) {\n        // implementation omitted\n    }\n\n>**Tip**\n>\nmethod parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date... Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.\n\n\n### 3. `@RequestParam`\n\n官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟`@PathVariable`功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。\n\n对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:\n\n    @RequestMapping(\"/imageUpload\")\n    public String processImageUpload(@RequestParam(\"name\") String name,\n                    @RequestParam(\"description\") String description,\n                    @RequestParam(\"image\") MultipartFile image) throws IOException {\n        this.imageDatabase.storeImage(name, image.getInputStream(), \n                                        (int) image.getSize(), description);\n        return \"redirect:imageList\";\n    }\n\n    \n还可以设置defaultValue：\n\n    @RequestMapping(\"/imageUpload\")\n    public String processImageUpload(@RequestParam(value=\"name\", defaultValue=\"arganzheng\") String name,\n                    @RequestParam(\"description\") String description,\n                    @RequestParam(\"image\") MultipartFile image) throws IOException {\n        this.imageDatabase.storeImage(name, image.getInputStream(), \n                                        (int) image.getSize(), description);\n        return \"redirect:imageList\";\n    }\n\n### 4. `@RequestBody`和`@ResponseBody`\n\n这两个注解其实用到了Spring的一个非常灵活的设计——`HttpMessageConverter` [18.3.2 HTTP Message Conversion](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion)\n\n与`@RequestParam`不同，`@RequestBody`和`@ResponseBody`是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。\n\n`HtppMessageConverter`负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。\n    \n    public interface HttpMessageConverter<T> {\n\n        // Indicate whether the given class is supported by this converter.\n        boolean supports(Class<? extends T> clazz);\n\n        // Return the list of MediaType objects supported by this converter.\n        List<MediaType> getSupportedMediaTypes();\n\n        // Read an object of the given type form the given input message, and returns it.\n        T read(Class<T> clazz, HttpInputMessage inputMessage) throws IOException, \n                                                                        HttpMessageNotReadableException;\n\n        // Write an given object to the given output message.\n        void write(T t, HttpOutputMessage outputMessage) throws IOException, \n                                                                HttpMessageNotWritableException;\n\n    }        \n    \n    \nSpring MVC对`HttpMessageConverter`有多种默认实现，基本上不需要自己再自定义`HttpMessageConverter`\n>\n+ StringHttpMessageConverter - converts strings\n+ FormHttpMessageConverter - converts form data to/from a MultiValueMap<String, String>\n+ ByteArrayMessageConverter - converts byte arrays\n+ SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source\n+ RssChannelHttpMessageConverter - convert to/from RSS feeds\n+ MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson's ObjectMapper\n+ etc...\n\n然而对于RESTful应用，用的最多的当然是`MappingJacksonHttpMessageConverter`。\n\n但是`MappingJacksonHttpMessageConverter`不是默认的`HttpMessageConverter`：\n\n    public class AnnotationMethodHandlerAdapter extends WebContentGenerator\n    implements HandlerAdapter, Ordered, BeanFactoryAware {\n\n        ...\n        \n        public AnnotationMethodHandlerAdapter() {\n            // no restriction of HTTP methods by default\n            super(false);\n\n            // See SPR-7316\n            StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();\n            stringHttpMessageConverter.setWriteAcceptCharset(false);\n            this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,\n            new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};\n        }\n    }   \n\n如上：默认的`HttpMessageConverter`是`ByteArrayHttpMessageConverter`、`stringHttpMessageConverter`、`SourceHttpMessageConverter`和`XmlAwareFormHttpMessageConverter`转换器。所以需要配置一下：\n        \n    <bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n        <property name=\"messageConverters\">\n        <list>\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n            <property name=\"supportedMediaTypes\">\n                <list>\n                <value>text/plain;charset=GBK</value>\n                </list>\n            </property>\n            </bean>\n            <bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\" />\n        </list>\n        </property>\n    </bean>\n\n配置好了之后，就可以享受`@Requestbody`和`@ResponseBody`对JONS转换的便利之处了：\n\n    @RequestMapping(value = \"api\", method = RequestMethod.POST)\n    @ResponseBody\n    public boolean addApi(@RequestBody\n        Api api, @RequestParam(value = \"afterApiId\", required = false)\n        Integer afterApiId) {\n            Integer id = apiMetadataService.addApi(api);\n            return id > 0;\n    }\n\n    @RequestMapping(value = \"api/{apiId}\", method = RequestMethod.GET)\n    @ResponseBody\n    public Api getApi(@PathVariable(\"apiId\")\n        int apiId) {\n            return apiMetadataService.getApi(apiId, Version.primary);\n    }\n\n一般情况下我们是不需要自定义`HttpMessageConverter`，不过对于Restful应用，有时候我们需要返回jsonp数据：\n\n    package me.arganzheng.study.springmvc.util;\n\n    import java.io.IOException;\n    import java.io.PrintStream;\n\n    import org.codehaus.jackson.map.ObjectMapper;\n    import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;\n    import org.springframework.http.HttpOutputMessage;\n    import org.springframework.http.converter.HttpMessageNotWritableException;\n    import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;\n    import org.springframework.web.context.request.RequestAttributes;\n    import org.springframework.web.context.request.RequestContextHolder;\n    import org.springframework.web.context.request.ServletRequestAttributes;\n\n    public class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {\n\n        public MappingJsonpHttpMessageConverter() {\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));\n        setObjectMapper(objectMapper);\n        }\n\n        @Override\n        protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n        String jsonpCallback = null;\n\n        RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();\n        if(reqAttrs instanceof ServletRequestAttributes){\n            jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(\"jsonpCallback\");\n        }\n\n        if(jsonpCallback != null){\n            new PrintStream(outputMessage.getBody()).print(jsonpCallback + \"(\");\n        }\n        \n        super.writeInternal(o, outputMessage);\n        \n        if(jsonpCallback != null){\n            new PrintStream(outputMessage.getBody()).println(\");\");\n        }\n        }\n    }\n\n如果请求的参数中带有`jsonpCallback`，那么会返回jsonp格式数据。比如：\nhttp://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。\n会返回`clientFunction(…);`\n\n\n### 5. `@CookieValue`\n\n`@CookieValue`用于将请求的Cookie数据映射到功能处理方法的参数上。\n\n    public String test(@CookieValue(value=\"JSESSIONID\", defaultValue=\"\") String sessionId){\n        ...\n    }\n    \n如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。\n    \n    public String test2(@CookieValue(value=\"JSESSIONID\", defaultValue=\"\") Cookie sessionId){\n        ...\n    }\n    \n传入参数类型也可以是javax.servlet.http.Cookie类型。\n\n**TIPS** 如果是使用cookies值来保持回话状态的话，推荐使用Spring的[Bean Scopes](http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html)机制，具体参见笔者的另一篇文章：[Spring的Bean Scopes](http://blog.arganzheng.me/posts/spring-bean-scopes.html)。非常方便。\n\n### 6. `@RequestHeader`\n\n`@RequestHeader`用于将请求的头信息区数据映射到功能处理方法的参数上。\n\n    @RequestMapping(value=\"/header\")  \n    public String test(  \n       @RequestHeader(\"User-Agent\") String userAgent,  \n       @RequestHeader(value=\"Accept\") String[] accepts)  \n          \n如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。\n\n\n### 7. 返回多种表现形式(Returning multiple representations)\n\n对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？\n\n一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：\n\n1. 使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式.\n2. 使用一个请求参数告诉服务器希望得到的资源格式。如format=json。\n3. 使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求http://blog.arganzheng.me/users/argan，如果带上`text/xml` accept header表示请求一个XML资源，带上`application/pdf`则表示期望收到pdf格式资源。\n \n这其实就是Spring MVC默认的三个`ContentNegotiationStrategy`，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。\n\nSpring提供了[`ContentNegotiatingViewResolver`](http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html)来解决这个问题：\n\n  \n    public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {\n\n        private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);\n    \n        private static final String ACCEPT_HEADER = \"Accept\";\n    \n        private static final boolean jafPresent =\n            ClassUtils.isPresent(\"javax.activation.FileTypeMap\", ContentNegotiatingViewResolver.class.getClassLoader());\n    \n        private static final UrlPathHelper urlPathHelper = new UrlPathHelper();\n    \n    \n        private int order = Ordered.HIGHEST_PRECEDENCE;\n    \n        private boolean favorPathExtension = true;\n    \n        private boolean favorParameter = false;\n    \n        private String parameterName = \"format\";\n    \n        private boolean useNotAcceptableStatusCode = false;\n    \n        private boolean ignoreAcceptHeader = false;\n    \n        private boolean useJaf = true;\n    \n        private ConcurrentMap<String, MediaType> mediaTypes = new ConcurrentHashMap<String, MediaType>();\n    \n        private List<View> defaultViews;\n    \n        private MediaType defaultContentType;\n    \n        private List<ViewResolver> viewResolvers;\n    \n    \n        // ignore some setter and getter...    \n        \n        public void setMediaTypes(Map<String, String> mediaTypes) {\n          Assert.notNull(mediaTypes, \"'mediaTypes' must not be null\");\n          for (Map.Entry<String, String> entry : mediaTypes.entrySet()) {\n            String extension = entry.getKey().toLowerCase(Locale.ENGLISH);\n            MediaType mediaType = MediaType.parseMediaType(entry.getValue());\n            this.mediaTypes.put(extension, mediaType);\n          }\n        }\n    \n        public void setDefaultViews(List<View> defaultViews) {\n          this.defaultViews = defaultViews;\n        }\n    \n        public void setDefaultContentType(MediaType defaultContentType) {\n          this.defaultContentType = defaultContentType;\n        }\n        \n        public void setViewResolvers(List<ViewResolver> viewResolvers) {\n          this.viewResolvers = viewResolvers;\n        }\n    \n    \n        @Override\n        protected void initServletContext(ServletContext servletContext) {\n          if (this.viewResolvers == null) {\n            Map<String, ViewResolver> matchingBeans =\n                BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);\n            this.viewResolvers = new ArrayList<ViewResolver>(matchingBeans.size());\n            for (ViewResolver viewResolver : matchingBeans.values()) {\n              if (this != viewResolver) {\n                this.viewResolvers.add(viewResolver);\n              }\n            }\n          }\n          if (this.viewResolvers.isEmpty()) {\n            logger.warn(\"Did not find any ViewResolvers to delegate to; please configure them using the \" +\n                \"'viewResolvers' property on the ContentNegotiatingViewResolver\");\n          }\n          OrderComparator.sort(this.viewResolvers);\n        }\n    \n        public View resolveViewName(String viewName, Locale locale) throws Exception {\n          RequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n          Assert.isInstanceOf(ServletRequestAttributes.class, attrs);\n          List<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n          if (requestedMediaTypes != null) {\n            List<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n            View bestView = getBestView(candidateViews, requestedMediaTypes);\n            if (bestView != null) {\n              return bestView;\n            }\n          }\n          if (this.useNotAcceptableStatusCode) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"No acceptable view found; returning 406 (Not Acceptable) status code\");\n            }\n            return NOT_ACCEPTABLE_VIEW;\n          }\n          else {\n            logger.debug(\"No acceptable view found; returning null\");\n            return null;\n          }\n        }\n    \n        \n        protected List<MediaType> getMediaTypes(HttpServletRequest request) {\n          if (this.favorPathExtension) {\n            String requestUri = urlPathHelper.getRequestUri(request);\n            String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);\n            MediaType mediaType = getMediaTypeFromFilename(filename);\n            if (mediaType != null) {\n              if (logger.isDebugEnabled()) {\n                logger.debug(\"Requested media type is '\" + mediaType + \"' (based on filename '\" + filename + \"')\");\n              }\n              return Collections.singletonList(mediaType);\n            }\n          }\n          if (this.favorParameter) {\n            if (request.getParameter(this.parameterName) != null) {\n              String parameterValue = request.getParameter(this.parameterName);\n              MediaType mediaType = getMediaTypeFromParameter(parameterValue);\n              if (mediaType != null) {\n                if (logger.isDebugEnabled()) {\n                  logger.debug(\"Requested media type is '\" + mediaType + \"' (based on parameter '\" +\n                      this.parameterName + \"'='\" + parameterValue + \"')\");\n                }\n                return Collections.singletonList(mediaType);\n              }\n            }\n          }\n          if (!this.ignoreAcceptHeader) {\n            String acceptHeader = request.getHeader(ACCEPT_HEADER);\n            if (StringUtils.hasText(acceptHeader)) {\n              try {\n                          List<MediaType> mediaTypes = MediaType.parseMediaTypes(acceptHeader);\n                          MediaType.sortByQualityValue(mediaTypes);\n                          if (logger.isDebugEnabled()) {\n                              logger.debug(\"Requested media types are \" + mediaTypes + \" (based on Accept header)\");\n                          }\n                          return mediaTypes;\n              }\n              catch (IllegalArgumentException ex) {\n                if (logger.isDebugEnabled()) {\n                  logger.debug(\"Could not parse accept header [\" + acceptHeader + \"]: \" + ex.getMessage());\n                }\n                return null;\n              }\n            }\n          }\n          if (this.defaultContentType != null) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(\"Requested media types is \" + this.defaultContentType +\n                  \" (based on defaultContentType property)\");\n            }\n            return Collections.singletonList(this.defaultContentType);\n          }\n          else {\n            return Collections.emptyList();\n          }\n        }\n    \n        \n        protected MediaType getMediaTypeFromFilename(String filename) {\n          String extension = StringUtils.getFilenameExtension(filename);\n          if (!StringUtils.hasText(extension)) {\n            return null;\n          }\n          extension = extension.toLowerCase(Locale.ENGLISH);\n          MediaType mediaType = this.mediaTypes.get(extension);\n          if (mediaType == null && this.useJaf && jafPresent) {\n            mediaType = ActivationMediaTypeFactory.getMediaType(filename);\n            if (mediaType != null) {\n              this.mediaTypes.putIfAbsent(extension, mediaType);\n            }\n          }\n          return mediaType;\n        }\n    \n        \n        protected MediaType getMediaTypeFromParameter(String parameterValue) {\n          return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));\n        }\n    \n        private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes)\n            throws Exception {\n    \n          List<View> candidateViews = new ArrayList<View>();\n          for (ViewResolver viewResolver : this.viewResolvers) {\n            View view = viewResolver.resolveViewName(viewName, locale);\n            if (view != null) {\n              candidateViews.add(view);\n            }\n            for (MediaType requestedMediaType : requestedMediaTypes) {\n              List<String> extensions = getExtensionsForMediaType(requestedMediaType);\n              for (String extension : extensions) {\n                String viewNameWithExtension = viewName + \".\" + extension;\n                view = viewResolver.resolveViewName(viewNameWithExtension, locale);\n                if (view != null) {\n                  candidateViews.add(view);\n                }\n              }\n    \n            }\n          }\n          if (!CollectionUtils.isEmpty(this.defaultViews)) {\n            candidateViews.addAll(this.defaultViews);\n          }\n          return candidateViews;\n        }\n    \n        private List<String> getExtensionsForMediaType(MediaType requestedMediaType) {\n          List<String> result = new ArrayList<String>();\n          for (Entry<String, MediaType> entry : this.mediaTypes.entrySet()) {\n            if (requestedMediaType.includes(entry.getValue())) {\n              result.add(entry.getKey());\n            }\n          }\n          return result;\n        }\n    \n        private View getBestView(List<View> candidateViews, List<MediaType> requestedMediaTypes) {\n          MediaType bestRequestedMediaType = null;\n          View bestView = null;\n          for (MediaType requestedMediaType : requestedMediaTypes) {\n            for (View candidateView : candidateViews) {\n              if (StringUtils.hasText(candidateView.getContentType())) {\n                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());\n                if (requestedMediaType.includes(candidateContentType)) {\n                  bestRequestedMediaType = requestedMediaType;\n                  bestView = candidateView;\n                  break;\n                }\n              }\n            }\n            if (bestView != null) {\n              if (logger.isDebugEnabled()) {\n                logger.debug(\"Returning [\" + bestView + \"] based on requested media type '\" +\n                    bestRequestedMediaType + \"'\");\n              }\n              break;\n            }\n          }\n          return bestView;\n    \n        }\n        \n        ...\n        \n    }\n\n\n可以看到`ContentNegotiationViewResolver`有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。\n\n所以关键在两点：\n\n#### 1. content negotiation策略 (`ContentNegotiationStrategy`)\n\n>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:\n>\n1. If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.\n2. If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.\n3. If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.\n4. If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.\n>   \nOnce the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view's content type). The most compatible view is returned.\n\n这个就是上面提到的Spring MVC默认的三个`ContentNegotiationStrategy`，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。\n\n关于`ContentNegotiationStrategy`，可以参考笔者的另一篇文章：[content negotiation using spring mvc](http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html)。有具体的实际案例。\n\n##### 2. 供选择的SingleViewResolver\n>    \n1. The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)\n> \n    说明：即`private List<ViewResolver> viewResolvers;`属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到`ContentNegotiationViewResolover`的`viewResolvers`属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由`ContentNegotiationViewResolover`来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给`ContentNegotiationViewResolover`配置最高的order(其实默认就是最高了)。\n>\n2. Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.\n>\n    说明：即`private List<View> defaultViews;`和`private MediaType defaultContentType;`属性。\n\n\n关于`ContentNegotiatingViewResolver`，下面两篇文章都不错，值得一看：\n\n1. [Content Negotiation using Spring MVC's ContentNegotiatingViewResolver](http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html):使用了`viewResolvers`配置。\n2. [ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING'S REST SUPPORT](http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/):使用了`ViewResolvers`配置。\n3. [Spring 3 MVC ContentNegotiatingViewResolver Example](http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/):使用了`defaultViews`配置。\n\n注意：`@ResponseBody`是为了单个View准备的，即它只能转换成一种格式，对于`ContentNegotiatingViewResolver`，需要多个**Single**ViewResolver来接收。\n\n### 8. 客户端调用 [Accessing RESTful services on the Client](http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate)\n\nSpring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。\n\n以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：\n    \n    String uri = \"http://example.com/hotels/1/bookings\";\n    \n    PostMethod post = new PostMethod(uri);\n    String request = // create booking request content\n    post.setRequestEntity(new StringRequestEntity(request));\n    \n    httpClient.executeMethod(post);\n    \n    if (HttpStatus.SC_CREATED == post.getStatusCode()) {\n      Header location = post.getRequestHeader(\"Location\");\n      if (location != null) {\n        System.out.println(\"Created new booking at :\" + location.getValue());\n      }\n    }\n\n太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。\n\n#### [RestTemplate](http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/)\n\nRestTemplate是client-site HTTP access的核心类。正如它的名称所示，`RestTemplate`非常类似于`JdbcTemplate`, `JmsTemplate`等XXXTemplate。这意味着`RestTemplate`是线程安全的并且可以通过callback来定制它的行为。\n\n**TIPS** Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。\n\nRestTemplate默认使用`java.net`包下的基础类来创建HTTP请求。你可以实现`ClientHttpRequestFactory`接口，提供你自己的Http请求工厂类。Spring提供了`CommonsClientHttpRequestFactory`，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。\n\n[RestTemplate提供的方法如下](http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html)：\n\n>**HTTP Method**\t**RestTemplate Method**\n>\n* DELETE\tdelete(String url, String… urlVariables)\n* GET\tgetForObject(String url, Class<T> responseType, String… urlVariables)\n* HEAD\theadForHeaders(String url, String… urlVariables)\n* OPTIONS\toptionsForAllow(String url, String… urlVariables)\n* POST\tpostForLocation(String url, Object request, String… urlVariables)\n* PUT\tput(String url, Object request, String…urlVariables)\n* ANY\texchange(String, HttpMethod, HttpEntity, Class, Object...)\n        execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)\n\n方法名称很有规律，都是这个pattern——`${HTTP Method}${WhatIsReturne}`。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.\n\n其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过`HttpMessageConverter`来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的`@RequestBody`和`@ResponseBody`是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。\n\n另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得`@PathVariable`吗:)哦。参数有两种方式绑定值：\n\n1. 作为字符串变量数组(String variable arguments array)\n    \n        String result = restTemplate.getForObject(\"http://example.com/hotels/{hotel}/bookings/{booking}\", String.class, \"42\", \"21\");\n        \n    会转换为一个对`http://example.com/hotels/42/bookings/21`的GET请求。\n    \n2. 或者Map对象(Map)\n\n   The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.\n        \n        Map<String, String> vars = new HashMap<String, String>();\n        vars.put(\"hotel\", \"42\");\n        vars.put(\"booking\", \"21\");\n        String result = restTemplate.getForObject(\"http://example.com/hotels/{hotel}/bookings/{booking}\", String.class, vars);\n        会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。\n\n关于RestTemplate使用的具体例子可以参考这篇文章[\nREST IN SPRING 3: RESTTEMPLATE](http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/)。写的非常好，强烈推荐！\n    \n### 9. 支持RESTful的URL\n\n在开发功能模块之前，应该先把URL设计好。比查对 **消息** 这个资源的操作URL可以这么设计：\n    \n    http://arganzheng.me/messages/show/123456\n    http://arganzheng.me/messages/preview/123456\n    http://arganzheng.me/messages/delete/123456\n    http://arganzheng.me/messages/new\n    http://arganzheng.me/message/update\n    \n说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。\n\n要支持这种URL，web.xml需要这么配置：\n\n    <!-- REST servlet-mapping -->\n    <servlet-mapping>\n    \t<servlet-name>DispatcherServlet<srvlet-name>\n    \t<url-pattern>/</url-pattern>\n    <srvlet-mapping>\n\t\n但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理[16.14.5 Configuring Serving of Resources](http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources)：\n\n    <!-- Forwards requests to the \"/\" resource to the \"welcome\" view -->\n  \t<mvc:view-controller path=\"/\" view-name=\"index\"/>\n  \t\n  \t<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory -->\n  \t<mvc:resources mapping=\"/resources/**\" location=\"/resources/\" />\n  \t<!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 \n  \t\t@see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined \n  \t-->\n  \t<mvc:annotation-driven />\n\n这样所有请求：`http://arganzheng.me/resources/**`会映射到webapp下的resources目录，而不是找我们的controller处理。\n\n但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个`<mvc:annotation-driven />`配置。具体参见[The handler mapping from the mvc:resource override other mappings which defined with annotation](http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined)。\n\n另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：\n\n    <!-- 避免被Spring DispatcherServlet接管 -->\n  \t<servlet-mapping>\n  \t\t<servlet-name>default<srvlet-name>\n  \t\t<url-pattern>*.html</url-pattern>\n  \t<srvlet-mapping>\n\n\n\n\n   \n\n","slug":"2015-11-03-restful-springmvc","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmop7m009iv8fy6d4hhwcc","content":"<p>Spring MVC本身对Restful支持非常好。它的<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@ResponseBody</code>注解很好的支持了REST。<a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html\" target=\"_blank\" rel=\"external\">18.2 Creating RESTful services</a></p>\n<h3 id=\"1-RequestMapping\"><a href=\"#1-RequestMapping\" class=\"headerlink\" title=\"1. @RequestMapping\"></a>1. <code>@RequestMapping</code></h3><p>Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。</p>\n<h3 id=\"2-PathVariable\"><a href=\"#2-PathVariable\" class=\"headerlink\" title=\"2. @PathVariable\"></a>2. <code>@PathVariable</code></h3><p>The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是<code>@RequestParam</code>做的事情。）</p>\n<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)\npublic String findOwner(@PathVariable String ownerId, Model model) {\n        // ...\n}\n</code></pre><p>如果变量名与pathVariable名不一致，那么需要指定：</p>\n<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)\npublic String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) {\n    // implementation omitted\n}\n</code></pre><blockquote>\n<p><strong>Tip</strong></p>\n<p>method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.</p>\n</blockquote>\n<h3 id=\"3-RequestParam\"><a href=\"#3-RequestParam\" class=\"headerlink\" title=\"3. @RequestParam\"></a>3. <code>@RequestParam</code></h3><p>官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟<code>@PathVariable</code>功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。</p>\n<p>对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:</p>\n<pre><code>@RequestMapping(&quot;/imageUpload&quot;)\npublic String processImageUpload(@RequestParam(&quot;name&quot;) String name,\n                @RequestParam(&quot;description&quot;) String description,\n                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {\n    this.imageDatabase.storeImage(name, image.getInputStream(), \n                                    (int) image.getSize(), description);\n    return &quot;redirect:imageList&quot;;\n}\n</code></pre><p>还可以设置defaultValue：</p>\n<pre><code>@RequestMapping(&quot;/imageUpload&quot;)\npublic String processImageUpload(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;arganzheng&quot;) String name,\n                @RequestParam(&quot;description&quot;) String description,\n                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {\n    this.imageDatabase.storeImage(name, image.getInputStream(), \n                                    (int) image.getSize(), description);\n    return &quot;redirect:imageList&quot;;\n}\n</code></pre><h3 id=\"4-RequestBody和-ResponseBody\"><a href=\"#4-RequestBody和-ResponseBody\" class=\"headerlink\" title=\"4. @RequestBody和@ResponseBody\"></a>4. <code>@RequestBody</code>和<code>@ResponseBody</code></h3><p>这两个注解其实用到了Spring的一个非常灵活的设计——<code>HttpMessageConverter</code> <a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion\" target=\"_blank\" rel=\"external\">18.3.2 HTTP Message Conversion</a></p>\n<p>与<code>@RequestParam</code>不同，<code>@RequestBody</code>和<code>@ResponseBody</code>是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。</p>\n<p><code>HtppMessageConverter</code>负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。</p>\n<pre><code>public interface HttpMessageConverter&lt;T&gt; {\n\n    // Indicate whether the given class is supported by this converter.\n    boolean supports(Class&lt;? extends T&gt; clazz);\n\n    // Return the list of MediaType objects supported by this converter.\n    List&lt;MediaType&gt; getSupportedMediaTypes();\n\n    // Read an object of the given type form the given input message, and returns it.\n    T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException, \n                                                                    HttpMessageNotReadableException;\n\n    // Write an given object to the given output message.\n    void write(T t, HttpOutputMessage outputMessage) throws IOException, \n                                                            HttpMessageNotWritableException;\n\n}        \n</code></pre><p>Spring MVC对<code>HttpMessageConverter</code>有多种默认实现，基本上不需要自己再自定义<code>HttpMessageConverter</code><br>&gt;</p>\n<ul>\n<li>StringHttpMessageConverter - converts strings</li>\n<li>FormHttpMessageConverter - converts form data to/from a MultiValueMap<string, string=\"\"></string,></li>\n<li>ByteArrayMessageConverter - converts byte arrays</li>\n<li>SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source</li>\n<li>RssChannelHttpMessageConverter - convert to/from RSS feeds</li>\n<li>MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson’s ObjectMapper</li>\n<li>etc…</li>\n</ul>\n<p>然而对于RESTful应用，用的最多的当然是<code>MappingJacksonHttpMessageConverter</code>。</p>\n<p>但是<code>MappingJacksonHttpMessageConverter</code>不是默认的<code>HttpMessageConverter</code>：</p>\n<pre><code>public class AnnotationMethodHandlerAdapter extends WebContentGenerator\nimplements HandlerAdapter, Ordered, BeanFactoryAware {\n\n    ...\n\n    public AnnotationMethodHandlerAdapter() {\n        // no restriction of HTTP methods by default\n        super(false);\n\n        // See SPR-7316\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,\n        new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};\n    }\n}   \n</code></pre><p>如上：默认的<code>HttpMessageConverter</code>是<code>ByteArrayHttpMessageConverter</code>、<code>stringHttpMessageConverter</code>、<code>SourceHttpMessageConverter</code>和<code>XmlAwareFormHttpMessageConverter</code>转换器。所以需要配置一下：</p>\n<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;\n    &lt;property name=&quot;messageConverters&quot;&gt;\n    &lt;list&gt;\n        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n        &lt;property name=&quot;supportedMediaTypes&quot;&gt;\n            &lt;list&gt;\n            &lt;value&gt;text/plain;charset=GBK&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n        &lt;/bean&gt;\n        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot; /&gt;\n    &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>配置好了之后，就可以享受<code>@Requestbody</code>和<code>@ResponseBody</code>对JONS转换的便利之处了：</p>\n<pre><code>@RequestMapping(value = &quot;api&quot;, method = RequestMethod.POST)\n@ResponseBody\npublic boolean addApi(@RequestBody\n    Api api, @RequestParam(value = &quot;afterApiId&quot;, required = false)\n    Integer afterApiId) {\n        Integer id = apiMetadataService.addApi(api);\n        return id &gt; 0;\n}\n\n@RequestMapping(value = &quot;api/{apiId}&quot;, method = RequestMethod.GET)\n@ResponseBody\npublic Api getApi(@PathVariable(&quot;apiId&quot;)\n    int apiId) {\n        return apiMetadataService.getApi(apiId, Version.primary);\n}\n</code></pre><p>一般情况下我们是不需要自定义<code>HttpMessageConverter</code>，不过对于Restful应用，有时候我们需要返回jsonp数据：</p>\n<pre><code>package me.arganzheng.study.springmvc.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;\nimport org.springframework.http.HttpOutputMessage;\nimport org.springframework.http.converter.HttpMessageNotWritableException;\nimport org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\npublic class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {\n\n    public MappingJsonpHttpMessageConverter() {\n    ObjectMapper objectMapper = new ObjectMapper();\n    objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));\n    setObjectMapper(objectMapper);\n    }\n\n    @Override\n    protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n    String jsonpCallback = null;\n\n    RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();\n    if(reqAttrs instanceof ServletRequestAttributes){\n        jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(&quot;jsonpCallback&quot;);\n    }\n\n    if(jsonpCallback != null){\n        new PrintStream(outputMessage.getBody()).print(jsonpCallback + &quot;(&quot;);\n    }\n\n    super.writeInternal(o, outputMessage);\n\n    if(jsonpCallback != null){\n        new PrintStream(outputMessage.getBody()).println(&quot;);&quot;);\n    }\n    }\n}\n</code></pre><p>如果请求的参数中带有<code>jsonpCallback</code>，那么会返回jsonp格式数据。比如：<br><a href=\"http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。\" target=\"_blank\" rel=\"external\">http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。</a><br>会返回<code>clientFunction(…);</code></p>\n<h3 id=\"5-CookieValue\"><a href=\"#5-CookieValue\" class=\"headerlink\" title=\"5. @CookieValue\"></a>5. <code>@CookieValue</code></h3><p><code>@CookieValue</code>用于将请求的Cookie数据映射到功能处理方法的参数上。</p>\n<pre><code>public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId){\n    ...\n}\n</code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>\n<pre><code>public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId){\n    ...\n}\n</code></pre><p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>\n<p><strong>TIPS</strong> 如果是使用cookies值来保持回话状态的话，推荐使用Spring的<a href=\"http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\" target=\"_blank\" rel=\"external\">Bean Scopes</a>机制，具体参见笔者的另一篇文章：<a href=\"http://blog.arganzheng.me/posts/spring-bean-scopes.html\" target=\"_blank\" rel=\"external\">Spring的Bean Scopes</a>。非常方便。</p>\n<h3 id=\"6-RequestHeader\"><a href=\"#6-RequestHeader\" class=\"headerlink\" title=\"6. @RequestHeader\"></a>6. <code>@RequestHeader</code></h3><p><code>@RequestHeader</code>用于将请求的头信息区数据映射到功能处理方法的参数上。</p>\n<pre><code>@RequestMapping(value=&quot;/header&quot;)  \npublic String test(  \n   @RequestHeader(&quot;User-Agent&quot;) String userAgent,  \n   @RequestHeader(value=&quot;Accept&quot;) String[] accepts)  \n</code></pre><p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。</p>\n<h3 id=\"7-返回多种表现形式-Returning-multiple-representations\"><a href=\"#7-返回多种表现形式-Returning-multiple-representations\" class=\"headerlink\" title=\"7. 返回多种表现形式(Returning multiple representations)\"></a>7. 返回多种表现形式(Returning multiple representations)</h3><p>对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？</p>\n<p>一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：</p>\n<ol>\n<li>使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如<a href=\"http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式\" target=\"_blank\" rel=\"external\">http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式</a>.</li>\n<li>使用一个请求参数告诉服务器希望得到的资源格式。如format=json。</li>\n<li>使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求<a href=\"http://blog.arganzheng.me/users/argan，如果带上`text/xml`\" target=\"_blank\" rel=\"external\">http://blog.arganzheng.me/users/argan，如果带上`text/xml`</a> accept header表示请求一个XML资源，带上<code>application/pdf</code>则表示期望收到pdf格式资源。</li>\n</ol>\n<p>这其实就是Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>\n<p>Spring提供了<a href=\"http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html\" target=\"_blank\" rel=\"external\"><code>ContentNegotiatingViewResolver</code></a>来解决这个问题：</p>\n<pre><code>public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {\n\n    private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);\n\n    private static final String ACCEPT_HEADER = &quot;Accept&quot;;\n\n    private static final boolean jafPresent =\n        ClassUtils.isPresent(&quot;javax.activation.FileTypeMap&quot;, ContentNegotiatingViewResolver.class.getClassLoader());\n\n    private static final UrlPathHelper urlPathHelper = new UrlPathHelper();\n\n\n    private int order = Ordered.HIGHEST_PRECEDENCE;\n\n    private boolean favorPathExtension = true;\n\n    private boolean favorParameter = false;\n\n    private String parameterName = &quot;format&quot;;\n\n    private boolean useNotAcceptableStatusCode = false;\n\n    private boolean ignoreAcceptHeader = false;\n\n    private boolean useJaf = true;\n\n    private ConcurrentMap&lt;String, MediaType&gt; mediaTypes = new ConcurrentHashMap&lt;String, MediaType&gt;();\n\n    private List&lt;View&gt; defaultViews;\n\n    private MediaType defaultContentType;\n\n    private List&lt;ViewResolver&gt; viewResolvers;\n\n\n    // ignore some setter and getter...    \n\n    public void setMediaTypes(Map&lt;String, String&gt; mediaTypes) {\n      Assert.notNull(mediaTypes, &quot;&apos;mediaTypes&apos; must not be null&quot;);\n      for (Map.Entry&lt;String, String&gt; entry : mediaTypes.entrySet()) {\n        String extension = entry.getKey().toLowerCase(Locale.ENGLISH);\n        MediaType mediaType = MediaType.parseMediaType(entry.getValue());\n        this.mediaTypes.put(extension, mediaType);\n      }\n    }\n\n    public void setDefaultViews(List&lt;View&gt; defaultViews) {\n      this.defaultViews = defaultViews;\n    }\n\n    public void setDefaultContentType(MediaType defaultContentType) {\n      this.defaultContentType = defaultContentType;\n    }\n\n    public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {\n      this.viewResolvers = viewResolvers;\n    }\n\n\n    @Override\n    protected void initServletContext(ServletContext servletContext) {\n      if (this.viewResolvers == null) {\n        Map&lt;String, ViewResolver&gt; matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);\n        this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.size());\n        for (ViewResolver viewResolver : matchingBeans.values()) {\n          if (this != viewResolver) {\n            this.viewResolvers.add(viewResolver);\n          }\n        }\n      }\n      if (this.viewResolvers.isEmpty()) {\n        logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &quot; +\n            &quot;&apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);\n      }\n      OrderComparator.sort(this.viewResolvers);\n    }\n\n    public View resolveViewName(String viewName, Locale locale) throws Exception {\n      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n      Assert.isInstanceOf(ServletRequestAttributes.class, attrs);\n      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n      if (requestedMediaTypes != null) {\n        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n        View bestView = getBestView(candidateViews, requestedMediaTypes);\n        if (bestView != null) {\n          return bestView;\n        }\n      }\n      if (this.useNotAcceptableStatusCode) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);\n        }\n        return NOT_ACCEPTABLE_VIEW;\n      }\n      else {\n        logger.debug(&quot;No acceptable view found; returning null&quot;);\n        return null;\n      }\n    }\n\n\n    protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {\n      if (this.favorPathExtension) {\n        String requestUri = urlPathHelper.getRequestUri(request);\n        String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);\n        MediaType mediaType = getMediaTypeFromFilename(filename);\n        if (mediaType != null) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on filename &apos;&quot; + filename + &quot;&apos;)&quot;);\n          }\n          return Collections.singletonList(mediaType);\n        }\n      }\n      if (this.favorParameter) {\n        if (request.getParameter(this.parameterName) != null) {\n          String parameterValue = request.getParameter(this.parameterName);\n          MediaType mediaType = getMediaTypeFromParameter(parameterValue);\n          if (mediaType != null) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on parameter &apos;&quot; +\n                  this.parameterName + &quot;&apos;=&apos;&quot; + parameterValue + &quot;&apos;)&quot;);\n            }\n            return Collections.singletonList(mediaType);\n          }\n        }\n      }\n      if (!this.ignoreAcceptHeader) {\n        String acceptHeader = request.getHeader(ACCEPT_HEADER);\n        if (StringUtils.hasText(acceptHeader)) {\n          try {\n                      List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(acceptHeader);\n                      MediaType.sortByQualityValue(mediaTypes);\n                      if (logger.isDebugEnabled()) {\n                          logger.debug(&quot;Requested media types are &quot; + mediaTypes + &quot; (based on Accept header)&quot;);\n                      }\n                      return mediaTypes;\n          }\n          catch (IllegalArgumentException ex) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(&quot;Could not parse accept header [&quot; + acceptHeader + &quot;]: &quot; + ex.getMessage());\n            }\n            return null;\n          }\n        }\n      }\n      if (this.defaultContentType != null) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(&quot;Requested media types is &quot; + this.defaultContentType +\n              &quot; (based on defaultContentType property)&quot;);\n        }\n        return Collections.singletonList(this.defaultContentType);\n      }\n      else {\n        return Collections.emptyList();\n      }\n    }\n\n\n    protected MediaType getMediaTypeFromFilename(String filename) {\n      String extension = StringUtils.getFilenameExtension(filename);\n      if (!StringUtils.hasText(extension)) {\n        return null;\n      }\n      extension = extension.toLowerCase(Locale.ENGLISH);\n      MediaType mediaType = this.mediaTypes.get(extension);\n      if (mediaType == null &amp;&amp; this.useJaf &amp;&amp; jafPresent) {\n        mediaType = ActivationMediaTypeFactory.getMediaType(filename);\n        if (mediaType != null) {\n          this.mediaTypes.putIfAbsent(extension, mediaType);\n        }\n      }\n      return mediaType;\n    }\n\n\n    protected MediaType getMediaTypeFromParameter(String parameterValue) {\n      return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));\n    }\n\n    private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)\n        throws Exception {\n\n      List&lt;View&gt; candidateViews = new ArrayList&lt;View&gt;();\n      for (ViewResolver viewResolver : this.viewResolvers) {\n        View view = viewResolver.resolveViewName(viewName, locale);\n        if (view != null) {\n          candidateViews.add(view);\n        }\n        for (MediaType requestedMediaType : requestedMediaTypes) {\n          List&lt;String&gt; extensions = getExtensionsForMediaType(requestedMediaType);\n          for (String extension : extensions) {\n            String viewNameWithExtension = viewName + &quot;.&quot; + extension;\n            view = viewResolver.resolveViewName(viewNameWithExtension, locale);\n            if (view != null) {\n              candidateViews.add(view);\n            }\n          }\n\n        }\n      }\n      if (!CollectionUtils.isEmpty(this.defaultViews)) {\n        candidateViews.addAll(this.defaultViews);\n      }\n      return candidateViews;\n    }\n\n    private List&lt;String&gt; getExtensionsForMediaType(MediaType requestedMediaType) {\n      List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n      for (Entry&lt;String, MediaType&gt; entry : this.mediaTypes.entrySet()) {\n        if (requestedMediaType.includes(entry.getValue())) {\n          result.add(entry.getKey());\n        }\n      }\n      return result;\n    }\n\n    private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes) {\n      MediaType bestRequestedMediaType = null;\n      View bestView = null;\n      for (MediaType requestedMediaType : requestedMediaTypes) {\n        for (View candidateView : candidateViews) {\n          if (StringUtils.hasText(candidateView.getContentType())) {\n            MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());\n            if (requestedMediaType.includes(candidateContentType)) {\n              bestRequestedMediaType = requestedMediaType;\n              bestView = candidateView;\n              break;\n            }\n          }\n        }\n        if (bestView != null) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Returning [&quot; + bestView + &quot;] based on requested media type &apos;&quot; +\n                bestRequestedMediaType + &quot;&apos;&quot;);\n          }\n          break;\n        }\n      }\n      return bestView;\n\n    }\n\n    ...\n\n}\n</code></pre><p>可以看到<code>ContentNegotiationViewResolver</code>有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。</p>\n<p>所以关键在两点：</p>\n<h4 id=\"1-content-negotiation策略-ContentNegotiationStrategy\"><a href=\"#1-content-negotiation策略-ContentNegotiationStrategy\" class=\"headerlink\" title=\"1. content negotiation策略 (ContentNegotiationStrategy)\"></a>1. content negotiation策略 (<code>ContentNegotiationStrategy</code>)</h4><blockquote>\n<p>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:</p>\n<ol>\n<li>If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.</li>\n<li>If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.</li>\n<li>If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.</li>\n<li>If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.</li>\n</ol>\n<p>Once the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view’s content type). The most compatible view is returned.</p>\n</blockquote>\n<p>这个就是上面提到的Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>\n<p>关于<code>ContentNegotiationStrategy</code>，可以参考笔者的另一篇文章：<a href=\"http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html\" target=\"_blank\" rel=\"external\">content negotiation using spring mvc</a>。有具体的实际案例。</p>\n<h5 id=\"2-供选择的SingleViewResolver\"><a href=\"#2-供选择的SingleViewResolver\" class=\"headerlink\" title=\"2. 供选择的SingleViewResolver\"></a>2. 供选择的SingleViewResolver</h5><blockquote>\n<ol>\n<li><p>The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)</p>\n<p> 说明：即<code>private List&lt;ViewResolver&gt; viewResolvers;</code>属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到<code>ContentNegotiationViewResolover</code>的<code>viewResolvers</code>属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由<code>ContentNegotiationViewResolover</code>来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给<code>ContentNegotiationViewResolover</code>配置最高的order(其实默认就是最高了)。</p>\n</li>\n<li><p>Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.</p>\n<p> 说明：即<code>private List&lt;View&gt; defaultViews;</code>和<code>private MediaType defaultContentType;</code>属性。</p>\n</li>\n</ol>\n</blockquote>\n<p>关于<code>ContentNegotiatingViewResolver</code>，下面两篇文章都不错，值得一看：</p>\n<ol>\n<li><a href=\"http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html\" target=\"_blank\" rel=\"external\">Content Negotiation using Spring MVC’s ContentNegotiatingViewResolver</a>:使用了<code>viewResolvers</code>配置。</li>\n<li><a href=\"http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/\" target=\"_blank\" rel=\"external\">ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING’S REST SUPPORT</a>:使用了<code>ViewResolvers</code>配置。</li>\n<li><a href=\"http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/\" target=\"_blank\" rel=\"external\">Spring 3 MVC ContentNegotiatingViewResolver Example</a>:使用了<code>defaultViews</code>配置。</li>\n</ol>\n<p>注意：<code>@ResponseBody</code>是为了单个View准备的，即它只能转换成一种格式，对于<code>ContentNegotiatingViewResolver</code>，需要多个<strong>Single</strong>ViewResolver来接收。</p>\n<h3 id=\"8-客户端调用-Accessing-RESTful-services-on-the-Client\"><a href=\"#8-客户端调用-Accessing-RESTful-services-on-the-Client\" class=\"headerlink\" title=\"8. 客户端调用 Accessing RESTful services on the Client\"></a>8. 客户端调用 <a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate\" target=\"_blank\" rel=\"external\">Accessing RESTful services on the Client</a></h3><p>Spring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。</p>\n<p>以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：</p>\n<pre><code>String uri = &quot;http://example.com/hotels/1/bookings&quot;;\n\nPostMethod post = new PostMethod(uri);\nString request = // create booking request content\npost.setRequestEntity(new StringRequestEntity(request));\n\nhttpClient.executeMethod(post);\n\nif (HttpStatus.SC_CREATED == post.getStatusCode()) {\n  Header location = post.getRequestHeader(&quot;Location&quot;);\n  if (location != null) {\n    System.out.println(&quot;Created new booking at :&quot; + location.getValue());\n  }\n}\n</code></pre><p>太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。</p>\n<h4 id=\"RestTemplate\"><a href=\"#RestTemplate\" class=\"headerlink\" title=\"RestTemplate\"></a><a href=\"http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/\" target=\"_blank\" rel=\"external\">RestTemplate</a></h4><p>RestTemplate是client-site HTTP access的核心类。正如它的名称所示，<code>RestTemplate</code>非常类似于<code>JdbcTemplate</code>, <code>JmsTemplate</code>等XXXTemplate。这意味着<code>RestTemplate</code>是线程安全的并且可以通过callback来定制它的行为。</p>\n<p><strong>TIPS</strong> Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。</p>\n<p>RestTemplate默认使用<code>java.net</code>包下的基础类来创建HTTP请求。你可以实现<code>ClientHttpRequestFactory</code>接口，提供你自己的Http请求工厂类。Spring提供了<code>CommonsClientHttpRequestFactory</code>，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。</p>\n<p><a href=\"http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html\" target=\"_blank\" rel=\"external\">RestTemplate提供的方法如下</a>：</p>\n<blockquote>\n<p><strong>HTTP Method</strong>    <strong>RestTemplate Method</strong></p>\n<ul>\n<li>DELETE    delete(String url, String… urlVariables)</li>\n<li>GET    getForObject(String url, Class<t> responseType, String… urlVariables)</t></li>\n<li>HEAD    headForHeaders(String url, String… urlVariables)</li>\n<li>OPTIONS    optionsForAllow(String url, String… urlVariables)</li>\n<li>POST    postForLocation(String url, Object request, String… urlVariables)</li>\n<li>PUT    put(String url, Object request, String…urlVariables)</li>\n<li>ANY    exchange(String, HttpMethod, HttpEntity, Class, Object…)<pre><code>execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)\n</code></pre></li>\n</ul>\n</blockquote>\n<p>方法名称很有规律，都是这个pattern——<code>${HTTP Method}${WhatIsReturne}</code>。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.</p>\n<p>其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过<code>HttpMessageConverter</code>来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的<code>@RequestBody</code>和<code>@ResponseBody</code>是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。</p>\n<p>另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得<code>@PathVariable</code>吗:)哦。参数有两种方式绑定值：</p>\n<ol>\n<li><p>作为字符串变量数组(String variable arguments array)</p>\n<pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, &quot;42&quot;, &quot;21&quot;);\n</code></pre><p> 会转换为一个对<code>http://example.com/hotels/42/bookings/21</code>的GET请求。</p>\n</li>\n<li><p>或者Map对象(Map)</p>\n<p>The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.</p>\n<pre><code>Map&lt;String, String&gt; vars = new HashMap&lt;String, String&gt;();\nvars.put(&quot;hotel&quot;, &quot;42&quot;);\nvars.put(&quot;booking&quot;, &quot;21&quot;);\nString result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, vars);\n会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。\n</code></pre></li>\n</ol>\n<p>关于RestTemplate使用的具体例子可以参考这篇文章<a href=\"http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/\" target=\"_blank\" rel=\"external\"><br>REST IN SPRING 3: RESTTEMPLATE</a>。写的非常好，强烈推荐！</p>\n<h3 id=\"9-支持RESTful的URL\"><a href=\"#9-支持RESTful的URL\" class=\"headerlink\" title=\"9. 支持RESTful的URL\"></a>9. 支持RESTful的URL</h3><p>在开发功能模块之前，应该先把URL设计好。比查对 <strong>消息</strong> 这个资源的操作URL可以这么设计：</p>\n<pre><code>http://arganzheng.me/messages/show/123456\nhttp://arganzheng.me/messages/preview/123456\nhttp://arganzheng.me/messages/delete/123456\nhttp://arganzheng.me/messages/new\nhttp://arganzheng.me/message/update\n</code></pre><p>说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。</p>\n<p>要支持这种URL，web.xml需要这么配置：</p>\n<pre><code>&lt;!-- REST servlet-mapping --&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DispatcherServlet&lt;srvlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;srvlet-mapping&gt;\n</code></pre><p>但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理<a href=\"http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources\" target=\"_blank\" rel=\"external\">16.14.5 Configuring Serving of Resources</a>：</p>\n<pre><code>&lt;!-- Forwards requests to the &quot;/&quot; resource to the &quot;welcome&quot; view --&gt;\n  &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;\n\n  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory --&gt;\n  &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt;\n  &lt;!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 \n      @see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined \n  --&gt;\n  &lt;mvc:annotation-driven /&gt;\n</code></pre><p>这样所有请求：<code>http://arganzheng.me/resources/**</code>会映射到webapp下的resources目录，而不是找我们的controller处理。</p>\n<p>但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个<code>&lt;mvc:annotation-driven /&gt;</code>配置。具体参见<a href=\"http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined\" target=\"_blank\" rel=\"external\">The handler mapping from the mvc:resource override other mappings which defined with annotation</a>。</p>\n<p>另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：<a href=\"http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：\" target=\"_blank\" rel=\"external\">http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：</a></p>\n<pre><code>&lt;!-- 避免被Spring DispatcherServlet接管 --&gt;\n  &lt;servlet-mapping&gt;\n      &lt;servlet-name&gt;default&lt;srvlet-name&gt;\n      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;\n  &lt;srvlet-mapping&gt;\n</code></pre>","excerpt":"","more":"<p>Spring MVC本身对Restful支持非常好。它的<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@ResponseBody</code>注解很好的支持了REST。<a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html\">18.2 Creating RESTful services</a></p>\n<h3 id=\"1-RequestMapping\"><a href=\"#1-RequestMapping\" class=\"headerlink\" title=\"1. @RequestMapping\"></a>1. <code>@RequestMapping</code></h3><p>Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。</p>\n<h3 id=\"2-PathVariable\"><a href=\"#2-PathVariable\" class=\"headerlink\" title=\"2. @PathVariable\"></a>2. <code>@PathVariable</code></h3><p>The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是<code>@RequestParam</code>做的事情。）</p>\n<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)\npublic String findOwner(@PathVariable String ownerId, Model model) {\n        // ...\n}\n</code></pre><p>如果变量名与pathVariable名不一致，那么需要指定：</p>\n<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)\npublic String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) {\n    // implementation omitted\n}\n</code></pre><blockquote>\n<p><strong>Tip</strong></p>\n<p>method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.</p>\n</blockquote>\n<h3 id=\"3-RequestParam\"><a href=\"#3-RequestParam\" class=\"headerlink\" title=\"3. @RequestParam\"></a>3. <code>@RequestParam</code></h3><p>官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟<code>@PathVariable</code>功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。</p>\n<p>对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:</p>\n<pre><code>@RequestMapping(&quot;/imageUpload&quot;)\npublic String processImageUpload(@RequestParam(&quot;name&quot;) String name,\n                @RequestParam(&quot;description&quot;) String description,\n                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {\n    this.imageDatabase.storeImage(name, image.getInputStream(), \n                                    (int) image.getSize(), description);\n    return &quot;redirect:imageList&quot;;\n}\n</code></pre><p>还可以设置defaultValue：</p>\n<pre><code>@RequestMapping(&quot;/imageUpload&quot;)\npublic String processImageUpload(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;arganzheng&quot;) String name,\n                @RequestParam(&quot;description&quot;) String description,\n                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {\n    this.imageDatabase.storeImage(name, image.getInputStream(), \n                                    (int) image.getSize(), description);\n    return &quot;redirect:imageList&quot;;\n}\n</code></pre><h3 id=\"4-RequestBody和-ResponseBody\"><a href=\"#4-RequestBody和-ResponseBody\" class=\"headerlink\" title=\"4. @RequestBody和@ResponseBody\"></a>4. <code>@RequestBody</code>和<code>@ResponseBody</code></h3><p>这两个注解其实用到了Spring的一个非常灵活的设计——<code>HttpMessageConverter</code> <a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion\">18.3.2 HTTP Message Conversion</a></p>\n<p>与<code>@RequestParam</code>不同，<code>@RequestBody</code>和<code>@ResponseBody</code>是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。</p>\n<p><code>HtppMessageConverter</code>负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。</p>\n<pre><code>public interface HttpMessageConverter&lt;T&gt; {\n\n    // Indicate whether the given class is supported by this converter.\n    boolean supports(Class&lt;? extends T&gt; clazz);\n\n    // Return the list of MediaType objects supported by this converter.\n    List&lt;MediaType&gt; getSupportedMediaTypes();\n\n    // Read an object of the given type form the given input message, and returns it.\n    T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException, \n                                                                    HttpMessageNotReadableException;\n\n    // Write an given object to the given output message.\n    void write(T t, HttpOutputMessage outputMessage) throws IOException, \n                                                            HttpMessageNotWritableException;\n\n}        \n</code></pre><p>Spring MVC对<code>HttpMessageConverter</code>有多种默认实现，基本上不需要自己再自定义<code>HttpMessageConverter</code><br>&gt;</p>\n<ul>\n<li>StringHttpMessageConverter - converts strings</li>\n<li>FormHttpMessageConverter - converts form data to/from a MultiValueMap<String, String></li>\n<li>ByteArrayMessageConverter - converts byte arrays</li>\n<li>SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source</li>\n<li>RssChannelHttpMessageConverter - convert to/from RSS feeds</li>\n<li>MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson’s ObjectMapper</li>\n<li>etc…</li>\n</ul>\n<p>然而对于RESTful应用，用的最多的当然是<code>MappingJacksonHttpMessageConverter</code>。</p>\n<p>但是<code>MappingJacksonHttpMessageConverter</code>不是默认的<code>HttpMessageConverter</code>：</p>\n<pre><code>public class AnnotationMethodHandlerAdapter extends WebContentGenerator\nimplements HandlerAdapter, Ordered, BeanFactoryAware {\n\n    ...\n\n    public AnnotationMethodHandlerAdapter() {\n        // no restriction of HTTP methods by default\n        super(false);\n\n        // See SPR-7316\n        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();\n        stringHttpMessageConverter.setWriteAcceptCharset(false);\n        this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,\n        new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};\n    }\n}   \n</code></pre><p>如上：默认的<code>HttpMessageConverter</code>是<code>ByteArrayHttpMessageConverter</code>、<code>stringHttpMessageConverter</code>、<code>SourceHttpMessageConverter</code>和<code>XmlAwareFormHttpMessageConverter</code>转换器。所以需要配置一下：</p>\n<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;\n    &lt;property name=&quot;messageConverters&quot;&gt;\n    &lt;list&gt;\n        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n        &lt;property name=&quot;supportedMediaTypes&quot;&gt;\n            &lt;list&gt;\n            &lt;value&gt;text/plain;charset=GBK&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n        &lt;/bean&gt;\n        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot; /&gt;\n    &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>配置好了之后，就可以享受<code>@Requestbody</code>和<code>@ResponseBody</code>对JONS转换的便利之处了：</p>\n<pre><code>@RequestMapping(value = &quot;api&quot;, method = RequestMethod.POST)\n@ResponseBody\npublic boolean addApi(@RequestBody\n    Api api, @RequestParam(value = &quot;afterApiId&quot;, required = false)\n    Integer afterApiId) {\n        Integer id = apiMetadataService.addApi(api);\n        return id &gt; 0;\n}\n\n@RequestMapping(value = &quot;api/{apiId}&quot;, method = RequestMethod.GET)\n@ResponseBody\npublic Api getApi(@PathVariable(&quot;apiId&quot;)\n    int apiId) {\n        return apiMetadataService.getApi(apiId, Version.primary);\n}\n</code></pre><p>一般情况下我们是不需要自定义<code>HttpMessageConverter</code>，不过对于Restful应用，有时候我们需要返回jsonp数据：</p>\n<pre><code>package me.arganzheng.study.springmvc.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;\nimport org.springframework.http.HttpOutputMessage;\nimport org.springframework.http.converter.HttpMessageNotWritableException;\nimport org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;\nimport org.springframework.web.context.request.RequestAttributes;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\npublic class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {\n\n    public MappingJsonpHttpMessageConverter() {\n    ObjectMapper objectMapper = new ObjectMapper();\n    objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));\n    setObjectMapper(objectMapper);\n    }\n\n    @Override\n    protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n    String jsonpCallback = null;\n\n    RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();\n    if(reqAttrs instanceof ServletRequestAttributes){\n        jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(&quot;jsonpCallback&quot;);\n    }\n\n    if(jsonpCallback != null){\n        new PrintStream(outputMessage.getBody()).print(jsonpCallback + &quot;(&quot;);\n    }\n\n    super.writeInternal(o, outputMessage);\n\n    if(jsonpCallback != null){\n        new PrintStream(outputMessage.getBody()).println(&quot;);&quot;);\n    }\n    }\n}\n</code></pre><p>如果请求的参数中带有<code>jsonpCallback</code>，那么会返回jsonp格式数据。比如：<br><a href=\"http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。\">http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。</a><br>会返回<code>clientFunction(…);</code></p>\n<h3 id=\"5-CookieValue\"><a href=\"#5-CookieValue\" class=\"headerlink\" title=\"5. @CookieValue\"></a>5. <code>@CookieValue</code></h3><p><code>@CookieValue</code>用于将请求的Cookie数据映射到功能处理方法的参数上。</p>\n<pre><code>public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId){\n    ...\n}\n</code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>\n<pre><code>public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId){\n    ...\n}\n</code></pre><p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>\n<p><strong>TIPS</strong> 如果是使用cookies值来保持回话状态的话，推荐使用Spring的<a href=\"http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html\">Bean Scopes</a>机制，具体参见笔者的另一篇文章：<a href=\"http://blog.arganzheng.me/posts/spring-bean-scopes.html\">Spring的Bean Scopes</a>。非常方便。</p>\n<h3 id=\"6-RequestHeader\"><a href=\"#6-RequestHeader\" class=\"headerlink\" title=\"6. @RequestHeader\"></a>6. <code>@RequestHeader</code></h3><p><code>@RequestHeader</code>用于将请求的头信息区数据映射到功能处理方法的参数上。</p>\n<pre><code>@RequestMapping(value=&quot;/header&quot;)  \npublic String test(  \n   @RequestHeader(&quot;User-Agent&quot;) String userAgent,  \n   @RequestHeader(value=&quot;Accept&quot;) String[] accepts)  \n</code></pre><p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。</p>\n<h3 id=\"7-返回多种表现形式-Returning-multiple-representations\"><a href=\"#7-返回多种表现形式-Returning-multiple-representations\" class=\"headerlink\" title=\"7. 返回多种表现形式(Returning multiple representations)\"></a>7. 返回多种表现形式(Returning multiple representations)</h3><p>对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？</p>\n<p>一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：</p>\n<ol>\n<li>使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如<a href=\"http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式\">http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式</a>.</li>\n<li>使用一个请求参数告诉服务器希望得到的资源格式。如format=json。</li>\n<li>使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求<a href=\"http://blog.arganzheng.me/users/argan，如果带上`text/xml`\">http://blog.arganzheng.me/users/argan，如果带上`text/xml`</a> accept header表示请求一个XML资源，带上<code>application/pdf</code>则表示期望收到pdf格式资源。</li>\n</ol>\n<p>这其实就是Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>\n<p>Spring提供了<a href=\"http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html\"><code>ContentNegotiatingViewResolver</code></a>来解决这个问题：</p>\n<pre><code>public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {\n\n    private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);\n\n    private static final String ACCEPT_HEADER = &quot;Accept&quot;;\n\n    private static final boolean jafPresent =\n        ClassUtils.isPresent(&quot;javax.activation.FileTypeMap&quot;, ContentNegotiatingViewResolver.class.getClassLoader());\n\n    private static final UrlPathHelper urlPathHelper = new UrlPathHelper();\n\n\n    private int order = Ordered.HIGHEST_PRECEDENCE;\n\n    private boolean favorPathExtension = true;\n\n    private boolean favorParameter = false;\n\n    private String parameterName = &quot;format&quot;;\n\n    private boolean useNotAcceptableStatusCode = false;\n\n    private boolean ignoreAcceptHeader = false;\n\n    private boolean useJaf = true;\n\n    private ConcurrentMap&lt;String, MediaType&gt; mediaTypes = new ConcurrentHashMap&lt;String, MediaType&gt;();\n\n    private List&lt;View&gt; defaultViews;\n\n    private MediaType defaultContentType;\n\n    private List&lt;ViewResolver&gt; viewResolvers;\n\n\n    // ignore some setter and getter...    \n\n    public void setMediaTypes(Map&lt;String, String&gt; mediaTypes) {\n      Assert.notNull(mediaTypes, &quot;&apos;mediaTypes&apos; must not be null&quot;);\n      for (Map.Entry&lt;String, String&gt; entry : mediaTypes.entrySet()) {\n        String extension = entry.getKey().toLowerCase(Locale.ENGLISH);\n        MediaType mediaType = MediaType.parseMediaType(entry.getValue());\n        this.mediaTypes.put(extension, mediaType);\n      }\n    }\n\n    public void setDefaultViews(List&lt;View&gt; defaultViews) {\n      this.defaultViews = defaultViews;\n    }\n\n    public void setDefaultContentType(MediaType defaultContentType) {\n      this.defaultContentType = defaultContentType;\n    }\n\n    public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {\n      this.viewResolvers = viewResolvers;\n    }\n\n\n    @Override\n    protected void initServletContext(ServletContext servletContext) {\n      if (this.viewResolvers == null) {\n        Map&lt;String, ViewResolver&gt; matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);\n        this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.size());\n        for (ViewResolver viewResolver : matchingBeans.values()) {\n          if (this != viewResolver) {\n            this.viewResolvers.add(viewResolver);\n          }\n        }\n      }\n      if (this.viewResolvers.isEmpty()) {\n        logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &quot; +\n            &quot;&apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);\n      }\n      OrderComparator.sort(this.viewResolvers);\n    }\n\n    public View resolveViewName(String viewName, Locale locale) throws Exception {\n      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();\n      Assert.isInstanceOf(ServletRequestAttributes.class, attrs);\n      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());\n      if (requestedMediaTypes != null) {\n        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);\n        View bestView = getBestView(candidateViews, requestedMediaTypes);\n        if (bestView != null) {\n          return bestView;\n        }\n      }\n      if (this.useNotAcceptableStatusCode) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);\n        }\n        return NOT_ACCEPTABLE_VIEW;\n      }\n      else {\n        logger.debug(&quot;No acceptable view found; returning null&quot;);\n        return null;\n      }\n    }\n\n\n    protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {\n      if (this.favorPathExtension) {\n        String requestUri = urlPathHelper.getRequestUri(request);\n        String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);\n        MediaType mediaType = getMediaTypeFromFilename(filename);\n        if (mediaType != null) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on filename &apos;&quot; + filename + &quot;&apos;)&quot;);\n          }\n          return Collections.singletonList(mediaType);\n        }\n      }\n      if (this.favorParameter) {\n        if (request.getParameter(this.parameterName) != null) {\n          String parameterValue = request.getParameter(this.parameterName);\n          MediaType mediaType = getMediaTypeFromParameter(parameterValue);\n          if (mediaType != null) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on parameter &apos;&quot; +\n                  this.parameterName + &quot;&apos;=&apos;&quot; + parameterValue + &quot;&apos;)&quot;);\n            }\n            return Collections.singletonList(mediaType);\n          }\n        }\n      }\n      if (!this.ignoreAcceptHeader) {\n        String acceptHeader = request.getHeader(ACCEPT_HEADER);\n        if (StringUtils.hasText(acceptHeader)) {\n          try {\n                      List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(acceptHeader);\n                      MediaType.sortByQualityValue(mediaTypes);\n                      if (logger.isDebugEnabled()) {\n                          logger.debug(&quot;Requested media types are &quot; + mediaTypes + &quot; (based on Accept header)&quot;);\n                      }\n                      return mediaTypes;\n          }\n          catch (IllegalArgumentException ex) {\n            if (logger.isDebugEnabled()) {\n              logger.debug(&quot;Could not parse accept header [&quot; + acceptHeader + &quot;]: &quot; + ex.getMessage());\n            }\n            return null;\n          }\n        }\n      }\n      if (this.defaultContentType != null) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(&quot;Requested media types is &quot; + this.defaultContentType +\n              &quot; (based on defaultContentType property)&quot;);\n        }\n        return Collections.singletonList(this.defaultContentType);\n      }\n      else {\n        return Collections.emptyList();\n      }\n    }\n\n\n    protected MediaType getMediaTypeFromFilename(String filename) {\n      String extension = StringUtils.getFilenameExtension(filename);\n      if (!StringUtils.hasText(extension)) {\n        return null;\n      }\n      extension = extension.toLowerCase(Locale.ENGLISH);\n      MediaType mediaType = this.mediaTypes.get(extension);\n      if (mediaType == null &amp;&amp; this.useJaf &amp;&amp; jafPresent) {\n        mediaType = ActivationMediaTypeFactory.getMediaType(filename);\n        if (mediaType != null) {\n          this.mediaTypes.putIfAbsent(extension, mediaType);\n        }\n      }\n      return mediaType;\n    }\n\n\n    protected MediaType getMediaTypeFromParameter(String parameterValue) {\n      return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));\n    }\n\n    private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)\n        throws Exception {\n\n      List&lt;View&gt; candidateViews = new ArrayList&lt;View&gt;();\n      for (ViewResolver viewResolver : this.viewResolvers) {\n        View view = viewResolver.resolveViewName(viewName, locale);\n        if (view != null) {\n          candidateViews.add(view);\n        }\n        for (MediaType requestedMediaType : requestedMediaTypes) {\n          List&lt;String&gt; extensions = getExtensionsForMediaType(requestedMediaType);\n          for (String extension : extensions) {\n            String viewNameWithExtension = viewName + &quot;.&quot; + extension;\n            view = viewResolver.resolveViewName(viewNameWithExtension, locale);\n            if (view != null) {\n              candidateViews.add(view);\n            }\n          }\n\n        }\n      }\n      if (!CollectionUtils.isEmpty(this.defaultViews)) {\n        candidateViews.addAll(this.defaultViews);\n      }\n      return candidateViews;\n    }\n\n    private List&lt;String&gt; getExtensionsForMediaType(MediaType requestedMediaType) {\n      List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n      for (Entry&lt;String, MediaType&gt; entry : this.mediaTypes.entrySet()) {\n        if (requestedMediaType.includes(entry.getValue())) {\n          result.add(entry.getKey());\n        }\n      }\n      return result;\n    }\n\n    private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes) {\n      MediaType bestRequestedMediaType = null;\n      View bestView = null;\n      for (MediaType requestedMediaType : requestedMediaTypes) {\n        for (View candidateView : candidateViews) {\n          if (StringUtils.hasText(candidateView.getContentType())) {\n            MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());\n            if (requestedMediaType.includes(candidateContentType)) {\n              bestRequestedMediaType = requestedMediaType;\n              bestView = candidateView;\n              break;\n            }\n          }\n        }\n        if (bestView != null) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(&quot;Returning [&quot; + bestView + &quot;] based on requested media type &apos;&quot; +\n                bestRequestedMediaType + &quot;&apos;&quot;);\n          }\n          break;\n        }\n      }\n      return bestView;\n\n    }\n\n    ...\n\n}\n</code></pre><p>可以看到<code>ContentNegotiationViewResolver</code>有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。</p>\n<p>所以关键在两点：</p>\n<h4 id=\"1-content-negotiation策略-ContentNegotiationStrategy\"><a href=\"#1-content-negotiation策略-ContentNegotiationStrategy\" class=\"headerlink\" title=\"1. content negotiation策略 (ContentNegotiationStrategy)\"></a>1. content negotiation策略 (<code>ContentNegotiationStrategy</code>)</h4><blockquote>\n<p>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:</p>\n<ol>\n<li>If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.</li>\n<li>If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.</li>\n<li>If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.</li>\n<li>If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.</li>\n</ol>\n<p>Once the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view’s content type). The most compatible view is returned.</p>\n</blockquote>\n<p>这个就是上面提到的Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>\n<p>关于<code>ContentNegotiationStrategy</code>，可以参考笔者的另一篇文章：<a href=\"http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html\">content negotiation using spring mvc</a>。有具体的实际案例。</p>\n<h5 id=\"2-供选择的SingleViewResolver\"><a href=\"#2-供选择的SingleViewResolver\" class=\"headerlink\" title=\"2. 供选择的SingleViewResolver\"></a>2. 供选择的SingleViewResolver</h5><blockquote>\n<ol>\n<li><p>The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)</p>\n<p> 说明：即<code>private List&lt;ViewResolver&gt; viewResolvers;</code>属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到<code>ContentNegotiationViewResolover</code>的<code>viewResolvers</code>属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由<code>ContentNegotiationViewResolover</code>来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给<code>ContentNegotiationViewResolover</code>配置最高的order(其实默认就是最高了)。</p>\n</li>\n<li><p>Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.</p>\n<p> 说明：即<code>private List&lt;View&gt; defaultViews;</code>和<code>private MediaType defaultContentType;</code>属性。</p>\n</li>\n</ol>\n</blockquote>\n<p>关于<code>ContentNegotiatingViewResolver</code>，下面两篇文章都不错，值得一看：</p>\n<ol>\n<li><a href=\"http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html\">Content Negotiation using Spring MVC’s ContentNegotiatingViewResolver</a>:使用了<code>viewResolvers</code>配置。</li>\n<li><a href=\"http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/\">ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING’S REST SUPPORT</a>:使用了<code>ViewResolvers</code>配置。</li>\n<li><a href=\"http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/\">Spring 3 MVC ContentNegotiatingViewResolver Example</a>:使用了<code>defaultViews</code>配置。</li>\n</ol>\n<p>注意：<code>@ResponseBody</code>是为了单个View准备的，即它只能转换成一种格式，对于<code>ContentNegotiatingViewResolver</code>，需要多个<strong>Single</strong>ViewResolver来接收。</p>\n<h3 id=\"8-客户端调用-Accessing-RESTful-services-on-the-Client\"><a href=\"#8-客户端调用-Accessing-RESTful-services-on-the-Client\" class=\"headerlink\" title=\"8. 客户端调用 Accessing RESTful services on the Client\"></a>8. 客户端调用 <a href=\"http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate\">Accessing RESTful services on the Client</a></h3><p>Spring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。</p>\n<p>以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：</p>\n<pre><code>String uri = &quot;http://example.com/hotels/1/bookings&quot;;\n\nPostMethod post = new PostMethod(uri);\nString request = // create booking request content\npost.setRequestEntity(new StringRequestEntity(request));\n\nhttpClient.executeMethod(post);\n\nif (HttpStatus.SC_CREATED == post.getStatusCode()) {\n  Header location = post.getRequestHeader(&quot;Location&quot;);\n  if (location != null) {\n    System.out.println(&quot;Created new booking at :&quot; + location.getValue());\n  }\n}\n</code></pre><p>太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。</p>\n<h4 id=\"RestTemplate\"><a href=\"#RestTemplate\" class=\"headerlink\" title=\"RestTemplate\"></a><a href=\"http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/\">RestTemplate</a></h4><p>RestTemplate是client-site HTTP access的核心类。正如它的名称所示，<code>RestTemplate</code>非常类似于<code>JdbcTemplate</code>, <code>JmsTemplate</code>等XXXTemplate。这意味着<code>RestTemplate</code>是线程安全的并且可以通过callback来定制它的行为。</p>\n<p><strong>TIPS</strong> Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。</p>\n<p>RestTemplate默认使用<code>java.net</code>包下的基础类来创建HTTP请求。你可以实现<code>ClientHttpRequestFactory</code>接口，提供你自己的Http请求工厂类。Spring提供了<code>CommonsClientHttpRequestFactory</code>，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。</p>\n<p><a href=\"http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html\">RestTemplate提供的方法如下</a>：</p>\n<blockquote>\n<p><strong>HTTP Method</strong>    <strong>RestTemplate Method</strong></p>\n<ul>\n<li>DELETE    delete(String url, String… urlVariables)</li>\n<li>GET    getForObject(String url, Class<T> responseType, String… urlVariables)</li>\n<li>HEAD    headForHeaders(String url, String… urlVariables)</li>\n<li>OPTIONS    optionsForAllow(String url, String… urlVariables)</li>\n<li>POST    postForLocation(String url, Object request, String… urlVariables)</li>\n<li>PUT    put(String url, Object request, String…urlVariables)</li>\n<li>ANY    exchange(String, HttpMethod, HttpEntity, Class, Object…)<pre><code>execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)\n</code></pre></li>\n</ul>\n</blockquote>\n<p>方法名称很有规律，都是这个pattern——<code>${HTTP Method}${WhatIsReturne}</code>。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.</p>\n<p>其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过<code>HttpMessageConverter</code>来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的<code>@RequestBody</code>和<code>@ResponseBody</code>是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。</p>\n<p>另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得<code>@PathVariable</code>吗:)哦。参数有两种方式绑定值：</p>\n<ol>\n<li><p>作为字符串变量数组(String variable arguments array)</p>\n<pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, &quot;42&quot;, &quot;21&quot;);\n</code></pre><p> 会转换为一个对<code>http://example.com/hotels/42/bookings/21</code>的GET请求。</p>\n</li>\n<li><p>或者Map对象(Map)</p>\n<p>The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.</p>\n<pre><code>Map&lt;String, String&gt; vars = new HashMap&lt;String, String&gt;();\nvars.put(&quot;hotel&quot;, &quot;42&quot;);\nvars.put(&quot;booking&quot;, &quot;21&quot;);\nString result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, vars);\n会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。\n</code></pre></li>\n</ol>\n<p>关于RestTemplate使用的具体例子可以参考这篇文章<a href=\"http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/\"><br>REST IN SPRING 3: RESTTEMPLATE</a>。写的非常好，强烈推荐！</p>\n<h3 id=\"9-支持RESTful的URL\"><a href=\"#9-支持RESTful的URL\" class=\"headerlink\" title=\"9. 支持RESTful的URL\"></a>9. 支持RESTful的URL</h3><p>在开发功能模块之前，应该先把URL设计好。比查对 <strong>消息</strong> 这个资源的操作URL可以这么设计：</p>\n<pre><code>http://arganzheng.me/messages/show/123456\nhttp://arganzheng.me/messages/preview/123456\nhttp://arganzheng.me/messages/delete/123456\nhttp://arganzheng.me/messages/new\nhttp://arganzheng.me/message/update\n</code></pre><p>说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。</p>\n<p>要支持这种URL，web.xml需要这么配置：</p>\n<pre><code>&lt;!-- REST servlet-mapping --&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DispatcherServlet&lt;srvlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;srvlet-mapping&gt;\n</code></pre><p>但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理<a href=\"http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources\">16.14.5 Configuring Serving of Resources</a>：</p>\n<pre><code>&lt;!-- Forwards requests to the &quot;/&quot; resource to the &quot;welcome&quot; view --&gt;\n  &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;\n\n  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory --&gt;\n  &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt;\n  &lt;!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 \n      @see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined \n  --&gt;\n  &lt;mvc:annotation-driven /&gt;\n</code></pre><p>这样所有请求：<code>http://arganzheng.me/resources/**</code>会映射到webapp下的resources目录，而不是找我们的controller处理。</p>\n<p>但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个<code>&lt;mvc:annotation-driven /&gt;</code>配置。具体参见<a href=\"http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined\">The handler mapping from the mvc:resource override other mappings which defined with annotation</a>。</p>\n<p>另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：<a href=\"http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：\">http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：</a></p>\n<pre><code>&lt;!-- 避免被Spring DispatcherServlet接管 --&gt;\n  &lt;servlet-mapping&gt;\n      &lt;servlet-name&gt;default&lt;srvlet-name&gt;\n      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;\n  &lt;srvlet-mapping&gt;\n</code></pre>"},{"layout":"post","title":"JSTL介绍","date":"2014-03-18T10:49:00.000Z","comments":1,"_content":"###EL 表达式\n在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。\n      \nSun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。\n      \nStandard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。\n      \nStandard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。\n      \n本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：\n      \n - 核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。\n - 国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。\n - 数据库标签库：可以做访问数据库的工作。\n - XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。\n - 函数标签库：用来读取已经定义的某个函数。\n \n此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。\n      \nJSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。\n      \n说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。\n      \n<!--more-->\n\n####9.2.1JSTL EL 表达式语言简介\nEL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。\n      \n下面的示例就是一个EL表达式，见例9.1。\n\n例9.1：简单EL表达式\n\n      <%@ page contentType=\"text/html; charset=UTF-8\"%>\n      <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n      <html>\n       <body> ${sampleValue + 1} <br> </body>\n      </html>\n      \n这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。   \n\n####9.2.2 EL 表达式的默认变量 \n一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：\n\n1．默认变量pageScope、requestScope、sessionScope、applicationScope\n      这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：\n\n例9.2：使用sessionScope变量的EL表达式\n\n    <%request.getSession().setAttribute(\"sampleValue\", new Integer(10));%>\n    ${sessionScope.sampleValue}\n\n取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。\n\n2．默认变量param、paramValues\n      这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：\n\n例9.3：提交请求的页面和接受的页面\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n         <form action=\"SampleJsp.jsp\">\n        <input type=\"text\" name=\"sampleValue\" value=\"10\">\n        <input type=\"text\" name=\"sampleValue\" value=\"11\">\n        <input type=\"text\" name=\"sampleValue\" value=\"12\">\n        <input type=\"text\" name=\"sampleSingleValue\" value=\"SingleValue\">\n        <input type=\"submit\" value=\"Submit\">\n        </form>\n     </body>\n    </html>\n\n在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n        ${paramValues.sampleValue[2]} <br>\n        ${param.sampleSingleValue} <br>\n     </body>\n    </html>\n\n这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。\n\n3．默认变量header、headerValues\n\n这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。\n\n4．默认变量cookie\n\n包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。\n\n5．默认变量initParam\n\n包含所有应用程序初始化参数的集合。\n\n6．默认变量pageContext\n\n等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。\n11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。\n \n\n###表达式的操作符\nEL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。\n\n表9.1 EL表达式的操作符\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"562\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">操作符</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">功能和作用</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">.</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">访问一个bean属性或者Map entry</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">[]</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">访问一个数组或者链表元素</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">()</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">对子表达式分组，用来改变赋值顺序</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">? :</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">条件语句，比如：条件?ifTrue:ifFalse</p>\n\t\t\t\t\t\t\t\t<p align=\"left\">如果条件为真，表达式值为前者，反之为后者</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">+</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，加操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">-</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，减操作或者对一个值取反</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">*</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，乘操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">/ 或div</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，除操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">% 或mod</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，模操作(取余)</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">== 或eq</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">!= 或ne</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt; 或lt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&gt; 或gt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;= 或le</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&gt;= 或ge</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&amp;&amp; 或and</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">|| 或or</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">! 或not</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">empty</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">func(args)</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：\n\n例9.4：几组操作符的示例\n\n    ${pageScope.sampleValue + 12} <br>           //显示12\n    ${(pageScope.sampleValue + 12)/3} <br>     //显示4.0\n    ${(pageScope.sampleValue + 12) /3==4} <br>         //显示true\n    ${(pageScope.sampleValue + 12) /3>=5} <br>         //显示false\n    <input type=\"text\" name=\"sample1\" value=\"${pageScope.sampleValue + 10}\"> //显示值为10的Text控件\n\n可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。\n\n###标签库介绍\n在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。\n对应的标识符见表9.2所示：\n\n表9.2 标签库的标识符\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"360\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">标签库</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">URI</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"center\">前缀</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Core</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/core</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">c</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">XML processing</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/xml</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">x</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">I18N formatting</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/fmt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">fmt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Database access</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/sql</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">sql</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Functions</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/functions</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">fn</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看例9.5，简单使用标签库的示例。\n\n例9.5：简单JSTL标签库示例\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n        <c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\"> ${i} <br /></c:forEach>\n     </body>\n    </html>\n\n在该示例的JSP页面中声明了将使用Core标签库，它的URI为“http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中<c:forEach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。 \n\n###标签库\nCore标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：\n\n- 多用途核心标签：<c:out>、<c:set>、<c:remove>、<c:catch>。\n- 条件控制标签：<c:if>、<c:choose>、<c:when>、<c:otherwise>。\n- 循环控制标签：<c:forEach>、<c:forTokens>。\n- URL相关标签：<c:import>、<c:url>、<c:redirect>、<c:param>。\n\n以下是各个标签的用途和属性以及简单示例。\n\n###用于显示的` <c:out>` 标签 \n`<c:out>`标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：\n\n表9.3　`<c:out>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"535\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">输出到页面的数据，可以是EL表达式或常量（必须）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">default</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">当value为null时显示的数据（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">escapeXml</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n在JSTL1.0的时候，在页面显示数据必须使用<c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。\n\n    <c:out value=\"${sessionScope.anyValue}\" default=\"no value\" escapeXml=\"false\"/>\n\n该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。\n\n###`<c: >` 标签 \n\n####用于赋值的<c:set>标签\n`<c:set>`标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：\n\n表9.4　`<c:set>`标签属性和说明\n\n<table cellpadding=\"0\" width=\"393\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"311\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">值的信息，可以是EL表达式或常量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">target</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">被赋值的JavaBean实例的名称，若存在该属性则必须<br />\n\t\t\t\t\t\t\t\t存在property属性（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">property</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">JavaBean实例的变量属性名称（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">被赋值的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为page（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：\n\n    <c:set value=\"this is andy\" var=\"oneString\"/>\n    ${oneString} <br>\n\n该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。\n\n####9.3.3 用于删除的 `<c:remove> `标签 \n`<c:remove>`标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：\n\n表9.5　`<c:remove>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"365\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">需要被删除的变量名</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为全部查找（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:remove var=\"sampleValue\" scope=\"session\"/>\n    ${sessionScope.sampleValue} <br>\n\n该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。\n\n####9.3.4 用于异常捕获的 `<c:catch>` 标签 \n`<c:catch>`标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。\n\n    <c:catch var=\"err\"> ${param.sampleSingleValue[9] == 3}</c:catch>\n    ${err}\n    \n当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。\n\n####9.3.5 用于判断的 `<c:if>` 标签 \n`<c:if>`标签用于简单的条件语句。它的属性和描述如表9.6所示：\n\n表9.6　`<c:if>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"454\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">test</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">需要判断的条件</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:if test=\"${paramValues.sampleValue[2] == 12}\" var=\"visits\">It is 12</c:if><br>\n    ${visits} <br>\n\n该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。\n\n####9.3.6 用于复杂判断的 `<c:choose> 、 <c:when> 、 <c:otherwise>` 标签 \n这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。\n\n`<c:choose>`标签没有属性，可以被认为是父标签，`<c:when>、<c:otherwise>`将作为其子标签来使用。\n`<c:when>`标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。\n`<c:otherwise>`标签没有属性，它等价于“else”语句。\n\n下面看一个复杂条件语句的示例。\n\n    <c:choose>\n             <c:when test=\"${paramValues.sampleValue[2] == 11}\">\n                       not 12 not 13,it is 11\n             </c:when>\n             <c:when test=\"${paramValues.sampleValue[2] == 12}\">\n                       not 11 not 13,it is 12\n             </c:when>\n             <c:when test=\"${paramValues.sampleValue[2] == 13}\">\n                       not 11 not 12,it is 13\n             </c:when>\n             <c:otherwise>\n                       not 11 、12、13\n             </c:otherwise>\n    </c:choose>\n\n该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。\n\n####9.3.7 用于循环的 `<c:forEach>` 标签\n`<c:forEach>`为循环控制标签。它的属性和描述如表9.7所示：\n\n表9.7　`<c:forEach>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"511\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">items</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">进行循环的集合（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">begin</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">开始条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">end</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结束条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">step</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">循环的步长，默认为1（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varStatus</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">显示循环状态的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个集合循环的示例。\n\n<%ArrayList arrayList = new ArrayList();\n                   arrayList.add(\"aa\");\n                   arrayList.add(\"bb\");\n                   arrayList.add(\"cc\");\n%>\n<%request.getSession().setAttribute(\"arrayList\", arrayList);%>\n<c:forEach items=\"${sessionScope.arrayList}\" var=\"arrayListI\">\n         ${arrayListI}\n</c:forEach>\n\n该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。\n\n    <c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\">\n          ${i}<br />\n    </c:forEach>\n\n该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。\n\n####9.3.8 用于分隔字符的 `<c:forTokens>` 标签 \n`<c:forTokens>`标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：\n\n表9.8　`<c:forTokens>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"268\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">items</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">进行分隔的EL表达式或常量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">delims</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">分隔符</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">begin</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">开始条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">end</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结束条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">step</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">循环的步长，默认为1（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">做循环的对象变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varStatus</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">显示循环状态的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <c:forTokens items=\"aa,bb,cc,dd\" begin=\"0\" end=\"2\" step=\"2\" delims=\",\" var=\"aValue\">\n             ${aValue}\n    </c:forTokens>\n\n需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa\n\n###`<x: >` 标签\n\n \n\n####9.3.9 用于包含页面的`<c:import>` \n`<c:import>`标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：\n\n表9.9　`<c:import>`标签属性和说明\n<table cellpadding=\"0\" width=\"360\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"73\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"271\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">rl</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">需要导入页面的URL</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">context</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">charEncoding</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">导入页面的字符集（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">可以定义导入文本的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">导入文本的变量名作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">varReader</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">接受文本的java.io.Reader类变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n 下面看一个示例。\n\n    <c:import url=\"/MyHtml.html\" var=\"thisPage\" />\n    <c:import url=\"/MyHtml.html\" context=”/sample2” var=\"thisPage\"/>\n    <c:import url=\"www.sample.com/MyHtml.html\" var=\"thisPage\"/>\n\n该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。\n\n####9.3.10 用于得到URL地址的`<c:url>`标签\n`<c:url>` 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：\n\n表9.10 `<c:url>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"459\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">页面的URL地址</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">context</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">charEncoding</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">URL的字符集（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">存储URL的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量名作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:url value=\"/MyHtml.html\" var=\"urlPage\" />\n    <a href=\"${urlPage}\">link</a>\n\n得到了一个 URL 后，以 EL 表达式放入` <a>` 标签的 href 属性，达到链接的目的。\n\n####9.3.11 用于页面重定向的`<c:redirect>`标签\n`<c:redirect>` 用于页面的重定向，该标签的作用相当于 `response.setRedirect` 方法的工作。它包含 url 和 context 两个属性，属性含义和 `<c:url>` 标签相同。下面看一个示例。\n\n    <c:redirect url=\"/MyHtml.html\"/>\n\n该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 `<c:if>` 等标签一起使用。\n\n####9.3.12 用于包含传递参数的`<c:param>`标签\n `<c:param>` 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：\n\n表9.11　`<c:param>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"190\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">name</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">传递的参数名</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">传递的参数值（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面是一个示例：\n\n    <c:redirect url=\"/MyHtml.jsp\">\n    <c:param name=\"userName\" value=”RW” />\n    </c:redirect>\n\n该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。\n\n###9.4 JSTL XML processing标签库 \n在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：\n\n- XML核心标签：`<x:parse>、<x:out>、<x:set>`。\n- XML流控制标签：`<x:if>、<x:choose>、<x:when>、<x:otherwise>、<x:forEach>`。\n- XML转换标签：`<x:transform>、<x:param>`。\n\n由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。\n\n####9.4.1 用于解析XML文件的`<x:parse>`标签\n`<x:parse>` 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：\n\n表9.12　`<x:parse>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"537\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">doc</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varDom</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scopeDom</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">org.w3c.dom.Document的接口类型变量作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">systemId</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">filter</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。\n\n`<x:parse>`标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。\n\n首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <xml-body>\n             <name>RW</name>\n             <passWord>123456</passWord>\n             <age>28</age>\n             <books>\n                       <book>book1</book>\n                       <book>book2</book>\n                       <book>book3</book>\n             </books>\n    </xml-body>\n\n标签库的工作：\n\n    <c:import var=\"xmlFile\" url=\"http://localhost:8080/booksamplejstl/SampleXml.xml\"/>\n    <x:parse var=\"xmlFileValue\" doc=\"${xmlFile}\"/>\n\n###`<fmt: >` 标签 \n\n看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：\n\n- 国际化核心标签：`<fmt:setLocale>、<fmt:bundle>、<fmt:setBundle>、<fmt:message>、<fmt:param>、<fmt:requestEncoding>`。\n- 格式化标签：`<fmt:timeZone>、<fmt:setTimeZone>、<fmt:formatNumber>、<fmt:parseNumber>、<fmt:formatDate>、<fmt:parseDate>`。\n\n下面只选择其中常见的一些标签和属性进行介绍。\n\n####9.5.1 用于设置本地化环境的`<fmt:setLocale>`标签\n    `<fmt:setLocale>`标签用于设置Locale环境。它的属性和描述如表9.17所示：\n\n表9.17　`<fmt:setLocale>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Locale环境的指定，可以是java.util.Locale或String类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Locale环境变量的作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n下面看一个示例：\n\n    <fmt:setLocale value=\"zh_TW\"/>\n\n表示设置本地环境为繁体中文。      \n\n####9.5.2 用于资源文件绑定的`<fmt:bundle>、<fmt:setBundle>`标签\n \n这两组标签用于资源配置文件的绑定，唯一不同的是`<fmt:bundle>`标签将资源配置文件绑定于它标签体中的显示，`<fmt:setBundle>`标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。\n\n根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：\n        \n\n表9.18　`<fmt:bundle>、<fmt:setBundle>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">basename</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例\n\n    <fmt:setLocale value=\"zh_CN\"/>\n    <fmt:setBundle basename=\"applicationMessage\" var=\"applicationBundle\"/>\n    \n该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。\n\n####9.5.3  用于显示资源配置文件信息的`<fmt:message>`标签\n用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：\n\n表9.19　`<fmt:message>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">key</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">资源配置文件的&ldquo;键&rdquo;指定</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">bundle</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将显示信息保存为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n    \n    <fmt:setBundle basename=\"applicationMessage\" var=\"applicationBundle\"/>\n    <fmt:bundle basename=\"applicationAllMessage\">\n             <fmt:message key=\"userName\" />\n             <p>\n             <fmt:message key=\"passWord\" bundle=\"${applicationBundle}\" />\n    </fmt:bundle>\n\n该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用`<fmt:setBundle>`标签被赋于了变量“ applicationBundle ”，而作为`<fmt:bundle>`标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。\n\n第一个`<fmt:message>`标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。\n第二个`<fmt:message>`标签虽然被定义在`<fmt:bundle>`标签体内，但是它使用了bundle属性，因此将指定之前由`<fmt:setBundle>`标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。\n\n#### 9.5.4  用于参数传递的`<fmt:param>`标签\n`<fmt:param>`标签应该位于`<fmt:message>`标签内，将为该消息标签提供参数值。它只有一个属性value。\n`<fmt:param>`标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。\n\n####9.5.6  用于为请求设置字符编码的`<fmt:requestEncoding>`标签\n`<fmt:requestEncoding>`标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。\n\n####9.5.7  用于设定时区的`<fmt:timeZone>、<fmt:setTimeZone>`标签\n这两组标签都用于设定一个时区。唯一不同的是`<fmt:timeZone>`标签将使得在其标签体内的工作可以使用该时区设置，`<fmt:setBundle>`标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：\n\n表9.20　`<fmt:timeZone>、<fmt:setTimeZone>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">时区的设置</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n#### 9.5.8  用于格式化数字的`<fmt:formatNumber>`标签\n`<fmt: formatNumber >` 标签用于格式化数字。它的属性和描述如表9.21所示：\n\n表9.21　`<fmt:formatNumber>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">maxIntegerDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最大值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">minIntegerDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最小值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">maxFractionDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最大值，带小数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">minFractionDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最小值，带小数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:formatNumber>`标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。\n\n下面看一个示例。\n\n    <fmt:formatNumber value=\"1000.888\" type=\"currency\" var=\"money\"/>\n\n该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。\n\n#### 9.5.9  用于解析数字的`<fmt:parseNumber>`标签\n`<fmt:parseNumber>`标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。`<fmt:parseNumber>`标签看起来和`<fmt:formatNumber>`标签的作用正好相反。它的属性和描述如表9.22所示：\n\n表9.22　`<fmt:parseNumber>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将被解析的字符串</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量，类型为java.lang.Number</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">parseLocale</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <fmt:parseNumber value=\"15%\" type=\"percent\" var=\"num\"/>\n\n解析之后的结果为“ 0.15 ”。\n\n####9.5.10  用于格式化日期的`<fmt:formatDate>`标签\n`<fmt:formatDate>`标签用于格式化日期。它的属性和描述如表9.23所示：\n\n表9.23　`<fmt:formatDate>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">timeZone</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化日期的时区</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:formatDate>`标签与`<fmt:timeZone>、<fmt:setTimeZone>`两组标签的关系密切。若没有指定 timeZone属性，也可以通过`<fmt:timeZone>、<fmt:setTimeZone>`两组标签设定的时区来格式化最后的结果。\n\n#### 9.5.11  用于解析日期的`<fmt:parseDate>`标签\n`<fmt:parseDate>`标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。`<fmt:parseDate>`标签看起来和`<fmt:formatDate>`标签的作用正好相反。它的属性和描述如表9.24所示：\n\n表9.24　`<fmt:parseDate>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将被解析的字符串</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量，类型为java.lang.Date</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">parseLocale</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">timeZone</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定解析格式化日期的时区</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:parseNumber>`和`<fmt:parseDate>`两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此`<fmt:parseNumber>`和`<fmt:parseDate>`两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。\n\n `<sql:>`标签 \n\n###9.6  Database access 标签库\n\nDatabase access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。\n\n对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。\n\nDatabase access标签库有以下6组标签来进行工作：`<sql:setDataSource>、<sql:query>、<sql:update>、<sql:transaction>、<sql:setDataSource>、<sql:param>、<sql:dateParam>`。\n\n####9.6.1 用于设置数据源的 `<sql:setDataSource>` 标签\n`<sql:setDataSource>`标签用于设置数据源，下面看一个示例：\n\n    <sql:setDataSource\n             var=\"dataSrc\"\n             url=\"jdbc:postgresql://localhost:5432/myDB\"\n             driver=\"org.postgresql.Driver\"\n             user=\"admin\"\n             password=\"1111\"/>\n\n该示例定义一个数据源并保存在“ dataSrc ”变量内。\n\n####9.6.2 用于查询的 `<sql:query>`标签\n\n`<sql:query>`标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：\n\n    <sql:query var=\"queryResults\" dataSource=\"${dataSrc}\">\n          select * from table1\n    </sql:query>\n\n该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用`<c:forEach>`循环来进行。下面看一个示例。\n\n    <c:forEach var=\"row\" items=\"${queryResults.rows}\">\n          <tr>\n                   <td>${row.userName}</td>\n                    <td>${row.passWord}</td>\n          </tr>\n    </c:forEach>\n\n“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。\n\n####9.6.3 用于更新的 `<sql:update>` 标签\n`<sql:update>`标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和`<sql:query>`标签没有什么不同。\n\n####9.6.4 用于事务处理的` <sql:transaction> `标签\n`<sql:transaction>`标签用于数据库的事务处理，在该标签体内可以使用`<sql:update>`标签和`<sql:query>`标签，而`<sql:transaction>`标签的事务管理将作用于它们之上。\n`<sql:transaction>`标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。\n\n####9.6.5 用于事务处理的` <sql:param> 、 <sql:dateParam>` 标签\n这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。`<sql:param>`标签传递除java.util.Date类型以外的所有相融参数，`<sql:dateParam>`标签则指定必须传递java.util.Date类型的参数。\n\n###`<fn:>` 标签 \n\n###9.7 Functions 标签库\n       称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。\n\n       长度函数：fn:length\n       字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim\n\n以下是各个函数的用途和属性以及简单示例。\n\n####9.7.1 长度函数 fn:length 函数\n       长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。\n\nfn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。\n\n    <%ArrayList arrayList1 = new ArrayList();\n                                arrayList1.add(\"aa\");\n                                arrayList1.add(\"bb\");\n                                arrayList1.add(\"cc\");\n    \n    %>\n    <%request.getSession().setAttribute(\"arrayList1\", arrayList1);%>\n    ${fn:length(sessionScope.arrayList1)}\n\n假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。\n\n####9.7.2 判断函数 fn:contains 函数\n       fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。\n\n    ${fn:contains(\"ABC\", \"a\")}<br>\n    ${fn:contains(\"ABC\", \"A\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n####9.7.3 fn:containsIgnoreCase函数 \n      fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:containsIgnoreCase(\"ABC\", \"a\")}<br>\n    ${fn:containsIgnoreCase(\"ABC\", \"A\")}<br>\n\n前者和后者都会返回“ true ”。\n\n\n####9.7.4 词头判断函数 fn:startsWith 函数\n       fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:startsWith (\"ABC\", \"ab\")}<br>\n    ${fn:startsWith (\"ABC\", \"AB\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n\n####9.7.5 词尾判断函数 fn:endsWith 函数\n       fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:endsWith(\"ABC\", \"bc\")}<br>\n    ${fn:endsWith(\"ABC\", \"BC\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n\n####9.7.6 字符实体转换函数 fn:escapeXml 函数\nfn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。\n\n\n####9.7.8 字符匹配函数 fn:indexOf 函数\n       fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。\n\n    ${fn:indexOf(\"ABCD\",\"aBC\")}<br>\n    ${fn:indexOf(\"ABCD\",\"BC\")}<br>\n\n前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。\n\n####9.7.9 分隔符函数 fn:join 函数\n       fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：\n\n表9.25　fn:join函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"350\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>array</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>字符串数组。其类型必须为String[]类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>separator</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>分隔符。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <% String[] stringArray = {\"a\",\"b\",\"c\"}; %>\n    <%request.getSession().setAttribute(\"stringArray\", stringArray);%>\n    ${fn:join(sessionScope.stringArray,\";\")}<br>\n\n定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。\n\n\n####9.7.10 替换函数 fn:replace 函数\n       fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：\n\n表9.26　fn:replace函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>inputString</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>beforeSubstring</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>指定被替换字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>afterSubstring</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>指定替换字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:replace(\"ABC\",\"A\",\"B\")}<br>\n\n将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。\n\n\n####9.7.11 分隔符转换数组函数 fn:split 函数\nfn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：\n\n表9.27　fn:split函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"281\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>string</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>delimiters</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>指定分隔符。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>返回一个String[]类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:split(\"A,B,C\",\",\")}<br>\n\n将“ A,B,C ”字符串转换为数组{A,B,C}。\n\n\n####9.7.12 字符串截取函数 fn:substring 函数\nfn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：\n\n表9.28　fn:substring函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>string</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>beginIndex</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>指定起始下标（值从0开始）。其类型必须为int类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>endIndex</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>指定结束下标（值从0开始）。其类型必须为int类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:substring(\"ABC\",\"1\",\"2\")}<br>\n\n截取结果为“ B ”。\n\n\n####9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数\nfn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。\n\n    ${fn:substringBefore(\"ABCD\",\"BC\")}<br>\n\n截取的结果为“ A ”。\n\n\n####9.7.15 小写转换函数 fn:toLowerCase 函数\nfn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。\n\n    ${fn:toLowerCase(\"ABCD\")}<br>\n\n转换的结果为“ abcd ”。\n\n\n####9.7.16大写转换函数 fn:toUpperCase 函数\nfn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。\n\n    ${fn:toUpperCase(\"abcd\")}<br>\n\n转换的结果为“ ABCD ”。\n\n\n####9.7.17空格删除函数 fn:trim 函数\nfn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。\n\n    ${fn:trim(\"AB C \")}D<br>\n\n转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。\n\n\n参考文档<http://www.javawind.net/help/html/jstl_el.htm>","source":"_posts/2014-03-18-use-jstl.markdown","raw":"---\nlayout: post\ntitle: \"JSTL介绍\"\ndate: 2014-03-18 18:49\ncomments: true\ncategories: java\ntags: [ jstl, el ]\n---\n###EL 表达式\n在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。\n      \nSun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。\n      \nStandard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。\n      \nStandard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。\n      \n本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：\n      \n - 核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。\n - 国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。\n - 数据库标签库：可以做访问数据库的工作。\n - XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。\n - 函数标签库：用来读取已经定义的某个函数。\n \n此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。\n      \nJSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。\n      \n说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。\n      \n<!--more-->\n\n####9.2.1JSTL EL 表达式语言简介\nEL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。\n      \n下面的示例就是一个EL表达式，见例9.1。\n\n例9.1：简单EL表达式\n\n      <%@ page contentType=\"text/html; charset=UTF-8\"%>\n      <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n      <html>\n       <body> ${sampleValue + 1} <br> </body>\n      </html>\n      \n这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。   \n\n####9.2.2 EL 表达式的默认变量 \n一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：\n\n1．默认变量pageScope、requestScope、sessionScope、applicationScope\n      这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：\n\n例9.2：使用sessionScope变量的EL表达式\n\n    <%request.getSession().setAttribute(\"sampleValue\", new Integer(10));%>\n    ${sessionScope.sampleValue}\n\n取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。\n\n2．默认变量param、paramValues\n      这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：\n\n例9.3：提交请求的页面和接受的页面\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n         <form action=\"SampleJsp.jsp\">\n        <input type=\"text\" name=\"sampleValue\" value=\"10\">\n        <input type=\"text\" name=\"sampleValue\" value=\"11\">\n        <input type=\"text\" name=\"sampleValue\" value=\"12\">\n        <input type=\"text\" name=\"sampleSingleValue\" value=\"SingleValue\">\n        <input type=\"submit\" value=\"Submit\">\n        </form>\n     </body>\n    </html>\n\n在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n        ${paramValues.sampleValue[2]} <br>\n        ${param.sampleSingleValue} <br>\n     </body>\n    </html>\n\n这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。\n\n3．默认变量header、headerValues\n\n这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。\n\n4．默认变量cookie\n\n包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。\n\n5．默认变量initParam\n\n包含所有应用程序初始化参数的集合。\n\n6．默认变量pageContext\n\n等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。\n11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。\n \n\n###表达式的操作符\nEL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。\n\n表9.1 EL表达式的操作符\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"562\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">操作符</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">功能和作用</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">.</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">访问一个bean属性或者Map entry</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">[]</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">访问一个数组或者链表元素</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">()</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">对子表达式分组，用来改变赋值顺序</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">? :</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">条件语句，比如：条件?ifTrue:ifFalse</p>\n\t\t\t\t\t\t\t\t<p align=\"left\">如果条件为真，表达式值为前者，反之为后者</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">+</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，加操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">-</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，减操作或者对一个值取反</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">*</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，乘操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">/ 或div</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，除操作</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">% 或mod</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">数学运算符，模操作(取余)</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">== 或eq</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">!= 或ne</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt; 或lt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&gt; 或gt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;= 或le</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&gt;= 或ge</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&amp;&amp; 或and</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">|| 或or</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">! 或not</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">empty</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" width=\"64\">\n\t\t\t\t\t\t\t\t<p align=\"left\">func(args)</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"498\">\n\t\t\t\t\t\t\t\t<p align=\"left\">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：\n\n例9.4：几组操作符的示例\n\n    ${pageScope.sampleValue + 12} <br>           //显示12\n    ${(pageScope.sampleValue + 12)/3} <br>     //显示4.0\n    ${(pageScope.sampleValue + 12) /3==4} <br>         //显示true\n    ${(pageScope.sampleValue + 12) /3>=5} <br>         //显示false\n    <input type=\"text\" name=\"sample1\" value=\"${pageScope.sampleValue + 10}\"> //显示值为10的Text控件\n\n可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。\n\n###标签库介绍\n在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。\n对应的标识符见表9.2所示：\n\n表9.2 标签库的标识符\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"360\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">标签库</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">URI</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"center\">前缀</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Core</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/core</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">c</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">XML processing</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/xml</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">x</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">I18N formatting</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/fmt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">fmt</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Database access</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/sql</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">sql</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"107\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Functions</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"202\">\n\t\t\t\t\t\t\t\t<p align=\"left\">http://java.sun.com/jsp/jstl/functions</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"50\">\n\t\t\t\t\t\t\t\t<p align=\"left\">fn</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看例9.5，简单使用标签库的示例。\n\n例9.5：简单JSTL标签库示例\n\n    <%@ page contentType=\"text/html; charset=UTF-8\"%>\n    <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n    <html>\n     <body>\n        <c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\"> ${i} <br /></c:forEach>\n     </body>\n    </html>\n\n在该示例的JSP页面中声明了将使用Core标签库，它的URI为“http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中<c:forEach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。 \n\n###标签库\nCore标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：\n\n- 多用途核心标签：<c:out>、<c:set>、<c:remove>、<c:catch>。\n- 条件控制标签：<c:if>、<c:choose>、<c:when>、<c:otherwise>。\n- 循环控制标签：<c:forEach>、<c:forTokens>。\n- URL相关标签：<c:import>、<c:url>、<c:redirect>、<c:param>。\n\n以下是各个标签的用途和属性以及简单示例。\n\n###用于显示的` <c:out>` 标签 \n`<c:out>`标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：\n\n表9.3　`<c:out>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"535\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">输出到页面的数据，可以是EL表达式或常量（必须）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">default</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">当value为null时显示的数据（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"79\">\n\t\t\t\t\t\t\t\t<p align=\"left\">escapeXml</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"456\">\n\t\t\t\t\t\t\t\t<p align=\"left\">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n在JSTL1.0的时候，在页面显示数据必须使用<c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。\n\n    <c:out value=\"${sessionScope.anyValue}\" default=\"no value\" escapeXml=\"false\"/>\n\n该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。\n\n###`<c: >` 标签 \n\n####用于赋值的<c:set>标签\n`<c:set>`标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：\n\n表9.4　`<c:set>`标签属性和说明\n\n<table cellpadding=\"0\" width=\"393\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"311\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">值的信息，可以是EL表达式或常量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">target</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">被赋值的JavaBean实例的名称，若存在该属性则必须<br />\n\t\t\t\t\t\t\t\t存在property属性（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">property</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">JavaBean实例的变量属性名称（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">被赋值的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为page（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：\n\n    <c:set value=\"this is andy\" var=\"oneString\"/>\n    ${oneString} <br>\n\n该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。\n\n####9.3.3 用于删除的 `<c:remove> `标签 \n`<c:remove>`标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：\n\n表9.5　`<c:remove>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"365\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">需要被删除的变量名</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为全部查找（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:remove var=\"sampleValue\" scope=\"session\"/>\n    ${sessionScope.sampleValue} <br>\n\n该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。\n\n####9.3.4 用于异常捕获的 `<c:catch>` 标签 \n`<c:catch>`标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。\n\n    <c:catch var=\"err\"> ${param.sampleSingleValue[9] == 3}</c:catch>\n    ${err}\n    \n当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。\n\n####9.3.5 用于判断的 `<c:if>` 标签 \n`<c:if>`标签用于简单的条件语句。它的属性和描述如表9.6所示：\n\n表9.6　`<c:if>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"454\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">test</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">需要判断的条件</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"60\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"394\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:if test=\"${paramValues.sampleValue[2] == 12}\" var=\"visits\">It is 12</c:if><br>\n    ${visits} <br>\n\n该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。\n\n####9.3.6 用于复杂判断的 `<c:choose> 、 <c:when> 、 <c:otherwise>` 标签 \n这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。\n\n`<c:choose>`标签没有属性，可以被认为是父标签，`<c:when>、<c:otherwise>`将作为其子标签来使用。\n`<c:when>`标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。\n`<c:otherwise>`标签没有属性，它等价于“else”语句。\n\n下面看一个复杂条件语句的示例。\n\n    <c:choose>\n             <c:when test=\"${paramValues.sampleValue[2] == 11}\">\n                       not 12 not 13,it is 11\n             </c:when>\n             <c:when test=\"${paramValues.sampleValue[2] == 12}\">\n                       not 11 not 13,it is 12\n             </c:when>\n             <c:when test=\"${paramValues.sampleValue[2] == 13}\">\n                       not 11 not 12,it is 13\n             </c:when>\n             <c:otherwise>\n                       not 11 、12、13\n             </c:otherwise>\n    </c:choose>\n\n该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。\n\n####9.3.7 用于循环的 `<c:forEach>` 标签\n`<c:forEach>`为循环控制标签。它的属性和描述如表9.7所示：\n\n表9.7　`<c:forEach>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"511\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">items</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">进行循环的集合（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">begin</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">开始条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">end</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结束条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">step</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">循环的步长，默认为1（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"59\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varStatus</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"452\">\n\t\t\t\t\t\t\t\t<p align=\"left\">显示循环状态的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个集合循环的示例。\n\n<%ArrayList arrayList = new ArrayList();\n                   arrayList.add(\"aa\");\n                   arrayList.add(\"bb\");\n                   arrayList.add(\"cc\");\n%>\n<%request.getSession().setAttribute(\"arrayList\", arrayList);%>\n<c:forEach items=\"${sessionScope.arrayList}\" var=\"arrayListI\">\n         ${arrayListI}\n</c:forEach>\n\n该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。\n\n    <c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\">\n          ${i}<br />\n    </c:forEach>\n\n该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。\n\n####9.3.8 用于分隔字符的 `<c:forTokens>` 标签 \n`<c:forTokens>`标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：\n\n表9.8　`<c:forTokens>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"268\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">items</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">进行分隔的EL表达式或常量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">delims</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">分隔符</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">begin</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">开始条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">end</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结束条件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">step</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">循环的步长，默认为1（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">做循环的对象变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"76\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varStatus</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"192\">\n\t\t\t\t\t\t\t\t<p align=\"left\">显示循环状态的变量（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <c:forTokens items=\"aa,bb,cc,dd\" begin=\"0\" end=\"2\" step=\"2\" delims=\",\" var=\"aValue\">\n             ${aValue}\n    </c:forTokens>\n\n需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa\n\n###`<x: >` 标签\n\n \n\n####9.3.9 用于包含页面的`<c:import>` \n`<c:import>`标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：\n\n表9.9　`<c:import>`标签属性和说明\n<table cellpadding=\"0\" width=\"360\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"73\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"271\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">rl</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">需要导入页面的URL</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">context</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">charEncoding</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">导入页面的字符集（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">可以定义导入文本的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">导入文本的变量名作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">varReader</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t<p align=\"left\">接受文本的java.io.Reader类变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n 下面看一个示例。\n\n    <c:import url=\"/MyHtml.html\" var=\"thisPage\" />\n    <c:import url=\"/MyHtml.html\" context=”/sample2” var=\"thisPage\"/>\n    <c:import url=\"www.sample.com/MyHtml.html\" var=\"thisPage\"/>\n\n该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。\n\n####9.3.10 用于得到URL地址的`<c:url>`标签\n`<c:url>` 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：\n\n表9.10 `<c:url>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"459\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">页面的URL地址</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">context</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">charEncoding</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">URL的字符集（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">存储URL的变量名（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"81\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"378\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量名作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n\n    <c:url value=\"/MyHtml.html\" var=\"urlPage\" />\n    <a href=\"${urlPage}\">link</a>\n\n得到了一个 URL 后，以 EL 表达式放入` <a>` 标签的 href 属性，达到链接的目的。\n\n####9.3.11 用于页面重定向的`<c:redirect>`标签\n`<c:redirect>` 用于页面的重定向，该标签的作用相当于 `response.setRedirect` 方法的工作。它包含 url 和 context 两个属性，属性含义和 `<c:url>` 标签相同。下面看一个示例。\n\n    <c:redirect url=\"/MyHtml.html\"/>\n\n该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 `<c:if>` 等标签一起使用。\n\n####9.3.12 用于包含传递参数的`<c:param>`标签\n `<c:param>` 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：\n\n表9.11　`<c:param>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"190\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">name</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">传递的参数名</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"58\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"132\">\n\t\t\t\t\t\t\t\t<p align=\"left\">传递的参数值（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面是一个示例：\n\n    <c:redirect url=\"/MyHtml.jsp\">\n    <c:param name=\"userName\" value=”RW” />\n    </c:redirect>\n\n该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。\n\n###9.4 JSTL XML processing标签库 \n在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：\n\n- XML核心标签：`<x:parse>、<x:out>、<x:set>`。\n- XML流控制标签：`<x:if>、<x:choose>、<x:when>、<x:otherwise>、<x:forEach>`。\n- XML转换标签：`<x:transform>、<x:param>`。\n\n由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。\n\n####9.4.1 用于解析XML文件的`<x:parse>`标签\n`<x:parse>` 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：\n\n表9.12　`<x:parse>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"537\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">doc</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">varDom</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scopeDom</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">org.w3c.dom.Document的接口类型变量作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">systemId</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"67\">\n\t\t\t\t\t\t\t\t<p align=\"left\">filter</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"470\">\n\t\t\t\t\t\t\t\t<p align=\"left\">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。\n\n`<x:parse>`标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。\n\n首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <xml-body>\n             <name>RW</name>\n             <passWord>123456</passWord>\n             <age>28</age>\n             <books>\n                       <book>book1</book>\n                       <book>book2</book>\n                       <book>book3</book>\n             </books>\n    </xml-body>\n\n标签库的工作：\n\n    <c:import var=\"xmlFile\" url=\"http://localhost:8080/booksamplejstl/SampleXml.xml\"/>\n    <x:parse var=\"xmlFileValue\" doc=\"${xmlFile}\"/>\n\n###`<fmt: >` 标签 \n\n看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：\n\n- 国际化核心标签：`<fmt:setLocale>、<fmt:bundle>、<fmt:setBundle>、<fmt:message>、<fmt:param>、<fmt:requestEncoding>`。\n- 格式化标签：`<fmt:timeZone>、<fmt:setTimeZone>、<fmt:formatNumber>、<fmt:parseNumber>、<fmt:formatDate>、<fmt:parseDate>`。\n\n下面只选择其中常见的一些标签和属性进行介绍。\n\n####9.5.1 用于设置本地化环境的`<fmt:setLocale>`标签\n    `<fmt:setLocale>`标签用于设置Locale环境。它的属性和描述如表9.17所示：\n\n表9.17　`<fmt:setLocale>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Locale环境的指定，可以是java.util.Locale或String类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"49\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"336\">\n\t\t\t\t\t\t\t\t<p align=\"left\">Locale环境变量的作用范围（可选）</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n下面看一个示例：\n\n    <fmt:setLocale value=\"zh_TW\"/>\n\n表示设置本地环境为繁体中文。      \n\n####9.5.2 用于资源文件绑定的`<fmt:bundle>、<fmt:setBundle>`标签\n \n这两组标签用于资源配置文件的绑定，唯一不同的是`<fmt:bundle>`标签将资源配置文件绑定于它标签体中的显示，`<fmt:setBundle>`标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。\n\n根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：\n        \n\n表9.18　`<fmt:bundle>、<fmt:setBundle>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">basename</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"69\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"421\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例\n\n    <fmt:setLocale value=\"zh_CN\"/>\n    <fmt:setBundle basename=\"applicationMessage\" var=\"applicationBundle\"/>\n    \n该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。\n\n####9.5.3  用于显示资源配置文件信息的`<fmt:message>`标签\n用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：\n\n表9.19　`<fmt:message>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">key</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">资源配置文件的&ldquo;键&rdquo;指定</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">bundle</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将显示信息保存为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"55\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"513\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例：\n    \n    <fmt:setBundle basename=\"applicationMessage\" var=\"applicationBundle\"/>\n    <fmt:bundle basename=\"applicationAllMessage\">\n             <fmt:message key=\"userName\" />\n             <p>\n             <fmt:message key=\"passWord\" bundle=\"${applicationBundle}\" />\n    </fmt:bundle>\n\n该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用`<fmt:setBundle>`标签被赋于了变量“ applicationBundle ”，而作为`<fmt:bundle>`标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。\n\n第一个`<fmt:message>`标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。\n第二个`<fmt:message>`标签虽然被定义在`<fmt:bundle>`标签体内，但是它使用了bundle属性，因此将指定之前由`<fmt:setBundle>`标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。\n\n#### 9.5.4  用于参数传递的`<fmt:param>`标签\n`<fmt:param>`标签应该位于`<fmt:message>`标签内，将为该消息标签提供参数值。它只有一个属性value。\n`<fmt:param>`标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。\n\n####9.5.6  用于为请求设置字符编码的`<fmt:requestEncoding>`标签\n`<fmt:requestEncoding>`标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。\n\n####9.5.7  用于设定时区的`<fmt:timeZone>、<fmt:setTimeZone>`标签\n这两组标签都用于设定一个时区。唯一不同的是`<fmt:timeZone>`标签将使得在其标签体内的工作可以使用该时区设置，`<fmt:setBundle>`标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：\n\n表9.20　`<fmt:timeZone>、<fmt:setTimeZone>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">时区的设置</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"53\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"312\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n#### 9.5.8  用于格式化数字的`<fmt:formatNumber>`标签\n`<fmt: formatNumber >` 标签用于格式化数字。它的属性和描述如表9.21所示：\n\n表9.21　`<fmt:formatNumber>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">maxIntegerDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最大值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">minIntegerDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最小值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">maxFractionDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最大值，带小数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"104\">\n\t\t\t\t\t\t\t\t<p align=\"left\">minFractionDigits</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"384\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化结果的最小值，带小数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:formatNumber>`标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。\n\n下面看一个示例。\n\n    <fmt:formatNumber value=\"1000.888\" type=\"currency\" var=\"money\"/>\n\n该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。\n\n#### 9.5.9  用于解析数字的`<fmt:parseNumber>`标签\n`<fmt:parseNumber>`标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。`<fmt:parseNumber>`标签看起来和`<fmt:formatNumber>`标签的作用正好相反。它的属性和描述如表9.22所示：\n\n表9.22　`<fmt:parseNumber>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将被解析的字符串</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量，类型为java.lang.Number</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">parseLocale</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"463\">\n\t\t\t\t\t\t\t\t<p align=\"left\">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <fmt:parseNumber value=\"15%\" type=\"percent\" var=\"num\"/>\n\n解析之后的结果为“ 0.15 ”。\n\n####9.5.10  用于格式化日期的`<fmt:formatDate>`标签\n`<fmt:formatDate>`标签用于格式化日期。它的属性和描述如表9.23所示：\n\n表9.23　`<fmt:formatDate>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p align=\"left\">timeZone</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"343\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定格式化日期的时区</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:formatDate>`标签与`<fmt:timeZone>、<fmt:setTimeZone>`两组标签的关系密切。若没有指定 timeZone属性，也可以通过`<fmt:timeZone>、<fmt:setTimeZone>`两组标签设定的时区来格式化最后的结果。\n\n#### 9.5.11  用于解析日期的`<fmt:parseDate>`标签\n`<fmt:parseDate>`标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。`<fmt:parseDate>`标签看起来和`<fmt:formatDate>`标签的作用正好相反。它的属性和描述如表9.24所示：\n\n表9.24　`<fmt:parseDate>`标签属性和说明\n\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">属性</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">value</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">将被解析的字符串</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">type</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化的类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">pattern</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">解析格式化模式</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">var</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">结果保存变量，类型为java.lang.Date</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">scope</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">变量的作用范围</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">parseLocale</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"72\">\n\t\t\t\t\t\t\t\t<p align=\"left\">timeZone</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"451\">\n\t\t\t\t\t\t\t\t<p align=\"left\">指定解析格式化日期的时区</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n`<fmt:parseNumber>`和`<fmt:parseDate>`两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此`<fmt:parseNumber>`和`<fmt:parseDate>`两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。\n\n `<sql:>`标签 \n\n###9.6  Database access 标签库\n\nDatabase access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。\n\n对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。\n\nDatabase access标签库有以下6组标签来进行工作：`<sql:setDataSource>、<sql:query>、<sql:update>、<sql:transaction>、<sql:setDataSource>、<sql:param>、<sql:dateParam>`。\n\n####9.6.1 用于设置数据源的 `<sql:setDataSource>` 标签\n`<sql:setDataSource>`标签用于设置数据源，下面看一个示例：\n\n    <sql:setDataSource\n             var=\"dataSrc\"\n             url=\"jdbc:postgresql://localhost:5432/myDB\"\n             driver=\"org.postgresql.Driver\"\n             user=\"admin\"\n             password=\"1111\"/>\n\n该示例定义一个数据源并保存在“ dataSrc ”变量内。\n\n####9.6.2 用于查询的 `<sql:query>`标签\n\n`<sql:query>`标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：\n\n    <sql:query var=\"queryResults\" dataSource=\"${dataSrc}\">\n          select * from table1\n    </sql:query>\n\n该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用`<c:forEach>`循环来进行。下面看一个示例。\n\n    <c:forEach var=\"row\" items=\"${queryResults.rows}\">\n          <tr>\n                   <td>${row.userName}</td>\n                    <td>${row.passWord}</td>\n          </tr>\n    </c:forEach>\n\n“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。\n\n####9.6.3 用于更新的 `<sql:update>` 标签\n`<sql:update>`标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和`<sql:query>`标签没有什么不同。\n\n####9.6.4 用于事务处理的` <sql:transaction> `标签\n`<sql:transaction>`标签用于数据库的事务处理，在该标签体内可以使用`<sql:update>`标签和`<sql:query>`标签，而`<sql:transaction>`标签的事务管理将作用于它们之上。\n`<sql:transaction>`标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。\n\n####9.6.5 用于事务处理的` <sql:param> 、 <sql:dateParam>` 标签\n这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。`<sql:param>`标签传递除java.util.Date类型以外的所有相融参数，`<sql:dateParam>`标签则指定必须传递java.util.Date类型的参数。\n\n###`<fn:>` 标签 \n\n###9.7 Functions 标签库\n       称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。\n\n       长度函数：fn:length\n       字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim\n\n以下是各个函数的用途和属性以及简单示例。\n\n####9.7.1 长度函数 fn:length 函数\n       长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。\n\nfn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。\n\n    <%ArrayList arrayList1 = new ArrayList();\n                                arrayList1.add(\"aa\");\n                                arrayList1.add(\"bb\");\n                                arrayList1.add(\"cc\");\n    \n    %>\n    <%request.getSession().setAttribute(\"arrayList1\", arrayList1);%>\n    ${fn:length(sessionScope.arrayList1)}\n\n假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。\n\n####9.7.2 判断函数 fn:contains 函数\n       fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。\n\n    ${fn:contains(\"ABC\", \"a\")}<br>\n    ${fn:contains(\"ABC\", \"A\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n####9.7.3 fn:containsIgnoreCase函数 \n      fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:containsIgnoreCase(\"ABC\", \"a\")}<br>\n    ${fn:containsIgnoreCase(\"ABC\", \"A\")}<br>\n\n前者和后者都会返回“ true ”。\n\n\n####9.7.4 词头判断函数 fn:startsWith 函数\n       fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:startsWith (\"ABC\", \"ab\")}<br>\n    ${fn:startsWith (\"ABC\", \"AB\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n\n####9.7.5 词尾判断函数 fn:endsWith 函数\n       fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。\n\n    ${fn:endsWith(\"ABC\", \"bc\")}<br>\n    ${fn:endsWith(\"ABC\", \"BC\")}<br>\n\n前者返回“ false ”，后者返回“ true ”。\n\n\n####9.7.6 字符实体转换函数 fn:escapeXml 函数\nfn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。\n\n\n####9.7.8 字符匹配函数 fn:indexOf 函数\n       fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。\n\n    ${fn:indexOf(\"ABCD\",\"aBC\")}<br>\n    ${fn:indexOf(\"ABCD\",\"BC\")}<br>\n\n前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。\n\n####9.7.9 分隔符函数 fn:join 函数\n       fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：\n\n表9.25　fn:join函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"350\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>array</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>字符串数组。其类型必须为String[]类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>separator</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>分隔符。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n    <% String[] stringArray = {\"a\",\"b\",\"c\"}; %>\n    <%request.getSession().setAttribute(\"stringArray\", stringArray);%>\n    ${fn:join(sessionScope.stringArray,\";\")}<br>\n\n定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。\n\n\n####9.7.10 替换函数 fn:replace 函数\n       fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：\n\n表9.26　fn:replace函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>inputString</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>beforeSubstring</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>指定被替换字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>afterSubstring</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>指定替换字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"105\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"249\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:replace(\"ABC\",\"A\",\"B\")}<br>\n\n将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。\n\n\n####9.7.11 分隔符转换数组函数 fn:split 函数\nfn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：\n\n表9.27　fn:split函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"281\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>string</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>delimiters</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>指定分隔符。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"65\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"216\">\n\t\t\t\t\t\t\t\t<p>返回一个String[]类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:split(\"A,B,C\",\",\")}<br>\n\n将“ A,B,C ”字符串转换为数组{A,B,C}。\n\n\n####9.7.12 字符串截取函数 fn:substring 函数\nfn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：\n\n表9.28　fn:substring函数\n\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>参数</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>描述</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>string</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>源字符串。其类型必须为String类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>beginIndex</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>指定起始下标（值从0开始）。其类型必须为int类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>endIndex</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>指定结束下标（值从0开始）。其类型必须为int类型</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td width=\"68\">\n\t\t\t\t\t\t\t\t<p>返回结果</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td width=\"285\">\n\t\t\t\t\t\t\t\t<p>返回一个String类型的值</p>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\n\n下面看一个示例。\n\n${fn:substring(\"ABC\",\"1\",\"2\")}<br>\n\n截取结果为“ B ”。\n\n\n####9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数\nfn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。\n\n    ${fn:substringBefore(\"ABCD\",\"BC\")}<br>\n\n截取的结果为“ A ”。\n\n\n####9.7.15 小写转换函数 fn:toLowerCase 函数\nfn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。\n\n    ${fn:toLowerCase(\"ABCD\")}<br>\n\n转换的结果为“ abcd ”。\n\n\n####9.7.16大写转换函数 fn:toUpperCase 函数\nfn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。\n\n    ${fn:toUpperCase(\"abcd\")}<br>\n\n转换的结果为“ ABCD ”。\n\n\n####9.7.17空格删除函数 fn:trim 函数\nfn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。\n\n    ${fn:trim(\"AB C \")}D<br>\n\n转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。\n\n\n参考文档<http://www.javawind.net/help/html/jstl_el.htm>","slug":"2014-03-18-use-jstl","published":1,"updated":"2016-08-12T09:29:39.000Z","photos":[],"link":"","_id":"cirrmopam00mzv8fyu60vjthh","content":"<p>###EL 表达式<br>在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。</p>\n<p>Sun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。</p>\n<p>Standard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。</p>\n<p>Standard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。</p>\n<p>本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从<a href=\"http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：\" target=\"_blank\" rel=\"external\">http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：</a></p>\n<ul>\n<li>核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。</li>\n<li>国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。</li>\n<li>数据库标签库：可以做访问数据库的工作。</li>\n<li>XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。</li>\n<li>函数标签库：用来读取已经定义的某个函数。</li>\n</ul>\n<p>此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。</p>\n<p>JSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。</p>\n<p>说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。</p>\n<a id=\"more\"></a>\n<p>####9.2.1JSTL EL 表达式语言简介<br>EL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。</p>\n<p>下面的示例就是一个EL表达式，见例9.1。</p>\n<p>例9.1：简单EL表达式</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt; ${sampleValue + 1} &lt;br&gt; &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。   </p>\n<p>####9.2.2 EL 表达式的默认变量<br>一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：</p>\n<p>1．默认变量pageScope、requestScope、sessionScope、applicationScope<br>      这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：</p>\n<p>例9.2：使用sessionScope变量的EL表达式</p>\n<pre><code>&lt;%request.getSession().setAttribute(&quot;sampleValue&quot;, new Integer(10));%&gt;\n${sessionScope.sampleValue}\n</code></pre><p>取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。</p>\n<p>2．默认变量param、paramValues<br>      这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：</p>\n<p>例9.3：提交请求的页面和接受的页面</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n     &lt;form action=&quot;SampleJsp.jsp&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;10&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;11&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;12&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleSingleValue&quot; value=&quot;SingleValue&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n    &lt;/form&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n    ${paramValues.sampleValue[2]} &lt;br&gt;\n    ${param.sampleSingleValue} &lt;br&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。</p>\n<p>3．默认变量header、headerValues</p>\n<p>这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。</p>\n<p>4．默认变量cookie</p>\n<p>包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。</p>\n<p>5．默认变量initParam</p>\n<p>包含所有应用程序初始化参数的集合。</p>\n<p>6．默认变量pageContext</p>\n<p>等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。<br>11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。</p>\n<p>###表达式的操作符<br>EL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。</p>\n<p>表9.1 EL表达式的操作符</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"562\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"64\"><br>                                <p align=\"left\">操作符</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">功能和作用</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">.</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">访问一个bean属性或者Map entry</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">[]</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">访问一个数组或者链表元素</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">()</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">对子表达式分组，用来改变赋值顺序</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">? :</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">条件语句，比如：条件?ifTrue:ifFalse</p><br>                                <p align=\"left\">如果条件为真，表达式值为前者，反之为后者</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">+</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，加操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">-</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，减操作或者对一个值取反</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">*</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，乘操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">/ 或div</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，除操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">% 或mod</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，模操作(取余)</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">== 或eq</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">!= 或ne</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&lt; 或lt</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&gt; 或gt</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&lt;= 或le</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&gt;= 或ge</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&amp;&amp; 或and</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">|| 或or</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">! 或not</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">empty</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">func(args)</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：</p>\n<p>例9.4：几组操作符的示例</p>\n<pre><code>${pageScope.sampleValue + 12} &lt;br&gt;           //显示12\n${(pageScope.sampleValue + 12)/3} &lt;br&gt;     //显示4.0\n${(pageScope.sampleValue + 12) /3==4} &lt;br&gt;         //显示true\n${(pageScope.sampleValue + 12) /3&gt;=5} &lt;br&gt;         //显示false\n&lt;input type=&quot;text&quot; name=&quot;sample1&quot; value=&quot;${pageScope.sampleValue + 10}&quot;&gt; //显示值为10的Text控件\n</code></pre><p>可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。</p>\n<p>###标签库介绍<br>在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。<br>对应的标识符见表9.2所示：</p>\n<p>表9.2 标签库的标识符</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"360\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">标签库</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\">URI</p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"center\">前缀</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Core</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/core\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/core</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">c</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">XML processing</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/xml\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/xml</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">x</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">I18N formatting</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/fmt\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/fmt</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">fmt</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Database access</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/sql\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/sql</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">sql</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Functions</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/functions\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/functions</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">fn</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看例9.5，简单使用标签库的示例。</p>\n<p>例9.5：简单JSTL标签库示例</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n    &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt; ${i} &lt;br /&gt;&lt;/c:forEach&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>在该示例的JSP页面中声明了将使用Core标签库，它的URI为“<a href=\"http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中\" target=\"_blank\" rel=\"external\">http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中</a><c:foreach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。 </c:foreach></p>\n<p>###标签库<br>Core标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：</p>\n<ul>\n<li>多用途核心标签：<c:out>、<c:set>、<c:remove>、<c:catch>。</c:catch></c:remove></c:set></c:out></li>\n<li>条件控制标签：<c:if>、<c:choose>、<c:when>、<c:otherwise>。</c:otherwise></c:when></c:choose></c:if></li>\n<li>循环控制标签：<c:foreach>、<c:fortokens>。</c:fortokens></c:foreach></li>\n<li>URL相关标签：<c:import>、<c:url>、<c:redirect>、<c:param>。</c:param></c:redirect></c:url></c:import></li>\n</ul>\n<p>以下是各个标签的用途和属性以及简单示例。</p>\n<p>###用于显示的<code>&lt;c:out&gt;</code> 标签<br><code>&lt;c:out&gt;</code>标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：</p>\n<p>表9.3　<code>&lt;c:out&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"535\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">输出到页面的数据，可以是EL表达式或常量（必须）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">default</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">当value为null时显示的数据（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">escapeXml</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>在JSTL1.0的时候，在页面显示数据必须使用<c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。</c:out></p>\n<pre><code>&lt;c:out value=&quot;${sessionScope.anyValue}&quot; default=&quot;no value&quot; escapeXml=&quot;false&quot;/&gt;\n</code></pre><p>该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。</p>\n<p>###<code>&lt;c: &gt;</code> 标签 </p>\n<p>####用于赋值的<c:set>标签<br><code>&lt;c:set&gt;</code>标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：</c:set></p>\n<p>表9.4　<code>&lt;c:set&gt;</code>标签属性和说明</p>\n<table cellpadding=\"0\" width=\"393\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"311\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">值的信息，可以是EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">target</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">被赋值的JavaBean实例的名称，若存在该属性则必须<br><br>                                存在property属性（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">property</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">JavaBean实例的变量属性名称（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">被赋值的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为page（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n<p> 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：</p>\n<pre><code>&lt;c:set value=&quot;this is andy&quot; var=&quot;oneString&quot;/&gt;\n${oneString} &lt;br&gt;\n</code></pre><p>该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。</p>\n<p>####9.3.3 用于删除的 <code>&lt;c:remove&gt;</code>标签<br><code>&lt;c:remove&gt;</code>标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：</p>\n<p>表9.5　<code>&lt;c:remove&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"365\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">需要被删除的变量名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为全部查找（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:remove var=&quot;sampleValue&quot; scope=&quot;session&quot;/&gt;\n${sessionScope.sampleValue} &lt;br&gt;\n</code></pre><p>该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。</p>\n<p>####9.3.4 用于异常捕获的 <code>&lt;c:catch&gt;</code> 标签<br><code>&lt;c:catch&gt;</code>标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。</p>\n<pre><code>&lt;c:catch var=&quot;err&quot;&gt; ${param.sampleSingleValue[9] == 3}&lt;/c:catch&gt;\n${err}\n</code></pre><p>当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。</p>\n<p>####9.3.5 用于判断的 <code>&lt;c:if&gt;</code> 标签<br><code>&lt;c:if&gt;</code>标签用于简单的条件语句。它的属性和描述如表9.6所示：</p>\n<p>表9.6　<code>&lt;c:if&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"454\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">test</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">需要判断的条件</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:if test=&quot;${paramValues.sampleValue[2] == 12}&quot; var=&quot;visits&quot;&gt;It is 12&lt;/c:if&gt;&lt;br&gt;\n${visits} &lt;br&gt;\n</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。</p>\n<p>####9.3.6 用于复杂判断的 <code>&lt;c:choose&gt; 、 &lt;c:when&gt; 、 &lt;c:otherwise&gt;</code> 标签<br>这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。</p>\n<p><code>&lt;c:choose&gt;</code>标签没有属性，可以被认为是父标签，<code>&lt;c:when&gt;、&lt;c:otherwise&gt;</code>将作为其子标签来使用。<br><code>&lt;c:when&gt;</code>标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。<br><code>&lt;c:otherwise&gt;</code>标签没有属性，它等价于“else”语句。</p>\n<p>下面看一个复杂条件语句的示例。</p>\n<pre><code>&lt;c:choose&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 11}&quot;&gt;\n                   not 12 not 13,it is 11\n         &lt;/c:when&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 12}&quot;&gt;\n                   not 11 not 13,it is 12\n         &lt;/c:when&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 13}&quot;&gt;\n                   not 11 not 12,it is 13\n         &lt;/c:when&gt;\n         &lt;c:otherwise&gt;\n                   not 11 、12、13\n         &lt;/c:otherwise&gt;\n&lt;/c:choose&gt;\n</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。</p>\n<p>####9.3.7 用于循环的 <code>&lt;c:forEach&gt;</code> 标签<br><code>&lt;c:forEach&gt;</code>为循环控制标签。它的属性和描述如表9.7所示：</p>\n<p>表9.7　<code>&lt;c:forEach&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"511\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">items</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">进行循环的集合（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">begin</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">end</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">step</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">varStatus</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个集合循环的示例。</p>\n<p>&lt;%ArrayList arrayList = new ArrayList();<br>                   arrayList.add(“aa”);<br>                   arrayList.add(“bb”);<br>                   arrayList.add(“cc”);<br>%&gt;<br>&lt;%request.getSession().setAttribute(“arrayList”, arrayList);%&gt;</p>\n<p><c:foreach items=\"${sessionScope.arrayList}\" var=\"arrayListI\"><br>         ${arrayListI}<br></c:foreach></p>\n<p>该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。</p>\n<pre><code>&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt;\n      ${i}&lt;br /&gt;\n&lt;/c:forEach&gt;\n</code></pre><p>该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。</p>\n<p>####9.3.8 用于分隔字符的 <code>&lt;c:forTokens&gt;</code> 标签<br><code>&lt;c:forTokens&gt;</code>标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：</p>\n<p>表9.8　<code>&lt;c:forTokens&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"268\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">items</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">进行分隔的EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">delims</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">分隔符</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">begin</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">end</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">step</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">做循环的对象变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">varStatus</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;c:forTokens items=&quot;aa,bb,cc,dd&quot; begin=&quot;0&quot; end=&quot;2&quot; step=&quot;2&quot; delims=&quot;,&quot; var=&quot;aValue&quot;&gt;\n         ${aValue}\n&lt;/c:forTokens&gt;\n</code></pre><p>需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa</p>\n<p>###<code>&lt;x: &gt;</code> 标签</p>\n<p>####9.3.9 用于包含页面的<code>&lt;c:import&gt;</code><br><code>&lt;c:import&gt;</code>标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：</p>\n<p>表9.9　<code>&lt;c:import&gt;</code>标签属性和说明</p>\n<table cellpadding=\"0\" width=\"360\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"73\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"271\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">rl</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">需要导入页面的URL</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">context</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">charEncoding</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">导入页面的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">可以定义导入文本的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">导入文本的变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">varReader</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">接受文本的java.io.Reader类变量名（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p> 下面看一个示例。</p>\n<pre><code>&lt;c:import url=&quot;/MyHtml.html&quot; var=&quot;thisPage&quot; /&gt;\n&lt;c:import url=&quot;/MyHtml.html&quot; context=”/sample2” var=&quot;thisPage&quot;/&gt;\n&lt;c:import url=&quot;www.sample.com/MyHtml.html&quot; var=&quot;thisPage&quot;/&gt;\n</code></pre><p>该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。</p>\n<p>####9.3.10 用于得到URL地址的<code>&lt;c:url&gt;</code>标签<br><code>&lt;c:url&gt;</code> 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：</p>\n<p>表9.10 <code>&lt;c:url&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"459\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">页面的URL地址</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">context</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">charEncoding</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">URL的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">存储URL的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:url value=&quot;/MyHtml.html&quot; var=&quot;urlPage&quot; /&gt;\n&lt;a href=&quot;${urlPage}&quot;&gt;link&lt;/a&gt;\n</code></pre><p>得到了一个 URL 后，以 EL 表达式放入<code>&lt;a&gt;</code> 标签的 href 属性，达到链接的目的。</p>\n<p>####9.3.11 用于页面重定向的<code>&lt;c:redirect&gt;</code>标签<br><code>&lt;c:redirect&gt;</code> 用于页面的重定向，该标签的作用相当于 <code>response.setRedirect</code> 方法的工作。它包含 url 和 context 两个属性，属性含义和 <code>&lt;c:url&gt;</code> 标签相同。下面看一个示例。</p>\n<pre><code>&lt;c:redirect url=&quot;/MyHtml.html&quot;/&gt;\n</code></pre><p>该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 <code>&lt;c:if&gt;</code> 等标签一起使用。</p>\n<p>####9.3.12 用于包含传递参数的<code>&lt;c:param&gt;</code>标签<br> <code>&lt;c:param&gt;</code> 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：</p>\n<p>表9.11　<code>&lt;c:param&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"190\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">name</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">传递的参数名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">传递的参数值（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面是一个示例：</p>\n<pre><code>&lt;c:redirect url=&quot;/MyHtml.jsp&quot;&gt;\n&lt;c:param name=&quot;userName&quot; value=”RW” /&gt;\n&lt;/c:redirect&gt;\n</code></pre><p>该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。</p>\n<p>###9.4 JSTL XML processing标签库<br>在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：</p>\n<ul>\n<li>XML核心标签：<code>&lt;x:parse&gt;、&lt;x:out&gt;、&lt;x:set&gt;</code>。</li>\n<li>XML流控制标签：<code>&lt;x:if&gt;、&lt;x:choose&gt;、&lt;x:when&gt;、&lt;x:otherwise&gt;、&lt;x:forEach&gt;</code>。</li>\n<li>XML转换标签：<code>&lt;x:transform&gt;、&lt;x:param&gt;</code>。</li>\n</ul>\n<p>由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。</p>\n<p>####9.4.1 用于解析XML文件的<code>&lt;x:parse&gt;</code>标签<br><code>&lt;x:parse&gt;</code> 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：</p>\n<p>表9.12　<code>&lt;x:parse&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"537\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">doc</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">varDom</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">scopeDom</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">org.w3c.dom.Document的接口类型变量作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">systemId</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">filter</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。</p>\n<p><code>&lt;x:parse&gt;</code>标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。</p>\n<p>首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;xml-body&gt;\n         &lt;name&gt;RW&lt;/name&gt;\n         &lt;passWord&gt;123456&lt;/passWord&gt;\n         &lt;age&gt;28&lt;/age&gt;\n         &lt;books&gt;\n                   &lt;book&gt;book1&lt;/book&gt;\n                   &lt;book&gt;book2&lt;/book&gt;\n                   &lt;book&gt;book3&lt;/book&gt;\n         &lt;/books&gt;\n&lt;/xml-body&gt;\n</code></pre><p>标签库的工作：</p>\n<pre><code>&lt;c:import var=&quot;xmlFile&quot; url=&quot;http://localhost:8080/booksamplejstl/SampleXml.xml&quot;/&gt;\n&lt;x:parse var=&quot;xmlFileValue&quot; doc=&quot;${xmlFile}&quot;/&gt;\n</code></pre><p>###<code>&lt;fmt: &gt;</code> 标签 </p>\n<p>看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：</p>\n<ul>\n<li>国际化核心标签：<code>&lt;fmt:setLocale&gt;、&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;、&lt;fmt:message&gt;、&lt;fmt:param&gt;、&lt;fmt:requestEncoding&gt;</code>。</li>\n<li>格式化标签：<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;、&lt;fmt:formatNumber&gt;、&lt;fmt:parseNumber&gt;、&lt;fmt:formatDate&gt;、&lt;fmt:parseDate&gt;</code>。</li>\n</ul>\n<p>下面只选择其中常见的一些标签和属性进行介绍。</p>\n<p>####9.5.1 用于设置本地化环境的<code>&lt;fmt:setLocale&gt;</code>标签<br>    <code>&lt;fmt:setLocale&gt;</code>标签用于设置Locale环境。它的属性和描述如表9.17所示：</p>\n<p>表9.17　<code>&lt;fmt:setLocale&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">Locale环境的指定，可以是java.util.Locale或String类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">Locale环境变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;fmt:setLocale value=&quot;zh_TW&quot;/&gt;\n</code></pre><p>表示设置本地环境为繁体中文。      </p>\n<p>####9.5.2 用于资源文件绑定的<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签</p>\n<p>这两组标签用于资源配置文件的绑定，唯一不同的是<code>&lt;fmt:bundle&gt;</code>标签将资源配置文件绑定于它标签体中的显示，<code>&lt;fmt:setBundle&gt;</code>标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。</p>\n<p>根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：</p>\n<p>表9.18　<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">basename</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例</p>\n<pre><code>&lt;fmt:setLocale value=&quot;zh_CN&quot;/&gt;\n&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;\n</code></pre><p>该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。</p>\n<p>####9.5.3  用于显示资源配置文件信息的<code>&lt;fmt:message&gt;</code>标签<br>用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：</p>\n<p>表9.19　<code>&lt;fmt:message&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">key</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">资源配置文件的&ldquo;键&rdquo;指定</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">bundle</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">将显示信息保存为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;\n&lt;fmt:bundle basename=&quot;applicationAllMessage&quot;&gt;\n         &lt;fmt:message key=&quot;userName&quot; /&gt;\n         &lt;p&gt;\n         &lt;fmt:message key=&quot;passWord&quot; bundle=&quot;${applicationBundle}&quot; /&gt;\n&lt;/fmt:bundle&gt;\n</code></pre><p>该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用<code>&lt;fmt:setBundle&gt;</code>标签被赋于了变量“ applicationBundle ”，而作为<code>&lt;fmt:bundle&gt;</code>标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。</p>\n<p>第一个<code>&lt;fmt:message&gt;</code>标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。<br>第二个<code>&lt;fmt:message&gt;</code>标签虽然被定义在<code>&lt;fmt:bundle&gt;</code>标签体内，但是它使用了bundle属性，因此将指定之前由<code>&lt;fmt:setBundle&gt;</code>标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。</p>\n<h4 id=\"9-5-4-用于参数传递的-lt-fmt-param-gt-标签\"><a href=\"#9-5-4-用于参数传递的-lt-fmt-param-gt-标签\" class=\"headerlink\" title=\"9.5.4  用于参数传递的&lt;fmt:param&gt;标签\"></a>9.5.4  用于参数传递的<code>&lt;fmt:param&gt;</code>标签</h4><p><code>&lt;fmt:param&gt;</code>标签应该位于<code>&lt;fmt:message&gt;</code>标签内，将为该消息标签提供参数值。它只有一个属性value。<br><code>&lt;fmt:param&gt;</code>标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。</p>\n<p>####9.5.6  用于为请求设置字符编码的<code>&lt;fmt:requestEncoding&gt;</code>标签<br><code>&lt;fmt:requestEncoding&gt;</code>标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。</p>\n<p>####9.5.7  用于设定时区的<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签<br>这两组标签都用于设定一个时区。唯一不同的是<code>&lt;fmt:timeZone&gt;</code>标签将使得在其标签体内的工作可以使用该时区设置，<code>&lt;fmt:setBundle&gt;</code>标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：</p>\n<p>表9.20　<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">时区的设置</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<h4 id=\"9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签\"><a href=\"#9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签\" class=\"headerlink\" title=\"9.5.8  用于格式化数字的&lt;fmt:formatNumber&gt;标签\"></a>9.5.8  用于格式化数字的<code>&lt;fmt:formatNumber&gt;</code>标签</h4><p><code>&lt;fmt: formatNumber &gt;</code> 标签用于格式化数字。它的属性和描述如表9.21所示：</p>\n<p>表9.21　<code>&lt;fmt:formatNumber&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">maxIntegerDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最大值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">minIntegerDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最小值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">maxFractionDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最大值，带小数</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">minFractionDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最小值，带小数</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:formatNumber&gt;</code>标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。</p>\n<p>下面看一个示例。</p>\n<pre><code>&lt;fmt:formatNumber value=&quot;1000.888&quot; type=&quot;currency&quot; var=&quot;money&quot;/&gt;\n</code></pre><p>该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。</p>\n<h4 id=\"9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签\"><a href=\"#9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签\" class=\"headerlink\" title=\"9.5.9  用于解析数字的&lt;fmt:parseNumber&gt;标签\"></a>9.5.9  用于解析数字的<code>&lt;fmt:parseNumber&gt;</code>标签</h4><p><code>&lt;fmt:parseNumber&gt;</code>标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。<code>&lt;fmt:parseNumber&gt;</code>标签看起来和<code>&lt;fmt:formatNumber&gt;</code>标签的作用正好相反。它的属性和描述如表9.22所示：</p>\n<p>表9.22　<code>&lt;fmt:parseNumber&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">结果保存变量，类型为java.lang.Number</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">parseLocale</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;fmt:parseNumber value=&quot;15%&quot; type=&quot;percent&quot; var=&quot;num&quot;/&gt;\n</code></pre><p>解析之后的结果为“ 0.15 ”。</p>\n<p>####9.5.10  用于格式化日期的<code>&lt;fmt:formatDate&gt;</code>标签<br><code>&lt;fmt:formatDate&gt;</code>标签用于格式化日期。它的属性和描述如表9.23所示：</p>\n<p>表9.23　<code>&lt;fmt:formatDate&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">timeZone</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">指定格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:formatDate&gt;</code>标签与<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签的关系密切。若没有指定 timeZone属性，也可以通过<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签设定的时区来格式化最后的结果。</p>\n<h4 id=\"9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签\"><a href=\"#9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签\" class=\"headerlink\" title=\"9.5.11  用于解析日期的&lt;fmt:parseDate&gt;标签\"></a>9.5.11  用于解析日期的<code>&lt;fmt:parseDate&gt;</code>标签</h4><p><code>&lt;fmt:parseDate&gt;</code>标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。<code>&lt;fmt:parseDate&gt;</code>标签看起来和<code>&lt;fmt:formatDate&gt;</code>标签的作用正好相反。它的属性和描述如表9.24所示：</p>\n<p>表9.24　<code>&lt;fmt:parseDate&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">结果保存变量，类型为java.lang.Date</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">parseLocale</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">timeZone</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">指定解析格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此<code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。</p>\n<p> <code>&lt;sql:&gt;</code>标签 </p>\n<p>###9.6  Database access 标签库</p>\n<p>Database access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。</p>\n<p>对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。</p>\n<p>Database access标签库有以下6组标签来进行工作：<code>&lt;sql:setDataSource&gt;、&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:transaction&gt;、&lt;sql:setDataSource&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;</code>。</p>\n<p>####9.6.1 用于设置数据源的 <code>&lt;sql:setDataSource&gt;</code> 标签<br><code>&lt;sql:setDataSource&gt;</code>标签用于设置数据源，下面看一个示例：</p>\n<pre><code>&lt;sql:setDataSource\n         var=&quot;dataSrc&quot;\n         url=&quot;jdbc:postgresql://localhost:5432/myDB&quot;\n         driver=&quot;org.postgresql.Driver&quot;\n         user=&quot;admin&quot;\n         password=&quot;1111&quot;/&gt;\n</code></pre><p>该示例定义一个数据源并保存在“ dataSrc ”变量内。</p>\n<p>####9.6.2 用于查询的 <code>&lt;sql:query&gt;</code>标签</p>\n<p><code>&lt;sql:query&gt;</code>标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：</p>\n<pre><code>&lt;sql:query var=&quot;queryResults&quot; dataSource=&quot;${dataSrc}&quot;&gt;\n      select * from table1\n&lt;/sql:query&gt;\n</code></pre><p>该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用<code>&lt;c:forEach&gt;</code>循环来进行。下面看一个示例。</p>\n<pre><code>&lt;c:forEach var=&quot;row&quot; items=&quot;${queryResults.rows}&quot;&gt;\n      &lt;tr&gt;\n               &lt;td&gt;${row.userName}&lt;/td&gt;\n                &lt;td&gt;${row.passWord}&lt;/td&gt;\n      &lt;/tr&gt;\n&lt;/c:forEach&gt;\n</code></pre><p>“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。</p>\n<p>####9.6.3 用于更新的 <code>&lt;sql:update&gt;</code> 标签<br><code>&lt;sql:update&gt;</code>标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和<code>&lt;sql:query&gt;</code>标签没有什么不同。</p>\n<p>####9.6.4 用于事务处理的<code>&lt;sql:transaction&gt;</code>标签<br><code>&lt;sql:transaction&gt;</code>标签用于数据库的事务处理，在该标签体内可以使用<code>&lt;sql:update&gt;</code>标签和<code>&lt;sql:query&gt;</code>标签，而<code>&lt;sql:transaction&gt;</code>标签的事务管理将作用于它们之上。<br><code>&lt;sql:transaction&gt;</code>标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。</p>\n<p>####9.6.5 用于事务处理的<code>&lt;sql:param&gt; 、 &lt;sql:dateParam&gt;</code> 标签<br>这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。<code>&lt;sql:param&gt;</code>标签传递除java.util.Date类型以外的所有相融参数，<code>&lt;sql:dateParam&gt;</code>标签则指定必须传递java.util.Date类型的参数。</p>\n<p>###<code>&lt;fn:&gt;</code> 标签 </p>\n<p>###9.7 Functions 标签库<br>       称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。</p>\n<pre><code>长度函数：fn:length\n字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim\n</code></pre><p>以下是各个函数的用途和属性以及简单示例。</p>\n<p>####9.7.1 长度函数 fn:length 函数<br>       长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。</p>\n<p>fn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。</p>\n<pre><code>&lt;%ArrayList arrayList1 = new ArrayList();\n                            arrayList1.add(&quot;aa&quot;);\n                            arrayList1.add(&quot;bb&quot;);\n                            arrayList1.add(&quot;cc&quot;);\n\n%&gt;\n&lt;%request.getSession().setAttribute(&quot;arrayList1&quot;, arrayList1);%&gt;\n${fn:length(sessionScope.arrayList1)}\n</code></pre><p>假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。</p>\n<p>####9.7.2 判断函数 fn:contains 函数<br>       fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:contains(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;\n${fn:contains(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.3 fn:containsIgnoreCase函数<br>      fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;\n${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;\n</code></pre><p>前者和后者都会返回“ true ”。</p>\n<p>####9.7.4 词头判断函数 fn:startsWith 函数<br>       fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:startsWith (&quot;ABC&quot;, &quot;ab&quot;)}&lt;br&gt;\n${fn:startsWith (&quot;ABC&quot;, &quot;AB&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.5 词尾判断函数 fn:endsWith 函数<br>       fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:endsWith(&quot;ABC&quot;, &quot;bc&quot;)}&lt;br&gt;\n${fn:endsWith(&quot;ABC&quot;, &quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.6 字符实体转换函数 fn:escapeXml 函数<br>fn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。</p>\n<p>####9.7.8 字符匹配函数 fn:indexOf 函数<br>       fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。</p>\n<pre><code>${fn:indexOf(&quot;ABCD&quot;,&quot;aBC&quot;)}&lt;br&gt;\n${fn:indexOf(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。</p>\n<p>####9.7.9 分隔符函数 fn:join 函数<br>       fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：</p>\n<p>表9.25　fn:join函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"350\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>array</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>字符串数组。其类型必须为String[]类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>separator</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;% String[] stringArray = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; %&gt;\n&lt;%request.getSession().setAttribute(&quot;stringArray&quot;, stringArray);%&gt;\n${fn:join(sessionScope.stringArray,&quot;;&quot;)}&lt;br&gt;\n</code></pre><p>定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。</p>\n<p>####9.7.10 替换函数 fn:replace 函数<br>       fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：</p>\n<p>表9.26　fn:replace函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>inputString</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>beforeSubstring</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>指定被替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>afterSubstring</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>指定替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:replace(“ABC”,”A”,”B”)}<br></p>\n<p>将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。</p>\n<p>####9.7.11 分隔符转换数组函数 fn:split 函数<br>fn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：</p>\n<p>表9.27　fn:split函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"281\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>string</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>delimiters</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>指定分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>返回一个String[]类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:split(“A,B,C”,”,”)}<br></p>\n<p>将“ A,B,C ”字符串转换为数组{A,B,C}。</p>\n<p>####9.7.12 字符串截取函数 fn:substring 函数<br>fn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：</p>\n<p>表9.28　fn:substring函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>string</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>beginIndex</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>指定起始下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>endIndex</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>指定结束下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:substring(“ABC”,”1”,”2”)}<br></p>\n<p>截取结果为“ B ”。</p>\n<p>####9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数<br>fn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。</p>\n<pre><code>${fn:substringBefore(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>截取的结果为“ A ”。</p>\n<p>####9.7.15 小写转换函数 fn:toLowerCase 函数<br>fn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:toLowerCase(&quot;ABCD&quot;)}&lt;br&gt;\n</code></pre><p>转换的结果为“ abcd ”。</p>\n<p>####9.7.16大写转换函数 fn:toUpperCase 函数<br>fn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:toUpperCase(&quot;abcd&quot;)}&lt;br&gt;\n</code></pre><p>转换的结果为“ ABCD ”。</p>\n<p>####9.7.17空格删除函数 fn:trim 函数<br>fn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:trim(&quot;AB C &quot;)}D&lt;br&gt;\n</code></pre><p>转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。</p>\n<p>参考文档<a href=\"http://www.javawind.net/help/html/jstl_el.htm\" target=\"_blank\" rel=\"external\">http://www.javawind.net/help/html/jstl_el.htm</a></p>\n","excerpt":"<p>###EL 表达式<br>在JSP页面中，使用标签库代替传统的Java片段语言来实现页面的显示逻辑已经不是新技术了，然而，由自定义标签很容易造成重复定义和非标准的实现。鉴于此，出现了JSTL（JSP Standard Tag Library），为大多数JSP页面逻辑提供了实现的JSTL技术，该技术本身就是一个标签库。</p>\n<p>Sun公司Java规范标准的JSTL由apache jakarta组织负责维护。作为开源的标准技术，它一直在不断地完善。JSTL的发布包有两个版本：Standard-1.0 Taglib、Standard-1.1 Taglib，它们在使用时是不同的。</p>\n<p>Standard-1.0 Taglib（JSTL1.0）支持Servlet2.3和JSP1.2规范，Web应用服务器Tomcat4支持这些规范，而它的发布也在Tomcat 4.1.24测试通过了。</p>\n<p>Standard-1.1 Taglib（JSTL1.1）支持Servlet2.4和JSP2.0规范，Web应用服务器Tomcat5支持这些规范，它的发布在Tomcat 5.0.3测试通过了。</p>\n<p>本文将以由Sun发布的Standard-1.1 Taglib标签库为主，而apache jakarta组织发布的开源标签库，可以从<a href=\"http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：\">http://jakarta.apache.org/taglibs/找到所需要的帮助。Sun发布的标准JSTL1.1标签库有以下几个标签：</a></p>\n<ul>\n<li>核心标签库：包含Web应用的常见工作，比如：循环、表达式赋值、基本输入输出等。</li>\n<li>国际化标签库：用来格式化显示数据的工作，比如：对不同区域的日期格式化等。</li>\n<li>数据库标签库：可以做访问数据库的工作。</li>\n<li>XML标签库：用来访问XML文件的工作，这是JSTL标签库的一个特点。</li>\n<li>函数标签库：用来读取已经定义的某个函数。</li>\n</ul>\n<p>此外，JSTL还提供了EL表达式语言（Expression Language）来进行辅助的工作。</p>\n<p>JSTL标签库由标签库和EL表达式语言两个部分组成。EL在JSTL 1.0规范中被引入，当时用来作为Java表达式来工作，而该表达式必须配合JSTL的标签库才能得到需要的结果。</p>\n<p>说明：在JSTL 1.1规范中，JSP2.0容器已经能够独立的理解任何EL表达式。EL可以独立出现在JSP页面的任何角落。本文随后的内容将以JSTL 1.1规范作为介绍的重点。</p>","more":"<p>####9.2.1JSTL EL 表达式语言简介<br>EL是从JavaScript脚本语言得到启发的一种表达式语言，它借鉴了JavaScript多类型转换无关性的特点。在使用EL从scope中得到参数时可以自动转换类型，因此对于类型的限制更加宽松。Web服务器对于request请求参数通常会以String类型来发送，在得到时使用的Java语言脚本就应该是request.getParameter(“XXX”)，这样的话，对于实际应用还必须进行强制类型转换。而EL就将用户从这种类型转换的繁琐工作脱离出来，允许用户直接使用EL表达式取得的值，而不用关心它是什么类型。</p>\n<p>下面的示例就是一个EL表达式，见例9.1。</p>\n<p>例9.1：简单EL表达式</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt; ${sampleValue + 1} &lt;br&gt; &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这个示例将在JSP页面显示为“1”，EL表达式必须以“${XXX}”来表示，其中“XXX”部分就是具体表达式内容，“${}”将这个表达式内容包含在其中作为EL表达式的定义。本示例可以在满足JSP2.0规范的任何Web应用服务器中使用。   </p>\n<p>####9.2.2 EL 表达式的默认变量<br>一个EL表达式包含变量和操作符两个内容。任何存在于JSP作用范围的JavaBean都可以被转化成EL表达式来使用，它所包含的默认变量如下：</p>\n<p>1．默认变量pageScope、requestScope、sessionScope、applicationScope<br>      这4个默认变量包含Scope作用范围的参数集合，相当于被保存在java.util.Map中的某个参数。下面看简单的示例9.2：</p>\n<p>例9.2：使用sessionScope变量的EL表达式</p>\n<pre><code>&lt;%request.getSession().setAttribute(&quot;sampleValue&quot;, new Integer(10));%&gt;\n${sessionScope.sampleValue}\n</code></pre><p>取得保存在Session中参数的sessionScope变量的EL表达式，“.”是property访问操作符，在这里表示从Session中取得“键”为“sampleValue”的参数，并显示出来。显示结果为“10”。</p>\n<p>2．默认变量param、paramValues<br>      这两个默认变量包含请求参数的集合，param表明请求包含的参数为单一控件，paramValues表明请求包含的参数为控件数组。下面看一个简单示例9.3：</p>\n<p>例9.3：提交请求的页面和接受的页面</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n     &lt;form action=&quot;SampleJsp.jsp&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;10&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;11&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleValue&quot; value=&quot;12&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;sampleSingleValue&quot; value=&quot;SingleValue&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;\n    &lt;/form&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>在这个页面中定义了两组控件，控件名为“sampleValue”的是一套控件数组，控件名为“sampleSingleValue”的是单一控件，通过递交将请求参数传送到SampleJsp.jsp。</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n    ${paramValues.sampleValue[2]} &lt;br&gt;\n    ${param.sampleSingleValue} &lt;br&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>这是请求转发到的页面，通过EL表达式的paramValues变量得到控件数组中最后一个控件的递交参数，通过EL表达式的param变量得到单一控件的递交参数。控件数组参数的EL表达式使用“[]”来指定数组下标。本示例将显示控件数组中最后一个控件的值“12”和单一控件的值“SingleValue”。</p>\n<p>3．默认变量header、headerValues</p>\n<p>这两个默认变量包含请求参数头部信息的集合，header变量表示单一头部信息，headerValues则表示数组型的头部信息。</p>\n<p>4．默认变量cookie</p>\n<p>包含所有请求的cookie集合，集合中的每个对象对应javax.servlet.http.Cookie。</p>\n<p>5．默认变量initParam</p>\n<p>包含所有应用程序初始化参数的集合。</p>\n<p>6．默认变量pageContext</p>\n<p>等价于page环境类javax.servlet.jsp.PageContext的实例，用来提供访问不同的请求参数。<br>11个默认变量几乎包含了Web应用的所有基本操作，若一个表达式不使用这些变量而直接使用参数名，那么就采用就近原则。该表达式将使用最近取得的参数值。</p>\n<p>###表达式的操作符<br>EL表达式中还有许多操作符可以帮助完成各种所需的操作，之前的示例中“.”、“[]”就是其中的两个，下面将用表9.1来展示所有操作符及它们各自的功能。</p>\n<p>表9.1 EL表达式的操作符</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"562\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"64\"><br>                                <p align=\"left\">操作符</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">功能和作用</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">.</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">访问一个bean属性或者Map entry</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">[]</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">访问一个数组或者链表元素</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">()</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">对子表达式分组，用来改变赋值顺序</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">? :</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">条件语句，比如：条件?ifTrue:ifFalse</p><br>                                <p align=\"left\">如果条件为真，表达式值为前者，反之为后者</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">+</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，加操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">-</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，减操作或者对一个值取反</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">*</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，乘操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">/ 或div</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，除操作</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">% 或mod</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">数学运算符，模操作(取余)</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">== 或eq</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">!= 或ne</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&lt; 或lt</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&gt; 或gt</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&lt;= 或le</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&gt;= 或ge</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">&amp;&amp; 或and</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">|| 或or</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">! 或not</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">empty</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">用来对一个空变量值进行判断: null、一个空String、空数组、空Map、没有条目的Collection集合</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td valign=\"top\" width=\"64\"><br>                                <p align=\"left\">func(args)</p><br>                                </td><br>                                <td width=\"498\"><br>                                <p align=\"left\">调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>这些操作符都是极其有用的，下面通过几个示例来演示它们的使用方法：</p>\n<p>例9.4：几组操作符的示例</p>\n<pre><code>${pageScope.sampleValue + 12} &lt;br&gt;           //显示12\n${(pageScope.sampleValue + 12)/3} &lt;br&gt;     //显示4.0\n${(pageScope.sampleValue + 12) /3==4} &lt;br&gt;         //显示true\n${(pageScope.sampleValue + 12) /3&gt;=5} &lt;br&gt;         //显示false\n&lt;input type=&quot;text&quot; name=&quot;sample1&quot; value=&quot;${pageScope.sampleValue + 10}&quot;&gt; //显示值为10的Text控件\n</code></pre><p>可以看到，对于这些示例，程序设计者完全无需管理它们的类型转换，在表达式内部都已经处理了。有了EL表达式，在JSP页面的编程变得更灵活，也更容易。</p>\n<p>###标签库介绍<br>在JSTL1.1中有以下这些标签库是被支持的：Core标签库、XML processing标签库、I18N formatting标签库、Database access标签库、Functions标签库。<br>对应的标识符见表9.2所示：</p>\n<p>表9.2 标签库的标识符</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"360\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">标签库</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\">URI</p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"center\">前缀</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Core</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/core\">http://java.sun.com/jsp/jstl/core</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">c</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">XML processing</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/xml\">http://java.sun.com/jsp/jstl/xml</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">x</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">I18N formatting</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/fmt\">http://java.sun.com/jsp/jstl/fmt</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">fmt</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Database access</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/sql\">http://java.sun.com/jsp/jstl/sql</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">sql</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"107\"><br>                                <p align=\"left\">Functions</p><br>                                </td><br>                                <td width=\"202\"><br>                                <p align=\"left\"><a href=\"http://java.sun.com/jsp/jstl/functions\">http://java.sun.com/jsp/jstl/functions</a></p><br>                                </td><br>                                <td width=\"50\"><br>                                <p align=\"left\">fn</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看例9.5，简单使用标签库的示例。</p>\n<p>例9.5：简单JSTL标签库示例</p>\n<pre><code>&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot;%&gt;\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n &lt;body&gt;\n    &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt; ${i} &lt;br /&gt;&lt;/c:forEach&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>在该示例的JSP页面中声明了将使用Core标签库，它的URI为“<a href=\"http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中\">http://java.sun.com/jsp/jstl/core”，前缀为“c”。之后，页面中</a><c:forEach>标签就是使用了JSTL的标签进行了工作。对于该标签的功能，这里暂时不作具体讲解，只是让读者能够有个简单的概念，了解怎样定义和使用标签库。 </p>\n<p>###标签库<br>Core标签库，又被称为核心标签库，该标签库的工作是对于JSP页面一般处理的封装。在该标签库中的标签一共有14个，被分为了四类，分别是：</p>\n<ul>\n<li>多用途核心标签：<c:out>、<c:set>、<c:remove>、<c:catch>。</li>\n<li>条件控制标签：<c:if>、<c:choose>、<c:when>、<c:otherwise>。</li>\n<li>循环控制标签：<c:forEach>、<c:forTokens>。</li>\n<li>URL相关标签：<c:import>、<c:url>、<c:redirect>、<c:param>。</li>\n</ul>\n<p>以下是各个标签的用途和属性以及简单示例。</p>\n<p>###用于显示的<code>&lt;c:out&gt;</code> 标签<br><code>&lt;c:out&gt;</code>标签是一个最常用的标签，用于在JSP中显示数据。它的属性和描述如表9.3所示：</p>\n<p>表9.3　<code>&lt;c:out&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"535\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">输出到页面的数据，可以是EL表达式或常量（必须）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">default</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">当value为null时显示的数据（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"79\"><br>                                <p align=\"left\">escapeXml</p><br>                                </td><br>                                <td width=\"456\"><br>                                <p align=\"left\">当设置为true时会主动更换特殊字符，比如&ldquo;&amp;lt;,&amp;gt;,&amp;amp;&rdquo;（可选，默认为true）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>在JSTL1.0的时候，在页面显示数据必须使用<c:out>来进行。然而，在JSTL1.1中，由于JSP2.0规范已经默认支持了EL表达式，因此可以直接在JSP页面使用表达式。下面看一个示例。</p>\n<pre><code>&lt;c:out value=&quot;${sessionScope.anyValue}&quot; default=&quot;no value&quot; escapeXml=&quot;false&quot;/&gt;\n</code></pre><p>该示例将从Session查找名为“anyValue”的参数，并显示在页面，若没有找到则显示“no value”。</p>\n<p>###<code>&lt;c: &gt;</code> 标签 </p>\n<p>####用于赋值的<c:set>标签<br><code>&lt;c:set&gt;</code>标签用于为变量或JavaBean中的变量属性赋值的工作。它的属性和描述如表9.4所示：</p>\n<p>表9.4　<code>&lt;c:set&gt;</code>标签属性和说明</p>\n<table cellpadding=\"0\" width=\"393\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"311\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">值的信息，可以是EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">target</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">被赋值的JavaBean实例的名称，若存在该属性则必须<br /><br>                                存在property属性（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">property</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">JavaBean实例的变量属性名称（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">被赋值的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为page（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n<p> 当不存在value的属性时，将以包含在标签内的实体数据作为赋值的内容。下面看一个示例：</p>\n<pre><code>&lt;c:set value=&quot;this is andy&quot; var=&quot;oneString&quot;/&gt;\n${oneString} &lt;br&gt;\n</code></pre><p>该示例将为名为“oneString”的变量赋值为“this is andy”，其作用范围为page。</p>\n<p>####9.3.3 用于删除的 <code>&lt;c:remove&gt;</code>标签<br><code>&lt;c:remove&gt;</code>标签用于删除存在于scope中的变量。它的属性和描述如表9.5所示：</p>\n<p>表9.5　<code>&lt;c:remove&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"365\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">需要被删除的变量名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为全部查找（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:remove var=&quot;sampleValue&quot; scope=&quot;session&quot;/&gt;\n${sessionScope.sampleValue} &lt;br&gt;\n</code></pre><p>该示例将存在于Session中名为“sampleValue”的变量删除。下一句EL表达式显示该变量时，该变量已经不存在了。</p>\n<p>####9.3.4 用于异常捕获的 <code>&lt;c:catch&gt;</code> 标签<br><code>&lt;c:catch&gt;</code>标签允许在JSP页面中捕捉异常。它包含一个var属性，是一个描述异常的变量，改变量可选。若没有var属性的定义，那么仅仅捕捉异常而不做任何事情，若定义了var属性，则可以利用var所定义的异常变量进行判断转发到其他页面或提示报错信息。看一个示例。</p>\n<pre><code>&lt;c:catch var=&quot;err&quot;&gt; ${param.sampleSingleValue[9] == 3}&lt;/c:catch&gt;\n${err}\n</code></pre><p>当“${param.sampleSingleValue[9] == 3}”表达式有异常时，可以从var属性“err”得到异常的内容，通常判断“err”是否为null来决定错误信息的提示。</p>\n<p>####9.3.5 用于判断的 <code>&lt;c:if&gt;</code> 标签<br><code>&lt;c:if&gt;</code>标签用于简单的条件语句。它的属性和描述如表9.6所示：</p>\n<p>表9.6　<code>&lt;c:if&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"454\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">test</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">需要判断的条件</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">保存判断结果true或false的变量名，该变量可供之后的工作使用（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"60\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"394\"><br>                                <p align=\"left\">变量的作用范围，若没有指定，默认为保存于page范围中的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:if test=&quot;${paramValues.sampleValue[2] == 12}&quot; var=&quot;visits&quot;&gt;It is 12&lt;/c:if&gt;&lt;br&gt;\n${visits} &lt;br&gt;\n</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”的控件内容是否为“12”，若为12则显示“It is 12”。判断结果被保存在page范围中的“visits”变量中。</p>\n<p>####9.3.6 用于复杂判断的 <code>&lt;c:choose&gt; 、 &lt;c:when&gt; 、 &lt;c:otherwise&gt;</code> 标签<br>这三个标签用于实现复杂条件判断语句，类似“if,elseif”的条件语句。</p>\n<p><code>&lt;c:choose&gt;</code>标签没有属性，可以被认为是父标签，<code>&lt;c:when&gt;、&lt;c:otherwise&gt;</code>将作为其子标签来使用。<br><code>&lt;c:when&gt;</code>标签等价于“if”语句，它包含一个test属性，该属性表示需要判断的条件。<br><code>&lt;c:otherwise&gt;</code>标签没有属性，它等价于“else”语句。</p>\n<p>下面看一个复杂条件语句的示例。</p>\n<pre><code>&lt;c:choose&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 11}&quot;&gt;\n                   not 12 not 13,it is 11\n         &lt;/c:when&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 12}&quot;&gt;\n                   not 11 not 13,it is 12\n         &lt;/c:when&gt;\n         &lt;c:when test=&quot;${paramValues.sampleValue[2] == 13}&quot;&gt;\n                   not 11 not 12,it is 13\n         &lt;/c:when&gt;\n         &lt;c:otherwise&gt;\n                   not 11 、12、13\n         &lt;/c:otherwise&gt;\n&lt;/c:choose&gt;\n</code></pre><p>该示例将判断request请求提交的传入控件数组参数中，下标为“2”控件内容是否为“11”或“12”或“13”，并根据判断结果显示各自的语句，若都不是则显示“not 11 、12、13”。</p>\n<p>####9.3.7 用于循环的 <code>&lt;c:forEach&gt;</code> 标签<br><code>&lt;c:forEach&gt;</code>为循环控制标签。它的属性和描述如表9.7所示：</p>\n<p>表9.7　<code>&lt;c:forEach&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"511\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">items</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">进行循环的集合（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">begin</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">end</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">step</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">做循环的对象变量名，若存在items属性，则表示循环集合中对象的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"59\"><br>                                <p align=\"left\">varStatus</p><br>                                </td><br>                                <td width=\"452\"><br>                                <p align=\"left\">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个集合循环的示例。</p>\n<p>&lt;%ArrayList arrayList = new ArrayList();<br>                   arrayList.add(“aa”);<br>                   arrayList.add(“bb”);<br>                   arrayList.add(“cc”);<br>%&gt;<br>&lt;%request.getSession().setAttribute(“arrayList”, arrayList);%&gt;</p>\n<p><c:forEach items=\"${sessionScope.arrayList}\" var=\"arrayListI\"><br>         ${arrayListI}<br></c:forEach></p>\n<p>该示例将保存在Session中的名为“arrayList”的ArrayList类型集合参数中的对象依次读取出来，items属性指向了ArrayList类型集合参数，var属性定义了一个新的变量来接收集合中的对象。最后直接通过EL表达式显示在页面上。下面看一个简单循环的示例。</p>\n<pre><code>&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot;&gt;\n      ${i}&lt;br /&gt;\n&lt;/c:forEach&gt;\n</code></pre><p>该示例从“1”循环到“10”，并将循环中变量“i”显示在页面上。</p>\n<p>####9.3.8 用于分隔字符的 <code>&lt;c:forTokens&gt;</code> 标签<br><code>&lt;c:forTokens&gt;</code>标签可以根据某个分隔符分隔指定字符串，相当于java.util.StringTokenizer类。它的属性和描述如表9.8所示：</p>\n<p>表9.8　<code>&lt;c:forTokens&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"268\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">items</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">进行分隔的EL表达式或常量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">delims</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">分隔符</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">begin</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">开始条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">end</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">结束条件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">step</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">循环的步长，默认为1（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">做循环的对象变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"76\"><br>                                <p align=\"left\">varStatus</p><br>                                </td><br>                                <td width=\"192\"><br>                                <p align=\"left\">显示循环状态的变量（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;c:forTokens items=&quot;aa,bb,cc,dd&quot; begin=&quot;0&quot; end=&quot;2&quot; step=&quot;2&quot; delims=&quot;,&quot; var=&quot;aValue&quot;&gt;\n         ${aValue}\n&lt;/c:forTokens&gt;\n</code></pre><p>需要分隔的字符串为“aa,bb,cc,dd”，分隔符为“,”。begin属性指定从第一个“,”开始分隔，end属性指定分隔到第三个“,”，并将做循环的变量名指定为“aValue”。由于步长为“2”，使用EL表达式${aValue}只能显示“aa</p>\n<p>###<code>&lt;x: &gt;</code> 标签</p>\n<p>####9.3.9 用于包含页面的<code>&lt;c:import&gt;</code><br><code>&lt;c:import&gt;</code>标签允许包含另一个JSP页面到本页面来。它的属性和描述如表9.9所示：</p>\n<p>表9.9　<code>&lt;c:import&gt;</code>标签属性和说明</p>\n<table cellpadding=\"0\" width=\"360\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"73\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"271\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">rl</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">需要导入页面的URL</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">context</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">Web Context该属性用于在不同的Context下导入页面，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">charEncoding</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">导入页面的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">可以定义导入文本的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">导入文本的变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td><br>                                <p align=\"left\">varReader</p><br>                                </td><br>                                <td><br>                                <p align=\"left\">接受文本的java.io.Reader类变量名（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p> 下面看一个示例。</p>\n<pre><code>&lt;c:import url=&quot;/MyHtml.html&quot; var=&quot;thisPage&quot; /&gt;\n&lt;c:import url=&quot;/MyHtml.html&quot; context=”/sample2” var=&quot;thisPage&quot;/&gt;\n&lt;c:import url=&quot;www.sample.com/MyHtml.html&quot; var=&quot;thisPage&quot;/&gt;\n</code></pre><p>该示例演示了三种不同的导入方法，第一种是在同一 Context 下的导入，第二种是在不同的 Context 下导入，第三种是导入任意一个 URL 。</p>\n<p>####9.3.10 用于得到URL地址的<code>&lt;c:url&gt;</code>标签<br><code>&lt;c:url&gt;</code> 标签用于得到一个 URL 地址。它的属性和描述如表 9.10 所示：</p>\n<p>表9.10 <code>&lt;c:url&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"459\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">页面的URL地址</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">context</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">Web Context该属性用于得到不同Context下的URL地址，当出现context属性时，必须以&ldquo;/&rdquo;开头，此时也需要url属性以&ldquo;/&rdquo;开头（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">charEncoding</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">URL的字符集（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">存储URL的变量名（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"81\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"378\"><br>                                <p align=\"left\">变量名作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;c:url value=&quot;/MyHtml.html&quot; var=&quot;urlPage&quot; /&gt;\n&lt;a href=&quot;${urlPage}&quot;&gt;link&lt;/a&gt;\n</code></pre><p>得到了一个 URL 后，以 EL 表达式放入<code>&lt;a&gt;</code> 标签的 href 属性，达到链接的目的。</p>\n<p>####9.3.11 用于页面重定向的<code>&lt;c:redirect&gt;</code>标签<br><code>&lt;c:redirect&gt;</code> 用于页面的重定向，该标签的作用相当于 <code>response.setRedirect</code> 方法的工作。它包含 url 和 context 两个属性，属性含义和 <code>&lt;c:url&gt;</code> 标签相同。下面看一个示例。</p>\n<pre><code>&lt;c:redirect url=&quot;/MyHtml.html&quot;/&gt;\n</code></pre><p>该示例若出现在 JSP 中，则将重定向到当前 Web Context 下的“ MyHtml.html ”页面，一般会与 <code>&lt;c:if&gt;</code> 等标签一起使用。</p>\n<p>####9.3.12 用于包含传递参数的<code>&lt;c:param&gt;</code>标签<br> <code>&lt;c:param&gt;</code> 用来为包含或重定向的页面传递参数。它的属性和描述如表 9.11 所示：</p>\n<p>表9.11　<code>&lt;c:param&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"190\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">name</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">传递的参数名</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"58\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"132\"><br>                                <p align=\"left\">传递的参数值（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面是一个示例：</p>\n<pre><code>&lt;c:redirect url=&quot;/MyHtml.jsp&quot;&gt;\n&lt;c:param name=&quot;userName&quot; value=”RW” /&gt;\n&lt;/c:redirect&gt;\n</code></pre><p>该示例将为重定向的“ MyHtml.jsp ”传递指定参数“ userName=’RW’ ”。</p>\n<p>###9.4 JSTL XML processing标签库<br>在企业级应用越来越依赖 XML 的今天， XML 格式的数据被作为信息交换的优先选择。 XML processing 标签库为程序设计者提供了基本的对 XML 格式文件的操作。在该标签库中的标签一共有 10 个，被分为了三类，分别是：</p>\n<ul>\n<li>XML核心标签：<code>&lt;x:parse&gt;、&lt;x:out&gt;、&lt;x:set&gt;</code>。</li>\n<li>XML流控制标签：<code>&lt;x:if&gt;、&lt;x:choose&gt;、&lt;x:when&gt;、&lt;x:otherwise&gt;、&lt;x:forEach&gt;</code>。</li>\n<li>XML转换标签：<code>&lt;x:transform&gt;、&lt;x:param&gt;</code>。</li>\n</ul>\n<p>由于该组标签库专注于对某一特定领域的实现，因此本书将只选择其中常见的一些标签和属性进行介绍。</p>\n<p>####9.4.1 用于解析XML文件的<code>&lt;x:parse&gt;</code>标签<br><code>&lt;x:parse&gt;</code> 标签是该组标签库的核心，从其标签名就可以知道，它是作为解析 XML 文件而存在的。它的属性和描述如表 9.12 所示：</p>\n<p>表9.12　<code>&lt;x:parse&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"537\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">doc</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">源XML的内容，该属性的内容应该为String类型或者java.io.Reader的实例，可以用xml属性来替代，但是不被推荐</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">将解析后的XML保存在该属性所指定的变量中，之后XML processing标签库中的其他标签若要取XML中的内容就可以从该变量中得到（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">varDom</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">指定保存的变量为org.w3c.dom.Document接口类型（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">scopeDom</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">org.w3c.dom.Document的接口类型变量作用范围（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">systemId</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">定义一个URI，该URI将被使用到XML文件中以接入其他资源文件（可选）</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"67\"><br>                                <p align=\"left\">filter</p><br>                                </td><br>                                <td width=\"470\"><br>                                <p align=\"left\">该属性必须为org.xml.sax.XMLFilter类的一个实例，可以使用EL表达式传入，将对XML文件做过滤得到自身需要的部分（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>其中， var 、 scope 和 varDom 、 scopeDom 不应该同时出现，而应该被视为两个版本来使用，二者的变量都可以被 XML processing 标签库的其他标签来使用。</p>\n<p><code>&lt;x:parse&gt;</code>标签单独使用的情况很少，一般会结合 XML processing 标签库中的其他标签来一起工作。下面看一个示例。</p>\n<p>首先给出一个简单的 XML 文件，将对该 XML 文件做解析，该 XML 文件名为 SampleXml.xml 。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;xml-body&gt;\n         &lt;name&gt;RW&lt;/name&gt;\n         &lt;passWord&gt;123456&lt;/passWord&gt;\n         &lt;age&gt;28&lt;/age&gt;\n         &lt;books&gt;\n                   &lt;book&gt;book1&lt;/book&gt;\n                   &lt;book&gt;book2&lt;/book&gt;\n                   &lt;book&gt;book3&lt;/book&gt;\n         &lt;/books&gt;\n&lt;/xml-body&gt;\n</code></pre><p>标签库的工作：</p>\n<pre><code>&lt;c:import var=&quot;xmlFile&quot; url=&quot;http://localhost:8080/booksamplejstl/SampleXml.xml&quot;/&gt;\n&lt;x:parse var=&quot;xmlFileValue&quot; doc=&quot;${xmlFile}&quot;/&gt;\n</code></pre><p>###<code>&lt;fmt: &gt;</code> 标签 </p>\n<p>看到I18N就应该想到知识“国际化”，I18N formatting标签库就是用于在JSP页面中做国际化的动作。在该标签库中的标签一共有12个，被分为了两类，分别是：</p>\n<ul>\n<li>国际化核心标签：<code>&lt;fmt:setLocale&gt;、&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;、&lt;fmt:message&gt;、&lt;fmt:param&gt;、&lt;fmt:requestEncoding&gt;</code>。</li>\n<li>格式化标签：<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;、&lt;fmt:formatNumber&gt;、&lt;fmt:parseNumber&gt;、&lt;fmt:formatDate&gt;、&lt;fmt:parseDate&gt;</code>。</li>\n</ul>\n<p>下面只选择其中常见的一些标签和属性进行介绍。</p>\n<p>####9.5.1 用于设置本地化环境的<code>&lt;fmt:setLocale&gt;</code>标签<br>    <code>&lt;fmt:setLocale&gt;</code>标签用于设置Locale环境。它的属性和描述如表9.17所示：</p>\n<p>表9.17　<code>&lt;fmt:setLocale&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">Locale环境的指定，可以是java.util.Locale或String类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"49\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"336\"><br>                                <p align=\"left\">Locale环境变量的作用范围（可选）</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;fmt:setLocale value=&quot;zh_TW&quot;/&gt;\n</code></pre><p>表示设置本地环境为繁体中文。      </p>\n<p>####9.5.2 用于资源文件绑定的<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签</p>\n<p>这两组标签用于资源配置文件的绑定，唯一不同的是<code>&lt;fmt:bundle&gt;</code>标签将资源配置文件绑定于它标签体中的显示，<code>&lt;fmt:setBundle&gt;</code>标签则允许将资源配置文件保存为一个变量，在之后的工作可以根据该变量来进行。</p>\n<p>根据Locale环境的不同将查找不同后缀的资源配置文件，这点在国际化的任何技术上都是一致的，通常来说，这两种标签单独使用是没有意义的，它们都会与I18N formatting标签库中的其他标签配合使用。它们的属性和描述如表9.18所示：</p>\n<p>表9.18　<code>&lt;fmt:bundle&gt;、&lt;fmt:setBundle&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">basename</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">资源配置文件的指定，只需要指定文件名而无须扩展名，二组标签共有的属性</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">&lt;fmt:setBundle&gt;独有的属性，用于保存资源配置文件为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"69\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"421\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例</p>\n<pre><code>&lt;fmt:setLocale value=&quot;zh_CN&quot;/&gt;\n&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;\n</code></pre><p>该示例将会查找一个名为applicationMessage_zh_CN.properties的资源配置文件，来作为显示的Resource绑定。</p>\n<p>####9.5.3  用于显示资源配置文件信息的<code>&lt;fmt:message&gt;</code>标签<br>用于信息显示的标签，将显示资源配置文件中定义的信息。它的属性和描述如表9.19所示：</p>\n<p>表9.19　<code>&lt;fmt:message&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">key</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">资源配置文件的&ldquo;键&rdquo;指定</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">bundle</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">若使用&lt;fmt:setBundle&gt;保存了资源配置文件，该属性就可以从保存的资源配置文件中进行查找</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">将显示信息保存为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"55\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"513\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例：</p>\n<pre><code>&lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;applicationBundle&quot;/&gt;\n&lt;fmt:bundle basename=&quot;applicationAllMessage&quot;&gt;\n         &lt;fmt:message key=&quot;userName&quot; /&gt;\n         &lt;p&gt;\n         &lt;fmt:message key=&quot;passWord&quot; bundle=&quot;${applicationBundle}&quot; /&gt;\n&lt;/fmt:bundle&gt;\n</code></pre><p>该示例使用了两种资源配置文件的绑定的做法，“ applicationMessage ”资源配置文件利用<code>&lt;fmt:setBundle&gt;</code>标签被赋于了变量“ applicationBundle ”，而作为<code>&lt;fmt:bundle&gt;</code>标签定义的“ applicationAllMessage ”资源配置文件作用于其标签体内的显示。</p>\n<p>第一个<code>&lt;fmt:message&gt;</code>标签将使用“ applicationAllMessage ”资源配置文件中“键”为“ userName ”的信息显示。<br>第二个<code>&lt;fmt:message&gt;</code>标签虽然被定义在<code>&lt;fmt:bundle&gt;</code>标签体内，但是它使用了bundle属性，因此将指定之前由<code>&lt;fmt:setBundle&gt;</code>标签保存的“ applicationMessage ”资源配置文件，该“键”为“ passWord ”的信息显示。</p>\n<h4 id=\"9-5-4-用于参数传递的-lt-fmt-param-gt-标签\"><a href=\"#9-5-4-用于参数传递的-lt-fmt-param-gt-标签\" class=\"headerlink\" title=\"9.5.4  用于参数传递的&lt;fmt:param&gt;标签\"></a>9.5.4  用于参数传递的<code>&lt;fmt:param&gt;</code>标签</h4><p><code>&lt;fmt:param&gt;</code>标签应该位于<code>&lt;fmt:message&gt;</code>标签内，将为该消息标签提供参数值。它只有一个属性value。<br><code>&lt;fmt:param&gt;</code>标签有两种使用版本，一种是直接将参数值写在value属性中，另一种是将参数值写在标签体内。</p>\n<p>####9.5.6  用于为请求设置字符编码的<code>&lt;fmt:requestEncoding&gt;</code>标签<br><code>&lt;fmt:requestEncoding&gt;</code>标签用于为请求设置字符编码。它只有一个属性value，在该属性中可以定义字符编码。</p>\n<p>####9.5.7  用于设定时区的<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签<br>这两组标签都用于设定一个时区。唯一不同的是<code>&lt;fmt:timeZone&gt;</code>标签将使得在其标签体内的工作可以使用该时区设置，<code>&lt;fmt:setBundle&gt;</code>标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行。它们的属性和描述如表9.20所示：</p>\n<p>表9.20　<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">时区的设置</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">&lt;fmt:setTimeZone&gt;独有的属性，用于保存时区为一个变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"53\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"312\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<h4 id=\"9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签\"><a href=\"#9-5-8-用于格式化数字的-lt-fmt-formatNumber-gt-标签\" class=\"headerlink\" title=\"9.5.8  用于格式化数字的&lt;fmt:formatNumber&gt;标签\"></a>9.5.8  用于格式化数字的<code>&lt;fmt:formatNumber&gt;</code>标签</h4><p><code>&lt;fmt: formatNumber &gt;</code> 标签用于格式化数字。它的属性和描述如表9.21所示：</p>\n<p>表9.21　<code>&lt;fmt:formatNumber&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化的数字，该数值可以是String类型或java.lang.Number类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">maxIntegerDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最大值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">minIntegerDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最小值</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">maxFractionDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最大值，带小数</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"104\"><br>                                <p align=\"left\">minFractionDigits</p><br>                                </td><br>                                <td width=\"384\"><br>                                <p align=\"left\">指定格式化结果的最小值，带小数</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:formatNumber&gt;</code>标签实际是对应java.util.NumberFormat类，type属性的可能值包括currency（货币）、number（数字）和percent（百分比）。</p>\n<p>下面看一个示例。</p>\n<pre><code>&lt;fmt:formatNumber value=&quot;1000.888&quot; type=&quot;currency&quot; var=&quot;money&quot;/&gt;\n</code></pre><p>该结果将被保存在“ money ”变量中，将根据Locale环境显示当地的货币格式。</p>\n<h4 id=\"9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签\"><a href=\"#9-5-9-用于解析数字的-lt-fmt-parseNumber-gt-标签\" class=\"headerlink\" title=\"9.5.9  用于解析数字的&lt;fmt:parseNumber&gt;标签\"></a>9.5.9  用于解析数字的<code>&lt;fmt:parseNumber&gt;</code>标签</h4><p><code>&lt;fmt:parseNumber&gt;</code>标签用于解析一个数字，并将结果作为java.lang.Number类的实例返回。<code>&lt;fmt:parseNumber&gt;</code>标签看起来和<code>&lt;fmt:formatNumber&gt;</code>标签的作用正好相反。它的属性和描述如表9.22所示：</p>\n<p>表9.22　<code>&lt;fmt:parseNumber&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">结果保存变量，类型为java.lang.Number</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">parseLocale</p><br>                                </td><br>                                <td width=\"463\"><br>                                <p align=\"left\">以本地化的形式来解析字符串，该属性的内容应为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;fmt:parseNumber value=&quot;15%&quot; type=&quot;percent&quot; var=&quot;num&quot;/&gt;\n</code></pre><p>解析之后的结果为“ 0.15 ”。</p>\n<p>####9.5.10  用于格式化日期的<code>&lt;fmt:formatDate&gt;</code>标签<br><code>&lt;fmt:formatDate&gt;</code>标签用于格式化日期。它的属性和描述如表9.23所示：</p>\n<p>表9.23　<code>&lt;fmt:formatDate&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化的日期，该属性的内容应该是java.util.Date类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">结果保存变量</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p align=\"left\">timeZone</p><br>                                </td><br>                                <td width=\"343\"><br>                                <p align=\"left\">指定格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:formatDate&gt;</code>标签与<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签的关系密切。若没有指定 timeZone属性，也可以通过<code>&lt;fmt:timeZone&gt;、&lt;fmt:setTimeZone&gt;</code>两组标签设定的时区来格式化最后的结果。</p>\n<h4 id=\"9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签\"><a href=\"#9-5-11-用于解析日期的-lt-fmt-parseDate-gt-标签\" class=\"headerlink\" title=\"9.5.11  用于解析日期的&lt;fmt:parseDate&gt;标签\"></a>9.5.11  用于解析日期的<code>&lt;fmt:parseDate&gt;</code>标签</h4><p><code>&lt;fmt:parseDate&gt;</code>标签用于解析一个日期，并将结果作为java.lang.Date类型的实例返回。<code>&lt;fmt:parseDate&gt;</code>标签看起来和<code>&lt;fmt:formatDate&gt;</code>标签的作用正好相反。它的属性和描述如表9.24所示：</p>\n<p>表9.24　<code>&lt;fmt:parseDate&gt;</code>标签属性和说明</p>\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">属性</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">value</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">将被解析的字符串</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">type</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">解析格式化的类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">pattern</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">解析格式化模式</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">var</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">结果保存变量，类型为java.lang.Date</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">scope</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">变量的作用范围</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">parseLocale</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">以本地化的形式来解析字符串，该属性的内容为String或java.util.Locale类型的实例</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"72\"><br>                                <p align=\"left\">timeZone</p><br>                                </td><br>                                <td width=\"451\"><br>                                <p align=\"left\">指定解析格式化日期的时区</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p><code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签都实现解析字符串为一个具体对象实例的工作，因此，这两组解析标签对var属性的字符串参数要求非常严格。就JSP页面的表示层前段来说，处理这种解析本不属于份内之事，因此<code>&lt;fmt:parseNumber&gt;</code>和<code>&lt;fmt:parseDate&gt;</code>两组标签应该尽量少用，替代工作的地方应该在服务器端表示层的后段，比如在Servlet中。</p>\n<p> <code>&lt;sql:&gt;</code>标签 </p>\n<p>###9.6  Database access 标签库</p>\n<p>Database access标签库中的标签用来提供在JSP页面中可以与数据库进行交互的功能，虽然它的存在对于早期纯JSP开发的应用以及小型的开发有着意义重大的贡献，但是对于MVC模型来说，它却是违反规范的。因为与数据库交互的工作本身就属于业务逻辑层的工作，所以不应该在JSP页面中出现，而是应该在模型层中进行。</p>\n<p>对于Database access标签库本书不作重点介绍，只给出几个简单示例让读者略微了解它们的功能。</p>\n<p>Database access标签库有以下6组标签来进行工作：<code>&lt;sql:setDataSource&gt;、&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:transaction&gt;、&lt;sql:setDataSource&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;</code>。</p>\n<p>####9.6.1 用于设置数据源的 <code>&lt;sql:setDataSource&gt;</code> 标签<br><code>&lt;sql:setDataSource&gt;</code>标签用于设置数据源，下面看一个示例：</p>\n<pre><code>&lt;sql:setDataSource\n         var=&quot;dataSrc&quot;\n         url=&quot;jdbc:postgresql://localhost:5432/myDB&quot;\n         driver=&quot;org.postgresql.Driver&quot;\n         user=&quot;admin&quot;\n         password=&quot;1111&quot;/&gt;\n</code></pre><p>该示例定义一个数据源并保存在“ dataSrc ”变量内。</p>\n<p>####9.6.2 用于查询的 <code>&lt;sql:query&gt;</code>标签</p>\n<p><code>&lt;sql:query&gt;</code>标签用于查询数据库，它标签体内可以是一句查询SQL。下面看一个示例：</p>\n<pre><code>&lt;sql:query var=&quot;queryResults&quot; dataSource=&quot;${dataSrc}&quot;&gt;\n      select * from table1\n&lt;/sql:query&gt;\n</code></pre><p>该示例将返回查询的结果到变量“ queryResults ”中，保存的结果是javax.servlet.jsp.jstl.sql.Result类型的实例。要取得结果集中的数据可以使用<code>&lt;c:forEach&gt;</code>循环来进行。下面看一个示例。</p>\n<pre><code>&lt;c:forEach var=&quot;row&quot; items=&quot;${queryResults.rows}&quot;&gt;\n      &lt;tr&gt;\n               &lt;td&gt;${row.userName}&lt;/td&gt;\n                &lt;td&gt;${row.passWord}&lt;/td&gt;\n      &lt;/tr&gt;\n&lt;/c:forEach&gt;\n</code></pre><p>“ rows ”是javax.servlet.jsp.jstl.sql.Result实例的变量属性之一，用来表示数据库表中的“列”集合，循环时，通过“ ${row.XXX} ”表达式可以取得每一列的数据，“ XXX ”是表中的列名。</p>\n<p>####9.6.3 用于更新的 <code>&lt;sql:update&gt;</code> 标签<br><code>&lt;sql:update&gt;</code>标签用于更新数据库，它的标签体内可以是一句更新的SQL语句。其使用和<code>&lt;sql:query&gt;</code>标签没有什么不同。</p>\n<p>####9.6.4 用于事务处理的<code>&lt;sql:transaction&gt;</code>标签<br><code>&lt;sql:transaction&gt;</code>标签用于数据库的事务处理，在该标签体内可以使用<code>&lt;sql:update&gt;</code>标签和<code>&lt;sql:query&gt;</code>标签，而<code>&lt;sql:transaction&gt;</code>标签的事务管理将作用于它们之上。<br><code>&lt;sql:transaction&gt;</code>标签对于事务处理定义了read_committed、read_uncommitted、repeatable_read、serializable4个隔离级别。</p>\n<p>####9.6.5 用于事务处理的<code>&lt;sql:param&gt; 、 &lt;sql:dateParam&gt;</code> 标签<br>这两个标签用于向SQL语句提供参数，就好像程序中预处理SQL的“ ? ”一样。<code>&lt;sql:param&gt;</code>标签传递除java.util.Date类型以外的所有相融参数，<code>&lt;sql:dateParam&gt;</code>标签则指定必须传递java.util.Date类型的参数。</p>\n<p>###<code>&lt;fn:&gt;</code> 标签 </p>\n<p>###9.7 Functions 标签库<br>       称呼Functions标签库为标签库，倒不如称呼其为函数库来得更容易理解些。因为Functions标签库并没有提供传统的标签来为JSP页面的工作服务，而是被用于EL表达式语句中。在JSP2.0规范下出现的Functions标签库为EL表达式语句提供了许多更为有用的功能。Functions标签库分为两大类，共16个函数。</p>\n<pre><code>长度函数：fn:length\n字符串处理函数：fn:contains、fn:containsIgnoreCase、fn:endsWith、fn:escapeXml、fn:indexOf、fn:join、fn:replace、fn:split、fn:startsWith、fn:substring、fn:substringAfter、fn:substringBefore、fn:toLowerCase、fn:toUpperCase、fn:trim\n</code></pre><p>以下是各个函数的用途和属性以及简单示例。</p>\n<p>####9.7.1 长度函数 fn:length 函数<br>       长度函数fn:length的出现有重要的意义。在JSTL1.0中，有一个功能被忽略了，那就是对集合的长度取值。虽然java.util.Collection接口定义了size方法，但是该方法不是一个标准的JavaBean属性方法（没有get,set方法），因此，无法通过EL表达式“ ${collection.size} ”来轻松取得。</p>\n<p>fn:length函数正是为了解决这个问题而被设计出来的。它的参数为input，将计算通过该属性传入的对象长度。该对象应该为集合类型或String类型。其返回结果是一个int类型的值。下面看一个示例。</p>\n<pre><code>&lt;%ArrayList arrayList1 = new ArrayList();\n                            arrayList1.add(&quot;aa&quot;);\n                            arrayList1.add(&quot;bb&quot;);\n                            arrayList1.add(&quot;cc&quot;);\n\n%&gt;\n&lt;%request.getSession().setAttribute(&quot;arrayList1&quot;, arrayList1);%&gt;\n${fn:length(sessionScope.arrayList1)}\n</code></pre><p>假设一个ArrayList类型的实例“ arrayList1 ”，并为其添加三个字符串对象，使用fn:length函数后就可以取得返回结果为“ 3 ”。</p>\n<p>####9.7.2 判断函数 fn:contains 函数<br>       fn:contains函数用来判断源字符串是否包含子字符串。它包括string和substring两个参数，它们都是String类型，分布表示源字符串和子字符串。其返回结果为一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:contains(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;\n${fn:contains(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.3 fn:containsIgnoreCase函数<br>      fn:containsIgnoreCase函数与fn:contains函数的功能差不多，唯一的区别是fn:containsIgnoreCase函数对于子字符串的包含比较将忽略大小写。它与fn:contains函数相同，包括string和substring两个参数，并返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;a&quot;)}&lt;br&gt;\n${fn:containsIgnoreCase(&quot;ABC&quot;, &quot;A&quot;)}&lt;br&gt;\n</code></pre><p>前者和后者都会返回“ true ”。</p>\n<p>####9.7.4 词头判断函数 fn:startsWith 函数<br>       fn:startsWith函数用来判断源字符串是否符合一连串的特定词头。它除了包含一个string参数外，还包含一个subffx参数，表示词头字符串，同样是String类型。该函数返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:startsWith (&quot;ABC&quot;, &quot;ab&quot;)}&lt;br&gt;\n${fn:startsWith (&quot;ABC&quot;, &quot;AB&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.5 词尾判断函数 fn:endsWith 函数<br>       fn:endsWith函数用来判断源字符串是否符合一连串的特定词尾。它与fn:startsWith函数相同，包括string和subffx两个参数，并返回一个boolean类型的值。下面看一个示例。</p>\n<pre><code>${fn:endsWith(&quot;ABC&quot;, &quot;bc&quot;)}&lt;br&gt;\n${fn:endsWith(&quot;ABC&quot;, &quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>前者返回“ false ”，后者返回“ true ”。</p>\n<p>####9.7.6 字符实体转换函数 fn:escapeXml 函数<br>fn:escapeXml函数用于将所有特殊字符转化为字符实体码。它只包含一个string参数，返回一个String类型的值。</p>\n<p>####9.7.8 字符匹配函数 fn:indexOf 函数<br>       fn:indexOf函数用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括string和substring两个参数，返回结果为int类型。下面看一个示例。</p>\n<pre><code>${fn:indexOf(&quot;ABCD&quot;,&quot;aBC&quot;)}&lt;br&gt;\n${fn:indexOf(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>前者由于没有匹配成功，所以返回-1，后者匹配成功将返回位置的下标，为1。</p>\n<p>####9.7.9 分隔符函数 fn:join 函数<br>       fn:join函数允许为一个字符串数组中的每一个字符串加上分隔符，并连接起来。它的参数、返回结果和描述如表9.25所示：</p>\n<p>表9.25　fn:join函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"350\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>array</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>字符串数组。其类型必须为String[]类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>separator</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<pre><code>&lt;% String[] stringArray = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; %&gt;\n&lt;%request.getSession().setAttribute(&quot;stringArray&quot;, stringArray);%&gt;\n${fn:join(sessionScope.stringArray,&quot;;&quot;)}&lt;br&gt;\n</code></pre><p>定义数组并放置到Session中，然后通过Session得到该字符串数组，使用fn:join函数并传入分隔符“ ; ”，得到的结果为“ a;b;c ”。</p>\n<p>####9.7.10 替换函数 fn:replace 函数<br>       fn:replace函数允许为源字符串做替换的工作。它的参数、返回结果和描述如表9.26所示：</p>\n<p>表9.26　fn:replace函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>inputString</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>beforeSubstring</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>指定被替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>afterSubstring</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>指定替换字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"105\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"249\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:replace(“ABC”,”A”,”B”)}<br></p>\n<p>将“ ABC ”字符串替换为“ BBC ”，在“ ABC ”字符串中用“ B ”替换了“ A ”。</p>\n<p>####9.7.11 分隔符转换数组函数 fn:split 函数<br>fn:split函数用于将一组由分隔符分隔的字符串转换成字符串数组。它的参数、返回结果和描述如表9.27所示：</p>\n<p>表9.27　fn:split函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"281\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>string</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>delimiters</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>指定分隔符。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"65\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"216\"><br>                                <p>返回一个String[]类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:split(“A,B,C”,”,”)}<br></p>\n<p>将“ A,B,C ”字符串转换为数组{A,B,C}。</p>\n<p>####9.7.12 字符串截取函数 fn:substring 函数<br>fn:substring函数用于截取字符串。它的参数、返回结果和描述如表9.28所示：</p>\n<p>表9.28　fn:substring函数</p>\n<table cellspacing=\"0\" cellpadding=\"0\" width=\"353\" border=\"1\"><br>                        <tbody><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>参数</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>描述</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>string</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>源字符串。其类型必须为String类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>beginIndex</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>指定起始下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>endIndex</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>指定结束下标（值从0开始）。其类型必须为int类型</p><br>                                </td><br>                            </tr><br>                            <tr><br>                                <td width=\"68\"><br>                                <p>返回结果</p><br>                                </td><br>                                <td width=\"285\"><br>                                <p>返回一个String类型的值</p><br>                                </td><br>                            </tr><br>                        </tbody><br>                    </table>\n\n\n<p>下面看一个示例。</p>\n<p>${fn:substring(“ABC”,”1”,”2”)}<br></p>\n<p>截取结果为“ B ”。</p>\n<p>####9.7.14 起始到定位截取字符串函数 fn:substringBefore 函数<br>fn:substringBefore函数允许截取源字符从开始到某个字符串。它的参数和fn:substringAfter函数相同，不同的是substring表示的是结束字符串。下面看一个示例。</p>\n<pre><code>${fn:substringBefore(&quot;ABCD&quot;,&quot;BC&quot;)}&lt;br&gt;\n</code></pre><p>截取的结果为“ A ”。</p>\n<p>####9.7.15 小写转换函数 fn:toLowerCase 函数<br>fn:toLowerCase函数允许将源字符串中的字符全部转换成小写字符。它只有一个表示源字符串的参数string，函数返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:toLowerCase(&quot;ABCD&quot;)}&lt;br&gt;\n</code></pre><p>转换的结果为“ abcd ”。</p>\n<p>####9.7.16大写转换函数 fn:toUpperCase 函数<br>fn:toUpperCase函数允许将源字符串中的字符全部转换成大写字符。它与fn:toLowerCase函数相同，也只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:toUpperCase(&quot;abcd&quot;)}&lt;br&gt;\n</code></pre><p>转换的结果为“ ABCD ”。</p>\n<p>####9.7.17空格删除函数 fn:trim 函数<br>fn:trim函数将删除源字符串中结尾部分的“空格”以产生一个新的字符串。它与fn:toLowerCase函数相同，只有一个String参数，并返回一个String类型的值。下面看一个示例。</p>\n<pre><code>${fn:trim(&quot;AB C &quot;)}D&lt;br&gt;\n</code></pre><p>转换的结果为“ AB CD ”，注意，它将只删除词尾的空格而不是全部，因此“ B ”和“ C ”之间仍然留有一个空格。</p>\n<p>参考文档<a href=\"http://www.javawind.net/help/html/jstl_el.htm\">http://www.javawind.net/help/html/jstl_el.htm</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cirrmop0q0000v8fy2eqmv8ua","category_id":"cirrmop110003v8fyfen7fg01","_id":"cirrmop1c000av8fyjosam404"},{"post_id":"cirrmop0v0001v8fym4ihcy5f","category_id":"cirrmop190008v8fy43ecng2d","_id":"cirrmop1l000gv8fylgw8ihhi"},{"post_id":"cirrmop120004v8fy0439sibq","category_id":"cirrmop190008v8fy43ecng2d","_id":"cirrmop1o000lv8fyhkef341g"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop1r000qv8fyjgek1irf"},{"post_id":"cirrmop140005v8fy8srg0wy9","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop1u000tv8fypmf9ztoz"},{"post_id":"cirrmop1n000kv8fyoldvk0hl","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop1w000yv8fy5w508g8n"},{"post_id":"cirrmop1p000ov8fyyd1y16fa","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop1z0011v8fy5zan9dfv"},{"post_id":"cirrmop180007v8fyhehnrqkk","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop210015v8fy970a451e"},{"post_id":"cirrmop1a0009v8fyj45inxb6","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop230017v8fyo55cuj6v"},{"post_id":"cirrmop1w000zv8fyfg2m1tdq","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop26001bv8fy9yqx162q"},{"post_id":"cirrmop1z0013v8fy0ifujnzz","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop29001ev8fyucutxfyf"},{"post_id":"cirrmop1d000bv8fy49e7yv2x","category_id":"cirrmop1z0012v8fyckvri337","_id":"cirrmop2c001jv8fyct4rfdra"},{"post_id":"cirrmop1i000ev8fy0vwvvldj","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop2e001mv8fydw9hokx8"},{"post_id":"cirrmop1k000fv8fy0ybvkfo6","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop2m001sv8fy7jlkg09j"},{"post_id":"cirrmop1s000rv8fyy0gon43l","category_id":"cirrmop2i001pv8fys33xgs51","_id":"cirrmop2t001yv8fy54utourx"},{"post_id":"cirrmop1u000wv8fycxbrmp6j","category_id":"cirrmop2i001pv8fys33xgs51","_id":"cirrmop2y0024v8fy2gipi8qx"},{"post_id":"cirrmop2s001xv8fyxd3gnqsx","category_id":"cirrmop110003v8fyfen7fg01","_id":"cirrmop300028v8fypsuwetpl"},{"post_id":"cirrmop210016v8fyce2wtlyp","category_id":"cirrmop2u001zv8fyxpeq13kr","_id":"cirrmop34002cv8fyum7f0s89"},{"post_id":"cirrmop2z0027v8fy0u8ss44o","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop39002gv8fyg3gnnvlw"},{"post_id":"cirrmop230018v8fyye1sv9ho","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3d002iv8fye1m0z8ef"},{"post_id":"cirrmop31002bv8fyx6tvkpj2","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3f002lv8fyvonmur0s"},{"post_id":"cirrmop36002ev8fykmyiunl6","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3h002pv8fyiycgt46p"},{"post_id":"cirrmop39002hv8fyv3k6bm7s","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3j002tv8fy49gdtqkk"},{"post_id":"cirrmop26001dv8fy9jfrpk29","category_id":"cirrmop35002dv8fytoin2l73","_id":"cirrmop3l002xv8fy4m9nzobt"},{"post_id":"cirrmop3e002jv8fy1mvjaf6r","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3o0031v8fyk2wo1zpi"},{"post_id":"cirrmop3g002nv8fycnx92dm2","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3r0035v8fyu1niup9o"},{"post_id":"cirrmop2a001gv8fyaintxjm5","category_id":"cirrmop3f002kv8fyigd6lmb0","_id":"cirrmop3s0038v8fyzsj61jhe"},{"post_id":"cirrmop3h002qv8fye3fxp4vs","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop3u003bv8fy17p3wp1e"},{"post_id":"cirrmop3k002vv8fyz80wsc8c","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop3v003ev8fy8qinh6w9"},{"post_id":"cirrmop2d001lv8fyy7yt9phy","category_id":"cirrmop35002dv8fytoin2l73","_id":"cirrmop3y003hv8fyzvhue467"},{"post_id":"cirrmop3m002yv8fyfwibvobk","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop40003lv8fyfbfpdnpj"},{"post_id":"cirrmop3o0033v8fylsi03g9a","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4e003pv8fy693eg2vu"},{"post_id":"cirrmop2f001ov8fypjpz83lp","category_id":"cirrmop3o002zv8fy4t1fi8si","_id":"cirrmop4i003tv8fyjmymcgcp"},{"post_id":"cirrmop3r0036v8fyqhzn3qra","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4k003xv8fy5pku1hh9"},{"post_id":"cirrmop3t003av8fyfh6hn5ye","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4l0040v8fyrdzo0xvg"},{"post_id":"cirrmop2k001rv8fy0q07097w","category_id":"cirrmop35002dv8fytoin2l73","_id":"cirrmop4n0042v8fys506wxr0"},{"post_id":"cirrmop3u003cv8fywtg0i3yp","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4p0045v8fycqozg8n9"},{"post_id":"cirrmop3v003fv8fy3ghlzida","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4r0048v8fyda26s0jp"},{"post_id":"cirrmop2n001tv8fyxq99sjme","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4s004bv8fyfyfcanoc"},{"post_id":"cirrmop3y003jv8fyc6faixfu","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4u004ev8fyr15yj9zr"},{"post_id":"cirrmop41003nv8fyzai65iut","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4x004jv8fyk91kp38n"},{"post_id":"cirrmop2r001wv8fyabnzsajp","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop4y004mv8fyp54x44o0"},{"post_id":"cirrmop4e003rv8fysl0qvk39","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop50004rv8fyyzaj5hwl"},{"post_id":"cirrmop4i003vv8fyxpebnjwd","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop52004tv8fy0blphqf2"},{"post_id":"cirrmop2u0020v8fyrizacemk","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop54004xv8fytj31jqln"},{"post_id":"cirrmop4k003yv8fyygk8l3oe","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop55004zv8fy53pkr42w"},{"post_id":"cirrmop4m0041v8fy7hdkd0vb","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop560053v8fyo5ikqp9s"},{"post_id":"cirrmop2w0023v8fyzi77bh0e","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop590056v8fy8k9qr4ll"},{"post_id":"cirrmop4s004dv8fy3abgab17","category_id":"cirrmop4r0047v8fy994mgc0n","_id":"cirrmop5b005bv8fy5zyngl65"},{"post_id":"cirrmop4n0044v8fybqcbhtxc","category_id":"cirrmop4r0047v8fy994mgc0n","_id":"cirrmop5d005ev8fygzdjj1l0"},{"post_id":"cirrmop4p0046v8fymj21gdzz","category_id":"cirrmop4x004hv8fy9rs6xu2e","_id":"cirrmop5e005iv8fyzkczi2gq"},{"post_id":"cirrmop4z004ov8fy5u54knw8","category_id":"cirrmop1l000hv8fyd73cizc3","_id":"cirrmop5g005lv8fywvoa8ag6"},{"post_id":"cirrmop4r0049v8fy0kgkomhl","category_id":"cirrmop4x004hv8fy9rs6xu2e","_id":"cirrmop5h005nv8fyb4j5dh8y"},{"post_id":"cirrmop4v004gv8fyxfrhn61a","category_id":"cirrmop54004vv8fycsh13pus","_id":"cirrmop5n005sv8fy8qo6qxsm"},{"post_id":"cirrmop4x004lv8fytma27g30","category_id":"cirrmop560051v8fyhs6q5ewk","_id":"cirrmop5q005vv8fyyr0czrsn"},{"post_id":"cirrmop51004sv8fycp8hzxs2","category_id":"cirrmop5b005av8fyzh2ipftr","_id":"cirrmop5t0060v8fyjglu11ah"},{"post_id":"cirrmop52004uv8fykkaj3nv1","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop5u0063v8fysnijd2cp"},{"post_id":"cirrmop5i005pv8fy7wbgi7yf","category_id":"cirrmop3f002kv8fyigd6lmb0","_id":"cirrmop5x0068v8fy8c6vics2"},{"post_id":"cirrmop5o005tv8fyr4xq7jts","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop5z006bv8fyfjyrg72z"},{"post_id":"cirrmop54004yv8fyyu4yqaj1","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop61006gv8fyl0n697mi"},{"post_id":"cirrmop550050v8fy7nw5clo1","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop62006jv8fy7enfmm9e"},{"post_id":"cirrmop570054v8fyaoehwp2h","category_id":"cirrmop5x0066v8fyxc4d3nk2","_id":"cirrmop65006ov8fypqc37js9"},{"post_id":"cirrmop5a0057v8fye4h6zlt3","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop69006rv8fypa8cao9e"},{"post_id":"cirrmop5c005cv8fyq0mc639g","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop6c006yv8fy3ickz01d"},{"post_id":"cirrmop67006qv8fynd80xv1y","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop6e0073v8fy0xrus217"},{"post_id":"cirrmop5d005fv8fyulqzoj31","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop6g0076v8fy6rcqf93e"},{"post_id":"cirrmop6b006xv8fyvlftxjid","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop6j007bv8fysel6hl6b"},{"post_id":"cirrmop5f005jv8fydwh5rtro","category_id":"cirrmop5g005kv8fynlvhlgzs","_id":"cirrmop6k007ev8fyhzr1j4f0"},{"post_id":"cirrmop5g005mv8fy0y4omzdk","category_id":"cirrmop6g0078v8fyssv6ymcr","_id":"cirrmop6n007jv8fyr4meogt1"},{"post_id":"cirrmop6j007dv8fytg1se3ac","category_id":"cirrmop2y0025v8fymbkyh5u0","_id":"cirrmop6p007nv8fyzler3aix"},{"post_id":"cirrmop6l007hv8fybctoipwp","category_id":"cirrmop2u001zv8fyxpeq13kr","_id":"cirrmop6q007qv8fyj3zuc27o"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","category_id":"cirrmop560051v8fyhs6q5ewk","_id":"cirrmop6s007vv8fyqthw7ads"},{"post_id":"cirrmop5q005xv8fypyyi40s3","category_id":"cirrmop6k007fv8fy76gkmx6p","_id":"cirrmop6u007yv8fykojhylhy"},{"post_id":"cirrmop5t0061v8fyqq294hgh","category_id":"cirrmop6k007fv8fy76gkmx6p","_id":"cirrmop6w0083v8fys295sing"},{"post_id":"cirrmop6q007sv8fyz4jijyce","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop6x0085v8fysdworpim"},{"post_id":"cirrmop6s007xv8fyebmufpb4","category_id":"cirrmop1p000mv8fynzehl4mb","_id":"cirrmop6z0088v8fyi0kq0wrq"},{"post_id":"cirrmop5v0065v8fy21pri61n","category_id":"cirrmop6k007fv8fy76gkmx6p","_id":"cirrmop70008cv8fyz92lfsj8"},{"post_id":"cirrmop6u0080v8fyxu8gz67l","category_id":"cirrmop6g0078v8fyssv6ymcr","_id":"cirrmop72008gv8fyn199l38f"},{"post_id":"cirrmop5x0069v8fyse368f4w","category_id":"cirrmop6k007fv8fy76gkmx6p","_id":"cirrmop73008kv8fyhk8xz1ap"},{"post_id":"cirrmop6x0086v8fym70ezwgu","category_id":"cirrmop560051v8fyhs6q5ewk","_id":"cirrmop75008nv8fyx0cph3oj"},{"post_id":"cirrmop6z008av8fyihmw6sam","category_id":"cirrmop35002dv8fytoin2l73","_id":"cirrmop76008qv8fymvrg8a6k"},{"post_id":"cirrmop5z006cv8fywvgf5w4z","category_id":"cirrmop6y0087v8fyx9b0652b","_id":"cirrmop78008uv8fyqv6043sg"},{"post_id":"cirrmop61006hv8fykw0v6hrx","category_id":"cirrmop6y0087v8fyx9b0652b","_id":"cirrmop7b008yv8fyra6218df"},{"post_id":"cirrmop62006kv8fyyfnsd87t","category_id":"cirrmop74008mv8fyf4c3r092","_id":"cirrmop7d0091v8fyzbb1n1w2"},{"post_id":"cirrmop76008sv8fybyemtels","category_id":"cirrmop74008mv8fyf4c3r092","_id":"cirrmop7e0094v8fyth2inwjp"},{"post_id":"cirrmop79008wv8fy0wup01we","category_id":"cirrmop6g0078v8fyssv6ymcr","_id":"cirrmop7h0097v8fyqeuxc5kg"},{"post_id":"cirrmop65006pv8fy45jh7jjp","category_id":"cirrmop6y0087v8fyx9b0652b","_id":"cirrmop7j0099v8fypostzche"},{"post_id":"cirrmop69006vv8fy9klufdlb","category_id":"cirrmop74008mv8fyf4c3r092","_id":"cirrmop7k009dv8fyo6v7bf44"},{"post_id":"cirrmop6d0072v8fyh4uokgp9","category_id":"cirrmop7g0096v8fyb5klrpbg","_id":"cirrmop7n009kv8fysh8e2qf8"},{"post_id":"cirrmop7l009fv8fyujnjkdk0","category_id":"cirrmop74008mv8fyf4c3r092","_id":"cirrmop7o009mv8fy5puak9ef"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","category_id":"cirrmop7k009ev8fykjmjp6m9","_id":"cirrmop7o009ov8fyz3cbr0he"},{"post_id":"cirrmop6h007av8fyh52rvnnc","category_id":"cirrmop7k009ev8fykjmjp6m9","_id":"cirrmop7q009rv8fyx0jg9dz2"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","category_id":"cirrmop7p009pv8fydcrgjtpz","_id":"cirrmop7q009uv8fylyxsmcnk"},{"post_id":"cirrmop6p007pv8fy4gvh6m6p","category_id":"cirrmop7q009sv8fyzfierybl","_id":"cirrmop7r00a0v8fyt91cp2oa"},{"post_id":"cirrmop6w0084v8fyuydtjwjo","category_id":"cirrmop7q009wv8fyvw18ey90","_id":"cirrmop7s00a4v8fyd9vu8tky"},{"post_id":"cirrmop70008dv8fyktivah25","category_id":"cirrmop7r00a1v8fy60d48h3t","_id":"cirrmop7s00a7v8fy3083i0s9"},{"post_id":"cirrmop72008iv8fydxaqx2yl","category_id":"cirrmop7s00a5v8fy6sn292hq","_id":"cirrmop7t00abv8fy65xmjt2a"},{"post_id":"cirrmop73008lv8fyb05snz15","category_id":"cirrmop7r00a1v8fy60d48h3t","_id":"cirrmop7t00agv8fynrw25ohd"},{"post_id":"cirrmop75008ov8fyfr7p08vo","category_id":"cirrmop7t00acv8fy6fihxmgp","_id":"cirrmop7u00alv8fykeifljoq"},{"post_id":"cirrmop7b008zv8fyakjcsgy5","category_id":"cirrmop7t00ahv8fyvphwk8t6","_id":"cirrmop7v00apv8fyqshm7g57"},{"post_id":"cirrmop7d0092v8fyiet0ynxf","category_id":"cirrmop7u00amv8fyayrl12cm","_id":"cirrmop7w00atv8fyxg1ijoeo"},{"post_id":"cirrmop7e0095v8fy66gdyn0i","category_id":"cirrmop7t00acv8fy6fihxmgp","_id":"cirrmop7y00axv8fy2voedopt"},{"post_id":"cirrmop7h0098v8fyf1dqo17l","category_id":"cirrmop7w00auv8fygjuge77w","_id":"cirrmop7y00b0v8fy7uvef9pv"},{"post_id":"cirrmop7j009bv8fytzdddjwa","category_id":"cirrmop7y00ayv8fyjb2vvp8m","_id":"cirrmop8000b5v8fyx1tms3vz"},{"post_id":"cirrmop7m009iv8fy6d4hhwcc","category_id":"cirrmop7y00b2v8fym0hr5110","_id":"cirrmop8000b7v8fy71utiuyv"},{"post_id":"cirrmopam00mzv8fyu60vjthh","category_id":"cirrmop74008mv8fyf4c3r092","_id":"cirrmopaq00n1v8fy6d2qqnbs"}],"PostTag":[{"post_id":"cirrmop0q0000v8fy2eqmv8ua","tag_id":"cirrmop0z0002v8fy7amxwwoy","_id":"cirrmop1r000pv8fydwq0y13n"},{"post_id":"cirrmop0q0000v8fy2eqmv8ua","tag_id":"cirrmop170006v8fyerxvcneg","_id":"cirrmop1u000sv8fybbjerld3"},{"post_id":"cirrmop0q0000v8fy2eqmv8ua","tag_id":"cirrmop1g000cv8fyjj3cgpun","_id":"cirrmop1w000xv8fyprs18ltd"},{"post_id":"cirrmop0q0000v8fy2eqmv8ua","tag_id":"cirrmop1m000iv8fyghj677xw","_id":"cirrmop1z0010v8fyng9f9j33"},{"post_id":"cirrmop0v0001v8fym4ihcy5f","tag_id":"cirrmop1p000nv8fyoywkk2ti","_id":"cirrmop26001cv8fy8x6l60vx"},{"post_id":"cirrmop0v0001v8fym4ihcy5f","tag_id":"cirrmop1u000vv8fyi8q1jvbc","_id":"cirrmop29001fv8fykf161h2g"},{"post_id":"cirrmop0v0001v8fym4ihcy5f","tag_id":"cirrmop0z0002v8fy7amxwwoy","_id":"cirrmop2c001kv8fyw85vcgdt"},{"post_id":"cirrmop120004v8fy0439sibq","tag_id":"cirrmop25001av8fynnquk426","_id":"cirrmop2e001nv8fyzu52h80d"},{"post_id":"cirrmop140005v8fy8srg0wy9","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop2w0022v8fy4scdpxla"},{"post_id":"cirrmop140005v8fy8srg0wy9","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop2z0026v8fycdbmgu0w"},{"post_id":"cirrmop140005v8fy8srg0wy9","tag_id":"cirrmop2r001vv8fydhk9xjyn","_id":"cirrmop31002av8fydjso8yvp"},{"post_id":"cirrmop180007v8fyhehnrqkk","tag_id":"cirrmop2w0021v8fyfgggb30d","_id":"cirrmop3h002ov8fy2no2r5bk"},{"post_id":"cirrmop180007v8fyhehnrqkk","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop3j002sv8fyukgnqc3u"},{"post_id":"cirrmop180007v8fyhehnrqkk","tag_id":"cirrmop39002fv8fya21es5u1","_id":"cirrmop3l002wv8fyi2gebwwp"},{"post_id":"cirrmop3h002qv8fye3fxp4vs","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop3o0030v8fy6rxop0jv"},{"post_id":"cirrmop3h002qv8fye3fxp4vs","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop3r0034v8fypxbwedsz"},{"post_id":"cirrmop1a0009v8fyj45inxb6","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop3y003iv8fyxg6wqssa"},{"post_id":"cirrmop1a0009v8fyj45inxb6","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop40003mv8fylm6p6xuu"},{"post_id":"cirrmop1a0009v8fyj45inxb6","tag_id":"cirrmop2r001vv8fydhk9xjyn","_id":"cirrmop4e003qv8fy8q3usfk6"},{"post_id":"cirrmop1a0009v8fyj45inxb6","tag_id":"cirrmop3s0039v8fyz22swuy5","_id":"cirrmop4i003uv8fykuqhbm4n"},{"post_id":"cirrmop1d000bv8fy49e7yv2x","tag_id":"cirrmop3x003gv8fymfdqfihy","_id":"cirrmop4s004cv8fyna9nyzwz"},{"post_id":"cirrmop1d000bv8fy49e7yv2x","tag_id":"cirrmop4d003ov8fyk6qoa1f7","_id":"cirrmop4u004fv8fyun5v7sh0"},{"post_id":"cirrmop1d000bv8fy49e7yv2x","tag_id":"cirrmop4k003wv8fy4o6krkz9","_id":"cirrmop4x004kv8fysunmtyzb"},{"post_id":"cirrmop1d000bv8fy49e7yv2x","tag_id":"cirrmop4n0043v8fy6297fj9i","_id":"cirrmop4y004nv8fy8lkkp36z"},{"post_id":"cirrmop1i000ev8fy0vwvvldj","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop590055v8fy9bq8w65c"},{"post_id":"cirrmop1i000ev8fy0vwvvldj","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop5b0058v8fykorfex88"},{"post_id":"cirrmop1i000ev8fy0vwvvldj","tag_id":"cirrmop50004pv8fy2y6u9770","_id":"cirrmop5d005dv8fyeqs25q6y"},{"post_id":"cirrmop1i000ev8fy0vwvvldj","tag_id":"cirrmop54004wv8fy2z2ki842","_id":"cirrmop5e005gv8fyjcg5y2lz"},{"post_id":"cirrmop1k000fv8fy0ybvkfo6","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop5m005rv8fy9dfzdhcj"},{"post_id":"cirrmop1k000fv8fy0ybvkfo6","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop5q005uv8fyock9kmip"},{"post_id":"cirrmop1k000fv8fy0ybvkfo6","tag_id":"cirrmop5e005hv8fyrklufiuq","_id":"cirrmop5t005zv8fy0n2lstsi"},{"post_id":"cirrmop5q005xv8fypyyi40s3","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop5u0062v8fy919n53my"},{"post_id":"cirrmop5t0061v8fyqq294hgh","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop5x0067v8fybqq6wn98"},{"post_id":"cirrmop5v0065v8fy21pri61n","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop5z006av8fy7039ytzl"},{"post_id":"cirrmop5x0069v8fyse368f4w","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop61006fv8fy9dwn5qpe"},{"post_id":"cirrmop5z006cv8fywvgf5w4z","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop62006iv8fyazwivd6t"},{"post_id":"cirrmop61006hv8fykw0v6hrx","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop64006nv8fy3lkrts5p"},{"post_id":"cirrmop65006pv8fy45jh7jjp","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop69006sv8fyyz65jgi7"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop6b006wv8fye75ybca5"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop6c006zv8fyl9rskznj"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","tag_id":"cirrmop5u0064v8fykryijakp","_id":"cirrmop6e0074v8fyjzi6rb6d"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","tag_id":"cirrmop60006dv8fyf4kq6sc8","_id":"cirrmop6g0077v8fyx6duan3k"},{"post_id":"cirrmop1m000jv8fy90cp8cvm","tag_id":"cirrmop64006lv8fybwo3ij60","_id":"cirrmop6j007cv8fyvom79tzi"},{"post_id":"cirrmop1n000kv8fyoldvk0hl","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop6p007ov8fy1ig2f3kn"},{"post_id":"cirrmop1n000kv8fyoldvk0hl","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop6q007rv8fyv82kyin9"},{"post_id":"cirrmop1n000kv8fyoldvk0hl","tag_id":"cirrmop6g0079v8fyejgll159","_id":"cirrmop6s007wv8fyfyx886b5"},{"post_id":"cirrmop1n000kv8fyoldvk0hl","tag_id":"cirrmop6l007gv8fyth66689x","_id":"cirrmop6u007zv8fyifdj128d"},{"post_id":"cirrmop1p000ov8fyyd1y16fa","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop70008bv8fyncw1j6rd"},{"post_id":"cirrmop1p000ov8fyyd1y16fa","tag_id":"cirrmop6r007uv8fyv8h5s7pr","_id":"cirrmop72008fv8fywy57jd4y"},{"post_id":"cirrmop1p000ov8fyyd1y16fa","tag_id":"cirrmop6w0082v8fykzi3sifb","_id":"cirrmop73008jv8fyour9vhnj"},{"post_id":"cirrmop1s000rv8fyy0gon43l","tag_id":"cirrmop6z0089v8fy069q7vgu","_id":"cirrmop76008rv8fydfy0p8t2"},{"post_id":"cirrmop1s000rv8fyy0gon43l","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop79008vv8fy5afk4ffp"},{"post_id":"cirrmop1u000wv8fycxbrmp6j","tag_id":"cirrmop6z0089v8fy069q7vgu","_id":"cirrmop7k009cv8fym5874mqp"},{"post_id":"cirrmop1u000wv8fycxbrmp6j","tag_id":"cirrmop7b008xv8fyf1vugb3q","_id":"cirrmop7m009gv8fydv3uj63w"},{"post_id":"cirrmop1u000wv8fycxbrmp6j","tag_id":"cirrmop7e0093v8fyc0km5gfs","_id":"cirrmop7n009jv8fy5h8jv9cu"},{"post_id":"cirrmop1w000zv8fyfg2m1tdq","tag_id":"cirrmop7j009av8fyt3kxzkqy","_id":"cirrmop7q009vv8fyd0h1e59d"},{"post_id":"cirrmop1w000zv8fyfg2m1tdq","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop7r009xv8fyclpo3lgl"},{"post_id":"cirrmop1w000zv8fyfg2m1tdq","tag_id":"cirrmop7o009nv8fyf5mfvnsl","_id":"cirrmop7r009zv8fyu7gx62kr"},{"post_id":"cirrmop1w000zv8fyfg2m1tdq","tag_id":"cirrmop7p009qv8fyb8vvvj28","_id":"cirrmop7r00a2v8fyj9g2a4i8"},{"post_id":"cirrmop1z0013v8fy0ifujnzz","tag_id":"cirrmop2c001iv8fy19cnzqty","_id":"cirrmop7t00aav8fyguuyq0m1"},{"post_id":"cirrmop1z0013v8fy0ifujnzz","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop7t00adv8fywb3yh71b"},{"post_id":"cirrmop1z0013v8fy0ifujnzz","tag_id":"cirrmop7s00a3v8fy31sj8uyk","_id":"cirrmop7t00afv8fya626i5kw"},{"post_id":"cirrmop1z0013v8fy0ifujnzz","tag_id":"cirrmop7s00a6v8fy7sn48n1a","_id":"cirrmop7t00aiv8fyd6jnu5c4"},{"post_id":"cirrmop210016v8fyce2wtlyp","tag_id":"cirrmop7s00a9v8fyox6vv9yf","_id":"cirrmop7u00akv8fy06t3vkm3"},{"post_id":"cirrmop210016v8fyce2wtlyp","tag_id":"cirrmop7t00aev8fy79tie3n5","_id":"cirrmop7v00anv8fyj7mmwwhs"},{"post_id":"cirrmop230018v8fyye1sv9ho","tag_id":"cirrmop7u00ajv8fyag9pv10r","_id":"cirrmop7w00asv8fyv7apeis3"},{"post_id":"cirrmop230018v8fyye1sv9ho","tag_id":"cirrmop7v00aov8fyrn5swu9a","_id":"cirrmop7x00avv8fy5dk1o2db"},{"post_id":"cirrmop26001dv8fy9jfrpk29","tag_id":"cirrmop7v00arv8fy1l54yu5r","_id":"cirrmop7y00b1v8fyqev2imz5"},{"post_id":"cirrmop26001dv8fy9jfrpk29","tag_id":"cirrmop7x00awv8fyvdl4t32y","_id":"cirrmop7z00b3v8fykvfambad"},{"post_id":"cirrmop2a001gv8fyaintxjm5","tag_id":"cirrmop7y00azv8fy38maln1v","_id":"cirrmop8000bav8fyrgsu5bif"},{"post_id":"cirrmop2a001gv8fyaintxjm5","tag_id":"cirrmop7z00b4v8fydbmfk38z","_id":"cirrmop8000bbv8fyfl2qmplw"},{"post_id":"cirrmop2a001gv8fyaintxjm5","tag_id":"cirrmop8000b6v8fynta2hpku","_id":"cirrmop8100bdv8fyptoizi6v"},{"post_id":"cirrmop2a001gv8fyaintxjm5","tag_id":"cirrmop8000b8v8fyvvlfectx","_id":"cirrmop8100bev8fybfxx7mtc"},{"post_id":"cirrmop2d001lv8fyy7yt9phy","tag_id":"cirrmop8000b9v8fyedms9q40","_id":"cirrmop8100biv8fyg2qzmdaf"},{"post_id":"cirrmop2d001lv8fyy7yt9phy","tag_id":"cirrmop7x00awv8fyvdl4t32y","_id":"cirrmop8100bjv8fy4bpe5q01"},{"post_id":"cirrmop2d001lv8fyy7yt9phy","tag_id":"cirrmop8100bfv8fy3k7nmv60","_id":"cirrmop8200blv8fym0yduknc"},{"post_id":"cirrmop2d001lv8fyy7yt9phy","tag_id":"cirrmop8100bgv8fyq97vw4tb","_id":"cirrmop8200bmv8fyapt0gyhd"},{"post_id":"cirrmop2f001ov8fypjpz83lp","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8300bqv8fyenkxrp08"},{"post_id":"cirrmop2f001ov8fypjpz83lp","tag_id":"cirrmop8100bkv8fywz95wm1q","_id":"cirrmop8300brv8fycwpo5tme"},{"post_id":"cirrmop2f001ov8fypjpz83lp","tag_id":"cirrmop8200bnv8fywtooomph","_id":"cirrmop8300btv8fyizumih88"},{"post_id":"cirrmop2f001ov8fypjpz83lp","tag_id":"cirrmop7x00awv8fyvdl4t32y","_id":"cirrmop8300buv8fyrrff869b"},{"post_id":"cirrmop2k001rv8fy0q07097w","tag_id":"cirrmop8300bpv8fya27atifg","_id":"cirrmop8300bwv8fyif7xq5ar"},{"post_id":"cirrmop2k001rv8fy0q07097w","tag_id":"cirrmop7x00awv8fyvdl4t32y","_id":"cirrmop8300bxv8fydvuf145w"},{"post_id":"cirrmop2n001tv8fyxq99sjme","tag_id":"cirrmop8300bvv8fyxrbhl7r1","_id":"cirrmop8400c1v8fy7cd6xevd"},{"post_id":"cirrmop2n001tv8fyxq99sjme","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8400c2v8fy9cujb02i"},{"post_id":"cirrmop2n001tv8fyxq99sjme","tag_id":"cirrmop8400bzv8fyg7ebbyoc","_id":"cirrmop8500c4v8fysev47zhe"},{"post_id":"cirrmop2r001wv8fyabnzsajp","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8c00c7v8fyduovobf0"},{"post_id":"cirrmop2r001wv8fyabnzsajp","tag_id":"cirrmop8500c3v8fy3dxzg636","_id":"cirrmop8c00c8v8fynx02gk1e"},{"post_id":"cirrmop2r001wv8fyabnzsajp","tag_id":"cirrmop8500c5v8fykt11cpzc","_id":"cirrmop8c00cav8fy15y0ozl8"},{"post_id":"cirrmop2s001xv8fyxd3gnqsx","tag_id":"cirrmop8b00c6v8fykib69ymm","_id":"cirrmop8c00ccv8fyoknpdzs1"},{"post_id":"cirrmop2s001xv8fyxd3gnqsx","tag_id":"cirrmop8c00c9v8fy6epnmnpg","_id":"cirrmop8c00cdv8fyrm3mwt9u"},{"post_id":"cirrmop2u0020v8fyrizacemk","tag_id":"cirrmop8c00cbv8fy18d09xsv","_id":"cirrmop8d00cgv8fyqev5g1w2"},{"post_id":"cirrmop2u0020v8fyrizacemk","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8d00chv8fyn29glah6"},{"post_id":"cirrmop2w0023v8fyzi77bh0e","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8d00ckv8fyliepss9a"},{"post_id":"cirrmop2w0023v8fyzi77bh0e","tag_id":"cirrmop8d00civ8fye983z02v","_id":"cirrmop8d00clv8fyikyjkfus"},{"post_id":"cirrmop2z0027v8fy0u8ss44o","tag_id":"cirrmop8d00cjv8fy81axxswt","_id":"cirrmop8e00cpv8fyotf3e619"},{"post_id":"cirrmop2z0027v8fy0u8ss44o","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8e00cqv8fypee971bj"},{"post_id":"cirrmop2z0027v8fy0u8ss44o","tag_id":"cirrmop8e00cnv8fyjj5d6l4t","_id":"cirrmop8e00csv8fynmxwa5pq"},{"post_id":"cirrmop31002bv8fyx6tvkpj2","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8f00cuv8fyecjt95r1"},{"post_id":"cirrmop31002bv8fyx6tvkpj2","tag_id":"cirrmop7t00aev8fy79tie3n5","_id":"cirrmop8f00cvv8fye5p3wpz0"},{"post_id":"cirrmop36002ev8fykmyiunl6","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8f00czv8fynaco4eb7"},{"post_id":"cirrmop36002ev8fykmyiunl6","tag_id":"cirrmop8f00cwv8fyxvin3niz","_id":"cirrmop8f00d0v8fyhbqsgscg"},{"post_id":"cirrmop36002ev8fykmyiunl6","tag_id":"cirrmop8f00cxv8fy1ziqui1y","_id":"cirrmop8g00d2v8fyngnvxhkd"},{"post_id":"cirrmop39002hv8fyv3k6bm7s","tag_id":"cirrmop8f00cyv8fy3r8ph50c","_id":"cirrmop8g00d4v8fyowh80nwj"},{"post_id":"cirrmop39002hv8fyv3k6bm7s","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8g00d5v8fyj3e71arh"},{"post_id":"cirrmop3e002jv8fy1mvjaf6r","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8g00d8v8fydnw8dub7"},{"post_id":"cirrmop3e002jv8fy1mvjaf6r","tag_id":"cirrmop8g00d6v8fyiq0qschw","_id":"cirrmop8h00d9v8fyh5m993ar"},{"post_id":"cirrmop3g002nv8fycnx92dm2","tag_id":"cirrmop8g00d7v8fy86qejmbp","_id":"cirrmop8h00ddv8fyapfq8qo8"},{"post_id":"cirrmop3g002nv8fycnx92dm2","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8h00dev8fyq6azcc19"},{"post_id":"cirrmop3g002nv8fycnx92dm2","tag_id":"cirrmop8h00dbv8fyldx67prs","_id":"cirrmop8i00dgv8fyk1khjh4h"},{"post_id":"cirrmop3k002vv8fyz80wsc8c","tag_id":"cirrmop8h00dcv8fyfx8jufrn","_id":"cirrmop8i00djv8fyhqkxtzfv"},{"post_id":"cirrmop3k002vv8fyz80wsc8c","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8i00dkv8fyc9et3c2k"},{"post_id":"cirrmop3k002vv8fyz80wsc8c","tag_id":"cirrmop8i00dhv8fy44lpdbsl","_id":"cirrmop8j00dmv8fyihxpj4a7"},{"post_id":"cirrmop3m002yv8fyfwibvobk","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8j00dov8fy2bnciozo"},{"post_id":"cirrmop3m002yv8fyfwibvobk","tag_id":"cirrmop8i00dlv8fybma8049w","_id":"cirrmop8j00dpv8fyhm12mw32"},{"post_id":"cirrmop3o0033v8fylsi03g9a","tag_id":"cirrmop8j00dnv8fyjw5f71o2","_id":"cirrmop8j00dsv8fy74sqfk39"},{"post_id":"cirrmop3o0033v8fylsi03g9a","tag_id":"cirrmop8j00dqv8fyrm87wl8s","_id":"cirrmop8j00dtv8fyw01x9vxs"},{"post_id":"cirrmop3r0036v8fyqhzn3qra","tag_id":"cirrmop8j00drv8fyahar6pts","_id":"cirrmop8k00dxv8fyu3sswx8c"},{"post_id":"cirrmop3r0036v8fyqhzn3qra","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8k00dyv8fy13f7k2tb"},{"post_id":"cirrmop3r0036v8fyqhzn3qra","tag_id":"cirrmop8k00dvv8fy683kuul9","_id":"cirrmop8k00e0v8fyf1kmgean"},{"post_id":"cirrmop3t003av8fyfh6hn5ye","tag_id":"cirrmop8k00dwv8fyk63ro2nk","_id":"cirrmop8k00e1v8fybr8g5ns1"},{"post_id":"cirrmop3u003cv8fywtg0i3yp","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8l00e5v8fyyhg64ksl"},{"post_id":"cirrmop3u003cv8fywtg0i3yp","tag_id":"cirrmop8l00e2v8fyvuo6d88m","_id":"cirrmop8l00e6v8fysz4y4kqg"},{"post_id":"cirrmop3u003cv8fywtg0i3yp","tag_id":"cirrmop8l00e3v8fyl3mqusvl","_id":"cirrmop8l00e8v8fyxnu64f63"},{"post_id":"cirrmop3v003fv8fy3ghlzida","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8m00ebv8fyoop2jn3r"},{"post_id":"cirrmop3v003fv8fy3ghlzida","tag_id":"cirrmop8l00e7v8fyxqx5253w","_id":"cirrmop8m00ecv8fy8gruyn3s"},{"post_id":"cirrmop3v003fv8fy3ghlzida","tag_id":"cirrmop8m00e9v8fye25rmkjo","_id":"cirrmop8m00eev8fyvnx5n4ar"},{"post_id":"cirrmop3y003jv8fyc6faixfu","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8o00eiv8fyo6pxdx26"},{"post_id":"cirrmop3y003jv8fyc6faixfu","tag_id":"cirrmop8m00edv8fypaynhcc8","_id":"cirrmop8o00ejv8fysqbihvtq"},{"post_id":"cirrmop3y003jv8fyc6faixfu","tag_id":"cirrmop7u00ajv8fyag9pv10r","_id":"cirrmop8o00elv8fywcgt2iix"},{"post_id":"cirrmop3y003jv8fyc6faixfu","tag_id":"cirrmop8n00egv8fyhsihwn98","_id":"cirrmop8o00emv8fygb1x40wm"},{"post_id":"cirrmop41003nv8fyzai65iut","tag_id":"cirrmop8n00ehv8fya04m406h","_id":"cirrmop8p00epv8fypoox7npy"},{"post_id":"cirrmop41003nv8fyzai65iut","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8p00eqv8fyv2kqpulz"},{"post_id":"cirrmop41003nv8fyzai65iut","tag_id":"cirrmop8o00env8fywdiijggt","_id":"cirrmop8p00esv8fyizpx2zib"},{"post_id":"cirrmop4e003rv8fysl0qvk39","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8q00euv8fyzea8wsed"},{"post_id":"cirrmop4e003rv8fysl0qvk39","tag_id":"cirrmop8p00erv8fyx3yvt8xf","_id":"cirrmop8q00evv8fyxxkcfsvu"},{"post_id":"cirrmop4i003vv8fyxpebnjwd","tag_id":"cirrmop72008hv8fyfezj0kaw","_id":"cirrmop8r00eyv8fyb0d3azec"},{"post_id":"cirrmop4i003vv8fyxpebnjwd","tag_id":"cirrmop8q00ewv8fyiqctkpi8","_id":"cirrmop8r00ezv8fyr3m6nkxn"},{"post_id":"cirrmop4k003yv8fyygk8l3oe","tag_id":"cirrmop8q00exv8fygqgtkdru","_id":"cirrmop8t00f3v8fymxwh6cc0"},{"post_id":"cirrmop4k003yv8fyygk8l3oe","tag_id":"cirrmop8r00f0v8fydvddepk5","_id":"cirrmop8t00f4v8fynwx4y39s"},{"post_id":"cirrmop4k003yv8fyygk8l3oe","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8t00f6v8fyfalcth8j"},{"post_id":"cirrmop4m0041v8fy7hdkd0vb","tag_id":"cirrmop8s00f2v8fyn6liuhcx","_id":"cirrmop8v00f9v8fy9pc14tpq"},{"post_id":"cirrmop4m0041v8fy7hdkd0vb","tag_id":"cirrmop8c00cev8fyzkox1ai0","_id":"cirrmop8v00fav8fyoxvuehac"},{"post_id":"cirrmop4m0041v8fy7hdkd0vb","tag_id":"cirrmop8t00f7v8fyxudze81m","_id":"cirrmop8v00fcv8fyyowbqee1"},{"post_id":"cirrmop4n0044v8fybqcbhtxc","tag_id":"cirrmop8u00f8v8fyu3xgrjj6","_id":"cirrmop8v00fev8fyxudk0zuh"},{"post_id":"cirrmop4n0044v8fybqcbhtxc","tag_id":"cirrmop8v00fbv8fy8wqw7smj","_id":"cirrmop8v00ffv8fyroc1wepk"},{"post_id":"cirrmop4p0046v8fymj21gdzz","tag_id":"cirrmop8v00fdv8fy2a41heag","_id":"cirrmop8w00fjv8fyptq0hvmm"},{"post_id":"cirrmop4p0046v8fymj21gdzz","tag_id":"cirrmop8v00fgv8fyi49to7ut","_id":"cirrmop8w00fkv8fy4dm3t6wv"},{"post_id":"cirrmop4p0046v8fymj21gdzz","tag_id":"cirrmop8v00fhv8fy6c7n0u8l","_id":"cirrmop8w00fmv8fyczxqwhgv"},{"post_id":"cirrmop4r0049v8fy0kgkomhl","tag_id":"cirrmop8v00fdv8fy2a41heag","_id":"cirrmop8x00fpv8fyhn5y7ewo"},{"post_id":"cirrmop4r0049v8fy0kgkomhl","tag_id":"cirrmop8w00flv8fy8v0qe6g0","_id":"cirrmop8x00fqv8fy3lhyikre"},{"post_id":"cirrmop4r0049v8fy0kgkomhl","tag_id":"cirrmop8w00fnv8fymre7of4m","_id":"cirrmop8x00fsv8fyn8c4zjfl"},{"post_id":"cirrmop4s004dv8fy3abgab17","tag_id":"cirrmop8u00f8v8fyu3xgrjj6","_id":"cirrmop8y00fvv8fy9yhwji1b"},{"post_id":"cirrmop4s004dv8fy3abgab17","tag_id":"cirrmop8x00frv8fymgw27km9","_id":"cirrmop8y00fwv8fyoy0xfuho"},{"post_id":"cirrmop4s004dv8fy3abgab17","tag_id":"cirrmop8x00ftv8fymoxtb8lp","_id":"cirrmop8y00fyv8fym6tqa1uv"},{"post_id":"cirrmop4x004lv8fytma27g30","tag_id":"cirrmop8y00fuv8fyrr6yvby8","_id":"cirrmop8z00g2v8fyvgpl6cjd"},{"post_id":"cirrmop4x004lv8fytma27g30","tag_id":"cirrmop8y00fxv8fyqhx2w1fm","_id":"cirrmop8z00g3v8fyhat3jtt3"},{"post_id":"cirrmop4x004lv8fytma27g30","tag_id":"cirrmop8c00c9v8fy6epnmnpg","_id":"cirrmop8z00g5v8fy67jgvhmk"},{"post_id":"cirrmop4x004lv8fytma27g30","tag_id":"cirrmop8y00g0v8fyt754rap2","_id":"cirrmop8z00g6v8fy2j19lkvt"},{"post_id":"cirrmop4z004ov8fy5u54knw8","tag_id":"cirrmop8z00g1v8fyaacbazp7","_id":"cirrmop9000g8v8fy2qb0vevq"},{"post_id":"cirrmop4z004ov8fy5u54knw8","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop9000g9v8fysw3oyprt"},{"post_id":"cirrmop51004sv8fycp8hzxs2","tag_id":"cirrmop8z00g4v8fyfy5yv9l4","_id":"cirrmop9000gcv8fyxiezho4c"},{"post_id":"cirrmop51004sv8fycp8hzxs2","tag_id":"cirrmop8z00g7v8fyy7aszh5s","_id":"cirrmop9000gdv8fywt6bjbge"},{"post_id":"cirrmop51004sv8fycp8hzxs2","tag_id":"cirrmop8y00g0v8fyt754rap2","_id":"cirrmop9100gfv8fyrig42wmp"},{"post_id":"cirrmop54004yv8fyyu4yqaj1","tag_id":"cirrmop9000gbv8fylmtm5ehr","_id":"cirrmop9100gjv8fyl2kra4jg"},{"post_id":"cirrmop54004yv8fyyu4yqaj1","tag_id":"cirrmop9000gev8fy953tmlb8","_id":"cirrmop9200gkv8fyncsm6l3t"},{"post_id":"cirrmop54004yv8fyyu4yqaj1","tag_id":"cirrmop9100ggv8fyknjp3v91","_id":"cirrmop9200gmv8fy5hj63w6b"},{"post_id":"cirrmop54004yv8fyyu4yqaj1","tag_id":"cirrmop9100ghv8fy8z6lz377","_id":"cirrmop9200gnv8fy2atz7r6u"},{"post_id":"cirrmop550050v8fy7nw5clo1","tag_id":"cirrmop9100ggv8fyknjp3v91","_id":"cirrmop9200gpv8fyr311qubr"},{"post_id":"cirrmop550050v8fy7nw5clo1","tag_id":"cirrmop9200glv8fyjks5wp4n","_id":"cirrmop9200gqv8fyqybb1mik"},{"post_id":"cirrmop570054v8fyaoehwp2h","tag_id":"cirrmop9100ghv8fy8z6lz377","_id":"cirrmop9300gvv8fyxf0gc6xf"},{"post_id":"cirrmop570054v8fyaoehwp2h","tag_id":"cirrmop9200grv8fy9va0gy4b","_id":"cirrmop9400gwv8fygcq9amz5"},{"post_id":"cirrmop570054v8fyaoehwp2h","tag_id":"cirrmop9300gsv8fyybdpmgnb","_id":"cirrmop9400gyv8fy3qr5uv48"},{"post_id":"cirrmop570054v8fyaoehwp2h","tag_id":"cirrmop9300gtv8fy11wkakuh","_id":"cirrmop9400gzv8fyozu0k942"},{"post_id":"cirrmop5a0057v8fye4h6zlt3","tag_id":"cirrmop9300guv8fy6vz5rcwl","_id":"cirrmop9400h1v8fyq8q3ucgv"},{"post_id":"cirrmop5a0057v8fye4h6zlt3","tag_id":"cirrmop9400gxv8fy0qxxsevb","_id":"cirrmop9400h2v8fyfjqa4422"},{"post_id":"cirrmop5c005cv8fyq0mc639g","tag_id":"cirrmop9400h0v8fyfwbg0e2s","_id":"cirrmop9600h6v8fyflrde246"},{"post_id":"cirrmop5c005cv8fyq0mc639g","tag_id":"cirrmop9100ggv8fyknjp3v91","_id":"cirrmop9600h7v8fy5u7dbcb8"},{"post_id":"cirrmop5c005cv8fyq0mc639g","tag_id":"cirrmop9500h4v8fy1rnedl6k","_id":"cirrmop9600h9v8fy54nz85a8"},{"post_id":"cirrmop5d005fv8fyulqzoj31","tag_id":"cirrmop9500h5v8fya5kdmer2","_id":"cirrmop9700hdv8fy8sug0cuz"},{"post_id":"cirrmop5d005fv8fyulqzoj31","tag_id":"cirrmop9600h8v8fyd3pzpb0q","_id":"cirrmop9700hev8fyw4v6abof"},{"post_id":"cirrmop5d005fv8fyulqzoj31","tag_id":"cirrmop9600hav8fy0bnx3stc","_id":"cirrmop9800hgv8fyafsduaj7"},{"post_id":"cirrmop5d005fv8fyulqzoj31","tag_id":"cirrmop9600hbv8fy964ytc86","_id":"cirrmop9800hhv8fycla55xaj"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9500h5v8fya5kdmer2","_id":"cirrmop9900hnv8fyiohfmh02"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9600h8v8fyd3pzpb0q","_id":"cirrmop9900hov8fyv0y7zvni"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9100ghv8fy8z6lz377","_id":"cirrmop9a00hqv8fyeyainyg4"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9800hjv8fy3wk3c99u","_id":"cirrmop9a00hrv8fygzh2robp"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9800hkv8fyytwnddte","_id":"cirrmop9a00htv8fyhfhplq4m"},{"post_id":"cirrmop5f005jv8fydwh5rtro","tag_id":"cirrmop9800hlv8fy6waugi1q","_id":"cirrmop9a00huv8fyywpgidq5"},{"post_id":"cirrmop5i005pv8fy7wbgi7yf","tag_id":"cirrmop7y00azv8fy38maln1v","_id":"cirrmop9a00hwv8fycf5z2sja"},{"post_id":"cirrmop5i005pv8fy7wbgi7yf","tag_id":"cirrmop8y00g0v8fyt754rap2","_id":"cirrmop9a00hxv8fyic687u2z"},{"post_id":"cirrmop5o005tv8fyr4xq7jts","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9b00hzv8fy1co22qek"},{"post_id":"cirrmop5o005tv8fyr4xq7jts","tag_id":"cirrmop9a00hsv8fy0t33mr1j","_id":"cirrmop9b00i0v8fyzjnchzz6"},{"post_id":"cirrmop5o005tv8fyr4xq7jts","tag_id":"cirrmop9a00hvv8fy73nlkbow","_id":"cirrmop9c00i2v8fya5oj6si9"},{"post_id":"cirrmop5o005tv8fyr4xq7jts","tag_id":"cirrmop2k001qv8fy09m8u1nq","_id":"cirrmop9c00i3v8fym0f48226"},{"post_id":"cirrmop62006kv8fyyfnsd87t","tag_id":"cirrmop39002fv8fya21es5u1","_id":"cirrmop9c00i5v8fybjx9f0ct"},{"post_id":"cirrmop62006kv8fyyfnsd87t","tag_id":"cirrmop9b00hyv8fye70i2169","_id":"cirrmop9c00i6v8fycumq6e7k"},{"post_id":"cirrmop67006qv8fynd80xv1y","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9e00i8v8fyumq59gjd"},{"post_id":"cirrmop67006qv8fynd80xv1y","tag_id":"cirrmop9c00i1v8fypyyk2j0c","_id":"cirrmop9e00i9v8fyqbfclpo0"},{"post_id":"cirrmop67006qv8fynd80xv1y","tag_id":"cirrmop9a00hsv8fy0t33mr1j","_id":"cirrmop9e00ibv8fyngw94230"},{"post_id":"cirrmop69006vv8fy9klufdlb","tag_id":"cirrmop39002fv8fya21es5u1","_id":"cirrmop9e00icv8fyglgyu1n8"},{"post_id":"cirrmop69006vv8fy9klufdlb","tag_id":"cirrmop9b00hyv8fye70i2169","_id":"cirrmop9g00iev8fyszi476lq"},{"post_id":"cirrmop6b006xv8fyvlftxjid","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9h00igv8fyh8guxm2o"},{"post_id":"cirrmop6b006xv8fyvlftxjid","tag_id":"cirrmop170006v8fyerxvcneg","_id":"cirrmop9h00ihv8fyh742b8xq"},{"post_id":"cirrmop6b006xv8fyvlftxjid","tag_id":"cirrmop9e00iav8fypk347lz3","_id":"cirrmop9h00ijv8fyzkouxo9y"},{"post_id":"cirrmop6b006xv8fyvlftxjid","tag_id":"cirrmop9f00idv8fyvb6nkbpt","_id":"cirrmop9h00ikv8fyfie3fjl1"},{"post_id":"cirrmop6d0072v8fyh4uokgp9","tag_id":"cirrmop9g00ifv8fywv9fm9xa","_id":"cirrmop9i00imv8fy93s532pi"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","tag_id":"cirrmop9h00iiv8fyem4tjnxx","_id":"cirrmop9k00irv8fycfcwies3"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","tag_id":"cirrmop9h00ilv8fy2p9850as","_id":"cirrmop9k00isv8fylu4ttq4u"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","tag_id":"cirrmop9i00inv8fy62q1t0pf","_id":"cirrmop9k00iuv8fysj1y8rri"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","tag_id":"cirrmop9i00iov8fyvf1l7cur","_id":"cirrmop9k00ivv8fyzt34ry9n"},{"post_id":"cirrmop6f0075v8fy3cutfxbz","tag_id":"cirrmop9j00ipv8fyv98tfh31","_id":"cirrmop9k00ixv8fyjdwp6ycq"},{"post_id":"cirrmop6h007av8fyh52rvnnc","tag_id":"cirrmop9j00iqv8fy97bgesvn","_id":"cirrmop9l00izv8fyy8utdqnd"},{"post_id":"cirrmop6h007av8fyh52rvnnc","tag_id":"cirrmop9k00itv8fysiu4cjt5","_id":"cirrmop9l00j0v8fyqjnt30zu"},{"post_id":"cirrmop6h007av8fyh52rvnnc","tag_id":"cirrmop9k00iwv8fy9vr89w2l","_id":"cirrmop9l00j2v8fy15ur82re"},{"post_id":"cirrmop6j007dv8fytg1se3ac","tag_id":"cirrmop8y00g0v8fyt754rap2","_id":"cirrmop9m00j5v8fyku9wrgh0"},{"post_id":"cirrmop6j007dv8fytg1se3ac","tag_id":"cirrmop9l00j1v8fyd7l6abzn","_id":"cirrmop9m00j6v8fyk0957i60"},{"post_id":"cirrmop6j007dv8fytg1se3ac","tag_id":"cirrmop9l00j3v8fy1eh15oca","_id":"cirrmop9m00j8v8fyopoqbv7g"},{"post_id":"cirrmop6l007hv8fybctoipwp","tag_id":"cirrmop7s00a9v8fyox6vv9yf","_id":"cirrmop9n00jbv8fyuux5zcns"},{"post_id":"cirrmop6l007hv8fybctoipwp","tag_id":"cirrmop9m00j7v8fyifpfhz9d","_id":"cirrmop9n00jcv8fybnpybxjj"},{"post_id":"cirrmop6l007hv8fybctoipwp","tag_id":"cirrmop9n00j9v8fy8s6ux46e","_id":"cirrmop9n00jev8fyiuibfxm9"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","tag_id":"cirrmop9n00jav8fyfle48tp2","_id":"cirrmop9o00jhv8fyh6jy85eb"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","tag_id":"cirrmop2w0021v8fyfgggb30d","_id":"cirrmop9o00jiv8fyr2byr13p"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","tag_id":"cirrmop9n00jdv8fyvsefrz2g","_id":"cirrmop9p00jkv8fyrpfrjgbg"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","tag_id":"cirrmop9o00jfv8fy5ogljnas","_id":"cirrmop9p00jlv8fyw5xtaeiq"},{"post_id":"cirrmop6m007iv8fyhlcya5n7","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9p00jnv8fyd2ekbw2s"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","tag_id":"cirrmop3x003gv8fymfdqfihy","_id":"cirrmop9q00jqv8fyuehkj7m7"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","tag_id":"cirrmop9o00jgv8fyua16jiqf","_id":"cirrmop9q00jrv8fyv2idpeu9"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","tag_id":"cirrmop8u00f8v8fyu3xgrjj6","_id":"cirrmop9q00jtv8fyer4x7dug"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","tag_id":"cirrmop9p00jmv8fye40oj7ir","_id":"cirrmop9q00juv8fyhvppctq4"},{"post_id":"cirrmop6n007kv8fyvepvrmyw","tag_id":"cirrmop9p00jov8fy9d2660z2","_id":"cirrmop9r00jwv8fyfn9b18hh"},{"post_id":"cirrmop6p007pv8fy4gvh6m6p","tag_id":"cirrmop9n00jdv8fyvsefrz2g","_id":"cirrmop9r00jxv8fyuskxgkk1"},{"post_id":"cirrmop6p007pv8fy4gvh6m6p","tag_id":"cirrmop9q00jsv8fydktsidtv","_id":"cirrmop9r00jzv8fyd98mn9up"},{"post_id":"cirrmop6q007sv8fyz4jijyce","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9s00k1v8fymi729gm3"},{"post_id":"cirrmop6q007sv8fyz4jijyce","tag_id":"cirrmop9q00jvv8fyjlbvnqbt","_id":"cirrmop9s00k2v8fyrp578t4q"},{"post_id":"cirrmop6q007sv8fyz4jijyce","tag_id":"cirrmop9r00jyv8fydt45zpea","_id":"cirrmop9t00k4v8fyy32x6gho"},{"post_id":"cirrmop6s007xv8fyebmufpb4","tag_id":"cirrmop300029v8fy0yuhv8gs","_id":"cirrmop9u00k7v8fy586h01mi"},{"post_id":"cirrmop6s007xv8fyebmufpb4","tag_id":"cirrmop9n00jdv8fyvsefrz2g","_id":"cirrmop9u00k8v8fylkwx7f92"},{"post_id":"cirrmop6s007xv8fyebmufpb4","tag_id":"cirrmop2w0021v8fyfgggb30d","_id":"cirrmop9u00kav8fyufnckou1"},{"post_id":"cirrmop6s007xv8fyebmufpb4","tag_id":"cirrmop9o00jfv8fy5ogljnas","_id":"cirrmop9u00kbv8fy77o2fi9m"},{"post_id":"cirrmop6s007xv8fyebmufpb4","tag_id":"cirrmop9t00k5v8fyiuu9ydvf","_id":"cirrmop9v00kdv8fydui1dj16"},{"post_id":"cirrmop6u0080v8fyxu8gz67l","tag_id":"cirrmop9m00j7v8fyifpfhz9d","_id":"cirrmop9v00kev8fyntry9axx"},{"post_id":"cirrmop6u0080v8fyxu8gz67l","tag_id":"cirrmop9p00jmv8fye40oj7ir","_id":"cirrmop9w00kgv8fyvu9iywr0"},{"post_id":"cirrmop6w0084v8fyuydtjwjo","tag_id":"cirrmop8y00g0v8fyt754rap2","_id":"cirrmop9w00khv8fy4z0um70m"},{"post_id":"cirrmop6x0086v8fym70ezwgu","tag_id":"cirrmop9v00kfv8fytkarjcda","_id":"cirrmop9x00klv8fy8uihagl5"},{"post_id":"cirrmop6x0086v8fym70ezwgu","tag_id":"cirrmop9b00hyv8fye70i2169","_id":"cirrmop9x00kmv8fy3mv9iswr"},{"post_id":"cirrmop6x0086v8fym70ezwgu","tag_id":"cirrmop9w00kjv8fyi8wwun86","_id":"cirrmop9y00kov8fyo8z2ymqy"},{"post_id":"cirrmop6z008av8fyihmw6sam","tag_id":"cirrmop9x00kkv8fy17wzzp66","_id":"cirrmop9z00ksv8fymd7v9j79"},{"post_id":"cirrmop6z008av8fyihmw6sam","tag_id":"cirrmop9100ghv8fy8z6lz377","_id":"cirrmop9z00ktv8fyt3v6x1cd"},{"post_id":"cirrmop6z008av8fyihmw6sam","tag_id":"cirrmop8j00dqv8fyrm87wl8s","_id":"cirrmop9z00kvv8fyxre1lmr4"},{"post_id":"cirrmop6z008av8fyihmw6sam","tag_id":"cirrmop9y00kqv8fyl1ycoknp","_id":"cirrmopa000kwv8fy1sd6e4wv"},{"post_id":"cirrmop70008dv8fyktivah25","tag_id":"cirrmop9z00krv8fyh1vxc5kq","_id":"cirrmopa100l0v8fyzzjpq2eg"},{"post_id":"cirrmop70008dv8fyktivah25","tag_id":"cirrmop9z00kuv8fy8vzywjid","_id":"cirrmopa100l1v8fy2sx346bd"},{"post_id":"cirrmop70008dv8fyktivah25","tag_id":"cirrmopa000kxv8fyuiy5ksc1","_id":"cirrmopa100l3v8fyb7a3j55l"},{"post_id":"cirrmop70008dv8fyktivah25","tag_id":"cirrmopa000kyv8fyw9z1f7zq","_id":"cirrmopa100l4v8fylo49x5jm"},{"post_id":"cirrmop72008iv8fydxaqx2yl","tag_id":"cirrmopa000kzv8fypkaz6rr0","_id":"cirrmopa200l6v8fykv50x9cj"},{"post_id":"cirrmop72008iv8fydxaqx2yl","tag_id":"cirrmopa100l2v8fy6ejpc0o5","_id":"cirrmopa200l7v8fylt89a7vs"},{"post_id":"cirrmop73008lv8fyb05snz15","tag_id":"cirrmopa100l5v8fysfjwpef8","_id":"cirrmopa300lbv8fynrxkljtl"},{"post_id":"cirrmop73008lv8fyb05snz15","tag_id":"cirrmopa100l2v8fy6ejpc0o5","_id":"cirrmopa300lcv8fy980k34bl"},{"post_id":"cirrmop73008lv8fyb05snz15","tag_id":"cirrmopa200l9v8fy4qr4l63f","_id":"cirrmopa300lev8fygn5yn4f9"},{"post_id":"cirrmop75008ov8fyfr7p08vo","tag_id":"cirrmopa300lav8fy6hm63ua8","_id":"cirrmopa500lhv8fyde7yoktu"},{"post_id":"cirrmop75008ov8fyfr7p08vo","tag_id":"cirrmopa300ldv8fygcgnndyw","_id":"cirrmopa500liv8fym6fepwy2"},{"post_id":"cirrmop75008ov8fyfr7p08vo","tag_id":"cirrmopa300lfv8fyl0bdziyl","_id":"cirrmopa500lkv8fyuuou2m8l"},{"post_id":"cirrmop76008sv8fybyemtels","tag_id":"cirrmopa400lgv8fy0dpixd8e","_id":"cirrmopa600lmv8fy74748nsf"},{"post_id":"cirrmop76008sv8fybyemtels","tag_id":"cirrmopa500ljv8fybctgo4vh","_id":"cirrmopa600lnv8fyj6elwxll"},{"post_id":"cirrmop79008wv8fy0wup01we","tag_id":"cirrmopa600llv8fy5vqfetdj","_id":"cirrmopa900lsv8fy8z11znw3"},{"post_id":"cirrmop79008wv8fy0wup01we","tag_id":"cirrmopa600lov8fy69nkbp17","_id":"cirrmopa900ltv8fyf7j0ep6m"},{"post_id":"cirrmop79008wv8fy0wup01we","tag_id":"cirrmopa700lpv8fy9lti1it4","_id":"cirrmopa900lvv8fyvj8349r0"},{"post_id":"cirrmop79008wv8fy0wup01we","tag_id":"cirrmop9y00kqv8fyl1ycoknp","_id":"cirrmopa900lwv8fyzqb1y83h"},{"post_id":"cirrmop7b008zv8fyakjcsgy5","tag_id":"cirrmopa800lrv8fy249bw8yd","_id":"cirrmopaa00lzv8fyh8x96fsl"},{"post_id":"cirrmop7b008zv8fyakjcsgy5","tag_id":"cirrmopa900luv8fyxzx4bbrg","_id":"cirrmopaa00m0v8fyrktmyynz"},{"post_id":"cirrmop7b008zv8fyakjcsgy5","tag_id":"cirrmopa900lxv8fy3jbdghro","_id":"cirrmopaa00m2v8fy67gzw8s5"},{"post_id":"cirrmop7d0092v8fyiet0ynxf","tag_id":"cirrmopa900lyv8fydtkzbh9n","_id":"cirrmopab00m6v8fyby2ueavj"},{"post_id":"cirrmop7d0092v8fyiet0ynxf","tag_id":"cirrmopaa00m1v8fysi62b5ja","_id":"cirrmopab00m7v8fy0dr5bc49"},{"post_id":"cirrmop7d0092v8fyiet0ynxf","tag_id":"cirrmopaa00m3v8fysyk9cysb","_id":"cirrmopac00m9v8fyu6lxwoc0"},{"post_id":"cirrmop7d0092v8fyiet0ynxf","tag_id":"cirrmopaa00m4v8fy23y1jljz","_id":"cirrmopac00mav8fy88jvvztp"},{"post_id":"cirrmop7e0095v8fy66gdyn0i","tag_id":"cirrmopab00m5v8fylq8smxhx","_id":"cirrmopad00mdv8fy49444ml8"},{"post_id":"cirrmop7e0095v8fy66gdyn0i","tag_id":"cirrmopa300lav8fy6hm63ua8","_id":"cirrmopad00mev8fylxsim7fa"},{"post_id":"cirrmop7e0095v8fy66gdyn0i","tag_id":"cirrmopa300ldv8fygcgnndyw","_id":"cirrmopad00mgv8fyi738rklk"},{"post_id":"cirrmop7h0098v8fyf1dqo17l","tag_id":"cirrmopac00mcv8fyd667nnd4","_id":"cirrmopae00miv8fyyd3qhfzd"},{"post_id":"cirrmop7h0098v8fyf1dqo17l","tag_id":"cirrmop9p00jmv8fye40oj7ir","_id":"cirrmopae00mjv8fykiw4kdx5"},{"post_id":"cirrmop7j009bv8fytzdddjwa","tag_id":"cirrmopad00mhv8fy192t7774","_id":"cirrmopaf00mmv8fyd0alshzk"},{"post_id":"cirrmop7j009bv8fytzdddjwa","tag_id":"cirrmopae00mkv8fy9dquv0de","_id":"cirrmopaf00mnv8fynz4cxgct"},{"post_id":"cirrmop7l009fv8fyujnjkdk0","tag_id":"cirrmopa100l2v8fy6ejpc0o5","_id":"cirrmopai00mrv8fyrpeqvtwu"},{"post_id":"cirrmop7l009fv8fyujnjkdk0","tag_id":"cirrmopaf00mov8fy0qu5l63h","_id":"cirrmopai00msv8fy2xo46rhr"},{"post_id":"cirrmop7l009fv8fyujnjkdk0","tag_id":"cirrmopag00mpv8fy5e0obolj","_id":"cirrmopaj00muv8fynq0azs6z"},{"post_id":"cirrmop7m009iv8fy6d4hhwcc","tag_id":"cirrmopaf00mov8fy0qu5l63h","_id":"cirrmopak00mwv8fyc6f6bl2y"},{"post_id":"cirrmop7m009iv8fy6d4hhwcc","tag_id":"cirrmopa100l2v8fy6ejpc0o5","_id":"cirrmopak00mxv8fyaeai7i4v"},{"post_id":"cirrmop7m009iv8fy6d4hhwcc","tag_id":"cirrmopaj00mvv8fyidki03wh","_id":"cirrmopak00myv8fy5vz30wwm"},{"post_id":"cirrmopam00mzv8fyu60vjthh","tag_id":"cirrmopao00n0v8fy50sf9f36","_id":"cirrmopas00n3v8fynv5kh19t"},{"post_id":"cirrmopam00mzv8fyu60vjthh","tag_id":"cirrmopaq00n2v8fy769p7ur1","_id":"cirrmopas00n4v8fysxi6dyfw"}],"Tag":[{"name":"octopress","_id":"cirrmop0z0002v8fy7amxwwoy"},{"name":"github","_id":"cirrmop170006v8fyerxvcneg"},{"name":"config.xml","_id":"cirrmop1g000cv8fyjj3cgpun"},{"name":"中文","_id":"cirrmop1m000iv8fyghj677xw"},{"name":"markdown","_id":"cirrmop1p000nv8fyoywkk2ti"},{"name":"syntax","_id":"cirrmop1u000vv8fyi8q1jvbc"},{"name":"MarkDownPad","_id":"cirrmop25001av8fynnquk426"},{"name":"webdriver","_id":"cirrmop2c001iv8fy19cnzqty"},{"name":"selenium","_id":"cirrmop2k001qv8fy09m8u1nq"},{"name":"stable","_id":"cirrmop2r001vv8fydhk9xjyn"},{"name":"pmd","_id":"cirrmop2w0021v8fyfgggb30d"},{"name":"maven","_id":"cirrmop300029v8fy0yuhv8gs"},{"name":"eclipse","_id":"cirrmop39002fv8fya21es5u1"},{"name":"wait","_id":"cirrmop3s0039v8fyz22swuy5"},{"name":"apache","_id":"cirrmop3x003gv8fymfdqfihy"},{"name":"mpm","_id":"cirrmop4d003ov8fyk6qoa1f7"},{"name":"worker","_id":"cirrmop4k003wv8fy4o6krkz9"},{"name":"perfork","_id":"cirrmop4n0043v8fy6297fj9i"},{"name":"alert","_id":"cirrmop50004pv8fy2y6u9770"},{"name":"FAQ","_id":"cirrmop54004wv8fy2z2ki842"},{"name":"JavaScript","_id":"cirrmop5e005hv8fyrklufiuq"},{"name":"Firefox","_id":"cirrmop5u0064v8fykryijakp"},{"name":"Chrome","_id":"cirrmop60006dv8fyf4kq6sc8"},{"name":"Driver","_id":"cirrmop64006lv8fybwo3ij60"},{"name":"PageObjects","_id":"cirrmop6g0079v8fyejgll159"},{"name":"PageFactory","_id":"cirrmop6l007gv8fyth66689x"},{"name":"install","_id":"cirrmop6r007uv8fyv8h5s7pr"},{"name":"config","_id":"cirrmop6w0082v8fykzi3sifb"},{"name":"JVM","_id":"cirrmop6z0089v8fy069q7vgu"},{"name":"Java","_id":"cirrmop72008hv8fyfezj0kaw"},{"name":"Tomcat","_id":"cirrmop7b008xv8fyf1vugb3q"},{"name":"GC","_id":"cirrmop7e0093v8fyc0km5gfs"},{"name":"配置","_id":"cirrmop7j009av8fyt3kxzkqy"},{"name":"LifeCycle","_id":"cirrmop7o009nv8fyf5mfvnsl"},{"name":"生命周期","_id":"cirrmop7p009qv8fyb8vvvj28"},{"name":"xpath","_id":"cirrmop7s00a3v8fy31sj8uyk"},{"name":"DOM","_id":"cirrmop7s00a6v8fy7sn48n1a"},{"name":"git","_id":"cirrmop7s00a9v8fyox6vv9yf"},{"name":"command","_id":"cirrmop7t00aev8fy79tie3n5"},{"name":"JDK","_id":"cirrmop7u00ajv8fyag9pv10r"},{"name":"design pattern","_id":"cirrmop7v00aov8fyrn5swu9a"},{"name":"story","_id":"cirrmop7v00arv8fy1l54yu5r"},{"name":"encode","_id":"cirrmop7x00awv8fyvdl4t32y"},{"name":"HTTP","_id":"cirrmop7y00azv8fy38maln1v"},{"name":"header","_id":"cirrmop7z00b4v8fydbmfk38z"},{"name":"request","_id":"cirrmop8000b6v8fynta2hpku"},{"name":"response","_id":"cirrmop8000b8v8fyvvlfectx"},{"name":"UTF8","_id":"cirrmop8000b9v8fyedms9q40"},{"name":"BOM","_id":"cirrmop8100bfv8fy3k7nmv60"},{"name":"XML","_id":"cirrmop8100bgv8fyq97vw4tb"},{"name":"class","_id":"cirrmop8100bkv8fywz95wm1q"},{"name":"String","_id":"cirrmop8200bnv8fywtooomph"},{"name":"UTF","_id":"cirrmop8300bpv8fya27atifg"},{"name":"设计模式","_id":"cirrmop8300bvv8fyxrbhl7r1"},{"name":"Adapter","_id":"cirrmop8400bzv8fyg7ebbyoc"},{"name":"decorator","_id":"cirrmop8500c3v8fy3dxzg636"},{"name":"IO","_id":"cirrmop8500c5v8fykt11cpzc"},{"name":"云南","_id":"cirrmop8b00c6v8fykib69ymm"},{"name":"旅游","_id":"cirrmop8c00c9v8fy6epnmnpg"},{"name":"bridge","_id":"cirrmop8c00cbv8fy18d09xsv"},{"name":"pattern","_id":"cirrmop8c00cev8fyzkox1ai0"},{"name":"builder","_id":"cirrmop8d00civ8fye983z02v"},{"name":"chain","_id":"cirrmop8d00cjv8fy81axxswt"},{"name":"责任链","_id":"cirrmop8e00cnv8fyjj5d6l4t"},{"name":"Facade","_id":"cirrmop8f00cwv8fyxvin3niz"},{"name":"slf4j","_id":"cirrmop8f00cxv8fy1ziqui1y"},{"name":"composite","_id":"cirrmop8f00cyv8fy3r8ph50c"},{"name":"Factory","_id":"cirrmop8g00d6v8fyiq0qschw"},{"name":"flyweight","_id":"cirrmop8g00d7v8fy86qejmbp"},{"name":"享元","_id":"cirrmop8h00dbv8fyldx67prs"},{"name":"interpreter","_id":"cirrmop8h00dcv8fyfx8jufrn"},{"name":"解释器","_id":"cirrmop8i00dhv8fy44lpdbsl"},{"name":"Iterator","_id":"cirrmop8i00dlv8fybma8049w"},{"name":"mediator","_id":"cirrmop8j00dnv8fyjw5f71o2"},{"name":"java","_id":"cirrmop8j00dqv8fyrm87wl8s"},{"name":"memento","_id":"cirrmop8j00drv8fyahar6pts"},{"name":"备忘录","_id":"cirrmop8k00dvv8fy683kuul9"},{"name":"object","_id":"cirrmop8k00dwv8fyk63ro2nk"},{"name":"Observer","_id":"cirrmop8l00e2v8fyvuo6d88m"},{"name":"Observable","_id":"cirrmop8l00e3v8fyl3mqusvl"},{"name":"prototype","_id":"cirrmop8l00e7v8fyxqx5253w"},{"name":"Clone","_id":"cirrmop8m00e9v8fye25rmkjo"},{"name":"proxy","_id":"cirrmop8m00edv8fypaynhcc8"},{"name":"cglib","_id":"cirrmop8n00egv8fyhsihwn98"},{"name":"state","_id":"cirrmop8n00ehv8fya04m406h"},{"name":"状态","_id":"cirrmop8o00env8fywdiijggt"},{"name":"singleton","_id":"cirrmop8p00erv8fyx3yvt8xf"},{"name":"template method","_id":"cirrmop8q00ewv8fyiqctkpi8"},{"name":"strategy","_id":"cirrmop8q00exv8fygqgtkdru"},{"name":"policy","_id":"cirrmop8r00f0v8fydvddepk5"},{"name":"visitor","_id":"cirrmop8s00f2v8fyn6liuhcx"},{"name":"访问者","_id":"cirrmop8t00f7v8fyxudze81m"},{"name":"mysql","_id":"cirrmop8u00f8v8fyu3xgrjj6"},{"name":"dump","_id":"cirrmop8v00fbv8fy8wqw7smj"},{"name":"jmeter","_id":"cirrmop8v00fdv8fy2a41heag"},{"name":"分布式","_id":"cirrmop8v00fgv8fyi49to7ut"},{"name":"压力测试","_id":"cirrmop8v00fhv8fy6c7n0u8l"},{"name":"ant","_id":"cirrmop8w00flv8fy8v0qe6g0"},{"name":"source","_id":"cirrmop8w00fnv8fymre7of4m"},{"name":"monitor","_id":"cirrmop8x00frv8fymgw27km9"},{"name":"slowquery","_id":"cirrmop8x00ftv8fymoxtb8lp"},{"name":"漫游","_id":"cirrmop8y00fuv8fyrr6yvby8"},{"name":"探索测试","_id":"cirrmop8y00fxv8fyqhx2w1fm"},{"name":"读书笔记","_id":"cirrmop8y00g0v8fyt754rap2"},{"name":"grid","_id":"cirrmop8z00g1v8fyaacbazp7"},{"name":"NodeJS","_id":"cirrmop8z00g4v8fyfy5yv9l4"},{"name":"express","_id":"cirrmop8z00g7v8fyy7aszh5s"},{"name":"Testacular","_id":"cirrmop9000gbv8fylmtm5ehr"},{"name":"JsTestDriver","_id":"cirrmop9000gev8fy953tmlb8"},{"name":"nodejs","_id":"cirrmop9100ggv8fyknjp3v91"},{"name":"jenkins","_id":"cirrmop9100ghv8fy8z6lz377"},{"name":"jasmine","_id":"cirrmop9200glv8fyjks5wp4n"},{"name":"hudson","_id":"cirrmop9200grv8fy9va0gy4b"},{"name":"ci","_id":"cirrmop9300gsv8fyybdpmgnb"},{"name":"plugins","_id":"cirrmop9300gtv8fy11wkakuh"},{"name":"qunit","_id":"cirrmop9300guv8fy6vz5rcwl"},{"name":"jquery","_id":"cirrmop9400gxv8fy0qxxsevb"},{"name":"jsTestDriver","_id":"cirrmop9400h0v8fyfwbg0e2s"},{"name":"test-runner","_id":"cirrmop9500h4v8fy1rnedl6k"},{"name":"karma","_id":"cirrmop9500h5v8fya5kdmer2"},{"name":"testacular","_id":"cirrmop9600h8v8fyd3pzpb0q"},{"name":"mocha","_id":"cirrmop9600hav8fy0bnx3stc"},{"name":"idea","_id":"cirrmop9600hbv8fy964ytc86"},{"name":"junit","_id":"cirrmop9800hjv8fy3wk3c99u"},{"name":"coverage","_id":"cirrmop9800hkv8fyytwnddte"},{"name":"cobertura","_id":"cirrmop9800hlv8fy6waugi1q"},{"name":"archetype","_id":"cirrmop9a00hsv8fy0t33mr1j"},{"name":"generate","_id":"cirrmop9a00hvv8fy73nlkbow"},{"name":"ast","_id":"cirrmop9b00hyv8fye70i2169"},{"name":"plugin","_id":"cirrmop9c00i1v8fypyyk2j0c"},{"name":"jar","_id":"cirrmop9e00iav8fypk347lz3"},{"name":"sonatype","_id":"cirrmop9f00idv8fyvb6nkbpt"},{"name":"testng","_id":"cirrmop9g00ifv8fywv9fm9xa"},{"name":"mockito","_id":"cirrmop9h00iiv8fyem4tjnxx"},{"name":"ut","_id":"cirrmop9h00ilv8fy2p9850as"},{"name":"powermock","_id":"cirrmop9i00inv8fy62q1t0pf"},{"name":"stub","_id":"cirrmop9i00iov8fyvf1l7cur"},{"name":"mock","_id":"cirrmop9j00ipv8fyv98tfh31"},{"name":"dbunit","_id":"cirrmop9j00iqv8fy97bgesvn"},{"name":"h2database","_id":"cirrmop9k00itv8fysiu4cjt5"},{"name":"ut，sql-maven-plugin","_id":"cirrmop9k00iwv8fy9vr89w2l"},{"name":"重构","_id":"cirrmop9l00j1v8fyd7l6abzn"},{"name":"模式","_id":"cirrmop9l00j3v8fy1eh15oca"},{"name":"ssh","_id":"cirrmop9m00j7v8fyifpfhz9d"},{"name":"connection","_id":"cirrmop9n00j9v8fy8s6ux46e"},{"name":"sonar","_id":"cirrmop9n00jav8fyfle48tp2"},{"name":"checkstyle","_id":"cirrmop9n00jdv8fyvsefrz2g"},{"name":"findbugs","_id":"cirrmop9o00jfv8fy5ogljnas"},{"name":"tomcat","_id":"cirrmop9o00jgv8fyua16jiqf"},{"name":"linux","_id":"cirrmop9p00jmv8fye40oj7ir"},{"name":"调优","_id":"cirrmop9p00jov8fy9d2660z2"},{"name":"antlr","_id":"cirrmop9q00jsv8fydktsidtv"},{"name":"package","_id":"cirrmop9q00jvv8fyjlbvnqbt"},{"name":"war","_id":"cirrmop9r00jyv8fydt45zpea"},{"name":"静态代码扫描","_id":"cirrmop9t00k5v8fyiuu9ydvf"},{"name":"ut-maven-plugin","_id":"cirrmop9v00kfv8fytkarjcda"},{"name":"javaparser","_id":"cirrmop9w00kjv8fyi8wwun86"},{"name":"dom4j","_id":"cirrmop9x00kkv8fy17wzzp66"},{"name":"编码","_id":"cirrmop9y00kqv8fyl1ycoknp"},{"name":"apache poi","_id":"cirrmop9z00krv8fyh1vxc5kq"},{"name":"excel","_id":"cirrmop9z00kuv8fy8vzywjid"},{"name":"jXLS","_id":"cirrmopa000kxv8fyuiy5ksc1"},{"name":"jxl","_id":"cirrmopa000kyv8fyw9z1f7zq"},{"name":"velocity","_id":"cirrmopa000kzv8fypkaz6rr0"},{"name":"spring","_id":"cirrmopa100l2v8fy6ejpc0o5"},{"name":"quartz","_id":"cirrmopa100l5v8fysfjwpef8"},{"name":"集群","_id":"cirrmopa200l9v8fy4qr4l63f"},{"name":"solr","_id":"cirrmopa300lav8fy6hm63ua8"},{"name":"lucene","_id":"cirrmopa300ldv8fygcgnndyw"},{"name":"tie","_id":"cirrmopa300lfv8fyl0bdziyl"},{"name":"java7","_id":"cirrmopa400lgv8fy0dpixd8e"},{"name":"java8","_id":"cirrmopa500ljv8fybctgo4vh"},{"name":"enca","_id":"cirrmopa600llv8fy5vqfetdj"},{"name":"iconv","_id":"cirrmopa600lov8fy69nkbp17"},{"name":"convmv","_id":"cirrmopa700lpv8fy9lti1it4"},{"name":"cloudera","_id":"cirrmopa800lrv8fy249bw8yd"},{"name":"oryx","_id":"cirrmopa900luv8fyxzx4bbrg"},{"name":"myrrix","_id":"cirrmopa900lxv8fy3jbdghro"},{"name":"mahout","_id":"cirrmopa900lyv8fydtkzbh9n"},{"name":"sogou","_id":"cirrmopaa00m1v8fysi62b5ja"},{"name":"ik-analyzer","_id":"cirrmopaa00m3v8fysyk9cysb"},{"name":"ubuntu","_id":"cirrmopaa00m4v8fy23y1jljz"},{"name":"同义词","_id":"cirrmopab00m5v8fylq8smxhx"},{"name":"hadoop","_id":"cirrmopac00mcv8fyd667nnd4"},{"name":"c3p0","_id":"cirrmopad00mhv8fy192t7774"},{"name":"dhcp","_id":"cirrmopae00mkv8fy9dquv0de"},{"name":"restful","_id":"cirrmopaf00mov8fy0qu5l63h"},{"name":"interface","_id":"cirrmopag00mpv8fy5e0obolj"},{"name":"mvc","_id":"cirrmopaj00mvv8fyidki03wh"},{"name":"jstl","_id":"cirrmopao00n0v8fy50sf9f36"},{"name":"el","_id":"cirrmopaq00n2v8fy769p7ur1"}]}}