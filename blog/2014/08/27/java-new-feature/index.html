
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Java新特性 - Blues 小站</title>
  <meta name="author" content="ShenYanchao">

  
  <meta name="description" content="专注于原创技术博客，并分享精品技术文章">
  <meta name="keywords" content="shenyanchao, karma, Java, Linux, selenium, webdriver, 设计模式, JavaEE, NodeJS">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.shenyanchao.cn/blog/2014/08/27/java-new-feature">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 40px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Blues 小站" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36243102-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <nav role="navigation"><div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Blues 小站</a>

      <div class="nav-collapse">
        ﻿<ul class="nav">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">博客</a></li>
  <li><a href="/tags/">Tag云</a></li>
  <li><a href="/friends/">友情链接</a></li>
<li><a href="/messagebox/">留言板</a></li>
  <li><a href="/author/">关于我</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://google.com.hk/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:www.shenyanchao.cn" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      
<article class="hentry span9" role="article">

  ﻿
  <header class="page-header">
    
      <h1 class="entry-title">Java新特性</h1>
    
	<p class="meta">
    

        








  


<time datetime="2014-08-27T14:43:00+08:00" pubdate data-updated="true">2014年08月27日 14:08:00</time>
        
         | <a href="#disqus_thread">我要评论</a>
        
    
 </p>
  </header>


<div class="entry-content"><h2>Java7新特性</h2>

<h3>Java7语法特性</h3>

<p>根据JSR 334，Java7添加了数个语法方面的新特性：</p>

<h4>1. switch可以消化String</h4>

<p>比如：</p>

<pre><code>public static void switchString(String s){
    switch (s){
    case "db": ...
    case "wls": ...
    case "ibm": ...
    case "soa": ...
    case "fa": ...
    default: ...
    }
}
</code></pre>

<!--more-->


<h4>2. 新的整数字面表达方式 - &#8220;0b&#8221;前缀和&#8221;_&#8221;连数符，提升程序员的幸福感。</h4>

<ul>
<li><p>a. 表示二进制字面值的前缀, 0b:
比如以下三个变量的值相同：</p>

<pre><code>   byte b1 = 0b00100001;     // New
   byte b2 = 0x21;        // Old
   byte b3 = 33;        // Old
</code></pre></li>
<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>

<pre><code>  long phone_nbr = 021_1111_2222;
</code></pre></li>
</ul>


<h4>3. 简化了泛型对象创建的语法 - &#8220;菱形 new&#8221;，以下两个语句等价：</h4>

<pre><code>    ArrayList&lt;String&gt; al1 = new ArrayList&lt;String&gt;();    // Old
    ArrayList&lt;String&gt; al2 = new ArrayList&lt;&gt;();        // New
</code></pre>

<h4>4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</h4>

<pre><code>    ClassNotFoundException, 
    IllegalAccessException, 
    InstantiationException, 
    InvocationTargetException, 
    NoSuchFieldException, 
    NoSuchMethodException
</code></pre>

<h4>5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</h4>

<pre><code>    try{
        // code
    }
    catch (SQLException | IOException ex) {
        // ...
    }
</code></pre>

<h4>6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</h4>

<pre><code>    public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类
        try{
            // code
        }
        catch (RelectiveOperationException ex){    // 父类
            throws ex;
        }
    }
</code></pre>

<h4>7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是&#8221;(&#8220;不是&#8221;{&#8220;：</h4>

<pre><code>try(BufferedReader br = new BufferedReader(new FileReader("/home/oracle/temp.txt"))){
    ... br.readLine() ...
}
</code></pre>

<p>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>

<h3>Java7 NIO 新方法</h3>

<p>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>

<h4>1.增加<code>java.nio.file.Paths</code>用于目录操作</h4>

<pre><code>    Path path = Paths.get("/home/shenyanchao", "Desktop");
    System.out.println(path.toAbsolutePath());
    System.out.println(path.getParent());
    System.out.println(path.getFileSystem().isOpen());
</code></pre>

<h4>2.增加<code>java.nio.file.Files</code>工具类来处理文件</h4>

<pre><code>    Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);

    Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);

    Files.createLink(src,dest);
    Files.createSymbolicLink(src,dest);
    Files.deleteIfExists(dest);

    Files.readAllLines(src);

    Files.createTempFile(src,"aa","bb");
</code></pre>

<h4>3.目录树遍历</h4>

<p>使用<code>FileVisitor</code>来实现访问者模式。</p>

<pre><code>preVisitDirectory(T dir, BasicFileAttributes attrs);
visitFile(T dir, BasicFileAttributes attrs);
visitFileFailed(T dir, IOException exc);
postVisitDirectory(T dir, IOException exc);
</code></pre>

<h4>4.使用WatchService来监控目录，变化请通知</h4>

<pre><code>    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path path = Paths.get("/home/shenyanchao/Documents");
    WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();
        for (WatchEvent&lt;?&gt; watchEvent : watchEvents) {
            System.out.printf("[%s]文件发生了[%s]事件。%n", watchEvent.context(), watchEvent.kind());
        }
        boolean valid = watchKey.reset();
        if (!valid){
            break;
        }
    }
</code></pre>

<h3>Java7并发（JSR166Y）</h3>

<h4>Fork Join框架，大任务分解为小任务</h4>

<p>通过ForkJoinPool，ForkJoinTask来实现的。</p>

<pre><code>public class Fibonacci extends RecursiveTask&lt;Integer&gt; {

    final int n;

    Fibonacci(int n) {
        this.n = n;
    }

    @Override
    protected Integer compute() {
        if (n &lt;= 1)
            return n;
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();
        Fibonacci f2 = new Fibonacci(n - 2);
        f2.fork();
        return f1.join() + f2.join();
    }

    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci(4);
        System.out.println(fibonacci.compute());
    }
}
</code></pre>

<h4>TransferQueue，ConcurrentLinkedDeque等新类</h4>

<p>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>

<h4>ThreadLocalRandom用于生成随机数</h4>

<pre><code>ThreadLocalRandom.current().nextInt (...)
</code></pre>

<p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>

<h3>Java7 client</h3>

<p>诸如更新了很多swing显示相关的api. <br/>
更好的支持linux fonts</p>

<h3>Java7 VM新特性</h3>

<h4>1.引入Garbage First回收算法</h4>

<p>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>

<hr />

<p>参考文档：<a href="http://www.slideshare.net/boulderjug/55-things-in-java-7">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>

<h2>Java8新特性</h2>

<h3>1.接口默认方法[接口允许有实现啦]</h3>

<p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>

<pre><code>interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
</code></pre>

<h3>2.Lambda表达式</h3>

<p>据说借鉴了各种动态语言的新特性，比如scala，python
首先看看在老版本的Java中是如何排列字符串的：</p>

<pre><code>List&lt;String&gt; names = Arrays.asList("peter", "anna", "mike", "xenia");

Collections.sort(names, new Comparator&lt;String&gt;() {
@Override
public int compare(String a, String b) {
    return b.compareTo(a);
}
});
</code></pre>

<p>Java 8 提供了更为简介的语法，lambda表达式：</p>

<pre><code>Collections.sort(names, (String a, String b) -&gt; {
    return b.compareTo(a);
});
</code></pre>

<p>可以更短：</p>

<pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
</code></pre>

<p>再短：</p>

<pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</code></pre>

<h3>3.@FunctionalInterface</h3>

<p>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>

<pre><code>@FunctionalInterface
interface Converter&lt;F, T&gt; {
    T convert(F from);
}

Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
</code></pre>

<p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>

<h4>(1)方法与构造函数的引用::</h4>

<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>

<pre><code>Converter&lt;String, Integer&gt; converter = Integer::valueOf;
Integer converted = converter.convert("123");
System.out.println(converted);   // 123
</code></pre>

<p>当然也可以引用一个对象的方法：</p>

<pre><code>converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);    // "J"
</code></pre>

<p>那么如何引用构造函数呢？</p>

<pre><code>class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre>

<p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>

<pre><code>interface PersonFactory&lt;P extends Person&gt; {
    P create(String firstName, String lastName);
}
</code></pre>

<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>

<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
</code></pre>

<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>

<h4>(2)内嵌的Functional Interfaces</h4>

<p>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>

<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>

<ul>
<li>Predicates</li>
</ul>


<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>

<pre><code>    Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;

    predicate.test("foo");              // true
    predicate.negate().test("foo");     // false

    Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;
    Predicate&lt;Boolean&gt; isNull = Objects::isNull;

    Predicate&lt;String&gt; isEmpty = String::isEmpty;
    Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();
</code></pre>

<ul>
<li>Function</li>
</ul>


<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>

<pre><code>    Function&lt;String, Integer&gt; toInteger = Integer::valueOf;
    Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);

    backToString.apply("123");     // "123"
</code></pre>

<ul>
<li>Supplier</li>
</ul>


<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>

<pre><code>    Supplier&lt;Person&gt; personSupplier = Person::new;
    personSupplier.get();   // new Person
</code></pre>

<ul>
<li>Consumer</li>
</ul>


<p>Consumer在一个输入参数上做一些操作。</p>

<pre><code>    Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println("Hello, " + p.firstName);
    greeter.accept(new Person("Luke", "Skywalker"));
</code></pre>

<ul>
<li>Comparator</li>
</ul>


<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>

<pre><code>    Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);

    Person p1 = new Person("John", "Doe");
    Person p2 = new Person("Alice", "Wonderland");

    comparator.compare(p1, p2);             // &gt; 0
    comparator.reversed().compare(p1, p2);  // &lt; 0
</code></pre>

<ul>
<li>Optional</li>
</ul>


<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>

<pre><code>    Optional&lt;String&gt; optional = Optional.of("bam");

    optional.isPresent();           // true
    optional.get();                 // "bam"
    optional.orElse("fallback");    // "bam"

    optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // "b"
</code></pre>

<ul>
<li>Stream</li>
</ul>


<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。
首先，新建一个数组。</p>

<pre><code>    List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
    stringCollection.add("ddd2");
    stringCollection.add("aaa2");
    stringCollection.add("bbb1");
    stringCollection.add("aaa1");
    stringCollection.add("bbb3");
    stringCollection.add("ccc");
    stringCollection.add("bbb2");
    stringCollection.add("ddd1");
</code></pre>

<p>具体使用如下：</p>

<pre><code>    stringCollection
        .stream()
        .sorted()
        .filter((s) -&gt; s.startsWith("a"))
        .forEach(System.out::println);

    // "aaa1", "aaa2"
</code></pre>

<p>map()函数可以把每个值转换为另外的值。</p>

<pre><code>    stringCollection
        .stream()
        .map(String::toUpperCase)
        .sorted((a, b) -&gt; b.compareTo(a))
        .forEach(System.out::println);

    // "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"        
</code></pre>

<p>另外提供有各种match方法。</p>

<pre><code>    boolean anyStartsWithA =
        stringCollection
            .stream()
            .anyMatch((s) -&gt; s.startsWith("a"));

    System.out.println(anyStartsWithA);      // true

    boolean allStartsWithA =
        stringCollection
            .stream()
            .allMatch((s) -&gt; s.startsWith("a"));

    System.out.println(allStartsWithA);      // false

    boolean noneStartsWithZ =
        stringCollection
            .stream()
            .noneMatch((s) -&gt; s.startsWith("z"));

    System.out.println(noneStartsWithZ);      // true
</code></pre>

<p>count()方法返回的是一个值。</p>

<pre><code>    long startsWithB =
        stringCollection
            .stream()
            .filter((s) -&gt; s.startsWith("b"))
            .count();

    System.out.println(startsWithB);    // 3        
</code></pre>

<p>reduce则进行了归一化处理：</p>

<pre><code>    Optional&lt;String&gt; reduced =
        stringCollection
            .stream()
            .sorted()
            .reduce((s1, s2) -&gt; s1 + "#" + s2);

    reduced.ifPresent(System.out::println);
    // "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"
</code></pre>

<ul>
<li>ParallelStream</li>
</ul>


<p>它是一个并行的。速度要比stream快的多。</p>

<ul>
<li>Map</li>
</ul>


<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>

<pre><code>    Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; 10; i++) {
        map.putIfAbsent(i, "val" + i);
    }

    map.forEach((id, val) -&gt; System.out.println(val));

    map.computeIfPresent(3, (num, val) -&gt; val + num);
    map.get(3);             // val33

    map.computeIfPresent(9, (num, val) -&gt; null);
    map.containsKey(9);     // false

    map.computeIfAbsent(23, num -&gt; "val" + num);
    map.containsKey(23);    // true

    map.computeIfAbsent(3, num -&gt; "bam");
    map.get(3);             // val33

    map.remove(3, "val3");
    map.get(3);             // val33

    map.remove(3, "val33");
    map.get(3);             // null

    map.getOrDefault(42, "not found");  // not found

    map.merge(9, "val9", (value, newValue) -&gt; value.concat(newValue));
    map.get(9);             // val9

    map.merge(9, "concat", (value, newValue) -&gt; value.concat(newValue));
    map.get(9);             // val9concat
</code></pre>

<h3>4.时间API</h3>

<p>Java8更新了Date API,这个新的api与joda-time类似。</p>

<h4>(1)Clock</h4>

<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>

<pre><code>    Clock clock = Clock.systemDefaultZone();
    long millis = clock.millis();

    Instant instant = clock.instant();
    Date legacyDate = Date.from(instant);   // legacy java.util.Date
</code></pre>

<h4>(2)TimeZones</h4>

<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>

<pre><code>    System.out.println(ZoneId.getAvailableZoneIds());
    // prints all available timezone ids

    ZoneId zone1 = ZoneId.of("Europe/Berlin");
    ZoneId zone2 = ZoneId.of("Brazil/East");
    System.out.println(zone1.getRules());
    System.out.println(zone2.getRules());

    // ZoneRules[currentStandardOffset=+01:00]
    // ZoneRules[currentStandardOffset=-03:00]
</code></pre>

<h4>(3)LocalTime</h4>

<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>

<pre><code>    LocalTime now1 = LocalTime.now(zone1);
    LocalTime now2 = LocalTime.now(zone2);

    System.out.println(now1.isBefore(now2));  // false

    long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
    long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

    System.out.println(hoursBetween);       // -3
    System.out.println(minutesBetween);     // -239
</code></pre>

<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>

<pre><code>    LocalTime late = LocalTime.of(23, 59, 59);
    System.out.println(late);       // 23:59:59

    DateTimeFormatter germanFormatter =
        DateTimeFormatter
            .ofLocalizedTime(FormatStyle.SHORT)
            .withLocale(Locale.GERMAN);

    LocalTime leetTime = LocalTime.parse("13:37", germanFormatter);
    System.out.println(leetTime);   // 13:37
</code></pre>

<h4>(4)LocalDate</h4>

<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>

<pre><code>    LocalDate today = LocalDate.now();
    LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
    LocalDate yesterday = tomorrow.minusDays(2);

    LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
    DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
    System.out.println(dayOfWeek);    // FRIDAY

    DateTimeFormatter germanFormatter =
        DateTimeFormatter
            .ofLocalizedDate(FormatStyle.MEDIUM)
            .withLocale(Locale.GERMAN);

    LocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);
    System.out.println(xmas);   // 2014-12-24
</code></pre>

<h4>(5)LocalDateTime</h4>

<pre><code>    LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。

    LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

    DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
    System.out.println(dayOfWeek);      // WEDNESDAY

    Month month = sylvester.getMonth();
    System.out.println(month);          // DECEMBER

    long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
    System.out.println(minuteOfDay);    // 1439

    Instant instant = sylvester
            .atZone(ZoneId.systemDefault())
            .toInstant();

    Date legacyDate = Date.from(instant);
    System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014

    DateTimeFormatter formatter =
        DateTimeFormatter
            .ofPattern("MMM dd, yyyy - HH:mm");

    LocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);
    String string = formatter.format(parsed);
    System.out.println(string);     // Nov 03, 2014 - 07:13
</code></pre>

<h3>5.支持重复注解了，注解也可以用在任何地方了</h3>

<p>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>

<pre><code>new @Interned MyObject();
myString = (@NonNull String) str;

void monitorTemperature() throws @Critical TemperatureException { ... }
</code></pre>

<p>之前要实现重复注解需要这样：</p>

<pre><code>public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseOldVersion {

    @Authorities({@Authority(role="Admin"),@Authority(role="Manager")})
    public void doSomeThing(){
    }
}
</code></pre>

<p>而现在：</p>

<pre><code>@Repeatable(Authorities.class)
public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseNewVersion {
    @Authority(role="Admin")
    @Authority(role="Manager")
    public void doSomeThing(){ }
}
</code></pre>

<h3>6.Nashorn JavaScript 引擎</h3>

<p>简单的说，它是 Rhino 的接替者.升级啦。</p>

<h3>7.StampedLock</h3>

<p>它是java8在java.util.concurrent.locks新增的一个API。</p>

<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>

<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>

<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>

<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>

<p>它是java8在java.util.concurrent.locks新增的一个API。</p>

<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>

<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>

<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>

<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>

<pre><code>class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();
   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }
  //下面看看乐观读锁案例
   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁
     double currentX = x, currentY = y; //将两个字段读入本地局部变量
     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁
        try {
          currentX = x; // 将两个字段读入本地局部变量
          currentY = y; // 将两个字段读入本地局部变量
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }
//下面是悲观读锁案例
   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合
         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁
         if (ws != 0L) { //这是确认转为写锁是否成功
           stamp = ws; //如果成功 替换票据
           x = newX; //进行状态改变
           y = newY; //进行状态改变
           break;
         }
         else { //如果不能成功转换为写锁
           sl.unlockRead(stamp); //我们显式释放读锁
           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试
         }
       }
     } finally {
       sl.unlock(stamp); //释放读锁或写锁
     }
   }
 }
</code></pre>

<hr />

<p>参考文档：<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>
</div>


  <footer>
    <p class="meta">
      ﻿
  

<span class="byline author vcard"> <span class="fn">ShenYanchao</span> 发布于</span>

      








  


<time datetime="2014-08-27T14:43:00+08:00" pubdate data-updated="true">2014年08月27日 14:08:00</time>
      

<span class="categories">
	| 分类:
  
    <a class='category' href='/blog/categories/java/'>java</a>
  
</span>


	  

<span class="tags">
   | 标签:
  
    <a class='tag' href='/tags/java7/'>java7</a>, <a class='tag' href='/tags/java8/'>java8</a>
  
</span>

    </p>
    
      ﻿<div class="sharing">
  
  
  
<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare">
<a class="bds_tsina"></a>
<a class="bds_renren"></a>
<a class="bds_qzone"></a>
<a class="bds_kaixin001"></a>
<a class="bds_hi"></a>
<a class="bds_douban"></a>
<a class="bds_tsohu"></a>
<a class="bds_tqq"></a>
<a class="bds_ty"></a>
<a class="bds_twi"></a>
<a class="bds_tieba"></a>
<span class="bds_more"></span>
<a class="shareCount"></a>
</div>
<br><br>
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6337598" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->
  
  
  
  
  
</div>

    
    
    <section>
      <h1>讨论区</h1>
      <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </section>
    
    <ul class="pager">
      
      <li class="previous"><a class="basic-alignment left"
        href="/blog/2014/06/24/export-excel-by-jxls/" title="Previous Post:
        使用 jXLS导出报表">&laquo; 使用 jXLS导出报表</a></li>
      
      <li><a href="/blog/archives">博客</a></li>
      
      <li class="next"><a class="basic-alignment right" href="/blog/2014/10/22/tie-breaker-in-solr/"
        title="Next Post: solr中的tie breaker">solr中的tie breaker
        &raquo;</a></li>
      
    </ul>
  </footer>
</article>

<aside class="sidebar-nav span3">
  
    ﻿<section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">最近更新</li>
    
      <li class="post">
        <a href="/blog/2015/03/26/c3p0-config/">c3p0 config</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/25/better-synonym-handling-in-solr/">如何在Solr中更好的处理同义词</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/">使用mahout对Sogou语料库进行分类</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/encode-convert-in-linux/">Linux中文件编码转换</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/install-hadoop/">Hadoop1.2.1安装部署</a>
      </li>
    
  </ul>
</section>
<section class="well">
	<ul id="tags-cloud" class="nav nav-list">
	<li class="nav-header">分类云</li>
    <span id="tag-cloud"><a href='/blog/categories/apache' style='font-size: 102.4%'>apache(1)</a> <a href='/blog/categories/c3p0' style='font-size: 102.4%'>c3p0(1)</a> <a href='/blog/categories/checkstyle' style='font-size: 102.4%'>checkstyle(1)</a> <a href='/blog/categories/encode' style='font-size: 112.0%'>encode(5)</a> <a href='/blog/categories/git' style='font-size: 104.8%'>git(2)</a> <a href='/blog/categories/hadoop' style='font-size: 102.4%'>hadoop(1)</a> <a href='/blog/categories/http' style='font-size: 104.8%'>HTTP(2)</a> <a href='/blog/categories/idea' style='font-size: 102.4%'>IDEA(1)</a> <a href='/blog/categories/java' style='font-size: 109.6%'>java(4)</a> <a href='/blog/categories/java' style='font-size: 107.2%'>Java(3)</a> <a href='/blog/categories/javascript' style='font-size: 102.4%'>javascript(1)</a> <a href='/blog/categories/jenkins' style='font-size: 102.4%'>jenkins(1)</a> <a href='/blog/categories/jmeter' style='font-size: 104.8%'>jmeter(2)</a> <a href='/blog/categories/jvm' style='font-size: 104.8%'>JVM(2)</a> <a href='/blog/categories/linux' style='font-size: 107.2%'>linux(3)</a> <a href='/blog/categories/mahout' style='font-size: 102.4%'>mahout(1)</a> <a href='/blog/categories/markdown' style='font-size: 104.8%'>markdown(2)</a> <a href='/blog/categories/maven' style='font-size: 119.2%'>maven(8)</a> <a href='/blog/categories/mysql' style='font-size: 104.8%'>mysql(2)</a> <a href='/blog/categories/nodejs' style='font-size: 116.8%'>nodejs(7)</a> <a href='/blog/categories/oryx' style='font-size: 102.4%'>oryx(1)</a> <a href='/blog/categories/selenium' style='font-size: 121.6%'>selenium(9)</a> <a href='/blog/categories/selenium-wiki' style='font-size: 107.2%'>selenium-wiki(3)</a> <a href='/blog/categories/selenium官方文档' style='font-size: 109.6%'>selenium官方文档(4)</a> <a href='/blog/categories/solr' style='font-size: 104.8%'>solr(2)</a> <a href='/blog/categories/testng' style='font-size: 102.4%'>testng(1)</a> <a href='/blog/categories/ubuntu' style='font-size: 102.4%'>ubuntu(1)</a> <a href='/blog/categories/ut' style='font-size: 104.8%'>ut(2)</a> <a href='/blog/categories/velocity' style='font-size: 102.4%'>velocity(1)</a> <a href='/blog/categories/个人' style='font-size: 104.8%'>个人(2)</a> <a href='/blog/categories/开发' style='font-size: 102.4%'>开发(1)</a> <a href='/blog/categories/测试' style='font-size: 107.2%'>测试(3)</a> <a href='/blog/categories/设计模式' style='font-size: 160.0%'>设计模式(25)</a> <a href='/blog/categories/调优' style='font-size: 102.4%'>调优(1)</a> </span>
  </ul>
</section>﻿<section class="well">
<ul class="nav nav-list">
  <li class="nav-header">最新评论</li>
  <script type="text/javascript" src="http://blueshen.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</ul>
  </section><section class="well">
  <ul id="categories" class="nav nav-list">
    <li class="nav-header">文章分类</li>
    <li><a href='/blog/categories/apache'>apache (1)</a></li><li><a href='/blog/categories/c3p0'>c3p0 (1)</a></li><li><a href='/blog/categories/checkstyle'>checkstyle (1)</a></li><li><a href='/blog/categories/encode'>encode (5)</a></li><li><a href='/blog/categories/git'>git (2)</a></li><li><a href='/blog/categories/hadoop'>hadoop (1)</a></li><li><a href='/blog/categories/http'>HTTP (2)</a></li><li><a href='/blog/categories/idea'>IDEA (1)</a></li><li><a href='/blog/categories/java'>java (4)</a></li><li><a href='/blog/categories/java'>Java (3)</a></li><li><a href='/blog/categories/javascript'>javascript (1)</a></li><li><a href='/blog/categories/jenkins'>jenkins (1)</a></li><li><a href='/blog/categories/jmeter'>jmeter (2)</a></li><li><a href='/blog/categories/jvm'>JVM (2)</a></li><li><a href='/blog/categories/linux'>linux (3)</a></li><li><a href='/blog/categories/mahout'>mahout (1)</a></li><li><a href='/blog/categories/markdown'>markdown (2)</a></li><li><a href='/blog/categories/maven'>maven (8)</a></li><li><a href='/blog/categories/mysql'>mysql (2)</a></li><li><a href='/blog/categories/nodejs'>nodejs (7)</a></li><li><a href='/blog/categories/oryx'>oryx (1)</a></li><li><a href='/blog/categories/selenium'>selenium (9)</a></li><li><a href='/blog/categories/selenium-wiki'>selenium-wiki (3)</a></li><li><a href='/blog/categories/selenium官方文档'>selenium官方文档 (4)</a></li><li><a href='/blog/categories/solr'>solr (2)</a></li><li><a href='/blog/categories/testng'>testng (1)</a></li><li><a href='/blog/categories/ubuntu'>ubuntu (1)</a></li><li><a href='/blog/categories/ut'>ut (2)</a></li><li><a href='/blog/categories/velocity'>velocity (1)</a></li><li><a href='/blog/categories/个人'>个人 (2)</a></li><li><a href='/blog/categories/开发'>开发 (1)</a></li><li><a href='/blog/categories/测试'>测试 (3)</a></li><li><a href='/blog/categories/设计模式'>设计模式 (25)</a></li><li><a href='/blog/categories/调优'>调优 (1)</a></li>
  </ul>
</section>
<section class="well">
  <ul id="gh_repos" class="nav">
    <li class="nav-header">GitHub Repos</li>
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/blueshen">@blueshen</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        github.showRepos({
            user: 'blueshen',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/asides/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo" class="page-footer">﻿<hr>
<p>
  版权所有 &copy; 2015 - ShenYanchao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>

</p>
</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'blueshen';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/';
        var disqus_url = 'http://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>









<!--
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F97aa7abbb3b568fb66ab76664b57b8ba' type='text/javascript'%3E%3C/script%3E"));
</script>
-->
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F81c9612f8fdceca45435ef7f5404d7b2' type='text/javascript'%3E%3C/script%3E"));
</script>


</body>
</html>
