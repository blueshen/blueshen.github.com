<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.shenyanchao.cn","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概要单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。 单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式:单例（singleton） in java">
<meta property="og:url" content="https://www.shenyanchao.cn/blog/2012/11/02/singleton-in-java/index.html">
<meta property="og:site_name" content="申艳超-博客">
<meta property="og:description" content="概要单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。 单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象">
<meta property="og:locale">
<meta property="og:image" content="https://www.shenyanchao.cn/images/blog/singleton.jpg">
<meta property="article:published_time" content="2012-11-02T10:47:00.000Z">
<meta property="article:modified_time" content="2019-12-17T11:41:25.754Z">
<meta property="article:author" content="申艳超">
<meta property="article:tag" content="java">
<meta property="article:tag" content="singleton">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.shenyanchao.cn/images/blog/singleton.jpg">


<link rel="canonical" href="https://www.shenyanchao.cn/blog/2012/11/02/singleton-in-java/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://www.shenyanchao.cn/blog/2012/11/02/singleton-in-java/","path":"blog/2012/11/02/singleton-in-java/","title":"设计模式:单例（singleton） in java"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式:单例（singleton） in java | 申艳超-博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?81c9612f8fdceca45435ef7f5404d7b2"></script>





  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="申艳超-博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">申艳超-博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">搜索引擎、分布式、高性能、NLP、ElasticSearch、Solr</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">单例模式</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="申艳超"
      src="/images/shenyanchao.jpeg">
  <p class="site-author-name" itemprop="name">申艳超</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">244</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/blueshen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;blueshen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhiyi.shen@gmail.com" title="E-Mail → mailto:zhiyi.shen@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/blueshen" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.shenyanchao.cn/blog/2012/11/02/singleton-in-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/shenyanchao.jpeg">
      <meta itemprop="name" content="申艳超">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="申艳超-博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式:单例（singleton） in java | 申艳超-博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式:单例（singleton） in java
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2012-11-02 18:47:00" itemprop="dateCreated datePublished" datetime="2012-11-02T18:47:00+08:00">2012-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2019-12-17 19:41:25" itemprop="dateModified" datetime="2019-12-17T19:41:25+08:00">2019-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span id="/blog/2012/11/02/singleton-in-java/" class="post-meta-item leancloud_visitors" data-flag-title="设计模式:单例（singleton） in java" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在本月的专栏中，David Geary探讨了单例模式以及在面对多线程（multithreading)、类装载器（classloaders）和序列化(serialization)时如何处理这些缺陷。</p>
<p>单例模式适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问指针，这便是众所周知的单例模式的应用。当然这只有在你确信你不再需要任何多于一个的实例的情况下。</p>
<span id="more"></span>
<p>单例模式的用意在于前一段中所关心的。通过单例模式你可以：</p>
<ul>
<li>确保一个类只有一个实例被建立</li>
<li>提供了一个对对象的全局访问指针</li>
<li>在不影响单例类的客户端的情况下允许将来有多个实例</li>
</ul>
<p>尽管单例设计模式如在下面的图中的所显示的一样是最简单的设计模式，但对于粗心的Java开发者来说却呈现出许多缺陷。这篇文章讨论了单例模式并揭示了那些缺陷。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在《设计模式》一书中，作者这样来叙述单例模式的：确保一个类只有一个实例并提供一个对它的全局访问指针。<br>下图说明了单例模式的类图。<br><img src="/images/blog/singleton.jpg"></p>
<p>正如你在上图中所看到的，这不是单例模式的完整部分。此图中单例类保持了一个对唯一的单例实例的静态引用，并且会从静态getInstance()方法中返回对那个实例的引用。<br>例1显示了一个经典的单例模式的实现。<br>例1.经典的单例模式</p>
<pre><code>public class ClassicSingleton &#123;
       private static ClassicSingleton instance = null;

       protected ClassicSingleton() &#123;
          // Exists only to defeat instantiation.
       &#125;
       public static ClassicSingleton getInstance() &#123;
          if(instance == null) &#123;
             instance = new ClassicSingleton();
          &#125;
          return instance;
       &#125;
&#125;
</code></pre>
<p>在例1中的单例模式的实现很容易理解。ClassicSingleton类保持了一个对单独的单例实例的静态引用，并且从静态方法getInstance()中返回那个引用。<br>关于ClassicSingleton类，有几个让我们感兴趣的地方。<br>首先，ClassicSingleton使用了一个众所周知的懒汉式实例化去创建那个单例类的引用;结果，这个单例类的实例直到getInstance()方法被第一次调用时才被创建。这种技巧可以确保单例类的实例只有在需要时才被建立出来。其次，注意ClassicSingleton实现了一个protected的构造方法，这样客户端不能直接实例化一个ClassicSingleton类的实例。然而，你会惊奇的发现下面的代码完全合法：</p>
<pre><code>public class SingletonInstantiator &#123;
      public SingletonInstantiator() &#123;
           ClassicSingleton instance = ClassicSingleton.getInstance();
        ClassicSingleton anotherInstance =  new ClassicSingleton();
           ...
          &#125;
&#125;
</code></pre>
<p>前面这个代码片段为何能在没有继承ClassicSingleton并且ClassicSingleton类的构造方法是protected的情况下创建其实例？<br>答案是protected的构造方法可以被其子类以及在同一个包中的其它类调用。因为ClassicSingleton和SingletonInstantiator位于相同的包（缺省的包），所以SingletonInstantiator方法能创建ClasicSingleton的实例。<br>这种情况下有两种解决方案：一是你可以使ClassicSingleton的构造方法变化私有的（private）这样只有ClassicSingleton的方法能调用它;然而这也意味着ClassicSingleton不能有子类。有时这是一种很合意的解决方法，如果确实如此，那声明你的单例类为final是一个好主意，这样意图明确，并且让编译器去使用一些性能优化选项。另一种解决方法是把你的单例类放到一个外在的包中，以便在其它包中的类（包括缺省的包）无法实例化一个单例类。</p>
<p>关于ClassicSingleton的第三点感兴趣的地方是，如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>第四点，如果ClasicSingleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>最后也许是最重要的一点，就是例1中的ClassicSingleton类不是线程安全的。如果两个线程，我们称它们为线程1和线程2，在同一时间调用ClassicSingleton.getInstance()方法，如果线程1先进入if块，然后线程2进行控制，那么就会有ClassicSingleton的两个的实例被创建。</p>
<p>正如你从前面的讨论中所看到的，尽管单例模式是最简单的设计模式之一，在Java中实现它也是决非想象的那么简单。这篇文章接下来会揭示Java规范对单例模式进行的考虑，但是首先让我们近水楼台的看看你如何才能测试你的单例类。</p>
<p><strong>测试单例模式</strong></p>
<p>接下来，我使用与log4j相对应的JUnit来测试单例类，它会贯穿在这篇文章余下的部分。如果你对JUnit或log4j不很熟悉，请参考相关资源。</p>
<p>例2是一个用JUnit测试例1的单例模式的案例：<br>例2.一个单例模式的案例</p>
<pre><code>import org.apache.log4j.Logger;
import junit.framework.Assert;
import junit.framework.TestCase;

public class SingletonTest extends TestCase &#123;
       private ClassicSingleton sone = null, stwo = null;
       private static Logger logger = Logger.getRootLogger();

       public SingletonTest(String name) &#123;
          super(name);
       &#125;
       public void setUp() &#123;
          logger.info(&quot;getting singleton...&quot;);
          sone = ClassicSingleton.getInstance();
          logger.info(&quot;...got singleton: &quot; + sone);

          logger.info(&quot;getting singleton...&quot;);
          stwo = ClassicSingleton.getInstance();
          logger.info(&quot;...got singleton: &quot; + stwo);
       &#125;
       public void testUnique() &#123;
          logger.info(&quot;checking singletons for equality&quot;);
          Assert.assertEquals(true, sone == stwo);
       &#125;
&#125;
</code></pre>
<p>例2两次调用ClassicSingleton.getInstance()，并且把返回的引用存储在成员变量中。方法testUnique()会检查这些引用看它们是否相同。例3是这个测试案例的输出：<br>例3.是这个测试案例的输出<br>Buildfile: build.xml</p>
<p>init:<br>     [echo] Build 20030414 (14-04-2003 03:08)</p>
<p>compile:</p>
<p>run-test-text:<br>     [java] .INFO main: [b]getting singleton…[&#x2F;b]<br>     [java] INFO main: [b]created singleton:[&#x2F;b] Singleton@e86f41<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: [b]getting singleton…[&#x2F;b]<br>     [java] INFO main: …got singleton: Singleton@e86f41<br>     [java] INFO main: checking singletons for equality</p>
<pre><code> [java] Time: 0.032

 [java] OK (1 test)
</code></pre>
<p>正如前面的清单所示，例2的简单测试顺利通过—-通过ClassicSingleton.getInstance()获得的两个单例类的引用确实相同;然而，你要知道这些引用是在单线程中得到的。下面的部分着重于用多线程测试单例类。</p>
<p>多线程因素的考虑</p>
<p>在例1中的ClassicSingleton.getInstance()方法由于下面的代码而不是线程安全的：</p>
<pre><code>if(instance == null) &#123;
       instance = new Singleton();
 &#125;
</code></pre>
<p>如果一个线程在第二行的赋值语句发生之前切换，那么成员变量instance仍然是null，然后另一个线程可能接下来进入到if块中。在这种情况下，两个不同的单例类实例就被创建。不幸的是这种假定很少发生，这样这种假定也很难在测试期间出现（译注：在这可能是作者对很少出现这种情况而导致无法测试从而使人们放松警惕而感到叹惜）。为了演示这个线程轮换，我得重新实现例1中的那个类。例4就是修订后的单例类：<br>例4.人为安排的方式</p>
<pre><code>import org.apache.log4j.Logger;
public class Singleton &#123;
    private static Singleton singleton = null;
    private static Logger logger = Logger.getRootLogger();
    private static boolean firstThread = true;

      protected Singleton() &#123;
        // Exists only to defeat instantiation.
    &#125;
    public static Singleton getInstance() &#123;
        if(singleton == null) &#123;
            simulateRandomActivity();
            singleton = new Singleton();
     &#125;
     logger.info(&quot;created singleton: &quot; + singleton);
     return singleton;
  &#125;
private static void simulateRandomActivity() &#123;
     try &#123;
        if(firstThread) &#123;
               firstThread = false;
              logger.info(&quot;sleeping...&quot;);

               // This nap should give the second thread enough time
               // to get by the first thread.
             Thread.currentThread().sleep(50);
           &#125;
         &#125;
         catch(InterruptedException ex) &#123;
            logger.warn(&quot;Sleep interrupted&quot;);
         &#125;
      &#125;
&#125;
</code></pre>
<p>除了在这个清单中的单例类强制使用了一个多线程错误处理，例4类似于例1中的单例类。在getInstance()方法第一次被调用时，调用这个方法的线程会休眠50毫秒以便另外的线程也有时间调用getInstance()并创建一个新的单例类实例。当休眠的线程觉醒时，它也会创建一个新的单例类实例，这样我们就有两个单例类实例。尽管例4是人为如此的，但它却模拟了第一个线程调用了getInstance()并在没有完成时被切换的真实情形。<br>例5测试了例4的单例类：<br>例5.失败的测试</p>
<pre><code>import org.apache.log4j.Logger;
import junit.framework.Assert;
import junit.framework.TestCase;

public class SingletonTest extends TestCase &#123;
       private static Logger logger = Logger.getRootLogger();
       private static Singleton singleton = null;

   public SingletonTest(String name) &#123;
      super(name);
   &#125;
   public void setUp() &#123;
      singleton = null;
   &#125;
  public void testUnique() throws InterruptedException &#123;
  // Both threads call Singleton.getInstance().
  Thread threadOne = new Thread(new SingletonTestRunnable()),
         threadTwo = new Thread(new SingletonTestRunnable());

  threadOne.start();
  threadTwo.start();

  threadOne.join();
  threadTwo.join();
   &#125;
   private static class SingletonTestRunnable implements Runnable &#123;
  public void run() &#123;
     // Get a reference to the singleton.
     Singleton s = Singleton.getInstance();

     // Protect singleton member variable from
     // multithreaded access.
     synchronized(SingletonTest.class) &#123;
        if(singleton == null) // If local reference is null...
           singleton = s;     // ...set it to the singleton
         &#125;
     // Local reference must be equal to the one and
     // only instance of Singleton; otherwise, we have two
              // Singleton instances.
     Assert.assertEquals(true, s == singleton);
      &#125;
       &#125;
&#125;
</code></pre>
<p>例5的测试案例创建两个线程，然后各自启动，等待完成。这个案例保持了一个对单例类的静态引用，每个线程都会调用Singleton.getInstance()。如果这个静态成员变量没有被设置，那么第一个线程就会将它设为通过调用getInstance()而得到的引用，然后这个静态变量会与一个局部变量比较是否相等。<br>在这个测试案例运行时会发生一系列的事情：第一个线程调用getInstance()，进入if块，然后休眠;接着，第二个线程也调用getInstance()并且创建了一个单例类的实例。第二个线程会设置这个静态成员变量为它所创建的引用。第二个线程检查这个静态成员变量与一个局部备份的相等性。然后测试通过。当第一个线程觉醒时，它也会创建一个单例类的实例，并且它不会设置那个静态成员变量（因为第二个线程已经设置过了），所以那个静态变量与那个局部变量脱离同步，相等性测试即告失败。例6列出了例5的输出：<br>例6.例5的输出</p>
<pre><code>Buildfile: build.xml
init:
 	[echo] Build 20030414 (14-04-2003 03:06)
compile:
run-test-text:
INFO Thread-1: sleeping...
INFO Thread-2: created singleton: Singleton@7e5cbd
INFO Thread-1: created singleton: Singleton@704ebb
junit.framework.AssertionFailedError: expected: but was:
       at junit.framework.Assert.fail(Assert.java:47)
       at junit.framework.Assert.failNotEquals(Assert.java:282)
       at junit.framework.Assert.assertEquals(Assert.java:64)
       at junit.framework.Assert.assertEquals(Assert.java:149)
       at junit.framework.Assert.assertEquals(Assert.java:155)
       at SingletonTest$SingletonTestRunnable.run(Unknown Source)
       at java.lang.Thread.run(Thread.java:554)
     [java] .
     [java] Time: 0.577

     [java] OK (1 test)
</code></pre>
<p>到现在为止我们已经知道例4不是线程安全的，那就让我们看看如何修正它。</p>
<p><strong>同步</strong></p>
<p>要使例4的单例类为线程安全的很容易—-只要像下面一个同步化getInstance()方法：</p>
<pre><code>public synchronized static Singleton getInstance() &#123;
       if(singleton == null) &#123;
          simulateRandomActivity();
          singleton = new Singleton();
       &#125;
       logger.info(&quot;created singleton: &quot; + singleton);
       return singleton;
&#125;
</code></pre>
<p>在同步化getInstance()方法后，我们就可以得到例5的测试案例返回的下面的结果：</p>
<pre><code>Buildfile: build.xml

init:
 	[echo] Build 20030414 (14-04-2003 03:15)

compile:
    [javac] Compiling 2 source files

run-test-text:
INFO Thread-1: sleeping...
INFO Thread-1: created singleton: Singleton@ef577d
INFO Thread-2: created singleton: Singleton@ef577d
 	[java] .
 	[java] Time: 0.513

 	[java] OK (1 test)
</code></pre>
<p>这此，这个测试案例工作正常，并且多线程的烦恼也被解决;然而，机敏的读者可能会认识到getInstance()方法只需要在第一次被调用时同步。因为同步的性能开销很昂贵（同步方法比非同步方法能降低到100次左右），或许我们可以引入一种性能改进方法，它只同步单例类的getInstance()方法中的赋值语句。</p>
<p><strong>一种性能改进的方法</strong></p>
<p>寻找一种性能改进方法时，你可能会选择像下面这样重写getInstance()方法：</p>
<pre><code>public static Singleton getInstance() &#123;
       if(singleton == null) &#123;
          synchronized(Singleton.class) &#123;
             singleton = new Singleton();
          &#125;
       &#125;
   return singleton;
&#125;
</code></pre>
<p>这个代码片段只同步了关键的代码，而不是同步整个方法。然而这段代码却不是线程安全的。考虑一下下面的假定：线程1进入同步块，并且在它给singleton成员变量赋值之前线程1被切换。接着另一个线程进入if块。第二个线程将等待直到第一个线程完成，并且仍然会得到两个不同的单例类实例。有修复这个问题的方法吗？请读下去。</p>
<p><strong>双重加锁检查</strong></p>
<p>初看上去，双重加锁检查似乎是一种使懒汉式实例化为线程安全的技术。下面的代码片段展示了这种技术：</p>
<pre><code>public static Singleton getInstance() &#123;
      if(singleton == null) &#123;
         synchronized(Singleton.class) &#123;
               if(singleton == null) &#123;
                 singleton = new Singleton();
               &#125;
        &#125;
      &#125;
      return singleton;
&#125;
</code></pre>
<p>如果两个线程同时访问getInstance()方法会发生什么？想像一下线程1进行同步块马上又被切换。接着，第二个线程进入if 块。当线程1退出同步块时，线程2会重新检查看是否singleton实例仍然为null。因为线程1设置了singleton成员变量，所以线程2的第二次检查会失败，第二个单例类实例也就不会被创建。似乎就是如此。<br>不幸的是，双重加锁检查不会保证正常工作，因为编译器会在Singleton的构造方法被调用之前随意给singleton赋一个值。如果在singleton引用被赋值之后而被初始化之前线程1被切换，线程2就会被返回一个对未初始化的单例类实例的引用。</p>
<p><strong>一个改进的线程安全的单例模式实现</strong></p>
<p>例7列出了一个简单、快速而又是线程安全的单例模式实现：<br>例7.一个简单的单例类</p>
<pre><code>public class Singleton &#123;
       public final static Singleton INSTANCE = new Singleton();
       private Singleton() &#123;
         // Exists only to defeat instantiation.
      &#125;
&#125;
</code></pre>
<p>这段代码是线程安全的是因为静态成员变量一定会在类被第一次访问时被创建。你得到了一个自动使用了懒汉式实例化的线程安全的实现;你应该这样使用它：</p>
<pre><code>Singleton singleton = Singleton.INSTANCE;
singleton.dothis();
singleton.dothat();
...
</code></pre>
<p>当然万事并不完美，前面的Singleton只是一个折衷的方案;如果你使用那个实现，你就无法改变它以便后来你可能想要允许多个单例类的实例。用一种更折哀的单例模式实现(通过一个getInstance()方法获得实例)你可以改变这个方法以便返回一个唯一的实例或者是数百个实例中的一个．你不能用一个公开且是静态的（public static)成员变量这样做．</p>
<p>你可以安全的使用例７的单例模式实现或者是例１的带一个同步的getInstance()方法的实现．然而，我们必须要研究另一个问题：你必须在编译期指定这个单例类，这样就不是很灵活．一个单例类的注册表会让我们在运行期指定一个单例类．</p>
<p>使用注册表<br>使用一个单例类注册表可以：</p>
<p><strong>在运行期指定单例类</strong></p>
<p>防止产生多个单例类子类的实例<br>在例8的单例类中，保持了一个通过类名进行注册的单例类注册表：<br>例8 带注册表的单例类</p>
<pre><code>import java.util.HashMap;
import org.apache.log4j.Logger;

public class Singleton &#123;
       private static HashMap map = new HashMap();
       private static Logger logger = Logger.getRootLogger();

       protected Singleton() &#123;
          // Exists only to thwart instantiation
       &#125;
   public static synchronized Singleton getInstance(String classname) &#123;
      if(classname == null) throw new IllegalArgumentException(&quot;Illegal classname&quot;);
         Singleton singleton = (Singleton)map.get(classname);

      if(singleton != null) &#123;
         logger.info(&quot;got singleton from map: &quot; + singleton);
         return singleton;
      &#125;
      if(classname.equals(&quot;SingeltonSubclass_One&quot;))
        singleton = new SingletonSubclass_One();
    else if(classname.equals(&quot;SingeltonSubclass_Two&quot;))
        singleton = new SingletonSubclass_Two();

      map.put(classname, singleton);
      logger.info(&quot;created singleton: &quot; + singleton);
      return singleton;
       &#125;
       // Assume functionality follows that&#39;s attractive to inherit
&#125;
</code></pre>
<p>这段代码的基类首先创建出子类的实例，然后把它们存储在一个Map中。但是基类却得付出很高的代价因为你必须为每一个子类替换它的getInstance()方法。幸运的是我们可以使用反射处理这个问题。</p>
<p><strong>使用反射</strong></p>
<p>在例9的带注册表的单例类中，使用反射来实例化一个特殊的类的对象。与例8相对的是通过这种实现，Singleton.getInstance()方法不需要在每个被实现的子类中重写了。<br>例9 使用反射实例化单例类</p>
<pre><code>import java.util.HashMap;
import org.apache.log4j.Logger;

public class Singleton &#123;
       private static HashMap map = new HashMap();
       private static Logger logger = Logger.getRootLogger();

   protected Singleton() &#123;
  // Exists only to thwart instantiation
   &#125;
   public static synchronized Singleton getInstance(String classname) &#123;
      Singleton singleton = (Singleton)map.get(classname);

      if(singleton != null) &#123;
         logger.info(&quot;got singleton from map: &quot; + singleton);
         return singleton;
      &#125;
      try &#123;
     singleton = (Singleton)Class.forName(classname).newInstance();
      &#125;
      catch(ClassNotFoundException cnf) &#123;
     logger.fatal(&quot;Couldn&#39;t find class &quot; + classname);
      &#125;
      catch(InstantiationException ie) &#123;
         logger.fatal(&quot;Couldn&#39;t instantiate an object of type &quot; + classname);
      &#125;
      catch(IllegalAccessException ia) &#123;
         logger.fatal(&quot;Couldn&#39;t access class &quot; + classname);
      &#125;
      map.put(classname, singleton);
      logger.info(&quot;created singleton: &quot; + singleton);

      return singleton;
       &#125;
&#125;
</code></pre>
<p>关于单例类的注册表应该说明的是：它们应该被封装在它们自己的类中以便最大限度的进行复用。</p>
<p><strong>封装注册表</strong></p>
<p>例10列出了一个单例注册表类。<br>例10 一个SingletonRegistry类</p>
<pre><code>import java.util.HashMap;
import org.apache.log4j.Logger;

public class SingletonRegistry &#123;
       public static SingletonRegistry REGISTRY = new SingletonRegistry();

       private static HashMap map = new HashMap();
       private static Logger logger = Logger.getRootLogger();

       protected SingletonRegistry() &#123;
          // Exists to defeat instantiation
       &#125;
       public static synchronized Object getInstance(String classname) &#123;
          Object singleton = map.get(classname);

          if(singleton != null) &#123;
             return singleton;
          &#125;
      try &#123;
         singleton = Class.forName(classname).newInstance();
         logger.info(&quot;created singleton: &quot; + singleton);
      &#125;
      catch(ClassNotFoundException cnf) &#123;
         logger.fatal(&quot;Couldn&#39;t find class &quot; + classname);
      &#125;
      catch(InstantiationException ie) &#123;
         logger.fatal(&quot;Couldn&#39;t instantiate an object of type &quot; +
                   classname);
      &#125;
      catch(IllegalAccessException ia) &#123;
         logger.fatal(&quot;Couldn&#39;t access class &quot; + classname);
      &#125;
      map.put(classname, singleton);
      return singleton;
       &#125;
&#125;
</code></pre>
<p>注意我是把SingletonRegistry类作为一个单例模式实现的。我也通用化了这个注册表以便它能存储和取回任何类型的对象。例11显示了的Singleton类使用了这个注册表。<br>例11 使用了一个封装的注册表的Singleton类</p>
<pre><code>import java.util.HashMap;
import org.apache.log4j.Logger;

public class Singleton &#123;

       protected Singleton() &#123;
          // Exists only to thwart instantiation.
       &#125;
       public static Singleton getInstance() &#123;
          return (Singleton)SingletonRegistry.REGISTRY.getInstance(classname);
       &#125;
&#125;
</code></pre>
<p>上面的Singleton类使用那个注册表的唯一实例通过类名取得单例对象。<br>现在我们已经知道如何实现线程安全的单例类和如何使用一个注册表去在运行期指定单例类名，接着让我们考查一下如何安排类载入器和处理序列化。</p>
<p><strong>Classloaders</strong></p>
<p>在许多情况下，使用多个类载入器是很普通的–包括servlet容器–所以不管你在实现你的单例类时是多么小心你都最终可以得到多个单例类的实例。如果你想要确保你的单例类只被同一个的类载入器装入，那你就必须自己指定这个类载入器;例如：</p>
<pre><code>private static Class getClass(String classname)
                                     throws ClassNotFoundException &#123;
 	ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

  	if(classLoader == null)
     classLoader = Singleton.class.getClassLoader();

  	return (classLoader.loadClass(classname));
       &#125;
&#125;
</code></pre>
<p>这个方法会尝试把当前的线程与那个类载入器相关联;如果classloader为null，这个方法会使用与装入单例类基类的那个类载入器。这个方法可以用Class.forName()代替。</p>
<p><strong>序列化</strong></p>
<p>如果你序列化一个单例类，然后两次重构它，那么你就会得到那个单例类的两个实例，除非你实现readResolve()方法，像下面这样：<br>例12 一个可序列化的单例类</p>
<pre><code>import org.apache.log4j.Logger;

public class Singleton implements java.io.Serializable &#123;
       public static Singleton INSTANCE = new Singleton();

       protected Singleton() &#123;
          // Exists only to thwart instantiation.
       &#125;
       private Object readResolve() &#123;
        return INSTANCE;
      &#125;
   &#125;
</code></pre>
<p>上面的单例类实现从readResolve()方法中返回一个唯一的实例;这样无论Singleton类何时被重构，它都只会返回那个相同的单例类实例。<br>例13测试了例12的单例类：<br>例13 测试一个可序列化的单例类</p>
<pre><code>import java.io.*;
import org.apache.log4j.Logger;
import junit.framework.Assert;
import junit.framework.TestCase;

public class SingletonTest extends TestCase &#123;
       private Singleton sone = null, stwo = null;
       private static Logger logger = Logger.getRootLogger();

      public SingletonTest(String name) &#123;
          super(name);
       &#125;
       public void setUp() &#123;
          sone = Singleton.INSTANCE;
          stwo = Singleton.INSTANCE;
       &#125;
       public void testSerialize() &#123;
          logger.info(&quot;testing singleton serialization...&quot;);
        [b]      writeSingleton();
          Singleton s1 = readSingleton();
          Singleton s2 = readSingleton();
          Assert.assertEquals(true, s1 == s2);[/b]   &#125;
           private void writeSingleton() &#123;
          try &#123;
             FileOutputStream fos = new FileOutputStream(&quot;serializedSingleton&quot;);
             ObjectOutputStream oos = new ObjectOutputStream(fos);
             Singleton s = Singleton.INSTANCE;

             oos.writeObject(Singleton.INSTANCE);
             oos.flush();
          &#125;
          catch(NotSerializableException se) &#123;
             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());
          &#125;
          catch(IOException iox) &#123;
             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());
          &#125;
       &#125;
       private Singleton readSingleton() &#123;
          Singleton s = null;

          try &#123;
             FileInputStream fis = new FileInputStream(&quot;serializedSingleton&quot;);
             ObjectInputStream ois = new ObjectInputStream(fis);
             s = (Singleton)ois.readObject();
          &#125;
          catch(ClassNotFoundException cnf) &#123;
             logger.fatal(&quot;Class Not Found Exception: &quot; + cnf.getMessage());
          &#125;
          catch(NotSerializableException se) &#123;
             logger.fatal(&quot;Not Serializable Exception: &quot; + se.getMessage());
          &#125;
          catch(IOException iox) &#123;
             logger.fatal(&quot;IO Exception: &quot; + iox.getMessage());
          &#125;
          return s;
       &#125;
       public void testUnique() &#123;
          logger.info(&quot;testing singleton uniqueness...&quot;);
          Singleton another = new Singleton();

          logger.info(&quot;checking singletons for equality&quot;);
          Assert.assertEquals(true, sone == stwo);
       &#125;
&#125;
</code></pre>
<p>前面这个测试案例序列化例12中的单例类，并且两次重构它。然后这个测试案例检查看是否被重构的单例类实例是同一个对象。下面是测试案例的输出：</p>
<pre><code>Buildfile: build.xml

init:
 	[echo] Build 20030422 (22-04-2003 11:32)

compile:

run-test-text:
 	[java] .INFO main: testing singleton serialization...
 	[java] .INFO main: testing singleton uniqueness...
 	[java] INFO main: checking singletons for equality

 	[java] Time: 0.1

 	[java] OK (2 tests)
</code></pre>
<p><strong>单例模式结束语</strong></p>
<p>单例模式简单却容易让人迷惑，特别是对于Java的开发者来说。在这篇文章中，作者演示了Java开发者在顾及多线程、类载入器和序列化情况如何实现单例模式。作者也展示了你怎样才能实现一个单例类的注册表，以便能够在运行期指定单例类。</p>
<p>原文：<a target="_blank" rel="noopener" href="http://calmness.iteye.com/blog/60179">http://calmness.iteye.com/blog/60179</a></p>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div>您的支持是我原创的动力！</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="申艳超 WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="申艳超 Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/singleton/" rel="tag"># singleton</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/2012/11/02/how-webdriver-works/" rel="prev" title="Selenium WebDriver 工作原理">
                  <i class="fa fa-chevron-left"></i> Selenium WebDriver 工作原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/2012/11/02/bridge-in-java/" rel="next" title="设计模式：桥接(bridge) in java">
                  设计模式：桥接(bridge) in java <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2012 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">申艳超</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"vFAoofuVWgdHsCv6B6BtqROc-gzGzoHsz","app_key":"ANWUkmboGiNDNRmf2iVlUIGt","server_url":null,"security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
