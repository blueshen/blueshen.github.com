<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：测试 | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/blog/categories/测试/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-03-18T21:07:21+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ut-maven-plugin]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/12/14/ut-maven-plugin/"/>
    <updated>2013-12-14T21:31:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/12/14/ut-maven-plugin</id>
    <content type="html"><![CDATA[<h3>ut-maven-plugin简介</h3>

<p>这是一个用来生成Unit Test模板的maven插件。使用这个插件不能彻底解决单元测试的问题，她还没有这么智能，只能按照自己的理解帮助你生成一个方法的单元测试方法框架。通过这些自动生成的代码，来提高写单元测试的生产率。<br/>
《程序员修炼之道》里的提示29说：“Write Code That Writes Code”。这也是ut-maven-plugin所做的，帮助程序员生成需要重复的工作以及共性的工作。</p>

<p>也许，现在她还小，还不足够智能，智能到足以测试你的方法的所有业务逻辑。但是在将来，她将会越来越智能。帮你解决更多的单元测试问题，或者解决更多共性的问题。</p>

<!--more-->


<h3>实现原理</h3>

<p>如何解析源码，这是首先需要解决的问题。在计算机科学中，有<strong>抽象语法树(Abstract Syntax Tree)</strong>这一概念，它是源代码的抽象语法结构的树状表现形式。树上的每个节点都表示源代码中的一种结构。利用抽象语法树就可以对源码进行一个全方位的解析，从而知道如何生成特定的测试代码。</p>

<p>Eclipse（以及其它IDE）中就提供了AST的解析功能，比如Eclipse里的outline(大纲)视图。</p>

<p><img src="/images/blog/2013/eclipse-outline.png" alt="" /></p>

<p>同时,Eclipse也提供的有抽象语法树视图，即ASTView。</p>

<p><img src="/images/blog/2013/eclipse-ast-view.png" alt="" /></p>

<p>本插件选用<a href="https://code.google.com/p/javaparser/">JavaParser</a>来分析源码，提取并生成测试代码。</p>

<h3>如何使用这个工具？</h3>

<p>这个插件一个被我放到了<a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22ut-maven-plugin%22">Maven Central</a>上，因此，你可以直接在pom.xml里添加上这个插件就可以了。同时建议你使用最新的版本。 <br/>
比如：</p>

<pre><code>&lt;plugin&gt;
&lt;groupId&gt;cn.shenyanchao.ut&lt;/groupId&gt;
&lt;artifactId&gt;ut-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;0.2.9&lt;/version&gt;
&lt;executions&gt;
    &lt;execution&gt;
        &lt;id&gt;source2test&lt;/id&gt;
        &lt;phase&gt;process-test-sources&lt;/phase&gt;
        &lt;goals&gt;
            &lt;goal&gt;source2test&lt;/goal&gt;
        &lt;/goals&gt;
    &lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<h3>解决了什么问题？</h3>

<p>以<a href="https://github.com/spring-projects/spring-petclinic">spring-petclinic</a>中的代码为例。</p>

<p>下面的Service代码：</p>

<pre><code>package org.springframework.samples.petclinic.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.model.PetType;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;

@Service
public class ClinicServiceImpl implements ClinicService {

    @Autowired
    private PetRepository petRepository;
    //省略
    ......

    @Override
    @Transactional(readOnly = true)
    public Pet findPetById(int id) throws DataAccessException {
        return petRepository.findById(id);
    }
    //省略
    ......

}
</code></pre>

<p>那么，我们自己手工写的单元测试代码有可能是这样的：</p>

<pre><code>package org.springframework.samples.petclinic.service.test;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.samples.petclinic.model.Pet;
import org.springframework.samples.petclinic.repository.PetRepository;
import org.springframework.samples.petclinic.service.ClinicServiceImpl;

import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

public class ClinicServiceImplTest {

    @InjectMocks
    private ClinicServiceImpl clinicService = new ClinicServiceImpl();

    @Mock
    private PetRepository petRepository;

    @Before
    public void initMocks() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void findPetByIdTest() {
        when(petRepository.findById(anyInt())).thenReturn(new Pet());
        Pet pet = clinicService.findPetById(1);
        Assert.assertNotNull(pet);
    }
</code></pre>

<p>如果，有很多个类需要写单元测试，那么我们会发现有很多代码是具有共性的，或者是有一定规律的。但从这个类来说，我们认为大部分代码都是可以通过对源代码进行分析得到的，除了以下的业务逻辑部分：</p>

<pre><code>        when(petRepository.findById(anyInt())).thenReturn(new Pet());
        Pet pet = clinicService.findPetById(1);
</code></pre>

<p>因此余下的代码都可以由插件来完成，使得程序员直接关注于业务逻辑部分的编写。大大的提高了程序员单元测试的编写效率，甚至使程序员们爱上单测。</p>

<p>当然，这里只是一个例子，如果能抽象出更多的共性，本插件就可以进行不断的扩展。简单的来说，有共性有规律就可以自动生成出来。随着不断的扩展，ut-maven-plugin将越来越智能化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sonar的安装与使用]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/09/04/use-sonar/"/>
    <updated>2013-09-04T17:02:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/09/04/use-sonar</id>
    <content type="html"><![CDATA[<h3>什么是Sonar？</h3>

<p><a href="http://www.sonarqube.org/">Sonar</a>是一个开源的代码质量管理平台。它能对代码进行如下7个维度的管理。</p>

<p><img src="http://www.sonarqube.org/wp-content/themes/sonar/images/7axes.png" alt="" />
使用插件，它可以对20多种语言进行代码质量管理，这其中包括Java，C#，C/C++,PL/SQL等等。</p>

<h3>安装Sonar</h3>

<p>1.下载sonar,地址<a href="http://www.sonarqube.org/downloads/">http://www.sonarqube.org/downloads/</a>。通常选取稳定版本下载即可，这是一个zip文件。 <br/>
2.解压下载的sonar到一个目录。我们称这个解压后的路径为SONAR_HOME  <br/>
3.进入$SONAR_HOME/bin/${os-version}/,找到sonar.sh,执行<code>./sonar.sh console</code>即可。在windows下是StartSonar.bat。<br/>
4.现在进入<a href="http://localhost:9000">http://localhost:9000</a>,就看到了界面。默认的登录使用admin:admin</p>

<p>这个时候，Sonar已经运行啦。但是在生产环境是不行的。上面跑起来的只是一个样例，使用的是h2内存数据库。我们可不想重启服务后，生产环境的数据都没了。</p>

<!--more-->


<h3>配置Sonar数据库</h3>

<p>1.首先新建一个数据库。</p>

<pre><code>CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;  
grant all privileges on sonar.* to 'sonar'@'%' identified by '你的密码';  
flush privileges; 
</code></pre>

<p>这样就准备好了数据库sonar,并授权给sonar这个用户。</p>

<p>2.找到$SONAR_HOME/conf/sonar.properties。
注释掉默认的数据库配置，然后配上自己的数据库信息即可。这里以mysql为例。</p>

<pre><code># Comment the following line to deactivate the default embedded database.
#sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar
#sonar.jdbc.driverClassName:                org.h2.Driver

-------------------
# The schema must be created first.
</code></pre>

<p>sonar.jdbc.username:                       sonar
sonar.jdbc.password:                       sonar</p>

<pre><code>#----- MySQL 5.x
# Comment the embedded database and uncomment the following line to use MySQL
sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true

# Optional properties
sonar.jdbc.driverClassName:                com.mysql.jdbc.Driver
</code></pre>

<p>配置好之后，这样所有的数据都会存放到mysql内啦。不用再担心数据问题啦。要添加其他数据库，同理。</p>

<h3>把Sonar变为中文</h3>

<p>英文看这不方便啊。有2种方法可以将Sonar变为中文界面。</p>

<p>1.用管理员登录后，在Update Center种找到Localization里的Chinese Pack安装就可以了。<br/>
2.直接下载<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar">http://repository.codehaus.org/org/codehaus/sonar-plugins/l10n/sonar-l10n-zh-plugin/1.6/sonar-l10n-zh-plugin-1.6.jar</a>这个插件jar包到$SONAR_HOME/extensions/plugins内，重启即可。</p>

<h3>把Sonar放到JEE容器内</h3>

<p>默认的情况下，sonar启动是采用内置的jetty的，为了方便管理，一般在生产环境可以放到JEE容器内，这里就以Tomcat为例了。 <br/>
Sonar在经过上面几步的配置后，已经满足了基本的需求。接下来就可以进入到$SONAR_HOME/war/内。执行build-war命令。这样就生成了一个sonar.war，把这个war包发布到Tomcat即可。</p>

<h3>如何对源码进行检测</h3>

<p>1.配置maven的settings.xml,添加一下内容：</p>

<pre><code>    &lt;profile&gt;
         &lt;id&gt;sonar&lt;/id&gt;
         &lt;activation&gt;
             &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
         &lt;/activation&gt;
         &lt;properties&gt;
              &lt;sonar.jdbc.url&gt;
              jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8
              &lt;/sonar.jdbc.url&gt;
              &lt;sonar.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/sonar.jdbc.driver&gt;
              &lt;sonar.jdbc.username&gt;sonar&lt;/sonar.jdbc.username&gt;
              &lt;sonar.jdbc.password&gt;sonar&lt;/sonar.jdbc.password&gt;
             &lt;sonar.host.url&gt;http://localhost:9000/sonar&lt;/sonar.host.url&gt;
         &lt;/properties&gt;
      &lt;/profile&gt;
</code></pre>

<p>其中的数据库配置以及sonar主机地址都依据实际进行修改即可。 <br/>
2.在maven项目种执行</p>

<pre><code>mvn clean install
mvn sonar:sonar
</code></pre>

<p>3.打开sonar主页，就可以看到结果了。</p>

<h3>Sonar与Jenkins的集成。</h3>

<p>1.安装<a href="http://docs.codehaus.org/display/SONAR/Jenkins+Plugin">jenkins-sonar-plugin</a>到Jenkins内。  <br/>
2.在Jenkins里的系统配置中，填写Sonar安装信息。  <br/>
3.在Jenkins的JOB中，配置post-build action中添加上Sonar即可。这样在项目构建后，会自动的执行Sonar分析。并将结果放在首页进行展现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《探索式软件测试》读书笔记(1)]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1/"/>
    <updated>2013-01-21T19:14:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/01/21/exploratory-software-testing-reading-notes-1</id>
    <content type="html"><![CDATA[<p>书中，完全以旅游来讲解各种测试方法，从而让晦涩的理论变得浅显易懂。 <br/>
一般情况下，旅游地都会有这样一些区域：</p>

<ul>
<li><strong>商业区</strong>: 早晚交通拥挤，上班紧张。商业区有银行、办公楼、各类商店。对软件来说，指的是“在那里完成实际业务”。</li>
<li><strong>历史区</strong>: 城市一般都有写历史古迹，历史事件吸引着大批的旅游者。对软件来说，就是“历史遗留代码”。</li>
<li><strong>旅游区</strong>: 专门针对旅游者的区域，而一般人是不会去的。这是说故宫、长城吗？软件的有些特性和功能就是专门针对新用户的，老用户则不再使用。</li>
<li><strong>娱乐区</strong>: 旅游者看了所有景点和名胜古迹后，通常是很累的，筋疲力尽之后难免要去一些地方娱乐娱乐的，借此来消磨时间。软件也有这样的辅助特性和功能。</li>
<li><strong>旅馆区</strong>: 是人总是要有个休息的地方，睡一觉。可有时候，“休息”时还是很忙的。软件尤其如此。</li>
<li><strong>破旧区</strong>：每个城市都有阴暗的一面，但也有很多人无限向往之，贫民窟的百万富翁之类的。这些地方尽量不去，但是这些地方也可能存在一些漏洞。</li>
</ul>


<!--more-->


<h3>商业区测试类型</h3>

<p>商业区特点在于，上下班高峰以及午餐时间。并且是工作得以完成的地方。</p>

<blockquote><p><strong>指南测试法</strong>： 测试人员按照用户手册进行操作。 <br/>
各大旅游地，通常都有各种旅游攻略，告诉你应该去哪里，怎么选择路线等等。</p>

<p><strong>卖点测试法</strong>： 按照销售人员对客户演示的顺序（卖点）进行测试。 <br/>
令旅游者向往的任何一个地方一定有吸引他们的理由。</p>

<p><strong>地标测试法</strong>： 选择一个功能点，然后向另外的功能点测试。<br/>
在森林里漫步，首先要定位一个大致的方向，然后从一个地标开始走，走到下一个地标，最终到达目的地。</p>

<p><strong>极限测试法</strong>： 向软件提出很多难以回答的问题。 <br/>
旅游中，你可能会有很多问题要问，你的导游需要来回答你提出的问题。那如何判断一个导游是否真的很牛呢，发挥你的能力，向导游尽可能的发问。</p>

<p><strong>快递测试法</strong>： 专注与数据，保证数据在任何出现的地方都是同一个。<br/>
信息时代，网购盛行，快递更是得到大家青睐。但绝不允许出现的是，快递的东西在整个运输过程中发生了变化。即使是A->B->C->A也是不允许的，通常这个快递公司不会这么傻逼的，因此要绝对保证A->A->A->A，不能开封的说。</p>

<p><strong>深夜／清晨测试法</strong>： 在软件的空闲时段，去测试一些功能。 <br/>
下班后，城市很拥挤，这个时候的商业区是空荡荡的。但是，其实很多人还是在忙碌的运行的，以用来支持第2天的正常运转，比如设备检修，打扫卫生等等。对应与软件来说，这时候通常会有一些数据归档，定时任务等工作。这是软件人员需要关注的。</p>

<p><strong>遍历测试法</strong>： 通过选定一个目标，然后使用可以发现的最短路径来访问目标包含的所有对象。  <br/>
城市内的垃圾车，需要在夜间将各个地方的垃圾运走，垃圾车的司机通常对城市的所有路径都是特别熟悉的，他们通常都能按预先的规划，利用最短路径，将一个地方的垃圾装上，然后另外一家。</p></blockquote>

<h3>历史区测试类型</h3>

<p>主要是针对老功能以及修复代码的测试。</p>

<blockquote><p><strong>恶邻测试法</strong>： 随着测试的深入，发现BUG较多的区域，通常值得反复的测试。<br/>
每个旅游城市都有些不好的地方，旅游者通常被告知避免访问那里。但是也总有人会去的，通常这些地方更值得测试人员关注。</p>

<p><strong>博物馆测试法</strong>： 历史遗留代码值得测试人员多加关注。<br/>
展示古董的博物馆深受旅游者喜爱，但同时也要保证同现代建筑的和谐。</p>

<p><strong>上一版测试法</strong>： 当前产品如果是对先前版本的更新，那就必须运行先前版本的所有场景和测试用例。</p></blockquote>

<h3>娱乐区测试类型</h3>

<p>旅游者除了在繁忙的观光景点之外，还需要安排一些休闲时间。软件需要测试那些辅助特性，而不是主线特性，并确保这2种特性能够结合在一起。</p>

<blockquote><p><strong>配角测试法</strong>：鼓励测试人员，专注于某些特定特性，他们虽然不是主要功能，但是很可能紧邻着主要功能，容易引起别人的注意。 <br/>
导游向你介绍一栋建筑，可能你却毫无兴趣，只关注于建筑边草地上的MM。</p>

<p><strong>深巷测试法</strong>： 测试那些最不可能被用到或者那些最不吸引用户的特性。 <br/>
高质量的旅游是去大家喜闻乐见的地方，质量不好的旅游则是指到了别人不愿意去的地方。</p>

<p><strong>通宵测试法</strong>： 让程序一直运行，而不去关闭他。<br/>
通宵旅游，又称为夜总会之游。很多人都会在夜店狂欢，不断的喝酒，考验人的体力与素质。</p></blockquote>

<h3>旅游区测试类型</h3>

<p>每个重视旅游的城市，都有专供旅游者聚集的地方。旅行通常走马观花，简短。对软件来说，旅游不关心软件是否工作，关心的是快速访问软件的各种功能，仅仅在于到此一游。</p>

<blockquote><p><strong>收藏家测试法</strong>：  收集软件的输出，越多越好。尽可能观察所有的输出结果是否正确。<br/>
旅游区，通常都会有一些特色的产品或者赠品，甚至是门票。而有些游客是很喜欢收集这些东西的，尤其是免费的东西。</p>

<p><strong>长路径测试法</strong>： 测试距离目标功能点尽可能远的特性。指导思想是到达目的地之前尽量多的在应用程序中穿行。<br/>
在旅行中，有可能只是乘坐各种交通工具，往来与各个景点。殊不知，有时候，路上的风景也许更加的宜人，正所谓，慢慢走欣赏啊。</p>

<p><strong>超模测试法</strong>： 关注表面的东西，测试界面。<br/>
旅游中见到的都是美女，这是多么惬意的事情啊，还管什么旅游不旅游的呢。</p>

<p><strong>测一送一法</strong>: 测试同一个应用多个拷贝的情况。<br/>
旅行中，买一送一的促销手段，相比大家都了解。但这里不太一样，通常是从另外一个角度来说的，是说，如果你在一个拷贝上发现了一个缺陷，那么所有的拷贝都有同样的缺陷。</p>

<p><strong>苏格兰酒吧测试法</strong>： 测试者需要穷尽各种努力，来找到很不容易找的功能点，并测试之。<br/>
作者朋友，在旅游中加入了一个苏格兰泡吧团，从而找到很多隐藏于社区的各类酒吧。如果没有他们的带领，可能永远找不到这些地方。适用与大型的项目。</p></blockquote>

<h3>旅馆区测试类型</h3>

<p>休息的地方，远离喧嚣的热门景点。要求测试人员，放过主要的以及最受欢迎的功能，而测试一些经常被忽略或者测试计划中较少描述的次要辅助功能。</p>

<blockquote><p><strong>取消测试法</strong>： 启动操作然后停止它。学会使用取消按钮。 <br/>
任何一个旅行，都有可能因为天气、飞机、或者病痛而被迫中断。</p>

<p><strong>懒汉测试法</strong>： 测试人员做尽量少的实际工作，多使用默认值。程序则需要忙碌的来处理。 <br/>
一个旅游团，总有人不积极参与，那么导游通常需要积极努力，试着吸引懒汉来享受他的旅程。</p></blockquote>

<h3>破旧区测试类型</h3>

<blockquote><p><strong>破坏测试法</strong>： 试图利用每个可能的机会暗中破坏应用程序。让操纵环境变得恶劣。</p>

<p><strong>反叛测试法</strong>： 输入最不可能的数据，或者已知的恶意输入。<br/>
旅行团中，通常有这样的人，当大家都惊叹于某著名标志物时，他却惊呼地上的一只老鼠很迷人。总有一些人是对着干的。</p>

<p><strong>强迫症测试法</strong>： 患有“强迫症”的测试人员，一遍又一遍的输入同样的数据，执行同样的操作。 <br/>
如果步行旅游，但是规定参加它的人不允许踩到地上的任何裂缝，很难想象会有多少人感兴趣。但在测试中，通常会让人有所收获。</p></blockquote>
]]></content>
  </entry>
  
</feed>
