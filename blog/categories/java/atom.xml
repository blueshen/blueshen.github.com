<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Blues 小站]]></title>
  <link href="http://blueshen.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://blueshen.github.com/"/>
  <updated>2012-10-24T12:15:03+08:00</updated>
  <id>http://blueshen.github.com/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java字符编码及其使用详解]]></title>
    <link href="http://blueshen.github.com/blog/2012/10/23/encode-in-java/"/>
    <updated>2012-10-23T18:58:00+08:00</updated>
    <id>http://blueshen.github.com/blog/2012/10/23/encode-in-java</id>
    <content type="html"><![CDATA[<h2>Java的编译存储</h2>

<p>Java是跨平台的一种语言，这一概念想必已经深入人心。Java是如何实现跨平台的呢?其中起到重大作用的便是Unicode编码。在使用IDE进行开发时，比如ECLIPSE,IDEA等，可以指定源文件（.java）的编码格式，此处的编码格式是指Java文件自身的编码。Java文件可以用各种编码进行存储，考虑到兼容中文字符，大多采用GBK,UTF-8,GB18030等编码格式。但是经过javac命令编译后，生成的.class文件毫无疑问都是Unicode编码。这样在class被加载进JVM后，所有的对象都是Unicode进行编码的，这确保了Java的跨平台特性。<br/>
<strong>简言之</strong></p>

<p>.java(任意编码) ---> .class(Unicode) ---> JVM内（Unicode）</p>

<!--more-->


<h2>是什么导致了乱码的出现？</h2>

<p>在JVM内，从class文件加载的源码全部以UNICODE编码。即使如<code>String str = "中国";</code>这样的语句，在JVM内存中仍然是unicode编码的。可是，程序本身难免牵涉到外部文件的读写、与数据库的交互等。这样就会造成很多非unicode编码的字符存在于JVM中，这也就是乱码出现的根本原因所在。</p>

<h2>Java中如何实现字符编码转换？</h2>

<p>String类提供了三个重要的函数：</p>

<pre><code>getBytes(String charsetName)
getBytes()
new String(byte[],String charsetName)
</code></pre>

<p><code>getBytes(String charset)</code>的作用是将字符串按照指定的charset编码，返回其字节方式的表示。具体来说，实现的是从unicode-->charset的转变。比如“中文”，在JVM内存储为“4e2d 6587”,如果设置charset为GBK,则被编码为“d6d0 cec4”。如果charset=UTF-8,那么结果是“e4 b8 ad e6 96 87”。如果charset=ISO-8859-1,由于无法编码，将返回“3f 3f”,这是两个问号。这是因为Unicode->ISO-8859-1不能完成这两个字符集之间的映射，因此使用时需要注意，这也为乱码提供了存在的可能性。</p>

<p><code>getBytes()</code>与上面这个功能一致，只不过charset是采用的系统默认的。系统默认的charset是什么呢？恐怕在不同的机器上有不同的charset。当前环境的默认charset可以通过<code>Charset.defaultCharset()</code>来查看，据个人测试，eclipse内是“UTF-8”,windows中文环境默认是“GBK”。因此当你写下getBytes()的时候，乱码的祸根已经种下，当程序在不同的环境运行时，结果可能就不一样，乱码就这样铺天盖地铺面而来了。哭吧！</p>

<p><code>new String(byte[],String charsetName)</code>的作用是将字节数组按照charset进行识别，最终转化为Unicode存储在JVM内。因此，如上面所说，如果byte[]是以UTF-8等编码存储的时候，如果按照ISO-8859-1这些不能映射的编码识别，仍旧出现乱码。</p>

<p>因此，使用诸如<code>new String(str.getBytes("utf-8"), "gbk")</code>这种类似的转化时，需要谨慎，防止字符集的不可映射造成的乱码。</p>

<p><strong>完美解决方案：</strong> <br/>
考虑到Java的编译存储，以及字符在JVM中的组织格式。其实需要自己完成的就是： <br/>
任意编码的字符 --> unicode --->任意编码的目标字符
也就是在InputStream时，指定源字符编码格式，这样Java会自动转换为JVM内部的Unicode格式。而在OutputStream时，指定目标编码格式，Java会自动从Unicode转化为目标编码。Unicode是一个桥梁，而这种转换是不需认为控制的。
以OutputStream为例：</p>

<pre><code>String str = "123中文";
System.out.println(str);
System.out.println("默认字符:" +Charset.defaultCharset());
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File("e://encode.txt")),"GBK"));
writer.write(str);
writer.close();
</code></pre>

<p>在eclipse内，源文件是以UTF-8进行编码的，默认字符也为UTF-8,运行后encode.txt,内容正确显示，编码格式正确。</p>

<p>在windows cmd下进行javac,java进行执行。控制台输出“123 涓  .. ”等乱码。总之中文字符不能显示啊。查看encode.txt，内容倒是无乱码，编码格式怎么是UTF-8呢。我又一次纠结了？<code>System.out.println()</code>是不受环境影响的啊，它总能够以Unicode方式进行显示的啊。Java不至于这么弱吧。 <br/>
好吧，继续GOOGLE.BAIDU,找到了原因所在。javac 有这样一个参数<code>-encoding</code>来指定.java的编码格式。如果没有指定，那么编译时，认为编码格式为<code>Charset.defaultCharset()</code>,显然本例源码是以UTF-8进行编码的，直接javac是以GBK来读取的，那么在读到JVM成为UNICODE编码时，已经是乱码状态，不再是“123中文”了。<code>System.out.println()</code>只是按照实际情况进行了输出，因此在编译时，必须指定源文件的编码格式，保证了在Java文件内的常量字符的正常显示。</p>

<pre><code>javac -encoding utf-8 *.java
</code></pre>
]]></content>
  </entry>
  
</feed>
