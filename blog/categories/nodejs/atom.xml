<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：nodejs | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-03-22T15:28:25+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[qunit 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/22/qunit-in-brief/"/>
    <updated>2013-03-22T15:21:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/22/qunit-in-brief</id>
    <content type="html"><![CDATA[<h1>QUnit</h1>

<p>QUnit是一个强大的JavaScript单元测试框架，用于调试代码。该框架是由jQuery团队的成员所开发，并且是jQuery的官方测试套件。任意正规JavaScript代码QUnit都能测试。 <br/>
<a href="http://qunitjs.com/">项目官网</a> <br/>
<a href="https://github.com/jquery/qunit">文件下载地址</a></p>

<h1>建立测试程序</h1>

<p>建立html测试页面，引入 <code>qunit.js</code> 和 <code>qunit.css</code> 这两个必需的文件。其中<code>qunit.js</code>是测试套件程序，<code>qunit.css</code>用于控制测试套件的结果显示的样式。</p>

<pre><code>&lt;!--sample.html:--&gt;
&lt;html&gt;
    &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
  &lt;title&gt;QUnit basic example&lt;/title&gt;
  &lt;link rel="stylesheet" href="./resources/qunit.css"&gt;
&lt;script type="text/javascript" src="./resources/jquery.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="qunit"&gt;&lt;/div&gt;
  &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;script src="./resources/qunit.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    test( "a basic test example", function() {
      var value = "hello";
      equal( value, "hello", "We expect value to be hello" );
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<!--more-->


<p>其中放置的文件及文件结构如下：</p>

<pre><code>|-qunit-test   
|  |-sample.html   
|  |-resources   
|  |    |-qunit.js   
|  |    |-qunit.css
|  |    |-jquery.js   
</code></pre>

<p>测试的结果会由<code>qunit.js</code>控制输出到页面代码中的<code>&lt;div id="qunit"&gt;&lt;/div&gt;</code>中。另外一个必不可少的元素是<code>&lt;div id=""qunit-fixture""&gt;&lt;/div&gt;</code>。在每个test执行完毕后，如果改动了该元素，会自动重置。<code>jquery.js</code>的引入是为了测试使用jQuery语法写的程序。 <br/>
在浏览器中打开sample1.html可以看到结果显示如下图所示： <br/>
<img src="" title="/images/blog/qunit-pic.png" alt="qunit的用例运行显示结果" /></p>

<h1>测试框架使用说明</h1>

<p>标题下面有一条横线，绿色表示全部用例正确，红色表示至少有一个用例错误。 <br/>
下面是3个checkbox。"Hide passed tests"点击后可以过滤掉通过的用例，只显示失败的用例。"Check for Globals"，用来检查window对象在test运行前后的变化，如果出现变化，则会报错。"No try-catch"用来显示测试用例中抛出的异常，当选中时直接将其死掉，不选中时则显示报错信息。对每个测试用例，标题中包含（x,y,z）表示总共有z个断言，y个是正确的，x个是错误的。</p>

<h1>断言</h1>

<ul>
<li><strong>ok( truthy [, message ] )</strong>   判断是否为true</li>
<li><strong>equal( actual, expected [, message ] )</strong>    判断actual==expected</li>
<li><strong>deepEqual( actual, expected [, message ] )</strong>    判断actual===expected</li>
</ul>


<p>用例如下：</p>

<pre><code>test("assertion",function(){   

    ok( true, "true succeeds" );
    ok( NaN, "NaN fails" );

    equal( 0, 0, "0, 0 : equal succeeds" );
    equal( "", 0, "Empty, 0: equal succeeds" );
    equal( null, "", "null, empty: equal fails" );

    var obj = { foo: "bar" };
    deepEqual( obj, { foo: "bar" }, "Two objects can be the same in value" );
    equal( "", 0, "Empty, 0: equal succeeds" );
});    
</code></pre>

<h1>测试同步代码</h1>

<p>在同步代码的测试中，有两种方式： <br/>
-   test( name, expected, fucntion(){...})：expceted指assertion的数量。 <br/>
-   test( name, function(){expected(amount);...})：在function中增加expected(amount)，amount表示assertiong的数量。</p>

<p>test()是常规的测试用例，并且默认是同步的，这意味着他们是一个接一个的运行。expected()最有价值的地方在于callback函数的测试。当callback函数因为任何原因不能执行时，会造成实际断言的数量不等于expected值，这时会有额外的错误提示。</p>

<pre><code>test( "a test", 2, function() {
    ok( true, "sucess" );
    ok( false, "fail" );
});   

test( "a test", function() {
  expect( 2 );

  function calc( x, operation ) {
    return operation( x );
  }

  var result = calc( 2, function( x ) {
    ok( true, "calc() calls operation function" );
    return x * x;
  });

  equal( result, 4, "2 square equals 4" );
});
</code></pre>

<h1>测试异步代码</h1>

<p>对Ajax请求或通过setTimeout()或sestInterval()调用的方法，需要使用异步测试函数asyncTest()。</p>

<pre><code>asyncTest( "asynchronous test: one second later!", function() {
  expect( 1 );

  setTimeout(function() {
     ok( true, "Passed and ready to resume!" );
     start();
  }, 1000);
});      
</code></pre>

<h1>用户行为的测试</h1>

<p>测试用户行为时，无法使用一个函数就搞定，通常需要使用一个匿名函数绑定到元素的事件上来模拟。事件的触发使用<code>trigger()</code>或者<code>triggerHandler()</code>来实现。</p>

<pre><code>test( "div click test", 1, function() {
  var $body = $( "#qunit-fixture" );

  $body.bind( "click", function() {
    ok( true, "body was clicked!" );
  });

  $body.trigger( "click" );
});
</code></pre>

<p>下面是Qunit中的一个demo例子，其中模拟了一个key的记录器<code>KeyLogger()</code>，在test中初始化了一个事件event，并且使触发了两次，：</p>

<pre><code>function KeyLogger( target ) {
  if ( !(this instanceof KeyLogger) ) {
    return new KeyLogger( target );
  }
  this.target = target;
  this.log = [];

  var self = this;

  this.target.bind( "keydown", function( event ) {
    self.log.push( event.keyCode );
  });
}
test( "keylogger api behavior", function() {

  var event,
      $doc = $( document ),
      keys = KeyLogger( $doc );

  // trigger event
  event = $.Event( "keydown" );

  event.keyCode = 'A';
  $doc.trigger( event );
  $doc.trigger( event );

  // verify expected behavior
  equal( keys.log.length, 2, "2 key was logged" );
  equal( keys.log[ 0 ], 'A', "correct key was logged" );

});   
</code></pre>

<h1>模块化</h1>

<p>为了使自己的用例的顺序更加富有逻辑性，可以使用module()函数对用例进行分组。对出现在某个module（）后面的所有用例都被分在该组中。</p>

<pre><code>module( "group a" );
test( "a basic test example", function() {
  ok( true, "this test is fine" );
});
test( "a basic test example 2", function() {
  ok( true, "this test is fine" );
});

module( "group b" );
test( "a basic test example 3", function() {
  ok( true, "this test is fine" );
});
test( "a basic test example 4", function() {
  ok( true, "this test is fine" );
});
</code></pre>

<p>除了可以进行分组之外，module()还可以从测试用例中抽取通用的代码，用可选的第二个参数来定义每个test在运行之前、之后的函数。</p>

<pre><code>module( "module", {
  setup: function() {
    ok( true, "one extra assert per test" );
  }, teardown: function() {
    ok( true, "and one extra assert after each test" );
  }
});
test( "test with setup and teardown", function() {
  expect( 3 );
  ok( true, "test" );
});
</code></pre>

<h1>推荐使用的框架程序</h1>

<p>最上面建立的测试框架为用于学习时建立的demo框架。真正在使用中，为了方便我们习惯通过外部引入的方式来进行测试用例的书写。如下面所示，直接在项目中引入项目代码<code>myProject.js</code>和测试代码<code>myTests.js</code>。</p>

<pre><code>&lt;!--sample-framework.html:--&gt;
&lt;html&gt;
    &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
  &lt;title&gt;QUnit basic example&lt;/title&gt;
  &lt;link rel="stylesheet" href="./resources/qunit.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="qunit"&gt;&lt;/div&gt;
  &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;script src="./resources/qunit.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" src="./resources/jquery.js"&gt;&lt;/script&gt;
    &lt;!-- 项目代码 --&gt;
  &lt;script type="text/javascript" src="myProject.js"&gt;&lt;/script&gt;
    &lt;!-- 测试代码 --&gt;
  &lt;script type="text/javascript" src="myTests.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<hr />

<p>参考文献：<a href="http://qunitjs.com/cookbook/">http://qunitjs.com/cookbook/</a> <br/>
感谢：lizejun</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mocha简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/18/mocha-in-brief/"/>
    <updated>2013-03-18T20:44:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/18/mocha-in-brief</id>
    <content type="html"><![CDATA[<h2>Mocha</h2>

<p>Mocha作为一种咖啡名，应该是广为人知的，中文翻译为<strong>摩卡</strong>。在这里，我们介绍的是一个JavaScript Test Framework，它用于对NodeJS、JavaScript进行单元测试。<br/>
Mocha是一个功能丰富的Javascript测试框架，能够运行在node和浏览器上，并且有丰富的报表支持。 <br/>
项目主页：<a href="http://visionmedia.github.com/mocha/">http://visionmedia.github.com/mocha/</a></p>

<h2>安装</h2>

<pre><code>npm install -g mocha
</code></pre>

<h2>一个简单的样例</h2>

<pre><code>$ mkdir test
$ cd ..
$ mocha test/test.js

var assert = require("assert")
describe('Array', function(){
describe('#indexOf()', function(){
    it('should return -1 when the value is not present', function(){
    assert.equal(-1, [1,2,3].indexOf(5));
    assert.equal(-1, [1,2,3].indexOf(0));
    })
})
})

$  mocha

 .

 ✔ 1 test complete (1ms)
</code></pre>

<!--more-->


<h2>Assertions</h2>

<p>在Java Unit Test中类似JUNIT，TestNG提供了不少的Assert函数。同样的，mocha也有很多选择。而这些并不属于mocha的一部分。</p>

<ul>
<li><a href="http://github.com/visionmedia/should.js">should.js</a></li>
<li><a href="https://github.com/LearnBoost/expect.js">expect.js</a></li>
<li><a href="http://chaijs.com/">chai</a></li>
<li><a href="https://github.com/visionmedia/better-assert">better-assert</a></li>
</ul>


<h2>测试同步代码</h2>

<pre><code>describe('Array', function(){
describe('#indexOf()', function(){
    it('should return -1 when the value is not present', function(){
    [1,2,3].indexOf(5).should.equal(-1);
    [1,2,3].indexOf(0).should.equal(-1);
    })
})
})
</code></pre>

<h2>测试异步代码</h2>

<p>添加一个回调函数，通常称为done,给it。mocha就会知道应该等待操作完成。</p>

<pre><code>describe('User', function(){
describe('#save()', function(){
    it('should save without error', function(done){
    var user = new User('Luna');
    user.save(done);
    })
})
})
</code></pre>

<h2>类似与JUNIT的函数</h2>

<ul>
<li>before : 在所有测试执行之前</li>
<li>after ： 在所有测试执行之后</li>
<li>beforeEach ： 每个测试之前</li>
<li>afterEach ：每个测试之后</li>
</ul>


<h2>mocha指令</h2>

<pre><code>Usage: mocha [debug] [options] [files]

Commands:

init &lt;path&gt;
initialize a client-side mocha setup at &lt;path&gt;

Options:

-h, --help                      帮助信息
-V, --version                   版本信息
-r, --require &lt;name&gt;            依赖的module
-R, --reporter &lt;name&gt;           使用的报告模式
-u, --ui &lt;name&gt;                 用什么接口(bdd|tdd|exports)
-g, --grep &lt;pattern&gt;            执行匹配 &lt;pattern&gt;的测试
-i, --invert                    --grep 相反的测试
-t, --timeout &lt;ms&gt;              超时毫秒数 [2000]
-s, --slow &lt;ms&gt;                 "slow" 测试的门槛 [75]
-w, --watch                     查看文件的变化，如true,则变化后自动运行。
-c, --colors                    启用colors
-C, --no-colors                 禁用colors
-G, --growl                     启用growl notification
-d, --debug                     启用debug
-b, --bail                      只对第一个报错的TEST感兴趣
--recursive                     递归执行
--debug-brk                     enable node's debugger breaking on the first line
--globals &lt;names&gt;               allow the given comma-delimited global [names]
--ignore-leaks                  ignore global variable leaks
--interfaces                    显示可用的接口
--reporters                     显示可用的报表列表
--compilers &lt;ext&gt;:&lt;module&gt;,...  使用指定的module来编译文件
</code></pre>

<h2>报表</h2>

<pre><code>dot - dot matrix
    doc - html documentation
    spec - hierarchical spec list
    json - single json object
    progress - progress bar
    list - spec-style listing
    tap - test-anything-protocol
    landing - unicode landing strip
    xunit - xunit reportert
    teamcity - teamcity ci support
    html-cov - HTML test coverage
    json-cov - JSON test coverage
    min - minimal reporter (great with --watch)
    json-stream - newline delimited json events
    markdown - markdown documentation (github flavour)
    nyan - nyan cat!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[testacular or Karma 简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief/"/>
    <updated>2013-03-12T15:12:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/03/12/testacular-in-brief</id>
    <content type="html"><![CDATA[<h2>Testacular是什么？</h2>

<p>在2012年11月，Google开源了<a href="http://testacular.github.com/">Testacular</a>，一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。</p>

<p>Testacular可以在不同的桌面或移动设备浏览器上，或在持续集成的服务器上测试JavaScript代码。Testacular支持chrome、ChromeCanary、 Safari、Firefox、IE、Opera、PhantomJS，知道如何捕获浏览器正使用的默认路径，这些路径可能在启动器配置文件被忽视（overridden）。Testacular就是一个可以和多重测试框架协作的测试执行过程管理工具，它有针对Jasmine、Mocha和AngularJS的适配器，它也可以与<a href="http://jenkins-ci.org/">Jenkins</a>或<a href="https://travis-ci.org/">Travis</a>整合，用于执行持续集成测试。</p>

<!--more-->


<p>这个测试工具的一个强大特性就是，它可以监控一套文件的变换，并立即开始测试已保存的文件，用户无需离开文本编辑器。测试结果通常显示在命令行中，而非代码编辑器。这也就让Testacular基本可以和任何JS编辑器一起使用。为更好结果，它可以整合到<a href="http://www.jetbrains.com/webstorm/">WebStorm</a>中，而WebStorm持错误栈追踪和单元测试调试。</p>

<p>为更好运行，Testacular需要Node.js和一个配置文件，该配置文件包括：待测试的文件、需忽略的文件、基本路径、web服务器端口、日子等级等。（配置文件样例）</p>

<p>说到Testacular的性能，Google工程师Vojta Jína在Chrome Canary和Chrome做了一个演示，用WebStorm大约执行了1500个AngularJS测试，在5秒之内完成。</p>

<p>Jína也说到Testacular是受<a href="http://code.google.com/p/js-test-driver/">JS Test Driver(JSTD)</a>的启发，但他们决定写一个完全不同的测试执行过程管理工具，因为JSTD有很多问题，他们想要一个能稳定并快速执行Javascript测试的工具。所以他们用了Socket.io库和Node.js。</p>

<h2>Vojta Jína原版视频</h2>

<p>youtube(凸墙): <br/>
<a href="http://www.youtube.com/watch?v=5mHjJ4xf_K0">http://www.youtube.com/watch?v=5mHjJ4xf_K0</a>  <br/>
<a href="http://www.youtube.com/watch?v=MVw8N3hTfCI">http://www.youtube.com/watch?v=MVw8N3hTfCI</a>  <br/>
youku[个人转录]:</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Nzky" frameborder=0 allowfullscreen></iframe>




<iframe height=498 width=510 src="http://player.youku.com/embed/XNTI2NTg0Mzc2" frameborder=0 allowfullscreen></iframe>


<h2>Testacular 安装</h2>

<p>首先，保证已经有Node.js环境以及NPM。然后执行以下命令即可：</p>

<pre><code>npm install -g testacular
</code></pre>

<p>安装成功后，可以查看其支持的命令。</p>

<pre><code>testacular --help
Testacular - Spectacular Test Runner for JavaScript.

Usage:
testacular &lt;command&gt;

Commands:
start [&lt;configFile&gt;] [&lt;options&gt;] Start the server / do single run.
init [&lt;configFile&gt;] Initialize a config file.
run [&lt;options&gt;] Trigger a test run.

Run --help with particular command to see its description and   available options.

Options:
--help     Print usage and options.
--version  Print current version.   
</code></pre>

<p>简单来看，就只有start,init,run这几个命令。start用于启动浏览器server,init用于辅助的生成配置文件，run用于驱动Test执行。<br/>
下面就来看以下，最主要的部分，那就是配置文件了。</p>

<h2>Testacular配置文件</h2>

<p>这个配置文件，定义了Test执行所需要的各种选项，testacular正是通过这个文件来进行测试执行的。 <br/>
在GitHub上可以看到一个官方提供的默认样例<a href="https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js">https://github.com/testacular/testacular/blob/master/test/client/testacular.conf.js</a>,可以看出里面有相当多的配置，还要里面都有一些注释的了，都大概能看懂一点。<br/>
同样的，使用<code>testacular init</code>命令也可以帮助你自动的生成一个配置文件。init后可以跟文件名，如果不写，默认的文件名就是testacular.conf.js。对应的<code>testacular start</code>也会默认搜索当前目录下的testacular.conf.js来启动。  <br/>
下面，我们来生成一个看看：</p>

<pre><code>testacular init my.conf.js

Which testing framework do you want to use ?
Press tab to list possible options. Enter to move to the next   question.
&gt; mocha

Do you want to use Require.js ?
This will add Require.js adapter into files.
Press tab to list possible options. Enter to move to the next question.
&gt; no

Do you want to capture a browser automatically ?
Press tab to list possible options. Enter empty string to move to the next question.
&gt; Firefox
......

Config file generated at "/home/shenyanchao/tmp/my.conf.js".
</code></pre>

<p>这样就生成了一个my.conf.js文件。其中要我们自己要做的就是选择一下而已。需要注意的是，正如提示所说，选择切换使用的是<strong>Tab</strong>。<br/>
此时，执行<code>testacular start my.conf.js</code>,可以发现，浏览器已经启动了。</p>

<p><img src="/images/blog/testacular-run-in-firefox.png" alt="Testacular启动" /></p>

<p><strong>配置文件参数：</strong></p>

<pre><code>autoWatch

类型: Boolean
默认: false
命令行: --auto-watch, --no-auto-watch
详细介绍:当文件内容变化的时候，是不是自动的重新运行Test

basePath

类型: String
默认: ''
详细介绍: 基本路径，用来解决相对路径问题。

browsers

类型: Array
默认: []
命令行: --browsers Chrome,Firefox
取值:
Chrome
ChromeCanary
Firefox
Opera
Safari
PhantomJS
IE
详细介绍: 定义一组需要启动的浏览器，那么所有测试将分别在各个浏览器运行并给出结果。关闭的时候也同时全部关闭。

captureTimeout

类型: Number
默认: 60000
详细介绍: 捕获浏览器的超时时间 (单位 ms)。超时后，testacular会关闭然后重新尝试。  

colors

类型: Boolean
默认: true
命令行: --colors, --no-colors
详细介绍: 在reporters和logs里面是否启用色彩。
exclude

类型: Array
默认: []
详细介绍: 排除在外的文件列表或者正则表达式

files

类型: Array
默认: []
详细介绍: 要加载的文件列表或者正则表达式

hostname

类型: String
默认: 'localhost'
详细介绍: 启动的浏览器主机名

logLevel

类型: Constant
默认: LOG_INFO
命令行: --log-level debug
取值:
LOG_DISABLE
LOG_ERROR
LOG_WARN
LOG_INFO
LOG_DEBUG
详细介绍: 日志级别.

loggers

类型: Array
默认: [{type: 'console'}]
详细介绍: 定义日志目标。比如log4js

port

类型: Number
默认: 9876
命令行: --port 9876
详细介绍: web服务的监听端口

preprocessors

类型: Object
默认: {'**/*.coffee': 'coffee'}
详细介绍: 前置处理器的MAP

proxies

类型: Object
默认: {}
详细介绍: 路径代理的映射MAP
例如:
proxies =  {
    '/static': 'http://gstatic.com',
    '/web': 'http://localhost:9000'
};

reportSlowerThan

类型: Number
默认: 0
详细介绍: 这时一个以ms为单位的数值，如果test执行超过这个时间，那么Testacular会进行记录。 

reporters

类型: Array
默认: ['progress']
命令行: --reporters progress,growl
取值:
dots
progress
junit
growl
coverage
详细介绍: 使用的报表列表

runnerPort

类型: Number
默认: 9100
命令行: --runner-port 9100
详细介绍: 使用testacular run时，服务器的监听端口

singleRun

类型: Boolean
默认: false
命令行: --single-run, no-single-run
详细介绍: CI模式。如为true，就会在所有浏览器运行，通过返回0，失败返回1.

urlRoot

类型: String
默认: '/'
详细介绍: 基本URL，相当于一个URL默认的前缀。尤其在使用proxies时有用。
</code></pre>

<h2>browser无法启动？</h2>

<p>当在testacular.conf.js中配置完browsersCanary，有可能会出现无法启动浏览器的情况。testacular会在一套默认的路径下进行尝试加载启动浏览器，而在不同的操作系统下默认位置是不同的。
如果无法找到，可以通过覆盖<code>&lt;BROWSER&gt;_BIN</code>来解决。 <br/>
比如：</p>

<pre><code>export CHROME_BIN=/usr/local/bin/my-chrome-build
export CHROME_CANARY_BIN=/usr/local/bin/my-chrome-build
export PHANTOMJS_BIN=$HOME/local/bin/phantomjs
</code></pre>

<p>就是要设置相应的变量。在windows下自然就是添加相应的环境变量了。这样配置后，testacular就直到从哪儿加载启动浏览器了。</p>

<h2>写在Testacular学习之后</h2>

<p>Testacular应该是Google<a href="http://angularjs.org/">AngularJS</a>的副产品。出于CommonJS的规范，以及对产品质量的保证。AngularJS只身需要进行单元测试，而在测试过程中遇到了种种的问题。也许他们最开始就是使用JsTestDriver来驱动测试的，后来发现不能满足需求，或者能更好。因此Testacular出现了，并开源了出来。<br/>
以上，存在一定的个人猜测，但是其产生的过程值得好好学习。</p>

<h2>改名为Karma</h2>

<p>2013年3月18日，Testacular更名为Karma，版本从V0.6.0直接升为V0.8.0，并在GitHub上提交时评论为<code>chore: rename this shit to Karma</code>。具体什么原因，不得而知。也许是因为令人诟病的Testacular名字不好听吧。不过功能都是一样的，只是使用的时候，testacular变为karma了。所以上面文档中的操作，只需要全部替换即可。</p>
]]></content>
  </entry>
  
</feed>
