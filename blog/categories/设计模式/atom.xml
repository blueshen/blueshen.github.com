<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/blog/categories/设计模式/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2012-11-07T20:44:38+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式：原型（prototype） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/07/prototype-in-java/"/>
    <updated>2012-11-07T20:41:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/07/prototype-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br/>
基本上，可以就是一个clone方法，通过这个方法进行对象的拷贝。</p>

<p>Java中的原型模式：</p>

<pre><code>public class ProtoTypeClass implements Cloneable {

    @Override
    public ProtoTypeClass clone(){
        ProtoTypeClass cloneObject = null;
        try{
            cloneObject = (ProtoTypeClass) super.clone();
        }catch (Exception e) {
            // TODO: handle exception
        }
        return cloneObject;
    }
}
</code></pre>

<p>上面就是实现了原型模式。不过Java在提供了Cloneable这一接口方便实现原型模式的同时，也带来了一些不容易注意到的问题。</p>

<ul>
<li>clone时，构造函数不会执行</li>
<li>浅拷贝与深拷贝</li>
</ul>


<p>这两个问题是需要时刻注意的。由于本文主要不是讲Cloneable,所以另辟专题吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：门面（Facade） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/07/facade-in-java/"/>
    <updated>2012-11-07T20:00:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/07/facade-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 <br/>
就是说，Facade提供了一个统一的接口，掩盖下层系统的复杂性，用户用起来更加的方便。</p>

<p>以医院的例子，做个比喻：</p>

<!--more-->


<blockquote></blockquote>

<p>在无接待员的时候，病人要做业务，好复杂啊，好累！</p>

<p><img src="/images/blog/facade-hospital1.png" alt="无接待员" /></p>

<p>有了接待员，各种就医流程好流畅的说。因为有接待员与各个部门打交道。</p>

<p><img src="/images/blog/facade-hospital2.png" alt="有接待员" /></p>

<p>这个例子很好的说出了facade的作用。甚至都不需要代码来表达了。</p>

<p>门面模式的优点：</p>

<p>　　●松散耦合</p>

<p>　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>

<p>　　●简单易用</p>

<p>　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p>

<p>　　●更好的划分访问层次</p>

<p>　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节</p>

<h2>门面模式 in JDK</h2>

<p>这个具体的例子，我首先想到的就是<a href="http://www.slf4j.org/">slf4j</a>这个日志框架。通过名字Simple Logging Facade for Java (SLF4J)就知道是采用的Facade模式了。下面是其官方的介绍： <br/>
The Simple Logging Facade for Java or (SLF4J) serves as a simple facade or abstraction for various logging frameworks, e.g. java.util.logging, log4j and logback, allowing the end user to plug in the desired logging framework at deployment time. <br/>
也就是说，他屏蔽了各种日志框架的差异，提供了一个统一的日志接口给用户使用。不得不说，<a href="http://www.slf4j.org/">slf4j</a>很好用，推荐！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：模板方法（template method） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/07/template-method-in-java/"/>
    <updated>2012-11-07T19:30:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/07/template-method-in-java</id>
    <content type="html"><![CDATA[<p><strong>定义：</strong>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义这个算法的某些特定步骤。 <br/>
简单的说，就是你首先定义一下算法的各部分之间的执行顺序或者调用关系，然后在子类中实现具体每一部分是如何实现的。</p>

<p>采用什么算法作为例子呢？就是用<strong>把动物放进冰箱</strong>这个算法吧。</p>

<!--more-->


<p>先定义一个抽象类:</p>

<pre><code>public abstract class AbstractAlgorithm {

    public abstract void openFridgeDoor();

    public abstract void putAnimalInFridge();

    public abstract void closeFridgeDoor();

    public void execute(){
        this.openFridgeDoor();
        this.putAnimalInFridge();
        this.closeFridgeDoor();
    }
}
</code></pre>

<p>这个类，定义了3个操作，打开冰箱门、把动物放进冰箱、关闭冰箱门，但并未实现，而留给子类来具体实现。<code>execute()</code>用来执行这一算法，它指定了各个操作之间的先后顺序。</p>

<p>比如：我想把大象放进冰箱里：</p>

<pre><code>public class PutElephantInFridge extends AbstractAlgorithm {

    @Override
    public void openFridgeDoor() {
        System.out.println("open the fridge door lightly");
    }

    @Override
    public void putAnimalInFridge() {
        System.out
            .println("try my best to put elephant in fridge,after 2 hours, I got it.");
    }

    @Override
    public void closeFridgeDoor() {
        System.out.println("close the fridge door...");
    }

}
</code></pre>

<p>具体使用：</p>

<pre><code>PutElephantInFridge algo = new PutElephantInFridge();
algo.execute();
</code></pre>

<p>好吧，执行一下算法就完成了。
下面吗？我想把猴子放进冰箱，好吧，新建一个类继承AbstractAlgorithm，然后重写相关步骤就可以了。</p>

<h2>模板方法 In JDK</h2>

<pre><code>java.io.InputStream, java.io.OutputStream, java.io.Reader，java.io.Writer      

java.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap
</code></pre>

<p>所有非抽象方法。</p>

<pre><code>javax.servlet.http.HttpServlet#doXXX()   
</code></pre>

<p>都默认返回一个<code>SC_METHOD_NOT_ALLOWED</code>类似的错误码，或者代码，要想使用，只有继承并且重写这些方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式:工厂（factory） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/07/factory-in-java/"/>
    <updated>2012-11-07T17:43:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/07/factory-in-java</id>
    <content type="html"><![CDATA[<p>工厂模式，直接按名字来说，就是负责专门生产产品的。 <br/>
大致分为3类：</p>

<ul>
<li>工厂方法</li>
<li>简单工厂</li>
<li>抽象工厂</li>
</ul>


<p>同时，也有人认为简单工厂只是工厂方法的一种特列，那么就分为两种了。本文就按3种分别进行介绍了。</p>

<h3>工厂方法</h3>

<p><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。</p>

<!--more-->


<p>简单的说，就是有一个抽象类定义了一个方法，而实现类来决定到底初始化那个实例。这些实例，就是一个个产品了。 <br/>
产品接口（主要是考虑面向接口变成吧，个人感觉不要也行，对理解模式没有影响）：</p>

<pre><code>public interface IProduct {
    public void sayName();
}
</code></pre>

<p>下面呢，假设有两种产品：</p>

<pre><code>public class ProductA implements IProduct {
    @Override
    public void sayName() {
        // TODO Auto-generated method stub
        System.out.println("I am ProductA");
    }
}
public class ProductB implements IProduct {
    @Override
    public void sayName() {
        System.out.println("I am productB");
    }
}
</code></pre>

<p>有了产品定义，那么下面就要建一个工厂了，怎么建呢？依据定义来说，首先要定义一个接口了：</p>

<pre><code>public abstract class AbstractProductFactory {
    public abstract &lt;T extends IProduct&gt; T createProduct(
        Class&lt;T&gt; productType);
}
</code></pre>

<p>下面就是一个子类了，也就是具体负责初始化实例的工厂了。</p>

<pre><code>public class ProductFactory extends AbstractProductFactory {

    @Override
    public &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {
        // TODO Auto-generated method stub
        IProduct product = null;
        try {
            product = productType.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return (T) product;
    }
}
</code></pre>

<p>如何生成不同的产品呢，本例是根据传入的不同的类，来返回不同的实例的。当然了也可以用一个标识符了,如果传入的是“A”那么返回一个ProductA。诸如此类，这就是工厂方法了。<br/>
具体使用时，是这样的：</p>

<pre><code>ProductFactory productFactory = new ProductFactory();
IProduct productA = productFactory.createProduct(ProductA.class);
IProduct productB = productFactory.createProduct(ProductB.class);
productA.sayName();
productB.sayName();
</code></pre>

<h2>简单工厂</h2>

<p>简单工厂，可以说是工厂方法的一种扩展。上例中，发现在使用<code>ProductFactory</code>的时候，还需要先实例化一个。怎么那么麻烦呢？就像在实际生活中，我想要某个产品，我还需要先建一个工厂是一个道理的。</p>

<p>还好，Java提供了这样一个关键字<code>static</code>,简单工厂类就变成这个样子了。</p>

<pre><code>public class SimpleProductFactory {

    public static &lt;T extends IProduct&gt; T createProduct(Class&lt;T&gt; productType) {
        // TODO Auto-generated method stub
        IProduct product = null;
        try {
            product = productType.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return (T) product;
    }
}
</code></pre>

<p>这样在使用的时间是方便了不少呢？</p>

<pre><code>IProduct productA = SimpleProductFactory.createProduct(ProductA.class);
IProduct productB = SimpleProductFactory.createProduct(ProductB.class);
productA.sayName();
productB.sayName();
</code></pre>

<h2>抽象工厂</h2>

<p>情况进一步发展，大家对美的追求不断提高。工厂也是需要对自己的产品不断升级的。那就对现有的产品ProductA，ProductB进行升级，各自推出红，蓝两种颜色的产品。那么，我就需要两个工厂了，一个工厂来生产红色产品，一个工厂来生产蓝色产品。 <br/>
下面，先对产品进行改造：</p>

<pre><code>public interface IProduct {
    public void sayName();
    public void sayColor();
}
public abstract class ProductA implements IProduct {
    @Override
    public void sayName() {
        // TODO Auto-generated method stub
        System.out.println("I am ProductA");
    }
}
public abstract class ProductB implements IProduct {
    @Override
    public void sayName() {
        System.out.println("I am productB");
    }
}
</code></pre>

<p>哎呀，貌似ProductA，ProductB没什么变化啊！还是有些变化的，都变为<code>abstract</code>了，也就是说他俩都是半成品，还没给上色呢。怎么能实例化，然后往外销售呢，这不坑人，影响工厂形象啊。当然了，没上色，那也没办法<code>sayColor</code>了，鬼知道将会涂成什么颜色。</p>

<p>好吧，有了半成品，现在进行上色操作。</p>

<pre><code>public class RedProductA extends ProductA {
    @Override
    public void sayColor() {
        System.out.println("my color is Red!");
    }
}
public class BlueProductA extends ProductA {
    @Override
    public void sayColor() {
        System.out.println("my color is Blue!");
    }
}

public class RedProductB extends ProductB {
    @Override
    public void sayColor() {
        System.out.println("my color is Red!");
    }
}
public class BlueProductB extends ProductB {
    @Override
    public void sayColor() {
        System.out.println("my color is Blue!");
    }
}
</code></pre>

<p>到此为止，产品定义完成了。  <br/>
下面就开建工厂了。一个<strong>红色工厂</strong>、一个<strong>蓝色工厂</strong> <br/>
先来个抽象的：</p>

<pre><code>public abstract class AbstractProductFactory {
    public abstract IProduct createProductA();

    public abstract IProduct createProductB();
}
</code></pre>

<p>工厂就是为负责生产两种产品的了。</p>

<pre><code>public class RedProductFactory extends AbstractProductFactory {

    @Override
    public IProduct createProductA() {
        return new RedProductA();
    }

    @Override
    public IProduct createProductB() {
        return new RedProductB();
    }
}

public class BlueProductFactory  extends AbstractProductFactory{
    @Override
    public IProduct createProductA() {
        return new BlueProductA();
    }

    @Override
    public IProduct createProductB() {
        return new BlueProductB();
    }
}
</code></pre>

<p>那么，通过这两种工厂生产出的产品，不论是A,还是B，颜色铁定是一致的啊。
使用场景如下：</p>

<pre><code>    RedProductFactory redProductFactory = new RedProductFactory();
    System.out.println("red factory is producing");
    IProduct product1 = redProductFactory.createProductA();
    product1.sayName();
    product1.sayColor();
    IProduct product2 = redProductFactory.createProductB();
    product2.sayName();
    product2.sayColor();

    BlueProductFactory blueProductFactory = new BlueProductFactory();
    System.out.println("blue factory is producing");
    IProduct product3 = blueProductFactory.createProductA();
    product3.sayName();
    product3.sayColor();
    IProduct product4 = blueProductFactory.createProductB();
    product4.sayName();
    product4.sayColor();
</code></pre>

<p>这样两个工厂分别开工了，一个出的产品都是红色的，一个都是蓝色的。这就是<strong>抽象工厂</strong>了。</p>

<h2>工厂模式 in JDK</h2>

<pre><code>Class.forName(String className);   
</code></pre>

<p>这种应该就是简单工厂的典型了。依据不同的className来生产相应的对象，只不过这里是Class对象了，不要混淆。</p>

<pre><code>javax.xml.parsers.DocumentBuilderFactory#newInstance()
javax.xml.transform.TransformerFactory#newInstance()
javax.xml.xpath.XPathFactory#newInstance()
</code></pre>

<p>这几个为什么就是抽象工厂了呢？不理解。高人指点。</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式：构建者（builder） in java]]></title>
    <link href="http://www.shenyanchao.cn/blog/2012/11/05/builder-in-java/"/>
    <updated>2012-11-05T20:08:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2012/11/05/builder-in-java</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
