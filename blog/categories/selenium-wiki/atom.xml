<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：selenium-wiki | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/blog/categories/selenium-wiki/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2013-05-30T20:21:10+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[selenium wiki:selenium常见问题]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions/"/>
    <updated>2013-05-30T19:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-frequently-asked-questions</id>
    <content type="html"><![CDATA[<h3>selenium常见问题</h3>

<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions">https://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions</a></p>

<h4>Q:什么是WebDriver?</h4>

<p>A:WebDriver是一个用来写网页自动化测试的工具。它致力于模拟真实用户的行为并尽可能的实现HTML上的交互。</p>

<h4>Q:Selenium与<a href="http://sahi.co.in/">Sahi</a>有什么异同？</h4>

<p>A:它们的目标是一样的，都是为了测试webapp。但是，它们的实现是不一样的。WebDriver是直接控制浏览器的，而不是在浏览器内运行了一个Javascript应用（这牵涉到同源策略问题）。这也意味着WebDriver可以充分利用原生平台提供的任何工具。</p>

<h4>Q：什么是Selenium 2.0?</h4>

<p>A:WebDriver是Selenium的一部分。而WebDriver为其提供了强大的API以及原生的Driver。</p>

<!--more-->


<h4>Q：如何从原来的selenium api迁移到新的webdriver api?</h4>

<p>A:参见<a href="http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html">http://seleniumhq.org/docs/appendix_migrating_from_rc_to_webdriver.html</a></p>

<h4>Q:WebDriver支持哪些浏览器？</h4>

<p>A:目前支持<a href="https://code.google.com/p/selenium/wiki/ChromeDriver">ChromeDriver</a>,<a href="https://code.google.com/p/selenium/wiki/InternetExplorerDriver">InternetExplorerDriver</a>,<a href="https://code.google.com/p/selenium/wiki/FirefoxDriver">FirefoxDriver</a>,<a href="https://code.google.com/p/selenium/wiki/OperaDriver">OperaDriver</a>,<a href="https://code.google.com/p/selenium/wiki/HtmlUnitDriver">HtmlUnitDriver</a>。它们各有什么优缺点，可以进入相应的链接进行查看。同时，它还支持移动测试，包括<a href="https://code.google.com/p/selenium/wiki/AndroidDriver">AndroidDriver</a>,OperaMobileDriver,IPhoneDriver。</p>

<h4>Q：“developer focused”是什么意思？</h4>

<p>A:我们认为，在一个软件开发团队内，那些能开发出别人都能使用的工具的人是真正的开发者。尽管直接使用WebDriver是很容易的，但是它也应该能作为一个构建块来产出更复杂智能的工具。正因为如此,webdriver也有一个很小的API使得你可以在你喜欢的IDE中简单的点击“autocomplete”，就能在任何浏览器内始终工作。</p>

<h4>Q:如何直接执行Javascript?</h4>

<p>A:我们相信当你使用工具时，有可能没有触发正确的时间，有可能于页面没有正确的交互，也有可能没有对一个XmlHttpRequest进行响应，这个时候就需要执行Javascript。当然，我们更加希望改进WebDriver来使其运行的连续而正确，而不是让测试人员来通过Javascript来调用。  <br/>
我们也感觉到有时因为种种限制，必须使用直接调用JavaScript。因此，对于支持JavaScript的浏览器，你可以直接将WebDriver实例强制转型为JavaScriptExecutor，然后执行。在Java语言中，类似于这样。</p>

<pre><code>WebDriver driver; // Assigned elsewhere
JavascriptExecutor js =     (JavascriptExecutor) driver;
js.executeScript("return document.title");
</code></pre>

<p>至于其他语言，都是很相似的方法。可以看一下UsingJavaScript章节。</p>

<h4>Q：为什么我执行Javascript,总是返回NULL？</h4>

<p>A:你需要让你的JS脚本有返回值。所以<code>js.executeScript("document.title");</code>会返回null;而<code>js.executeScript("return document.title");</code>则会返回页面的title。</p>

<h4>Q：使用XPATH定位元素，在有的浏览器可以，有的却不行，为什么？</h4>

<p>A:简单来说，不同的浏览器对XPATH的处理略有不同。而你整好碰上了。具体参见<a href="https://code.google.com/p/selenium/wiki/XpathInWebDriver">XpathInWebDriver</a>章节。</p>

<h4>Q：InternetExplorerDriver不能在Vista上很好的工作。我应该怎么做？</h4>

<p>A:InternetExplorerDriver需要所有的保护模式设置到相同的值（开启或关闭）。假如你不能修改这些，你也可以这样：</p>

<pre><code>DesiredCapabilities capabilities = DesiredCapabilities.internetExplorer();
capabilities.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);
WebDriver driver = new InternetExplorerDriver(capabilities);    
</code></pre>

<p>正如常量名所示，你的所有测试可能需要分开。当然，如果你所有的站点都在同一个保护模式，那是没问题的。</p>

<h4>Q：除了Java，还支持哪些语言？</h4>

<p>A:Python,Ruby,C#,Java都是直接支持的。并且还有PHP和Perl的webdriver实现。同时一个JS的API也正在计划中。</p>

<h4>Q：如何处理新弹出的浏览器窗口？</h4>

<p>A:WebDriver提供了处理多浏览器窗口的能力。通过使用<code>WebDriver.switchTo().window()</code>可以转向一个已知名字的窗口。假如不知道这个窗口的名字，可以使用<code>"WebDriver.getWindowHandles()</code>获取窗口的名字列表。然后就可以使用<code>switchTo().window()</code>来转向了。</p>

<h4>Q：WebDriver支持JavaScript弹出的alert和prompts框嘛？</h4>

<p>A: 使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/Alert.html">Alert API</a>可以搞定:</p>

<pre><code>// Get a handle to the open alert, prompt or confirmation
Alert alert = driver.switchTo().alert();
// Get the text of the alert or prompt
alert.getText();  
// And acknowledge the alert (equivalent to clicking "OK")
alert.accept();
</code></pre>

<h4>Q：WebDriver支持文件上传？</h4>

<p>A:答案是肯定的。你是不能直接与操作系统的浏览文件窗口直接交互的，但是做了一些神奇的工作，使得你在文件上传元素上调用<code>WebElement#sendKeys("/path/to/file")</code> 就可以正确上传。同时你要保证不要在文件上传元素上进行<code>WebElement#click()</code>操作，否则可能导致浏览器挂起。 <br/>
小提示：你是不能直接与隐藏的元素交互的，除非使他们显示出来。假如你的元素是隐藏的，可以使用类似下面的代码，来让元素可见。</p>

<pre><code>((JavascriptExecutor)driver).executeScript("arguments[0].style.visibility = 'visible';      arguments[0].style.height = '1px'; arguments[0].style.width = '1px'; arguments[0].style.opacity = 1", fileUploadElement); 
</code></pre>

<h4>Q：为什么在执行<code>sendKeys</code>后，没有触发onchange事件？</h4>

<p>A:WebDriver是将焦点一直放在调用<code>sendKeys</code>的元素上的。而onchange事件是当焦点离开元素才触发的。因此，你只需移动下焦点，简单的<code>click</code>下其他元素即可。</p>

<h4>Q：能同时运行多个WebDriver的实例？</h4>

<p>A:HtmlUnitDriver,ChromeDriver,FirefoxDriver的每个实例都是完全独立的（其中firefox和chrome，每个实例都使用它们自己的匿名profile）。由于Windows自身的运行方式，同时只能有一个InternetExplorerDriver实例。假如你同时需要运行多个InternetExplorerDriver实例，可以考虑使用Remote!WebDriver以及虚拟机。</p>

<h4>Q：我需要使用代理。我该如何配置呢？</h4>

<p>A：代理配置是通过<code>org.openqa.selenium.Proxy</code>类来实现的，类似下面代码所示：</p>

<pre><code>Proxy proxy = new Proxy();
proxy.setProxyAutoconfigUrl("http://youdomain/config");

// We use firefox as an example here.
DesiredCapabilities capabilities = DesiredCapabilities.firefox();
capabilities.setCapability(CapabilityType.PROXY, proxy);

// You could use any webdriver implementation here
WebDriver driver = new FirefoxDriver(capabilities);
</code></pre>

<h4>Q：使用HtmlUnitDriver该如何实现权限验证？</h4>

<p>A:当创建HtmlUnitDriver时，重写<code>modifyWebClient</code>方法即可。例如：</p>

<pre><code>WebDriver driver = new HtmlUnitDriver() {
  protected WebClient modifyWebClient(WebClient client) {
    // This class ships with HtmlUnit itself
    DefaultCredentialsProvider creds = new DefaultCredentialsProvider();

    // Set some example credentials
    creds.addCredentials("username", "password");

    // And now add the provider to the webClient instance
    client.setCredentialsProvider(creds);

    return client;
  }
};
</code></pre>

<h4>Q：WebDriver是线程安全的吗？</h4>

<p>A:WebDriver不是线程安全的。话说回来，如果你串行的访问driver实例，你就可以在多个线程之间共享一个driver引用。这个不是推荐的方法。其实你可以为每个线程实例化一个WebDriver。</p>

<h4>Q：如何向一个可编辑的iframe里输入？</h4>

<p>A:假设那个iframe的name是“foo”:</p>

<pre><code>driver.switchTo().frame("foo");
WebElement editable = driver.switchTo().activeElement();
editable.sendKeys("Your text here");
</code></pre>

<p>有时，这方法不管用。那是因为iframe没有任何内容。在Firefox中，你可以在<code>sendKeys</code>之前做以下的操作：</p>

<pre><code>((JavascriptExecutor) driver).executeScript("document.body.innerHTML = '&lt;br&gt;'");
</code></pre>

<p>因为iframe内默认是没有任何内容的，所以就不知道该往哪儿进行键盘输入，上面的操作是必须的。这个操作只是插入了一个空标签，就把一切搞定了。 <br/>
记得在做完iframe内的操作后，switch出来（因为进一步都交互都是使用下面的frame的）。</p>

<pre><code>driver.switchTo().defaultContent();
</code></pre>

<h4>Q：在Linux系统上WebDriver无法启动Firefox，并抛出<code>java.net.SocketException</code>。</h4>

<p>A:在Linux系统上运行WebDriver,Firefox无法启动并抛出如下错误：</p>

<pre><code>Caused by: java.net.SocketException: Invalid argument
        at java.net.PlainSocketImpl.socketBind(Native Method)
        at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)
        at java.net.Socket.bind(Socket.java:571)
        at org.openqa.selenium.firefox.internal.SocketLock.isLockFree(SocketLock.java:99)
        at org.openqa.selenium.firefox.internal.SocketLock.lock(SocketLock.java:63)
</code></pre>

<p>这可能是因为机器上的IPv6设置导致的。执行下面的脚本：</p>

<pre><code>sudo sysctl net.ipv6.bindv6only=0
</code></pre>

<p>为了使用相同的调用，就能让socket同时绑定到主机的IPv6和IPv4地址。更长远的解决方案是编辑<code>/etc/sysctl.d/bindv6only.conf</code>禁用这个行为。</p>

<h4>Q:WebDriver找不到元素/页面没有完全加载就返回了。</h4>

<p>A:这个问题可以从各种方式显现出来：</p>

<ul>
<li>使用WebDriver.findElement(...)抛出ElementNotFoundException，但当检查DOM（使用Firebug等工具）时，元素明明就在那里。</li>
<li>调用Driver.get时，一旦HTML加载，方法就立即返回了。但是onload触发的JavaScript代码没有加载。因此页面是没有加载完全的并且一些元素是无法找到的。</li>
<li>click一个元素或者链接时，触发了一个新建元素的操作。然而，click操作返回后，直接调用findElement并不能找到这个新建的元素。click操作不应该是被阻塞的吗？</li>
<li>我怎么才能知道一个页面是否已经完全加载了？</li>
</ul>


<p><strong>解析</strong>：WebDriver基本上都是blocking API。但是，在一些情况下，是允许页面没有完成加载就让get请求返回的。经典的样例就是，当页面加载后才开始执行JavaScript(onload触发)。浏览器（比如Firefox）会在基本的HTML内容加载后通知WebDriver，而就是此刻WebDriver才返回了。要想知道JavaScript什么时候执行完成是困难的（即使是能知道），因为JS代码可能在将来的某一刻才执行并且依赖于服务器的响应。这种情况同样也适用于click操作，在支持原生事件（Window,Linux）的系统平台上，click操作会转化为在操作系统层面的一个在元素坐标点进行的鼠标左键点击，WebDriver是无法很好的追踪到这个鼠标左键点击引起的一连串操作的。WebDriver并不了解这一切，所以WebDriver不可能等到所有的条件到来才执行测试流程。这样的情况下，blocking API是不完美的。通常，我们最为关心的是在接下来的交互中需要使用到元素是否已经显示并且可用。  <br/>
<strong>解决方案</strong>：使用Wait类来等待一个元素出现。这个类会一遍又一遍的调用findElement方法，忽略NoSuchElementException，直到找到元素为止（或者超时失效）。既然这个行为是很多用户希望默认实现的，我们实现了一个隐式等待元素出现的机制。这个可以使用<a href="http://selenium.googlecode.com/svn/trunk/docs/api/java/org/openqa/selenium/WebDriver.Timeouts.html">WebDriver.manage().timeouts()</a>来实现.</p>

<h4>Q:如何能触发页面上的任意事件？</h4>

<p>A:WebDriver致力于模拟用户交互，因此API直接反应了用户与各种元素的交互。 <br/>
触发一个特定的事件不能由API直接完成，但是可以直接通过执行JavaScript来调用元素上的各种方法。</p>

<h4>Q:为什么不能与隐藏的元素进行交互？</h4>

<p>A:既然用户不能看到隐藏元素的文本信息，WebDriver也一样。
然而，执行JavaScript来直接调用隐藏元素的getText是允许的。</p>

<pre><code>WebElement element = ...;
((JavascriptExecutor) driver).executeScript("return arguments[0].getText();", element);
</code></pre>

<h4>Q:如何启动一个带插件的Firefox？</h4>

<p>A:</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile()
profile.addExtension(....);

WebDriver driver = new FirefoxDriver(profile);
</code></pre>

<h4>Q: 要是WebDriver有...功能，我会更喜欢它。</h4>

<p>A: 如果你希望WebDriver有什么功能，或者发现有什么BUG。你可以添加一个issue到WebDriver主页。</p>

<h4>Q: 有时Selenium server启动一个新session的时候要花费很长的时间？</h4>

<p>A:如果运行在Linux上，你需要增加用于安全随机数生成所需要的熵数量。大多数的Linux发行版都可以通过安装一个叫“randomsound”的包来配置。<br/>
在Windows(XP)系统上，你可以看下<a href="http://bugs.sun.com/view_bug.do?bug_id=6705872">http://bugs.sun.com/view_bug.do?bug_id=6705872</a>,这通常需要从你的临时文件夹清理大量的数据文件。</p>

<h4>Q: 在Selenium WebDriver的API中哪个与TextPresent对等?</h4>

<p>A:</p>

<pre><code>driver.findElement(By.tagName("body")).getText()
</code></pre>

<p>会给出页面的文本内容。关于verifyTextPresent/assertTextPresent,你需要使用Test framework的Assert来验证。关于waitForTextPresent, 你需要使用WebDriverWait类来解决。</p>

<h4>Q:socket lock感觉是一个糟糕的设计。我如何能更好的实现。</h4>

<p>A:守护Firefox启动的socket lock在设计时，有以下的限制：</p>

<ul>
<li>socket lock需要在所有语言绑定之间共享。ruby,java以及其他语言的绑定可以在相同的机器同时共存。</li>
<li>启动firefox的某些关键部分必须在机器上独占锁定。</li>
<li>socket lock本身不是瓶颈。启动firefox才是。</li>
</ul>


<p><code>SocketLock</code>是<code>Lock</code>接口的一个实现. 这给你自己的接口实现提供了一个可插拔的策略。为了切换到一个不同的实现，你需要继承FirefoxDriver并且重写“obtainLock”方法。</p>

<h4>Q: 当我使用Python的send_keys方法时，为什么出现一个UnicodeEncodeError？</h4>

<p>A: 你很可能没有设置系统的Locale。比如设置LANG=en_US.UTF-8和LC_CTYPE="en_US.UTF-8"就可以了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:webdriverJs]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-web-driver-js</id>
    <content type="html"><![CDATA[<h1>WebDriverJS</h1>

<p>WebDriver 的 JavaScript 语言绑定。本文包含以下内容：</p>

<ul>
<li>介绍</li>
<li>快速上手

<ul>
<li>在 Node 中运行</li>
<li>在浏览器中运行</li>
</ul>
</li>
<li>设计细节

<ul>
<li>管理异步 API</li>
<li>同服务端通讯</li>
<li>/xdrpc</li>
</ul>
</li>
<li>未来计划</li>
</ul>


<h2>介绍</h2>

<p>WebDriver 的 JavaScript 绑定（WebDriverJS），可以使 JavaScript 开发人员避免上下文切换的开销，并且可以让他们使用和项目开发代码一样的语言来编写测试。WebDriverJS 既可以在服务端运行，例如 Node，也可以在浏览器中运行。</p>

<p><strong>警告：</strong> WebDriverJS 要求开发者习惯异步编程。对于那些 JavaScript 新手来说可能会发现 WebDriverJS 有点难上手。</p>

<!--more-->


<h2>快速上手</h2>

<h3>在 Node 中运行</h3>

<p>虽然 WebDriverJS 可以在 Node 中运行，但它至今还没有实现本地驱动的支持（也就是说，你的测试必须使用一个远程的 WebDriver 服务）。并且，你必须编译 Selenium 服务端，将其添加到 WebDriverJS 模块。进入 Selenium 客户端的根目录，执行：</p>

<pre><code>$ ./go selenium-server-standalone //javascript/node:webdriver
</code></pre>

<p>当两个目标都被编译好以后，启动服务和 Node，开始编写测试代码：</p>

<pre><code>$ java -jar build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
$ node

var webdriver = require('./build/javascript/node/webdriver');

var driver = new webdriver.Builder().
    usingServer('http://localhost:4444/wd/hub').
    withCapabilities({
      'browserName': 'chrome',
      'version': '',
      'platform': 'ANY',
      'javascriptEnabled': true
    }).
    build();

driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click();
driver.getTitle().then(function(title) {
  require('assert').equal('webdriver - Google Search', title);

});

driver.quit();
</code></pre>

<h3>在浏览器中运行</h3>

<p>除了 Node，WebDriverJS 也可以直接在浏览器中运行。编译比Node方式少很多依赖的浏览器模块，运行：</p>

<pre><code>$ ./go //javascript/webdriver:webdriver
</code></pre>

<p>为了和可能不在同一个域下的 WebDriver 的服务端进行通信，客户端使用的是修改过的 <a href="https://code.google.com/p/selenium/wiki/JsonWireProtocol">JsonWireProtocol</a> 和 <a href="https://code.google.com/p/selenium/wiki/WebDriverJs#Cross-Origin_Resource_Sharing">cross-origin resource sharing</a>：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;script&gt;
  var client = new webdriver.http.CorsClient('http://localhost:4444/wd/hub');
  var executor = new webdriver.http.Executor(client);

  // 启动一个新浏览器，这个浏览器可以被这段脚本控制
  var driver = webdriver.WebDriver.createSession(executor, {
    'browserName': 'chrome',
    'version': '',
    'platform': 'ANY',
    'javascriptEnabled': true
  });

  driver.get('http://www.google.com');
  driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
  driver.findElement(webdriver.By.name('btnG')).click();
  driver.getTitle().then(function(title) {
    if (title !== 'webdriver - Google Search') {
      throw new Error(
          'Expected "webdriver - Google Search", but was "' + title + '"');
    }
  });

  driver.quit();
&lt;/script&gt;
</code></pre>

<h4>控制宿主浏览器</h4>

<p>启动一个浏览器运行 WebDriver 来测试另一个浏览器看起来比较冗余（相比在 Node 中运行而言）。但是，使用 WebDriverJS 在浏览器中运行自动化测试是浏览器真实在跑这些脚本的。这只要服务端的 url 和浏览器的 session id 是已知的就可以实现。这些值可能会直接传递给 builder，它们也可以通过从页面 url 的查询字符串中解析出来的 wdurl 和 wdsid 定义 。</p>

<pre><code>&lt;!-- Assuming HTML URL is /test.html?wdurl=http://localhost:4444/wd/hub&amp;wdsid=foo1234 --&gt;
&lt;!DOCTYPE html&gt;
&lt;script src="webdriver.js"&gt;&lt;/script&gt;
&lt;input id="input" type="text"/&gt;
&lt;script&gt;
  // Attaches to the server and session controlling this browser.
  var driver = new webdriver.Builder().build();

  var input = driver.findElement(webdriver.By.tagName('input'));
  input.sendKeys('foo bar baz').then(function() {
    assertEquals('foo bar baz',
        document.getElementById('input').value);
  });
&lt;/script&gt;
</code></pre>

<h5>警告</h5>

<p>在浏览器中使用 WebDriverJS 有几个需要注意的地方。首先，webdriver.Builder 类只能用于已存在的 session。为了获得一个新的 session，你必须像上面的例子那样手工创建。其次，有一些命令可能会影响运行 WebDriverJS 脚本的页面。</p>

<ul>
<li>webdriver.WebDriver#quit: quit 命令将终止整个浏览器进程，包括在运行 WebDriverJS 的窗口。除非你确定要这样做，否则不要使用这个命令。</li>
<li><p>webdriver.WebDriver#get: WebDriver 的接口被设计为尽量接近用户的操作。这意味着无论 WebDriver 客户端当前聚焦在哪个帧，导航命令（如：driver.get(url)）总是指向最高层的帧。在操作宿主浏览器时，WebDriverJS 脚本可以通过使用 .get 命令导航离开当前页面，而当前页面仍然获得焦点。 如果要自动操作一个宿主浏览器但仍想在页面间跳转，请把WebDriver客户端的焦点设在另一个窗口上(这和Selenium RC 的多窗口模式的概念非常相似):</p>

<p>  &lt;!DOCTYPE html>
  <script src="webdriver.js"></script>
  <script></p>

<pre><code>var testWindow = window.open('', 'slave');

var driver = new webdriver.Builder().build();
driver.switchTo().window('slave');
driver.get('http://www.google.com');
driver.findElement(webdriver.By.name('q')).sendKeys('webdriver');
driver.findElement(webdriver.By.name('btnG')).click(); 
</code></pre>

<p>  </script></p></li>
</ul>


<h4>调试 Tests</h4>

<p>你可以使用 WebDriver 的服务来调试在浏览器中使用  WebDriverJS 运行的测试。</p>

<pre><code>$ ./go selenium-server-standalone
$ java -jar \
    -Dwebdriver.server.session.timeout=0 \
    build/java/server/src/org/openqa/grid/selenium/selenium-standalone.jar &amp;
</code></pre>

<p>启动服务后，访问 WebDriver 的控制面板： http://localhost:4444/wd/hub。你可以使用这个控制面板查看，创建或者删除 sessions。选择一个要调试的 session 后，点击 “load script” 按钮。在弹出的对话框中，输入你的 WebDriverJS 测试的地址：服务端将在你的浏览器中打开这个页面，这个页面的 url 含有额外的参数用于 WebDriverJS 客户端和服务端的通讯。</p>

<h5>支持的浏览器</h5>

<ul>
<li>IE 8+</li>
<li>Firefox 4+</li>
<li>Chrome 12+</li>
<li>Opera 12.0a+</li>
<li>Android 4.0+</li>
</ul>


<h2>设计细节</h2>

<h3>管理异步 API</h3>

<p>不同于其他那些提供了阻塞式 API 的语言绑定，WebDriverJS 完全是异步的。为了追踪每个命令的执行状态， WebDriverJS 对 “promise” 进行了扩展。promise 是一个这样的对象，它包含了在未来某一点可用的一个值。JavaScript 有几个 promise 的实现，WebDriverJS 的 promise 是基于 CommonJS 的 <a href="http://www.google.com/url?q=http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FPromises%2FA&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGC0NMXO-81exam-S5HjTuOxaV_mw">Promise/A</a> 提议，它定义了 promise 是任意对象上的 then 函数属性。</p>

<pre><code>/**
 * Registers listeners for when this instance is resolved.
 *
 * @param {?function(*)} callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {?function(*)=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the failure
 *     reason. While this argument is typically an {@code Error}, any type is
 *     permissible.
 * @return {!Promise} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
Promise.prototype.then = function(callback, opt_errback) {
};
</code></pre>

<p>通过使用 promises，你可以将一连串的异步操作连接起来，确保每个操作执行时，它之前的操作都已经完成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com').then(function() {
  return driver.findElement(webdriver.By.name('q')).then(function(searchBox){
    return searchBox.sendKeys('webdriver').then(function() {
      return driver.findElement(webdriver.By.name('btnG')).then(function(submitButton) {
        return submitButton.click().then(function() {
          return driver.getTitle().then(function(title) {
            assertEquals('webdriver - Google Search', title);
          });
        });
      });
    });
  });
});
</code></pre>

<p>不幸的是，上述范例非常冗长，难以辨别测试的意图。为了提供一套不降低测试可读性的干净利落的异步操作 API, WebDriverJS 引入了一个 promise “管理器” 来调度和执行所有的命令。</p>

<p>简言之，promise 管理器处理用户自定义任务的调度和执行。管理器保存了一个任务调度的列表，当列表中的某个任务执行完毕后，依次执行下一个任务。如果一个任务返回了一个 promise，管理器将把它当做一个回调注册，在这个 promise 完成后恢复其运行。WebDriver 将自动使用管理器，所以用户不需要使用链式调用。因此，之前的 google 搜索的例子可以简化成：</p>

<pre><code>var driver = new webdriver.Builder().build();
driver.get('http://www.google.com');

var searchBox = driver.findElement(webdriver.By.name('q'));
searchBox.sendKeys('webdriver');

var submitButton = driver.findElement(webdriver.By.name('btnG'));
submitButton.click();

driver.getTitle().then(function(title) {
  assertEquals('webdriver - Google Search', title);
});
</code></pre>

<h4>On Frames and Callbacks</h4>

<p>就内部而言，promise 管理器保存了一个调用栈。在管理器执行循环的每一圈，它将从最顶层帧的队列中取一个任务来执行。任何被包含在之前命令的回调中的命令将被排列在一个新帧中，以确保它们能在所有早先排列的任务之前运行。这样做的结果是，如果你的测试是 written-in line，所有的回调都使用函数字面量定义，命令将按照它们在屏幕上出现的垂直顺序来执行。例如，考虑以下 WebDriverJS 测试用例：</p>

<pre><code>driver.get(MY_APP_URL);
driver.getTitle().then(function(title) {
  if (title === 'Login page') {
    driver.findElement(webdriver.By.id('user')).sendKeys('bugs');
    driver.findElement(webdriver.By.id('pw')).sendKeys('bunny');
    driver.findElement(webdriver.By.id('login')).click();
  }
});
driver.findElement(webdriver.By.id('userPreferences')).click();
</code></pre>

<p>这个测试用例可以使用 WebDriver 的 Java API 重写如下：</p>

<pre><code>driver.get(MY_APP_URL);
if ("Login Page".equals(driver.getTitle())) {
  driver.findElement(By.id("user")).sendKeys("bugs");
  driver.findElement(By.id("pw")).sendKeys("bunny");
  driver.findElement(By.id("login")).click();
}
driver.findElement(By.id("userPreferences")).click();
</code></pre>

<h4>错误处理</h4>

<p>既然所有 WebDriverJS 的操作都是异步执行的，我们就不能使用 try-catch 语句。取而代之的是，你必须为所有命令的 promise 返回注册一个错误处理的函数。这个错误处理函数可以抛出一个错误，在这种情况下，它将被传递给链中的下一个错误处理，或者他将返回一个不同的值来抑制这个错误并切换回回调处理链。</p>

<p>如果错误处理器没有正确的处理被拒绝的 promise（不只是哪些来自于 WebDriver 命令的），则这个错误会传播至错误处理链的父级帧。如果一个错误没有被抑制而传播到了顶层帧，promise 管理器要么触发一个 uncaughtException 事件（如果有注册监听的话），或者将错误抛给全局错误处理器。在这两种情况下，promise 管理器都将抛弃所有队列中后续的命令。</p>

<pre><code>// 注册一个事件监听未处理的错误
webdriver.promise.Application.
    getInstance().
    on('uncaughtException', function(e) {
      console.error('There was an uncaught exception: ' + e.message);
    });

driver.switchTo().window('foo').then(null, function(e) {
  // 忽略 NoSuchWindow 错误，让其他类型的错误继续向上冒泡
  if (e.code !== bot.ErrorCode.NO_SUCH_WINDOW) {
    throw e;
  }
});
// 如果上面的错误不被抑制的话，这句将永远不会执行
driver.getTitle();
</code></pre>

<h3>同服务端通讯</h3>

<p>当在服务端环境中运行时，客户端不受安全沙箱的约束，可以简单的发送 http 请求（例如：node 的 http.ClientRequest）。当在浏览器端运行时，WebDriverJS 客户端就会收到同源策略的约束。为了和可能不在同一个域下的服务端通讯，WebDriverJS 客户端使用的是修改过的 JsonWireProtocol 和 cross-origin resource sharing。</p>

<h4>Cross-Origin Resource Sharing</h4>

<p>如果一个浏览器支持 cross-origin resource sharing (CORS), WebDriverJS 将使用 cross-origin XMLHttpRequests (XDR) 发送命令给服务端。服务端要想支持 XDR，就需要响应 preflight 请求，并带有合适的 access-control 头。</p>

<pre><code>Access-Control-Origin: *
Access-Control-Allow-Methods: DELETE,GET,HEAD,POST
Access-Control-Allow-Headers: Accept,Content-Type
</code></pre>

<p>在编写本文时，已有 Firefox 4+, Chrome 12+, Safari 4+, Mobile Safari 3.2+, Android 2.1+, Opera 12.0a, 和 IE8+ 支持 CORS。不幸的是，这些浏览器的实现并不一致，也不是完全都遵循 W3C 的规范。</p>

<ul>
<li>IE 的 XDomainRequest 对象，比其 XMLHttpRequest 对象的功能要弱。XDomainRequest 只能发送哪些标准的 form 表单可以发送的请求。这限制了 IE 只能发送 get 和 post 请求（wire 协议要求支持 delete 请求）。</li>
<li>WebKit 的 CORS 实现禁止了跨域请求的重定向，即使 access-control 头被正确设置了也是如此。</li>
<li>如果返回一个服务端错误（4xx 或 5xx），IE 和 Opera 的实现将触发 XDomainRequest/XMLHttpRequest 对象的错误处理，但是拿不到服务端返回的信息。这使得它们无法处理以标准的 JSON 格式返回的错误信息。</li>
</ul>


<p>为了弥补这些短处，当在浏览器中运行时，WebDriverJS 将使用修改过的 JsonWireProtocol 和通过 /xdrpc 路由所有的命令。</p>

<h4>/xdrpc</h4>

<p><strong>POST /xdrpc</strong></p>

<p>作为命令的代理，所有命令相关的内容必须被编码成 JSON 格式。命令的执行结果将在 HTTP 200 响应中作为一个标准的响应结果返回。客户端依赖于响应的转台吗以确认命令是否执行成功。</p>

<p><strong>参数：</strong></p>

<ul>
<li>method - {string} http 方法</li>
<li>path - {string} 命令路径</li>
<li>data - {Object} JSON 格式的命令参数</li>
</ul>


<p><strong>返回：</strong></p>

<p>{*} 命令执行的结果。</p>

<p>举个例子，考虑以下 /xdrpc 命令：</p>

<pre><code>POST /xdrpc HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 94

{"method":"POST","path":"/session/123/element/0a/element","data":{"using":"id","value":"foo"}}
</code></pre>

<p>服务端将编码这个命令并重新分发：</p>

<pre><code>POST /session/123/element/0a/element HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28

{"using":"id","value":"foo"}
</code></pre>

<p>不管是否成功，命令的执行结果都将作为一个标准的 JSON 返回：</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 60

{"status":7,"value":{"message":"Unable to locate element."}}
</code></pre>

<h2>未来计划</h2>

<p>以下是一些预期要做的事情。但什么时候完成，在现在仍然未知。如果你有兴趣参与开发，请加入 selenium-developers@googlegroups.com。当然，这是一个开源软件，你完全不需要等待我们。如果你有好主意，就马上开工吧：）</p>

<ul>
<li>使用 AutomationAtoms 实现一个纯 JavaScript 的命令执行器。这将允许开发者使用 js 编写非常轻量的测试代码，并且可以运行在任何服浏览器中（当然，仍然会收到同源策略的限制）。</li>
<li>基于扩展实现一个 SafariDriver。</li>
<li>为 Node 提供本地浏览器支持，而不需要通过 WebDriver Server 运行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selenium wiki:高级用户交互]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions/"/>
    <updated>2013-05-30T19:56:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/05/30/selenium-wiki-advanced-user-interactions</id>
    <content type="html"><![CDATA[<h3>AdvancedUserInteractions(高级用户交互)</h3>

<h3>入门</h3>

<p>高级用户交互API提供了一个更新更完善的机制来定义并描述用户在一个网页上的各种操作。这些操作包括：拖拽、按住CTRL键选择多个元素等等。</p>

<h4>开始（short how to）</h4>

<p>为了生成一连串的动作，我们使用Actions来建立。首先，我们先配置操作：</p>

<pre><code>Actions builder = new Actions(driver);

builder.keyDown(Keys.CONTROL)
.click(someElement)
.click(someOtherElement)
.keyUp(Keys.CONTROL);
</code></pre>

<p>然后，获得操作（Action）:</p>

<pre><code>Action selectMultiple = builder.build();
</code></pre>

<p>最后，执行这个动作：</p>

<pre><code>selectMultiple.perform();   
</code></pre>

<p>这一系列的动作应该尽量的短。在使用中最好在执行一个简短的动作后验证页面是否处于正确的状态，然后再执行下面的动作。下一节将会列出所有可用的动作（Action），并且说明它们如何进行扩展。</p>

<!--more-->


<p></p>

<h4>键盘交互（Keyboard interactions）</h4>

<p>键盘交互是发生在一个特定的页面元素的，而webdriver会确保这个页面元素在执行键盘动作时处于正确的状态。这个正确的状态，包括页面元素滚动到可视区域并定位到这个页面元素。 <br/>
既然这个新的API是面向用户（user-oriental）的接口，那么对于一个用户，在对一个元素输入文本前做显式的交互就更加的符合逻辑。这意味着，当想定位到相邻的页面元素时，可能需要点击一下元素或按下Tab（<code>Keys.TAB</code>）键。<br/>
The new interactions API will (first) support keyboard actions without a provided element. The additional work to focus on an element before sending it keyboard events will be added later on.</p>

<h4>鼠标交互（Mouse interactions）</h4>

<p>鼠标操作有一个上下文-鼠标的当前位置。因此，当为几个鼠标操作设定一个上下文时，第一个操作的上下文就是元素的相对位置，下一个操作的上下文就上一个操作后的鼠标相对位置。</p>

<h3>支持情况</h3>

<p>这个针对操作以及动作生成器的API已经（绝大部分）完成。HtmlUnit和Firefox已经完全支持，Opera和IE正在支持中。</p>

<h3>大纲</h3>

<h4>单个动作</h4>

<p>所有的动作都实现了<code>Action</code>接口，这个接口只有一个方法：<code>perform（）</code>。每个动作所需要的信息都通过Constructor传入。当调用这个动作的时候，动作知道如何与页面交互（如，找到活动的元素并输入文本或者计算出在屏幕上的点击坐标）并且调用底层实现来实现这个交互。 <br/>
下面是一些动作：</p>

<ul>
<li>ButtonReleaseAction - 释放鼠标左键</li>
<li>ClickAction - 相当于 WebElement.click()</li>
<li>ClickAndHoldAction - 按下鼠标左键并保持</li>
<li>ContextClickAction - 一般就是鼠标右键，通常调出右键菜单用。</li>
<li>DoubleClickAction - 双击某个元素</li>
<li>KeyDownAction - 按下修饰键（SHIFT，CTRL，ALT，WIN）</li>
<li>KeyUpAction - 释放修饰键</li>
<li>MoveMouseAction - 移动鼠标从当前位置到另外的元素.</li>
<li>MoveToOffsetAction - 移动鼠标到一个元素的偏移位置（偏移可以为负，元素是鼠标刚移动到的那个元素）。</li>
<li>SendKeysAction - 相当于 WebElement.sendKey(...)</li>
</ul>


<p><code>CompositeAction</code>包含一系列的动作，当被调用的时候，它会调用它所包含的所有动作的perform方法。通常，这个动作通常都不是直接建立的，一般是使用<code>ActionChainsGenerator</code>。</p>

<h4>生成动作链</h4>

<p><code>Actions</code>链生成器实现了创建者模式来新建一个包含一组动作的<code>CompositeAction</code>。使用Actions生成器可以很容易的生成动作并调用<code>build（）</code>方法来获得复杂的操作。</p>

<pre><code>Actions builder = new Actions(driver);

Action dragAndDrop = builder.clickAndHold(someElement)
   .moveToElement(otherElement)
   .release(otherElement)
   .build();

dragAndDrop.perform();
</code></pre>

<p>有一个对<code>Actions</code>进行扩展的计划，给<code>Actions</code>类添加一个方法，这个方法可以追加任何动作到其拥有的动作列表上。这将允许添加扩展的动作，而不用人工创建CompositeAction。关于扩展<code>Actions</code>,请往下看。</p>

<h4>扩展Action接口的指导</h4>

<p>Action接口只有一个方法-<code>perform()</code>。除了实际的交互本身，所有的条件判断也都应该在这个这个方法里实现。在动作创建和动作实际执行这段时间内，很可能页面的状态已经发生了变化，比如元素的可视情况已经坐标已经不能找到了。</p>

<h3>实现细节</h3>

<p>为了达到每个操作的执行与具体实现的分离，所有的动作都依赖2个接口：<code>Mouse</code>和<code>Keyboard</code>。这些接口被所有支持高级用户接口API的driver实现了。需要注意的是，这些接口是为了让动作使用的，而不是最终用户。本节的信息，主要是针对想扩展WebDriver的开发者的。</p>

<h4>一字警告</h4>

<p><code>Keyboard</code>和<code>Mouse</code>接口是设计用来支持各种Action类的。有鉴于此，它们的API没有Actions链生成器API稳定。直接使用这些接口可能达不到期望的结果，因为Action类做了额外的工作来确保在实际事件触发时处于正确的环境条件。这些准备工作包括定位在正确的元素上或者鼠标交互前保证元素是可见的。</p>

<h4>Keyboard接口</h4>

<p>Keyboard接口包含3个方法：</p>

<ul>
<li>void sendKeys(CharSequence... keysToSend) - 与 sendKeys(...)相似.</li>
<li>void pressKey(Keys keyToPress) - 按下一个键并保持。键仅限于修饰键(Control, Alt and Shift).</li>
<li>void releaseKey(Keys keyToRelease) - 释放修饰键.</li>
</ul>


<p>至于如何在调用之间保存修饰键的状态是Keyboard接口实现类的职责。只有活跃的元素才会接收到这些事件。</p>

<h4>Mouse接口</h4>

<p><code>Mouse</code>接口包含以下方法（有可能不久之后会有变化）：</p>

<ul>
<li>void click(WebElement onElement) - 同click()方法一样.</li>
<li>void doubleClick(WebElement onElement) - 双击一个元素.</li>
<li>void mouseDown(WebElement onElement) - 在一个元素上按下左键并保持
Action selectMultiple = builder.build();</li>
<li>void mouseUp(WebElement onElement) - 在一个元素上释放左键.</li>
<li>void mouseMove(WebElement toElement) - 从当前位置移动到一个元素</li>
<li>void mouseMove(WebElement toElement, long xOffset, long yOffset) - 从当前位置移动到一个元素的偏移坐标</li>
<li>void contextClick(WebElement onElement) - 在一个元素上做一个右键操作</li>
</ul>


<h4>Native events（原生事件） VS synthetic events（合成事件）</h4>

<p>WebDriver提供的高级用户接口，要么是直接模拟的Javascript事件（即合成事件），要么就是让浏览器生成Javascript事件（即原生事件）。原生事件能更好的模拟用户交互，而合成事件则是平台独立的，这使得使用了替代的窗口管理器的linux系统显得尤其重要，具体参加<a href="https://code.google.com/p/selenium/wiki/NativeEventsOnLinux">native events on Linux</a>。原生事件无论什么时候总是应该尽可能的使用。</p>

<p>下面的表格展示了浏览器对事件的支持情况。</p>

<table border="1px">
<tr>
<td>浏览器</td><td>操作系统</td><td>原生事件</td><td>合成事件</td>
</tr>
<tr>
<td>Firefox</td><td>Linux</td><td>支持</td><td>支持（默认）</td>
</tr>
<tr>
<td>Firefox</td><td>Windows</td><td>支持（默认）</td><td>支持</td>
</tr>
<tr>
<td>Internet Explorer</td><td>Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>Chrome</td><td>Linux/Windows</td><td>支持*</td><td>不支持</td>
</tr>
<tr>
<td>Opera</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
<tr>
<td>HtmlUnit</td><td>Linux/Windows</td><td>支持（默认）</td><td>不支持</td>
</tr>
</table>


<p>*)ChromeDriver提供了2种模式来支持原生事件：Webkit事件和原始事件。其中Webkit事件是使用Webkit函数来触发的Javascript事件，而原始事件模式则使用的是操作系统级别的事件。</p>

<p>FirefoxDriver中，原生事件可以使用FirefoxProfile来进行开关控制。</p>

<pre><code>FirefoxProfile profile = new FirefoxProfile();
profile.setEnableNativeEvents(true);
FirefoxDriver driver = new FirefoxDriver(profile);
</code></pre>

<h5>例子</h5>

<p>以下是原生事件与合成事件表现不同的一些例子：</p>

<ul>
<li>使用合成事件，点击隐藏在其他元素下面的元素是可以的。使用原生事件，浏览器会将点击事件作用在所给坐标最外层的元素上，就像是用户点击在特定的位置一样。</li>
<li>当一个用户，按下TAB键希望焦点从当前元素定位到下一个元素，浏览器是可以做到的。使用合成事件的话，浏览器并不知道TAB键被按下了，因此也不会改变焦点。而使用原生事件，浏览器则会表现正确。</li>
</ul>


<hr />

<p>原文：<a href="https://code.google.com/p/selenium/wiki/AdvancedUserInteractions">https://code.google.com/p/selenium/wiki/AdvancedUserInteractions</a></p>
]]></content>
  </entry>
  
</feed>
