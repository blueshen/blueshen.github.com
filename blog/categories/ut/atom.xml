<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ut | Blues 小站]]></title>
  <link href="http://www.shenyanchao.cn/blog/categories/ut/atom.xml" rel="self"/>
  <link href="http://www.shenyanchao.cn/"/>
  <updated>2014-03-31T16:43:42+08:00</updated>
  <id>http://www.shenyanchao.cn/</id>
  <author>
    <name><![CDATA[ShenYanchao]]></name>
    <email><![CDATA[zhiyi.shen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DbUnit使用入门]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit/"/>
    <updated>2013-06-27T15:57:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/27/usage-dbunit</id>
    <content type="html"><![CDATA[<p><a href="http://www.dbunit.org/">DbUnit</a>是一个意在对使用数据库驱动项目进行测试的JUnit扩展。它使得你的数据库在各个Test之间处于一个已知的状态。这很好的解决了以下问题：当一个测试破坏了数据库时，导致其后面的所有测试失败或给出了错误的结果。</p>

<h3>DbUnit原理</h3>

<p>DbUnit通过维护真实数据库与数据集(DataSet)之间的关系来发现与暴露测试过程中的问题。此处DataSet可以自建，可以由数据库导出，并以多种方式体现，xml文件、XLS文件和数据库查询数据等，一般多用XML文件。在测试过程中，DataSet被称为期望结果(expected result),真实数据库被称真实结果(actual result),你所要做的就是通过DbUnit完成期望结果与真实结果之间的操作与比较，从而发现问题和校验结果。 <br/>
DbUnit包括三个核心部分:</p>

<ul>
<li>IDatabaseConnection ：描述DbUnit数据库连接接口；</li>
<li>IDataSet：数据集操作接口；</li>
<li>DatabaseOperation：描述测试用例测试方法执行前与执行后所做操作的抽象类；</li>
</ul>


<!--more-->


<p>值得关注的是DatabaseOperation的各种实现，比较常用的有 REFRESH、DELETE_ALL和CLEAN_INSERT等。这些操作关系到数据集与数据库数据的同步、数据准备，不小心就会对数据库原有数据造成影响，所以务必做好备份。</p>

<p>DatabaseOperation有以下的可选项：</p>

<ul>
<li>NONE：不执行任何操作，是getTearDownOperation的默认返回值。</li>
<li>UPDATE：将数据集中的内容更新到数据库中。它假设数据库中已经有对应的记录，否则将失败。</li>
<li>INSERT：将数据集中的内容插入到数据库中。它假设数据库中没有对应的记录，否则将失败。</li>
<li>REFRESH：将数据集中的内容刷新到数据库中。如果数据库有对应的记录，则更新，没有则插入。</li>
<li>DELETE：删除数据库中与数据集对应的记录。</li>
<li>DELETE_ALL：删除表中所有的记录，如果没有对应的表，则不受影响。</li>
<li>TRUNCATE_TABLE：与DELETE_ALL类似，更轻量级，不能rollback。</li>
<li>CLEAN_INSERT：是一个组合操作，是DELETE_ALL和INSERT的组合。是getSetUpOeration的默认返回值。</li>
</ul>


<h3>开始使用DbUnit</h3>

<h4>DataSet数据集准备</h4>

<p>DataSet可以手工编写，当然也可以从已有数据库导出。以使用广泛的FlatXMlDataSet来说，可以<a href="http://www.dbunit.org/components.html#FlatXmlDataSet">手工编写</a>。另外也可以从数据库读取，DbUnit提供了相关的API：</p>

<pre><code>    QueryDataSet dataSet = new QueryDataSet(getConnection());
    dataSet.addTable("user", "select * from user ");
    FlatXmlDataSet.write(dataSet, new FileOutputStream("data.xml"));
</code></pre>

<h4>继承DBTestCase来实现测试用例</h4>

<p>最简单的使用DbUnit的方式就是继承DBTestCase。当然有一些方法需要重写，比如getDataSet()用来读取DataSet并返回。DBTestCase依赖于IDatabaseTester来连接数据库。默认使用的是PropertiesBasedJdbcDatabaseTester，它会从系统变量内获取DriverManager使用的相关变量。如果要使用其它的方式，可以重写getDatabaseTester()。当然也可以直接继承DBTestCase的其它子类。比如：</p>

<ul>
<li>JdbcBasedDBTestCase</li>
<li>DataSourceBasedDBTestCase</li>
<li>JndiBasedDBTestCase</li>
</ul>


<p>下面依默认的情况，那么如何设置系统变量呢？在Constructor里就好了。</p>

<pre><code>public class SampleTest extends DBTestCase
{
    public SampleTest(String name)
    {
        super( name );
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, "org.h2.Driver");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, "jdbc:h2:~/dbunitdemo");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, "sa");
        System.setProperty(PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, "");

    protected IDataSet getDataSet() throws Exception
    {
        return new FlatXmlDataSetBuilder().build(new FileInputStream("dataset.xml"));
    }
}
</code></pre>

<p>那么如果我要使用其它的DatabaseTester怎么办？比如JdbcDatabaseTester。那直接重写getDatabaseTester(),返回JdbcDatabaseTester就好了。其它同理。当然那个Constructor就可以去除哪些属性设置了。</p>

<pre><code>protected IDatabaseTester getDatabaseTester() throws ClassNotFoundException {
    return new JdbcDatabaseTester("org.h2.Driver", "jdbc:h2:~/dbunitdemo", "sa", "");
}
</code></pre>

<h4>定制测试执行前后的操作</h4>

<p>默认情况下，在Test执行前会做一个CLEAN_INSERT操作，然后结束后做一个NONE操作。那么，如何定制这个操作呢？我们可以重写getSetUpOperation()和 getTearDownOperation()方法就可以了。</p>

<pre><code>protected DatabaseOperation getSetUpOperation() throws Exception
{
    return DatabaseOperation.REFRESH;
}

protected DatabaseOperation getTearDownOperation() throws Exception
{
    return DatabaseOperation.NONE;
}
</code></pre>

<h4>DatabaseConfig设置</h4>

<p>有时候，需要对DatabaseConnection做一些特殊的配置，那么这个时候，我们可以重写setUpDatabaseConfig(DatabaseConfig config)。</p>

<pre><code>protected void setUpDatabaseConfig(DatabaseConfig config) {
        config.setProperty(DatabaseConfig.PROPERTY_BATCH_SIZE, new Integer(97));
        config.setFeature(DatabaseConfig.FEATURE_BATCHED_STATEMENTS, true);
}
</code></pre>

<p>比如，我在使用H2Database时，老是报一个这样的warn:</p>

<pre><code>WARN org.dbunit.dataset.AbstractTableMetaData - Potential problem found: The configured data type factory 'class org.dbunit.dataset.datatype.DefaultDataTypeFactory' might cause problems with the current database 'H2' (e.g. some datatypes may not be supported properly). In rare cases you might see this message because the list of supported database products is incomplete (list=[derby]). If so please request a java-class update via the forums.If you are using your own IDataTypeFactory extending DefaultDataTypeFactory, ensure that you override getValidDbProducts() to specify the supported database products.
</code></pre>

<p>那么，如何让这个WARN消失呢？加上这个配置：</p>

<pre><code>config.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());
</code></pre>

<h4>Database数据验证</h4>

<p>DbUnit提供了校验2个Table或者datasets是否包含相同数据的方法。</p>

<pre><code>public class Assertion
{
    public static void assertEquals(ITable expected, ITable actual)
    public static void assertEquals(IDataSet expected, IDataSet actual)
}
</code></pre>

<p>下面的例子，展示了如何对比一个数据库Table和Flat Xml table的数据是否一致。</p>

<pre><code>    // Fetch database data after executing your code
    IDataSet databaseDataSet = getConnection().createDataSet();
    ITable actualTable = databaseDataSet.getTable("TABLE_NAME");

    // Load expected data from an XML dataset
    IDataSet expectedDataSet = new FlatXmlDataSetBuilder().build(new File("expectedDataSet.xml"));
    ITable expectedTable = expectedDataSet.getTable("TABLE_NAME");

    // Assert actual database table match expected table
    Assertion.assertEquals(expectedTable, actualTable);
</code></pre>

<h3>DbUnit的运行步骤</h3>

<p>由于DBTestCase最终都是继承自JUnit的TestCase的，很明显，在一个测试方法执行前都会调用setUp(),执行后调用tearDown()。在DatabaseTestCase中对这2个函数进行了重写，如下所示：</p>

<pre><code>protected void setUp() throws Exception
{
    logger.debug("setUp() - start");

    super.setUp();
    final IDatabaseTester databaseTester = getDatabaseTester();
    assertNotNull( "DatabaseTester is not set", databaseTester );
    databaseTester.setSetUpOperation( getSetUpOperation() );
    databaseTester.setDataSet( getDataSet() );
    databaseTester.setOperationListener(getOperationListener());
    databaseTester.onSetup();
}

protected void tearDown() throws Exception
{
    logger.debug("tearDown() - start");

    try {
        final IDatabaseTester databaseTester = getDatabaseTester();
        assertNotNull( "DatabaseTester is not set", databaseTester );
        databaseTester.setTearDownOperation( getTearDownOperation() );
        databaseTester.setDataSet( getDataSet() );
        databaseTester.setOperationListener(getOperationListener());
        databaseTester.onTearDown();
    } finally {
        tester = null;
        super.tearDown();
    }
}
</code></pre>

<p>这2个重写的方法，也验证了前面所说，DBTestCase是依赖于databaseTester的。前面所做的一些重写方法，在这里得到了使用，从而改变了测试执行的动作。databaseTester.onSetup()，databaseTester.onTearDown()分别按照配置完成了测试执行前后的操作。</p>

<p>总结：</p>

<ul>
<li>1.移除数据库中的所有记录（CLEAN_INSERT中的DELETE_ALL)。</li>
<li>2.将数据集中的数据加载到数据库中（CLEAN_INSERT中的INSERT)。</li>
<li>3.运行测试。</li>
<li>4.测试运行完毕后，不执行任何操作。</li>
</ul>


<h3>使用什么数据库？</h3>

<p>由于单元测试，与生产环境不要求是一样的数据库。因此，原则上是可以随意选取的。但是考虑到敏捷性，尽量选取轻量级的，以及可移植的。  <br/>
这里推荐一个数据库<a href="http://www.h2database.com/html/main.html">H2Database</a>，它是一个内存数据库，极为轻量。它与其它几种数据库的对比如下：</p>

<table style="width: 470px;" border="1"><tr>
<th></th>
<th>H2</th>
<th><a href="http://db.apache.org/derby">Derby</a></th>
<th><a href="http://hsqldb.org">HSQLDB</a></th>
<th><a href="http://mysql.com">MySQL</a></th>
<th><a href="http://www.postgresql.org">PostgreSQL</a></th>
</tr><tr>
<td>Pure Java</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Memory Mode</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>Encrypted Database</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
</tr><tr>
<td>ODBC Driver</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Fulltext Search</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Multi Version Concurrency</td>
<td class="compareY">Yes</td>
<td class="compareN">No</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
<td class="compareY">Yes</td>
</tr><tr>
<td>Footprint (jar/dll size)</td>
<td>~1 MB</td>
<td>~2 MB</td>
<td>~1 MB</td>
<td>~4 MB</td>
<td>~6 MB</td>
</tr>
</table>


<p>之所以选择内存数据库，是因为在诸如持续集成时，不同的机器可能配置不一样，想运行还要搭建数据库，这个比较麻烦啊。  <br/>
有了数据库就牵涉到如何初始化数据库的问题。如果你使用MAVEN触发Test，这里推荐一个<a href="http://mojo.codehaus.org/sql-maven-plugin/">sql-maven-plugin</a>。它可以方便的执行数据库SQL脚本来创建数据库。</p>

<pre><code>            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;sql-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.5&lt;/version&gt;
                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
                        &lt;artifactId&gt;h2&lt;/artifactId&gt;
                        &lt;version&gt;1.3.172&lt;/version&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;configuration&gt;
                    &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
                    &lt;url&gt;jdbc:h2:~/dbunitdemo&lt;/url&gt;
                    &lt;username&gt;sa&lt;/username&gt;
                    &lt;password&gt;&lt;/password&gt;
                    &lt;srcFiles&gt;
                        &lt;srcFile&gt;${project.basedir}/src/main/sql/dbunitdemo.sql&lt;/srcFile&gt;
                    &lt;/srcFiles&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;create-db&lt;/id&gt;
                        &lt;phase&gt;process-test-resources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;execute&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>

<p>这里，创建了一个H2Database。直接执行<code>mvn sql:execute</code>用来初始化数据库。当然，这里把执行配置到了process-test-resources阶段，直接执行<code>mvn test</code>就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito简介]]></title>
    <link href="http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief/"/>
    <updated>2013-06-21T21:29:00+08:00</updated>
    <id>http://www.shenyanchao.cn/blog/2013/06/21/mockito-in-brief</id>
    <content type="html"><![CDATA[<p>Mockito 是目前 java 单测中使用比较流行的 mock 工具。其他还有 EasyMock，JMock，MockCreator，Mockrunner，MockMaker 及 PowerMock。</p>

<p>项目地址:<a href="https://code.google.com/p/mockito/">https://code.google.com/p/mockito/</a></p>

<h2>powermock 简介</h2>

<p>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。PowerMock 是在 EasyMock 以及 Mockito 基础上的扩展，通过定制类加载器等技术，PowerMock 实现了之前提到的所有模拟功能，使其成为大型系统上单元测试中的必备工具。缺点是缺少文档。</p>

<p>项目地址:<a href="https://code.google.com/p/powermock/">https://code.google.com/p/powermock/</a></p>

<!--more-->


<h2>Mock 和Stub</h2>

<h3>Mock</h3>

<p>所谓的mock，即模拟，模仿的意思。Mock 技术的主要作用是使用mock工具模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试目标与测试边界以外的对象隔离开。</p>

<h3>Stub</h3>

<p>Stub,桩。单元测试过程中，对于在应用中不容易构造或者比较复杂的对象，用一个虚拟的对象来代替它。从类的实现方式上看，stub有一个显式的类实现，按照stub类的复用层次可以实现为普通类(被多个测试案例复用)，内部类(被同一个测试案例的多个测试方法复用)乃至内部匿名类(只用于当前测试方法)。stub的方法也会有具体的实现，哪怕简单到只有一个简单的return语句。</p>

<h3>Stub 与 Mock 的区别</h3>

<p>Stub 是在单元测试过程中去代替某些对象来提供所需的测试数据，适用于基于状态的（state-based）测试，关注的是输入和输出。而Mock适用于基于交互的（interaction-based）测试，关注的是交互过程，不只是模拟状态，还能够模拟模块或对象的行为逻辑并能验证其正确性，Mock不需要类的显示实现，直接用工具模拟。</p>

<h2>Mockito 的使用</h2>

<h3>Maven</h3>

<p>通过Maven管理的，需要在项目的Pom.xml中增加如下的依赖：</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.mockito&lt;/groupId&gt;
&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
&lt;version&gt;1.9.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>在程序中可以<code>import org.mockito.Mockito</code>，然后调用它的static方法。</p>

<h3>Maven 程序</h3>

<h4>1.模拟对象</h4>

<p>创建 Mock 对象的语法为 mock(class or interface)。</p>

<h4>2.设置对象调用的预期返回值</h4>

<p>通过 when(mock.someMethod()).thenReturn(value) 来设定 Mock 对象某个方法调用时的返回值。或者使用 when(mock.someMethod()).thenThrow(new RuntimeException) 的方式来设定当调用某个方法时抛出的异常。</p>

<h4>3.验证被测试类方法</h4>

<p>Mock 对象一旦建立便会自动记录自己的交互行为，所以我们可以有选择的对它的 交互行为进行验证。在 Mockito 中验证 Mock 对象交互行为的方法是 verify(mock).someMethod(…)。最后 Assert() 验证返回值是否和预期一样。</p>

<h3>Demo</h3>

<h2>Mock 对象的创建</h2>

<pre><code>mock(Class&lt;T&gt; classToMock);
mock(Class&lt;T&gt; classToMock, String name)
mock(Class&lt;T&gt; classToMock, Answer defaultAnswer)
mock(Class&lt;T&gt; classToMock, MockSettings mockSettings)
mock(Class&lt;T&gt; classToMock, ReturnValues returnValues)
</code></pre>

<p>可以对类和接口进行mock对象的创建，创建时可以为mock对象命名。对mock对象命名的好处是调试的时候容易辨认mock对象。</p>

<h2>Mock对象的期望行为和返回值设定</h2>

<p>假设我们创建了LinkedList类的mock对象：</p>

<pre><code>LinkedList mockedList = mock(LinkedList.class);
</code></pre>

<h3>对方法进行设定返回值和异常</h3>

<h4>对包含返回值的方法的设定</h4>

<pre><code>when(mockedList.get(0)).thenReturn("first");
when(mockedList.get(1)).thenThrow(new RuntimeException());   
</code></pre>

<p>Mockito支持迭代风格的返回值设定</p>

<pre><code>when(mockedList.get(anyInt()).thenReturn("first").thenThrow(new RuntimeException());
when(mockedList.get(anyInt()).thenReturn("first","second");
</code></pre>

<p>Stubbing的另一种风格</p>

<pre><code>doReturn("Hello").when(mockedList).get(0);
doReturn("Hello").doReturn("world").when(mockedList).get(anyInt());
</code></pre>

<p>抛出异常</p>

<pre><code>doThrow(new RuntimeException()).when(mockedList).get(0);
</code></pre>

<h4>对void方法进行方法预期设定</h4>

<pre><code>doNothing().when(mockedClass).SomeVoidMethod();
doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<p>迭代风格</p>

<pre><code>doNothing().doThrow(new RuntimeException()).when(mockedClass).SomeVoidMethod();
</code></pre>

<h2>参数匹配器</h2>

<p>在Stubbing和Verify的时候，有时需要更加灵活的参数需求。参数匹配器(Argument Matcher)能够满足需求。</p>

<pre><code>//stubbing using anyInt() argument matcher
when(mockedList.get(anyInt())).thenReturn("element");

//following prints "element"
System.out.println(mockedList.get(999));

//you can also verify using argument matcher
verify(mockedList).get(anyInt());   
</code></pre>

<p>需要注意的是，如果使用了参数匹配器，所有的参数都需要由匹配器提供。如下eq("third argument")，直接修改为“third argument”会报错。</p>

<pre><code>verify(mockedClass).someMethod(anyObject(), anyString(), eq("third argument"));
</code></pre>

<h2>Mock对象行为的验证</h2>

<p>Mock 对象行为的验证，关注其交互行为，如mock对象调用的参数，调用次数，调用顺序等。</p>

<h3>调用次数验证</h3>

<pre><code>public static &lt;T&gt; T verify(T mock).someMethod()
public static &lt;T&gt; T verify(T mock, VerificationMode mode).someMethod()

Parameters:
    mock - to be verified
    mode - times(M), atLeastOnce() , atLeast(N) , atMost(X) , never() 
Returns:
    mock object itself
</code></pre>

<h3>调用顺序验证</h3>

<pre><code>public static InOrder inOrder(java.lang.Object... mocks)
</code></pre>

<p>创建mock对象</p>

<pre><code>// Multiple mocks that must be used in a particular order
List firstMock = mock(List.class);
List secondMock = mock(List.class);
</code></pre>

<p>调用mock对象的方法</p>

<pre><code>//using mocks
firstMock.add("was called first");
secondMock.add("was called second");
</code></pre>

<p>创建InOrder对象</p>

<pre><code>//create inOrder object passing any mocks that need to be verified in order
InOrder inOrder = inOrder(firstMock, secondMock);
</code></pre>

<p>验证方法调用</p>

<pre><code>//following will make sure that firstMock was called before secondMock
inOrder.verify(firstMock).add("was called first");
inOrder.verify(secondMock).add("was called second");
</code></pre>

<h2><code>RETURN_SMART_NULLS和RETURN_DEEP_STUBS</code></h2>

<p><code>RETURN_SMART_NULLS</code> 是实现了Answer 接口的对象，它是创建mock对象时的一个可选参数， <code>mock(class,answer)</code>。在创建mock对象时，使用该参数，调用没有stubbed的方法会返回 SmartNull 。如返回类型为String的，会返回空"", int 会返回 0,List 会返回 null。</p>

<p>mock对象使用RETURN_DEEP_STUBS 参数，会自动mock该对象中包含的对象。</p>

<h2>注解</h2>

<p>Mockito支持对变量进行注解，如将mock对象设为测试类的属性，然后通过注解的方式@Mock来定义它，可以减少重复代码，增强可维护性。Mockito支持的注解有@Mock，@Spy，@Captor，@InjectMocks</p>

<h3>Annotation 的初始化</h3>

<p>初始化方法为调用MockitoAnnotations.initMocks(testClass)，可以放到@Before中。</p>

<pre><code>public class ArticleManagerTest {

    @Mock private ArticleCalculator calculator;
    @Mock private ArticleDatabase database;
    @Mock private UserProvider userProvider;

    @Before public void setup() {
        MockitoAnnotations.initMocks(testClass);
    }
}
</code></pre>

<p>使用Mockito提供的Junit Runner可以省略上述步骤。</p>

<pre><code>@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {
    @Mock private List list;

    @Test public void shouldDoSomething() {
        list.add(100);
    }
}
</code></pre>

<h2>powermock 的使用</h2>

<h3>Maven配置</h3>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.powermock&lt;/groupId&gt;
    &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt;
    &lt;version&gt;1.4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<h2>PowerMock 在单元测试中的应用</h2>

<h3>模拟 Static 方法</h3>

<p>在任何需要用到 PowerMock 的类开始之前，首先我们要做如下声明：</p>

<pre><code>@RunWith(PowerMockRunner.class)   
</code></pre>

<p>然后，还需要用注释的形式将需要测试的静态方法提供给 PowerMock：</p>

<pre><code>@PrepareForTest( { YourClassWithEgStaticMethod.class })   
</code></pre>

<p>然后就可以开始写测试代码：</p>

<pre><code>1，首先，需要有一个含有 static 方法的代码 , 如
public class IdGenerator { 
    ... 
    public static long generateNewId() { 
        ... 
    } 
    ... 
 } 
2，然后，在被测代码中，引用了以上方法
public class ClassUnderTest { 
    ... 
    public void methodToTest() { 
    .. 
    final long id = IdGenerator.generateNewId(); 
    .. 
    } 
    ... 
} 

3，为了达到单元测试的目的，需要让静态方法 generateNewId()返回各种值
来达到对被测试方法 methodToTest()的覆盖测试，实现方式如下：

 @RunWith(PowerMockRunner.class) 
 @PrepareForTest(IdGenerator.class) 
 public class MyTestClass { 
    @Test 
    public void demoStaticMethodMocking() throws Exception { 
        PowerMockito.mockStatic(IdGenerator.class);  
        when(IdGenerator.generateNewId()).thenReturn(2L); 

        new ClassUnderTest().methodToTest(); 

        verifyStatic(); 
        IdGenerator.generateNewId(); 
    } 
 }
</code></pre>

<h3>模拟构造函数</h3>

<p>有时候，能模拟构造函数，从而使被测代码中 new 操作返回的对象可以被随意定制，会很大程度的提高单元测试的效率，考虑如下：</p>

<pre><code>public class DirectoryStructure { 
    public boolean create(String directoryPath) { 
        File directory = new File(directoryPath); 

        if (directory.exists()) { 
            throw new IllegalArgumentException(
            "\"" + directoryPath + "\" already exists."); 
        } 

        return directory.mkdirs(); 
    } 
 }    
</code></pre>

<p>为了充分测试 create()函数，我们需要被 new 出来的 File 对象返回文件存在和不存在两种结果。在 PowerMock 出现之前，实现这个单元测试的方式通常都会需要在实际的文件系统中去创建对应的路径以及文件。然而，在 PowerMock 的帮助下，本函数的测试可以和实际的文件系统彻底独立开来：使用 PowerMock 来模拟 File 类的构造函数，使其返回指定的模拟 File 对象而不是实际的 File 对象，然后只需要通过修改指定的模拟 File 对象的实现，即可实现对被测试代码的覆盖测试，参考如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(DirectoryStructure.class) 
 public class DirectoryStructureTest { 
    @Test 
    public void createDirectoryStructureWhenPathDoesntExist() 
    throws Exception { 
        final String directoryPath = "mocked path"; 

        File directoryMock = mock(File.class); 

        //File的初始化函数的mock
        whenNew(File.class).withArguments(directoryPath)
            .thenReturn(directoryMock); 

        // Standard expectations 
        when(directoryMock.exists()).thenReturn(false); 
        when(directoryMock.mkdirs()).thenReturn(true); 

        assertTrue(new NewFileExample()
            .createDirectoryStructure(directoryPath)); 

        // Optionally verify that a new File was "created". 
        verifyNew(File.class).withArguments(directoryPath); 
    } 
 } 
</code></pre>

<p>使用 whenNew().withArguments().thenReturn() 语句即可实现对具体类的构造函数的模拟操作。然后对于之前创建的模拟对象 directoryMock使用 When().thenReturn() 语句，即可实现需要的所有功能，从而实现对被测对象的覆盖测试。在本测试中，因为实际的模拟操作是在类 DirectoryStructureTest 中实现，所以需要指定的 @PrepareForTest 对象是 DirectoryStructureTest.class。</p>

<h3>模拟私有以及 Final 方法</h3>

<p>为了实现对类的私有方法或者是 Final 方法的模拟操作，需要 PowerMock 提供的另外一项技术：局部模拟。</p>

<p>在之前的介绍的模拟操作中，我们总是去模拟一整个类或者对象，然后使用 When().thenReturn()语句去指定其中值得关心的部分函数的返回值，从而达到搭建各种测试环境的目标。对于没有使用 When().thenReturn()方法指定的函数，系统会返回各种类型的默认值。</p>

<p>局部模拟则提供了另外一种方式，在使用局部模拟时，被创建出来的模拟对象依然是原系统对象，虽然可以使用方法 When().thenReturn()来指定某些具体方法的返回值，但是没有被用此函数修改过的函数依然按照系统原始类的方式来执行。</p>

<p>这种局部模拟的方式的强大之处在于，除开一般方法可以使用之外，Final 方法和私有方法一样可以使用。
参考如下所示的被测代码：</p>

<pre><code> public final class PrivatePartialMockingExample { 
    public String methodToTest() { 
        return methodToMock("input"); 
    } 

    private String methodToMock(String input) { 
        return "REAL VALUE = " + input; 
    } 
 } 
</code></pre>

<p>为了保持单元测试的纯洁性，在测试方法 methodToTest()时，我们不希望受到私有函数 methodToMock()实现的干扰，为了达到这个目的，我们使用刚提到的局部模拟方法来实现 , 实现方式如下：</p>

<pre><code> @RunWith(PowerMockRunner.class) 
 @PrepareForTest(PrivatePartialMockingExample.class) 
 public class PrivatePartialMockingExampleTest { 
    @Test 
    public void demoPrivateMethodMocking() throws Exception { 
        final String expected = "TEST VALUE"; 
        final String nameOfMethodToMock = "methodToMock"; 
        final String input = "input"; 

        PrivatePartialMockingExample underTest = spy(new PrivatePartialMockingExample()); 

        /* 
         * Setup the expectation to the private method using the method name 
         */ 
        when(underTest, nameOfMethodToMock, input).thenReturn(expected); 

        assertEquals(expected, underTest.methodToTest()); 

        // Optionally verify that the private method was actually called 
        verifyPrivate(underTest).invoke(nameOfMethodToMock, input); 
    } 
 } 
</code></pre>

<p>可以发现，为了实现局部模拟操作，用来创建模拟对象的函数从 mock() 变成了 spy()，操作对象也从类本身变成了一个具体的对象。同时，When() 函数也使用了不同的版本：在模拟私有方法或者是 Final 方法时，When() 函数需要依次指定模拟对象、被指定的函数名字以及针对该函数的输入参数列表。</p>

<p>参考文献:<a href="http://www.ibm.com/developerworks/cn/java/j-lo-powermock/">http://www.ibm.com/developerworks/cn/java/j-lo-powermock/</a></p>

<hr />

<p>Thanks to：lizejun</p>
]]></content>
  </entry>
  
</feed>
